<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>QDS Marble Run — True 3D v1</title>
<style>
  :root{
    --bg:#05060a; --panel:rgba(10,14,24,.78); --edge:rgba(140,170,255,.18);
    --text:#e9eeff; --accent:#86a6ff; --accent2:#7bffcf;
  }
  html,body{margin:0;height:100%;background:radial-gradient(1200px 700px at 20% 10%, #0b1025 0%, var(--bg) 45%, #010104 100%); color:var(--text); font-family:system-ui,Segoe UI,Roboto,Arial;}
  #c{position:fixed;inset:0;display:block;touch-action:none;}
  #hud{
    position:fixed; left:10px; top:10px; z-index:5;
    background:var(--panel); border:1px solid var(--edge);
    border-radius:14px; padding:10px 10px 8px; backdrop-filter: blur(10px);
    box-shadow: 0 10px 30px rgba(0,0,0,.45);
    min-width: 210px;
  }
  #hud h1{font-size:13px; letter-spacing:.08em; margin:0 0 6px; font-weight:650; color:#cfd9ff; text-transform:uppercase;}
  .row{display:flex; gap:6px; flex-wrap:wrap; margin:6px 0;}
  button{
    background:linear-gradient(135deg, rgba(134,166,255,.15), rgba(123,255,207,.08));
    border:1px solid var(--edge); color:var(--text);
    padding:8px 10px; border-radius:10px; font-size:12px; font-weight:600;
  }
  button:active{transform: translateY(1px) scale(.99);}
  .pill{
    display:inline-flex; align-items:center; gap:6px;
    border:1px solid var(--edge); border-radius:999px; padding:4px 8px;
    font-size:11px; opacity:.9;
  }
  #mini{
    position:fixed; right:10px; top:10px; z-index:5;
    background:var(--panel); border:1px solid var(--edge);
    border-radius:12px; padding:8px 10px; font-size:11px;
  }
  #hint{opacity:.7}
  a{color:var(--accent)}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
  <h1>QDS Marble Run — True 3D</h1>
  <div class="row">
    <span class="pill">Marbles: <b id="mCount">0</b></span>
    <span class="pill">Speed: <b id="spdTxt">1x</b></span>
  </div>
  <div class="row">
    <button id="dropBtn">Drop marble</button>
    <button id="multiBtn">Drop x5</button>
    <button id="clearBtn">Clear</button>
  </div>
  <div class="row">
    <button id="speedBtn">Speed toggle</button>
    <button id="camBtn">Reset camera</button>
    <button id="hudBtn">Hide HUD</button>
  </div>
  <div id="hint">Drag to orbit • pinch to zoom • two-finger pan</div>
</div>

<div id="mini">
  <b>Tip:</b> If HUD vanishes, tap the top-right corner again after reload.<br/>
  (State is now saved.)
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x05060a, 0.035);

const camera = new THREE.PerspectiveCamera(60, 1, 0.01, 200);
camera.position.set(6.5, 5.2, 8.2);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.minDistance = 2.2;
controls.maxDistance = 24;
controls.target.set(0, 0.8, 0);

function onResize(){
  const w = innerWidth, h = innerHeight;
  camera.aspect = w/h; camera.updateProjectionMatrix();
  renderer.setSize(w,h,false);
}
addEventListener("resize", onResize);
onResize();

/* Lighting */
const hemi = new THREE.HemisphereLight(0xaac6ff, 0x0a0f20, 0.9);
scene.add(hemi);

const key = new THREE.DirectionalLight(0xcfe0ff, 1.15);
key.position.set(6, 10, 4);
key.castShadow = false;
scene.add(key);

const rim = new THREE.PointLight(0x7bffcf, 0.6, 30);
rim.position.set(-6, 2.5, -4);
scene.add(rim);

/* Subtle star dust */
const starGeo = new THREE.BufferGeometry();
const starCount = 900;
const starPos = new Float32Array(starCount*3);
for(let i=0;i<starCount;i++){
  starPos[i*3+0] = (Math.random()-0.5)*60;
  starPos[i*3+1] = Math.random()*22;
  starPos[i*3+2] = (Math.random()-0.5)*60;
}
starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
const starMat = new THREE.PointsMaterial({ size:0.03, transparent:true, opacity:0.55 });
scene.add(new THREE.Points(starGeo, starMat));

/* Track curve (true 3D path) */
const pts = [
  new THREE.Vector3(-3.8, 2.2,  2.6),
  new THREE.Vector3(-2.4, 1.7,  1.3),
  new THREE.Vector3(-1.1, 1.2,  0.2),
  new THREE.Vector3( 0.6, 0.9, -0.6),
  new THREE.Vector3( 2.2, 1.1, -1.9),
  new THREE.Vector3( 3.2, 0.6, -3.0),
  new THREE.Vector3( 2.1, 0.2, -3.8),
  new THREE.Vector3( 0.4, 0.4, -3.1),
  new THREE.Vector3(-1.4, 0.1, -2.0),
  new THREE.Vector3(-2.6, 0.3, -0.9),
  new THREE.Vector3(-3.1, 0.0,  0.8),
  new THREE.Vector3(-2.0, -0.3,  2.2),
  new THREE.Vector3( 0.0, -0.5,  3.0),
  new THREE.Vector3( 2.1, -0.8,  2.0),
  new THREE.Vector3( 3.4, -1.2,  0.4),
  new THREE.Vector3( 2.6, -1.6, -1.0),
  new THREE.Vector3( 0.9, -1.8, -1.6),
  new THREE.Vector3(-1.0, -1.9, -0.9),
  new THREE.Vector3(-2.6, -2.1,  0.4),
];
const curve = new THREE.CatmullRomCurve3(pts, false, "catmullrom", 0.35);

/* Tube geometry */
const tubularSegments = 420;
const radius = 0.18;
const radialSegments = 16;

const tubeGeo = new THREE.TubeGeometry(curve, tubularSegments, radius, radialSegments, false);
const tubeMat = new THREE.MeshStandardMaterial({
  metalness: 0.15,
  roughness: 0.22,
  emissive: 0x0b1233,
  emissiveIntensity: 0.35
});
const tube = new THREE.Mesh(tubeGeo, tubeMat);
scene.add(tube);

/* Rail glow line */
const linePts = curve.getPoints(600);
const lineGeo = new THREE.BufferGeometry().setFromPoints(linePts);
const lineMat = new THREE.LineBasicMaterial({ transparent:true, opacity:0.35 });
const glowLine = new THREE.Line(lineGeo, lineMat);
scene.add(glowLine);

/* Base platform */
const baseGeo = new THREE.CylinderGeometry(3.6, 4.2, 0.35, 64);
const baseMat = new THREE.MeshStandardMaterial({ metalness:0.1, roughness:0.7, emissive:0x050812, emissiveIntensity:0.35 });
const base = new THREE.Mesh(baseGeo, baseMat);
base.position.set(0,-2.35,0);
scene.add(base);

/* Marble factory */
const marbleGeo = new THREE.SphereGeometry(0.13, 24, 24);
function makeMarble(){
  const mat = new THREE.MeshStandardMaterial({
    metalness: 0.45, roughness: 0.18,
    emissive: 0x0a0f2a, emissiveIntensity: 0.25
  });
  const m = new THREE.Mesh(marbleGeo, mat);
  m.userData.t = 0.0001;
  m.userData.v = 0;
  m.userData.alive = true;
  m.position.copy(curve.getPointAt(0.0001));
  scene.add(m);
  return m;
}

const marbles = [];

/* Pseudo-physics along curve */
const g = 9.81;
const gravity = new THREE.Vector3(0,-1,0);
const lengthApprox = curve.getLength();
const paramToMeters = lengthApprox; // dt in "t" scaled by length
const friction = 0.985;
const slopeGain = 0.65;

let speedModes = [0.5, 1, 2, 4];
let speedIndex = 1;
let timeScale = speedModes[speedIndex];

function updateMarbles(dt){
  for(const m of marbles){
    if(!m.userData.alive) continue;

    const t = m.userData.t;
    const tangent = curve.getTangentAt(t).normalize();
    // gravitational component along tangent
    const slope = THREE.MathUtils.clamp(tangent.dot(gravity), -1, 1);
    const a = g * slope * slopeGain;

    m.userData.v = (m.userData.v + a * dt) * friction;
    // convert velocity (m/s-ish) into param delta
    const dtParam = (m.userData.v * dt) / Math.max(paramToMeters, 0.0001);
    let nt = t + dtParam;

    if(nt >= 0.999){
      nt = 0.999;
      m.userData.alive = false; // reached end
      m.userData.v = 0;
    }
    if(nt < 0.0001) nt = 0.0001;

    m.userData.t = nt;
    m.position.copy(curve.getPointAt(nt));

    // subtle spin for vibes
    m.rotation.x += dt * 2.2;
    m.rotation.z += dt * 1.6;
  }

  // cleanup finished marbles if too many
  if(marbles.length > 120){
    const early = marbles.splice(0, 30);
    for(const m of early) scene.remove(m);
  }
}

/* UI */
const mCount = document.getElementById("mCount");
const spdTxt = document.getElementById("spdTxt");
const dropBtn = document.getElementById("dropBtn");
const multiBtn = document.getElementById("multiBtn");
const clearBtn = document.getElementById("clearBtn");
const speedBtn = document.getElementById("speedBtn");
const camBtn = document.getElementById("camBtn");
const hudBtn = document.getElementById("hudBtn");
const hud = document.getElementById("hud");
const mini = document.getElementById("mini");

function syncHUD(){
  mCount.textContent = String(marbles.length);
  spdTxt.textContent = timeScale + "x";
  speedBtn.textContent = "Speed: " + timeScale + "x";
  hudBtn.textContent = hud.style.display === "none" ? "Show HUD" : "Hide HUD";
}

function drop(n=1){
  for(let i=0;i<n;i++){
    const m = makeMarble();
    // slight stagger so they don't perfectly overlap
    m.userData.t = 0.0001 + i*0.00008;
    m.userData.v = 0.2 + Math.random()*0.15;
    marbles.push(m);
  }
  syncHUD();
}

dropBtn.onclick = ()=> drop(1);
multiBtn.onclick = ()=> drop(5);

clearBtn.onclick = ()=>{
  for(const m of marbles) scene.remove(m);
  marbles.length = 0;
  syncHUD();
};

speedBtn.onclick = ()=>{
  speedIndex = (speedIndex + 1) % speedModes.length;
  timeScale = speedModes[speedIndex];
  localStorage.setItem("QDS_MARBLE_SPEED_INDEX", String(speedIndex));
  syncHUD();
};

camBtn.onclick = ()=>{
  camera.position.set(6.5, 5.2, 8.2);
  controls.target.set(0, 0.8, 0);
  controls.update();
};

hudBtn.onclick = ()=>{
  const nowHidden = hud.style.display !== "none";
  hud.style.display = nowHidden ? "none" : "block";
  mini.style.display = nowHidden ? "block" : "block";
  localStorage.setItem("QDS_MARBLE_HUD", nowHidden ? "0" : "1");
  syncHUD();
};

/* Persisted states */
const savedHud = localStorage.getItem("QDS_MARBLE_HUD");
if(savedHud === "0") hud.style.display = "none";

const savedSpeed = localStorage.getItem("QDS_MARBLE_SPEED_INDEX");
if(savedSpeed !== null && !Number.isNaN(+savedSpeed)){
  speedIndex = Math.max(0, Math.min(speedModes.length-1, +savedSpeed));
  timeScale = speedModes[speedIndex];
}

/* Tap corner to restore HUD if hidden */
let cornerTap = 0;
mini.addEventListener("click", ()=>{
  cornerTap++;
  if(cornerTap >= 2){
    hud.style.display = "block";
    localStorage.setItem("QDS_MARBLE_HUD", "1");
    cornerTap = 0;
    syncHUD();
  }
});

syncHUD();

/* Animation loop */
let last = performance.now();
function tick(now){
  const rawDt = Math.min(0.033, (now-last)/1000);
  last = now;
  const dt = rawDt * timeScale;

  updateMarbles(dt);

  // gentle track shimmer
  tubeMat.emissiveIntensity = 0.28 + 0.08*Math.sin(now*0.0012);
  lineMat.opacity = 0.25 + 0.12*Math.sin(now*0.0015);

  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
