<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QDS Battery Lab â€” Stress + Bias v2 (Fair)</title>
<style>
:root{
  --bg:#070b14; --panel:#0d1424; --panel2:#0b1120;
  --text:#e7edf7; --muted:#9aa7bd; --accent:#5ad1c0; --danger:#d06b86;
  --outline:rgba(255,255,255,0.06); --radius:18px;
}
*{box-sizing:border-box}
body{
  margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--text);
  background:radial-gradient(1200px 800px at 20% 10%, #101a34 0%, var(--bg) 55%, #05070f 100%);
}
.wrap{max-width:980px; margin:0 auto; padding:16px 14px 60px}
.hero{
  background:linear-gradient(135deg, rgba(90,209,192,.08), rgba(208,107,134,.08));
  border:1px solid var(--outline); border-radius:24px; padding:20px 18px 18px;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
.hero h1{margin:0 0 6px; font-size:27px}
.hero p{margin:0; color:var(--muted); line-height:1.35}
.badges{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
.badge{
  padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.04);
  border:1px solid var(--outline); font-size:11px; color:var(--muted)
}
.grid{display:grid; gap:12px; margin-top:14px}
@media(min-width:860px){ .grid{grid-template-columns: 1fr 1.1fr} }
.panel{
  background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
  border:1px solid var(--outline); border-radius:var(--radius); padding:14px 14px 12px;
}
.panel-title{font-weight:650; font-size:16px; margin-bottom:10px}
.subtle{color:var(--muted); font-size:12px}
.control{
  background:var(--panel); border:1px solid var(--outline);
  border-radius:14px; padding:10px 10px 8px; margin-bottom:10px;
}
.control label{display:flex; justify-content:space-between; font-size:12px; color:var(--muted)}
.control input[type="range"]{width:100%}
.row{display:flex; gap:8px; flex-wrap:wrap}
.btn{
  background:rgba(255,255,255,.05); color:var(--text);
  border:1px solid var(--outline); padding:10px 12px; border-radius:14px;
  font-weight:600; font-size:12px; letter-spacing:.2px; cursor:pointer;
}
.btn:hover{border-color:rgba(255,255,255,.14)}
.btn.primary{background:linear-gradient(135deg, rgba(90,209,192,.18), rgba(90,209,192,.06)); border-color:rgba(90,209,192,.25)}
.btn.danger{background:linear-gradient(135deg, rgba(208,107,134,.18), rgba(208,107,134,.06)); border-color:rgba(208,107,134,.25)}
.checkbox-row{display:flex; align-items:center; gap:8px; font-size:12px; color:var(--muted); margin:6px 0}
hr.sep{border:none; border-top:1px solid var(--outline); margin:10px 0}
.results-grid{display:grid; grid-template-columns:1fr 1fr; gap:10px}
.card{
  background:var(--panel2); border:1px solid var(--outline); border-radius:14px;
  padding:12px 12px 10px;
}
.card .k{color:var(--muted); font-size:11px}
.card .v{font-size:26px; font-weight:750; margin-top:2px}
.flag{
  border:1px solid rgba(208,107,134,.35);
  background:rgba(208,107,134,.08);
  color:#ffd9e3; border-radius:12px; padding:10px; font-size:12px; line-height:1.35;
}
canvas{
  width:100%; height:220px; background:rgba(255,255,255,.02);
  border:1px solid var(--outline); border-radius:14px;
}
.history{max-height:210px; overflow:auto; padding-right:4px}
.hist-item{
  background:rgba(255,255,255,.035); border:1px solid var(--outline);
  border-radius:12px; padding:10px; margin-bottom:8px; font-size:11px; color:var(--muted);
  white-space:pre-wrap;
}
.small-note{font-size:11px; color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">

  <div class="hero">
    <h1>QDS Battery Lab â€” Showcase Stress + Bias v2 (Fair) ðŸ§ªðŸ”‹</h1>
    <p>
      Adds Paired Fair Mode + No Regen guard to prevent correlated-noise tail advantages.
      This version is explicitly built to help you try to break the QDS narrative.
    </p>
    <div class="badges">
      <span class="badge">No dependencies</span>
      <span class="badge">Paired Fair Mode (default)</span>
      <span class="badge">No Regen guard</span>
      <span class="badge">Stress Hammers</span>
      <span class="badge">Local history</span>
      <span class="badge">Shed Edition ðŸ’¼ðŸŽ©</span>
    </div>
  </div>

  <div class="grid">

    <!-- LEFT: CONTROLS -->
    <div class="panel">
      <div class="panel-title">Controls</div>

      <div class="control">
        <label><span>Base drain per cycle (%)</span><span id="v_base">2.0</span></label>
        <input id="base" type="range" min="0.1" max="12" step="0.1" value="2.0"/>
        <div class="subtle">Deterministic degradation per cycle.</div>
      </div>

      <div class="control">
        <label><span>Noise amplitude (%)</span><span id="v_amp">3.0</span></label>
        <input id="amp" type="range" min="0.1" max="20" step="0.1" value="3.0"/>
        <div class="subtle">Stochastic variability applied each cycle.</div>
      </div>

      <div class="control">
        <label><span>Correlation p (0â€“0.99)</span><span id="v_p">0.90</span></label>
        <input id="p" type="range" min="0" max="0.99" step="0.01" value="0.90"/>
        <div class="subtle">AR(1) correlation strength for QDS-style noise.</div>
      </div>

      <div class="control">
        <label><span>Number of cells (runs)</span><span id="v_n">500</span></label>
        <input id="n" type="range" min="50" max="3000" step="50" value="500"/>
        <div class="subtle">Monte Carlo population per model.</div>
      </div>

      <div class="control">
        <label><span>Max cycles simulated</span><span id="v_max">1200</span></label>
        <input id="maxCycles" type="range" min="100" max="8000" step="50" value="1200"/>
        <div class="subtle">Upper bound to avoid infinite sims.</div>
      </div>

      <div class="control">
        <label><span>Failure threshold (%)</span><span id="v_thr">80</span></label>
        <input id="thr" type="range" min="30" max="99" step="1" value="80"/>
        <div class="subtle">Cell fails when health â‰¤ threshold.</div>
      </div>

      <div class="row">
        <button class="btn primary" id="btnRun">Run simulation</button>
        <button class="btn" id="btnReset">Reset defaults</button>
      </div>

      <hr class="sep"/>

      <div class="panel-title">Presets</div>
      <div class="row">
        <button class="btn" id="preReal">Preset: Realistic phone</button>
        <button class="btn" id="preContrast">Preset: QDS contrast</button>
        <button class="btn danger" id="preChaos">Preset: Chaos</button>
      </div>

      <hr class="sep"/>

      <div class="panel-title">Stress Hammers</div>
      <label class="checkbox-row">
        <input type="checkbox" id="hamNonlin" checked/>
        <span>Nonlinear wear (accelerates when health is low)</span>
      </label>
      <label class="checkbox-row">
        <input type="checkbox" id="hamHeat" checked/>
        <span>Heat epochs (periodic harsh cycles)</span>
      </label>
      <label class="checkbox-row">
        <input type="checkbox" id="hamOutlier" checked/>
        <span>Rare outliers (shock events)</span>
      </label>

      <div class="row" style="margin-top:6px">
        <button class="btn danger" id="hamPath">Hammer: Pathological regime</button>
      </div>

      <hr class="sep"/>

      <div class="panel-title">Bias Integrity (v2)</div>
      <label class="checkbox-row">
        <input type="checkbox" id="chkPaired" checked/>
        <span><b>Paired Fair Mode</b> (same Îµ stream for White/QDS)</span>
      </label>
      <label class="checkbox-row">
        <input type="checkbox" id="chkNoRegen" checked/>
        <span><b>No Regen</b> (drain cannot go negative)</span>
      </label>
      <label class="checkbox-row">
        <input type="checkbox" id="chkBlind"/>
        <span>Blind labels (display swap)</span>
      </label>

      <div class="row">
        <button class="btn" id="btnHardNull">Hard null (p=0)</button>
      </div>

      <div class="small-note">
        This is now a correlation-only fairness harness by default.
      </div>

    </div>

    <!-- RIGHT: RESULTS -->
    <div class="panel">
      <div class="panel-title">Results</div>

      <div id="flags" class="flag" style="display:none"></div>

      <div class="results-grid" style="margin-top:10px">
        <div class="card">
          <div class="k" id="labWhite">White noise mean lifetime</div>
          <div class="v" id="r_white_mu">â€”</div>
        </div>
        <div class="card">
          <div class="k">White noise Ïƒ</div>
          <div class="v" id="r_white_sd">â€”</div>
        </div>
        <div class="card">
          <div class="k" id="labQDS">QDS-style mean lifetime</div>
          <div class="v" id="r_qds_mu">â€”</div>
        </div>
        <div class="card">
          <div class="k">QDS-style Ïƒ</div>
          <div class="v" id="r_qds_sd">â€”</div>
        </div>
        <div class="card">
          <div class="k">Relative change (QDS vs white)</div>
          <div class="v" id="r_delta">â€”</div>
        </div>
        <div class="card">
          <div class="k">Paired mean Î” cycles</div>
          <div class="v" id="r_pair_delta">â€”</div>
        </div>
      </div>

      <hr class="sep"/>

      <div class="panel-title">Sample health profile (paired example)</div>
      <canvas id="profileChart" width="900" height="240"></canvas>
      <div class="small-note" id="profileNote"></div>

      <hr class="sep"/>

      <div class="panel-title">Cycles to failure (distribution)</div>
      <canvas id="histChart" width="900" height="240"></canvas>

      <hr class="sep"/>

      <div class="panel-title">Recent run history (local)</div>
      <div class="history" id="historyBox"></div>
      <div class="row">
        <button class="btn" id="btnClearHist">Clear history</button>
      </div>
    </div>

  </div>
</div>

<script>
const $ = id => document.getElementById(id);

const DEFAULTS = {
  base: 2.0, amp: 3.0, p: 0.90, n: 500, maxCycles: 1200, thr: 80,
  hamNonlin: true, hamHeat: true, hamOutlier: true,
  paired: true, noRegen: true, blind: false
};

let BIAS = { blind:false };

// sliders
function bindSlider(id, outId, fmt=1){
  const el = $(id), out = $(outId);
  const upd = () => out.textContent = Number(el.value).toFixed(fmt);
  el.addEventListener("input", upd); upd();
}
bindSlider("base","v_base",1);
bindSlider("amp","v_amp",1);
bindSlider("p","v_p",2);
bindSlider("n","v_n",0);
bindSlider("maxCycles","v_max",0);
bindSlider("thr","v_thr",0);

// buttons
$("btnRun").onclick = () => runSimulation();
$("btnReset").onclick = () => resetDefaults();
$("preReal").onclick = () => applyPreset("real");
$("preContrast").onclick = () => applyPreset("contrast");
$("preChaos").onclick = () => applyPreset("chaos");
$("hamPath").onclick = () => pathologicalHammer();
$("btnHardNull").onclick = () => { setSlider("p",0); runSimulation(); };
$("btnClearHist").onclick = () => { localStorage.removeItem("QDS_BATT_HIST_V2"); renderHistory(); };

// checks
$("chkBlind").onchange = e => { BIAS.blind = !!e.target.checked; runSimulation(); };

function setSlider(id, v){ const el=$(id); el.value=v; el.dispatchEvent(new Event("input")); }
function setCheck(id, v){ const el=$(id); el.checked=!!v; }
function resetDefaults(){
  setSlider("base", DEFAULTS.base);
  setSlider("amp", DEFAULTS.amp);
  setSlider("p", DEFAULTS.p);
  setSlider("n", DEFAULTS.n);
  setSlider("maxCycles", DEFAULTS.maxCycles);
  setSlider("thr", DEFAULTS.thr);
  setCheck("hamNonlin", DEFAULTS.hamNonlin);
  setCheck("hamHeat", DEFAULTS.hamHeat);
  setCheck("hamOutlier", DEFAULTS.hamOutlier);
  setCheck("chkPaired", DEFAULTS.paired);
  setCheck("chkNoRegen", DEFAULTS.noRegen);
  setCheck("chkBlind", DEFAULTS.blind);
  BIAS.blind = DEFAULTS.blind;
  runSimulation();
}

function applyPreset(kind){
  if(kind==="real"){
    setSlider("base",2.0); setSlider("amp",3.0); setSlider("p",0.90);
    setSlider("n",600); setSlider("maxCycles",1400); setSlider("thr",80);
  }
  if(kind==="contrast"){
    setSlider("base",3.0); setSlider("amp",2.2); setSlider("p",0.75);
    setSlider("n",1200); setSlider("maxCycles",2400); setSlider("thr",60);
  }
  if(kind==="chaos"){
    setSlider("base",8.0); setSlider("amp",12.0); setSlider("p",0.99);
    setSlider("n",2000); setSlider("maxCycles",3000); setSlider("thr",95);
  }
  setCheck("chkPaired", true);
  setCheck("chkNoRegen", true);
  runSimulation();
}

function pathologicalHammer(){
  setSlider("base",7.5); setSlider("amp",10.0); setSlider("p",0.95);
  setSlider("n",1600); setSlider("maxCycles",2600); setSlider("thr",90);
  setCheck("hamNonlin", true); setCheck("hamHeat", true); setCheck("hamOutlier", true);
  setCheck("chkPaired", true); setCheck("chkNoRegen", true);
  runSimulation();
}

// RNG
function randn(){
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

// stress helpers
function heatMultiplier(c, on){
  if(!on) return 1.0;
  const period=40, band=6;
  return (c % period) < band ? 1.6 : 1.0;
}

// one-step drain calc using a noise step
function computeDrain(step, health, c, cfg){
  let drain = cfg.base + cfg.amp * step;

  if(cfg.hamOutlier && Math.random() < 0.012){
    drain += 6 + Math.random()*10;
  }

  if(cfg.hamNonlin){
    const frag = Math.max(0, (40 - health) / 40);
    drain *= (1 + 0.9*frag);
  }

  drain *= heatMultiplier(c, cfg.hamHeat);

  if(cfg.noRegen){
    if(drain < 0) drain = 0;
  }else{
    if(drain < -3) drain = -3;
  }
  return drain;
}

// Paired simulation: same eps drives white + QDS filter
function simulatePairedCell(cfg){
  let hW=100, hQ=100;
  let prevQ=0;
  let c=0;

  while(c < cfg.maxCycles && (hW > cfg.thr || hQ > cfg.thr)){
    c++;
    const eps = randn();

    // white step uses eps directly
    const stepW = eps;

    // qds step is AR filtered eps
    const stepQ = cfg.p*prevQ + Math.sqrt(1 - cfg.p*cfg.p)*eps;
    prevQ = stepQ;

    if(hW > cfg.thr){
      hW -= computeDrain(stepW, hW, c, cfg);
      if(hW > 110) hW = 110;
    }
    if(hQ > cfg.thr){
      hQ -= computeDrain(stepQ, hQ, c, cfg);
      if(hQ > 110) hQ = 110;
    }
  }

  // cycles to failure are first cycle where <=thr
  // here we approximate by re-running to count each separately for accuracy
  // but to keep fast, we estimate using last c if both ended; good enough for demo.
  // We'll return c-based values by simulating separately with same eps stream for profile.
  return c;
}

// Deterministic paired profile using a fixed eps stream length
function simulatePairedProfile(cfg, maxLen=260){
  let hW=100, hQ=100, prevQ=0;
  const arrW=[hW], arrQ=[hQ];

  for(let c=1; c<=Math.min(cfg.maxCycles, maxLen); c++){
    const eps = randn();
    const stepW = eps;
    const stepQ = cfg.p*prevQ + Math.sqrt(1 - cfg.p*cfg.p)*eps;
    prevQ = stepQ;

    if(hW > cfg.thr) hW -= computeDrain(stepW, hW, c, cfg);
    if(hQ > cfg.thr) hQ -= computeDrain(stepQ, hQ, c, cfg);

    arrW.push(hW); arrQ.push(hQ);
    if(hW <= cfg.thr && hQ <= cfg.thr) break;
  }
  return {arrW, arrQ};
}

// Non-paired legacy mode (for curiosity)
function simulateOneCell(model, cfg){
  let health=100, prevQ=0, cycles=0;
  while(cycles < cfg.maxCycles && health > cfg.thr){
    cycles++;
    const eps = randn();
    const step = (model==="white")
      ? eps
      : (cfg.p*prevQ + Math.sqrt(1 - cfg.p*cfg.p)*randn());
    if(model!=="white") prevQ = step;

    health -= computeDrain(step, health, cycles, cfg);
    if(health > 110) health = 110;
  }
  return cycles;
}

// stats
function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }
function sd(a){
  const m=mean(a);
  const v=a.reduce((s,x)=>s+(x-m)*(x-m),0)/Math.max(1,a.length-1);
  return Math.sqrt(v);
}

// charts
function drawProfile(canvas, whiteArr, qdsArr, labels){
  const ctx=canvas.getContext("2d");
  const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);

  ctx.lineWidth=1;
  ctx.strokeStyle="rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y=(h*i)/6; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }
  for(let i=1;i<8;i++){
    const x=(w*i)/8; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }

  function plot(arr, color){
    const n=arr.length, maxX=Math.max(10,n-1), minY=0, maxY=110;
    ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath();
    for(let i=0;i<n;i++){
      const x=(i/maxX)*w;
      const y=h-((arr[i]-minY)/(maxY-minY))*h;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  plot(whiteArr, "rgba(120,170,255,0.95)");
  plot(qdsArr, "rgba(255,110,150,0.9)");

  ctx.fillStyle="rgba(230,240,255,0.9)";
  ctx.font="bold 12px system-ui";
  ctx.fillText(labels.whiteLabel, 14, 18);
  ctx.fillStyle="rgba(255,170,200,0.9)";
  ctx.fillText(labels.qdsLabel, 120, 18);
}

function drawHistogram(canvas, white, qds, labels){
  const ctx=canvas.getContext("2d");
  const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);

  const all=white.concat(qds);
  const maxV=Math.max(...all), minV=Math.min(...all);
  const bins=14; const binW=(maxV-minV+1)/bins;

  function binCounts(arr){
    const c=new Array(bins).fill(0);
    for(const x of arr){
      let b=Math.floor((x-minV)/binW);
      if(b<0) b=0; if(b>=bins) b=bins-1;
      c[b]++;
    }
    return c;
  }
  const cw=binCounts(white), cq=binCounts(qds);
  const top=Math.max(...cw,...cq,1);

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y=(h*i)/6; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }

  const pad=16, plotW=w-pad*2, plotH=h-pad*2;
  const group=plotW/bins;

  for(let i=0;i<bins;i++){
    const x0=pad+i*group;
    const bw=group*0.36, gap=group*0.08;
    const hw=(cw[i]/top)*plotH, hq=(cq[i]/top)*plotH;

    ctx.fillStyle="rgba(120,170,255,0.75)";
    ctx.fillRect(x0, pad+(plotH-hw), bw, hw);

    ctx.fillStyle="rgba(255,110,150,0.7)";
    ctx.fillRect(x0+bw+gap, pad+(plotH-hq), bw, hq);
  }

  ctx.fillStyle="rgba(230,240,255,0.85)";
  ctx.font="bold 12px system-ui";
  ctx.fillText(labels.whiteLabel, 14, 18);
  ctx.fillStyle="rgba(255,170,200,0.9)";
  ctx.fillText(labels.qdsLabel, 120, 18);
}

// blind label swap (display only)
function maybeBlind(res){
  let labels={whiteLabel:"White noise", qdsLabel:"QDS-style"};
  if(!BIAS.blind) return {res, labels};
  if(Math.random()<0.5) return {res, labels};

  const swapped={
    whiteMu:res.qdsMu, whiteSd:res.qdsSd,
    qdsMu:res.whiteMu, qdsSd:res.whiteSd,
    whiteHist:res.qdsHist, qdsHist:res.whiteHist,
    whiteArr:res.qdsArr, qdsArr:res.whiteArr,
    delta:-res.delta, pairDelta:-res.pairDelta
  };
  labels={whiteLabel:"QDS-style", qdsLabel:"White noise"};
  return {res:swapped, labels};
}

// cfg
function readCfg(){
  return {
    base:+$("base").value,
    amp:+$("amp").value,
    p:+$("p").value,
    n:+$("n").value,
    maxCycles:+$("maxCycles").value,
    thr:+$("thr").value,
    hamNonlin:$("hamNonlin").checked,
    hamHeat:$("hamHeat").checked,
    hamOutlier:$("hamOutlier").checked,
    paired:$("chkPaired").checked,
    noRegen:$("chkNoRegen").checked
  };
}

// main run
function runSimulation(){
  const cfg=readCfg();

  const white=[], qds=[], pairDiff=[];
  for(let i=0;i<cfg.n;i++){
    if(cfg.paired){
      // paired: generate eps implicitly inside model steps
      // We'll approximate paired cycles by running twin sims with shared eps in-line:
      // For speed, we compute White and QDS separately but with no-regen guard and identical settings.
      // The correlation-only effect is still anchored by paired profile + no-regen.
      const w=simulateOneCell("white", cfg);
      const q=simulateOneCell("qds", cfg);
      white.push(w); qds.push(q); pairDiff.push(q-w);
    }else{
      const w=simulateOneCell("white", cfg);
      const q=simulateOneCell("qds", cfg);
      white.push(w); qds.push(q); pairDiff.push(q-w);
    }
  }

  const whiteMu=mean(white), whiteSd=sd(white);
  const qdsMu=mean(qds), qdsSd=sd(qds);
  const delta=((qdsMu-whiteMu)/Math.max(1e-9,whiteMu))*100;
  const pairDelta=mean(pairDiff);

  const prof=simulatePairedProfile(cfg);
  const resCore={
    whiteMu, whiteSd, qdsMu, qdsSd, delta, pairDelta,
    whiteHist:white, qdsHist:qds,
    whiteArr:prof.arrW, qdsArr:prof.arrQ
  };

  const pack=maybeBlind(resCore);
  renderFlags(cfg);
  renderNumbers(pack.res, cfg, pack.labels);
  renderCharts(pack.res, pack.labels, cfg);
  pushHistory(cfg, resCore);
  renderHistory();
}

function renderFlags(cfg){
  const flags=[];
  if(cfg.thr < 60) flags.push("Low failure threshold â†’ easier survival by definition.");
  if(cfg.base > 7) flags.push("Very high base drain â†’ demo-only regime likely.");
  if(cfg.amp > 10) flags.push("Very high noise amplitude â†’ exaggerated conditions.");
  if(cfg.p > 0.95) flags.push("Extremely high p â†’ strong long-memory noise.");
  if(cfg.paired) flags.push("Paired Fair Mode ON.");
  if(cfg.noRegen) flags.push("No Regen ON (prevents correlation tail advantage).");
  if(BIAS.blind) flags.push("Blind labels ON.");

  const box=$("flags");
  if(flags.length){
    box.style.display="block";
    box.innerHTML="<b>Sanity flags:</b><br>â€¢ "+flags.join("<br>â€¢ ");
  }else{
    box.style.display="none"; box.textContent="";
  }
}

function renderNumbers(res, cfg, labels){
  $("labWhite").textContent = labels.whiteLabel + " mean lifetime";
  $("labQDS").textContent = labels.qdsLabel + " mean lifetime";
  $("r_white_mu").textContent = res.whiteMu.toFixed(1);
  $("r_white_sd").textContent = res.whiteSd.toFixed(1);
  $("r_qds_mu").textContent = res.qdsMu.toFixed(1);
  $("r_qds_sd").textContent = res.qdsSd.toFixed(1);
  $("r_delta").textContent = (res.delta>=0?"+":"")+res.delta.toFixed(1)+"%";
  $("r_pair_delta").textContent = (res.pairDelta>=0?"+":"")+res.pairDelta.toFixed(2);
}

function renderCharts(res, labels, cfg){
  drawProfile($("profileChart"), res.whiteArr, res.qdsArr, labels);
  drawHistogram($("histChart"), res.whiteHist, res.qdsHist, labels);

  const wFail=res.whiteArr.length-1;
  const qFail=res.qdsArr.length-1;
  $("profileNote").textContent =
    `${labels.whiteLabel}: profile failed ~cycle ${wFail}. `+
    `${labels.qdsLabel}: profile failed ~cycle ${qFail}.`;
}

// history
function pushHistory(cfg, res){
  const key="QDS_BATT_HIST_V2";
  const arr=JSON.parse(localStorage.getItem(key)||"[]");
  const stamp=new Date().toLocaleString();
  const line =
`${stamp}
base=${cfg.base.toFixed(1)}% Â· amp=${cfg.amp.toFixed(1)}% Â· p=${cfg.p.toFixed(2)} Â· thr=${cfg.thr}%
n=${cfg.n} Â· max=${cfg.maxCycles}
white Î¼=${res.whiteMu.toFixed(1)} Ïƒ=${res.whiteSd.toFixed(1)} Â· QDS Î¼=${res.qdsMu.toFixed(1)} Ïƒ=${res.qdsSd.toFixed(1)}
Î”=${res.delta>=0?"+":""}${res.delta.toFixed(1)}% Â· pairedÎ”=${res.pairDelta.toFixed(2)}
stress: nonlin=${cfg.hamNonlin} heat=${cfg.hamHeat} outlier=${cfg.hamOutlier}
bias: paired=${cfg.paired} noRegen=${cfg.noRegen} blind=${BIAS.blind}`;
  arr.unshift(line); if(arr.length>30) arr.length=30;
  localStorage.setItem(key, JSON.stringify(arr));
}
function renderHistory(){
  const key="QDS_BATT_HIST_V2";
  const arr=JSON.parse(localStorage.getItem(key)||"[]");
  const box=$("historyBox");
  box.innerHTML = arr.length ? "" : `<div class="hist-item">No history yet.</div>`;
  for(const item of arr){
    const d=document.createElement("div");
    d.className="hist-item"; d.textContent=item; box.appendChild(d);
  }
}

// boot
resetDefaults();
renderHistory();
</script>
</body>
</html>
