<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>QDS • Random Walk Battery Habitat Lab v1.3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #050813;
      --bg-card: #0b1021;
      --bg-card-soft: #0f1427;
      --accent: #00f5ff;
      --accent-soft: rgba(0,245,255,0.12);
      --accent-2: #ffb83b;
      --danger: #ff4b6a;
      --text-main: #f5f7ff;
      --text-soft: #a3b1d9;
      --border-subtle: #1b2038;
      --good: #5af78e;
      --warn: #ffd56b;
      --bad: #ff6b81;
      --pill-bg: rgba(0,245,255,0.07);
      --radius-lg: 18px;
      --radius-pill: 999px;
      --shadow-soft: 0 18px 40px rgba(0,0,0,0.55);
      --shadow-strong: 0 22px 60px rgba(0,0,0,0.8);
      --transition-fast: 0.18s ease-out;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Roboto", "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #151c35 0, #050813 52%, #02030a 100%);
      color: var(--text-main);
      min-height: 100vh;
    }

    .wrap {
      max-width: 1120px;
      margin: 0 auto;
      padding: 16px 14px 26px;
    }

    .titlebar {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .pill {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(0,245,255,0.3);
      background: radial-gradient(circle at top left, rgba(0,245,255,0.22), rgba(0,0,0,0.2));
      color: var(--accent);
      letter-spacing: 0.03em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .pill span.dot {
      width: 5px;
      height: 5px;
      border-radius: 999px;
      background: var(--good);
      box-shadow: 0 0 6px rgba(90,247,142,0.9);
    }

    h1 {
      font-size: 21px;
      margin: 2px 0 0;
    }

    .sub {
      font-size: 13px;
      color: var(--text-soft);
      margin-top: 4px;
      max-width: 700px;
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.15fr);
      gap: 14px;
    }

    @media (max-width: 820px) {
      .grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      background: linear-gradient(145deg,#0c1021,#050817);
      border-radius: var(--radius-lg);
      padding: 12px 12px 14px;
      box-shadow: var(--shadow-soft);
      border: 1px solid var(--border-subtle);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -30%;
      background:
        radial-gradient(circle at 0 0, rgba(0,245,255,0.10), transparent 58%),
        radial-gradient(circle at 110% 20%, rgba(255,184,59,0.11), transparent 55%);
      opacity: 0.85;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .card-inner {
      position: relative;
      z-index: 1;
    }

    .card.compact {
      padding: 10px 10px 12px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 6px;
    }

    .card-title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .card-tagline {
      font-size: 11px;
      color: var(--text-soft);
    }

    .badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255,255,255,0.04);
      background: rgba(0,0,0,0.35);
      color: var(--text-soft);
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }

    .badge-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent-2);
      box-shadow: 0 0 8px rgba(255,184,59,0.8);
    }

    .badge-soft {
      background: rgba(0,245,255,0.05);
      border-color: rgba(0,245,255,0.3);
      color: var(--accent);
    }

    .fields {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 8px;
      margin-top: 4px;
    }

    @media (max-width: 640px) {
      .fields {
        grid-template-columns: minmax(0,1fr);
      }
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 11px;
    }

    .field label {
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      gap: 6px;
    }

    .field small {
      color: #6f7aa4;
      font-size: 10px;
    }

    input[type="number"],
    input[type="range"],
    select {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(4,7,20,0.95);
      color: var(--text-main);
      padding: 6px 8px;
      font-size: 12px;
      outline: none;
      transition: border var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast), transform var(--transition-fast);
    }

    input[type="number"]:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(0,245,255,0.3);
      background: #05091c;
      transform: translateY(-0.5px);
    }

    input[type="range"] {
      padding: 0;
      background: transparent;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 10px rgba(0,245,255,0.8);
      border: 1px solid #0b0f1f;
      margin-top: -6px;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      height: 4px;
      border-radius: 999px;
      background: linear-gradient(90deg, var(--good), var(--warn), var(--danger));
    }

    .hint-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
    }

    .hint-row strong {
      color: var(--accent-2);
      font-weight: 500;
    }

    .stack {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 4px;
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 4px 0 2px;
    }

    .chip {
      padding: 3px 8px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255,255,255,0.06);
      font-size: 10px;
      color: var(--text-soft);
      background: rgba(4,7,20,0.8);
    }

    .chip.good { border-color: rgba(90,247,142,0.6); color: var(--good); }
    .chip.warn { border-color: rgba(255,213,107,0.7); color: var(--warn); }
    .chip.bad  { border-color: rgba(255,107,129,0.7); color: var(--bad); }

    .metric-grid {
      display: grid;
      grid-template-columns: minmax(0,1.15fr) minmax(0,1fr);
      gap: 8px;
      margin-top: 6px;
    }

    @media (max-width: 640px) {
      .metric-grid {
        grid-template-columns: minmax(0,1fr);
      }
    }

    .metric {
      background: rgba(4,7,20,0.9);
      border-radius: 14px;
      padding: 8px 9px 9px;
      border: 1px solid rgba(255,255,255,0.04);
      display: flex;
      flex-direction: column;
      gap: 2px;
      box-shadow: 0 12px 26px rgba(0,0,0,0.55);
    }

    .metric label {
      font-size: 10px;
      color: var(--text-soft);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .metric-value {
      font-size: 17px;
      font-weight: 600;
      display: flex;
      align-items: baseline;
      gap: 4px;
    }

    .metric-value span.unit {
      font-size: 11px;
      color: var(--text-soft);
      font-weight: 400;
    }

    .metric-foot {
      font-size: 10px;
      color: #8490c0;
    }

    .metric-value.good { color: var(--good); }
    .metric-value.warn { color: var(--warn); }
    .metric-value.bad  { color: var(--bad); }

    canvas {
      width: 100%;
      height: 180px;
      border-radius: 14px;
      background: radial-gradient(circle at top left, rgba(0,245,255,0.14), rgba(0,0,0,0.8));
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: var(--shadow-soft);
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
      font-size: 10px;
      color: var(--text-soft);
    }

    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 9px;
      height: 9px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,0.9);
    }

    .legend-dot.base { border-color: var(--accent); }
    .legend-dot.nasa { border-color: var(--accent-2); }
    .legend-dot.target { border-color: var(--danger); }

    .exp-blocks {
      display: grid;
      grid-template-columns: minmax(0,1fr) minmax(0,1fr);
      gap: 8px;
      margin-top: 4px;
      font-size: 11px;
    }

    @media (max-width: 720px) {
      .exp-blocks {
        grid-template-columns: minmax(0,1fr);
      }
    }

    .exp-block {
      background: rgba(4,7,20,0.92);
      border-radius: 12px;
      padding: 7px 8px 8px;
      border: 1px solid rgba(255,255,255,0.04);
    }

    .exp-title {
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .exp-tag {
      font-size: 10px;
      color: var(--accent);
      margin-bottom: 4px;
    }

    ul {
      margin: 4px 0 0;
      padding-left: 16px;
      color: var(--text-soft);
    }

    li {
      margin-bottom: 2px;
    }

    .footnote {
      margin-top: 10px;
      font-size: 10px;
      color: var(--text-soft);
    }

    .footnote strong {
      color: var(--accent);
    }

    .linkish {
      text-decoration: underline;
      text-decoration-style: dotted;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="titlebar">
      <div class="pill-row">
        <span class="pill"><span class="dot"></span> QDS • Battery Habitat – RW Lab v1.3</span>
        <span class="pill">NASA 18650 random walk (room temp)</span>
        <span class="pill">Single-cell life estimator</span>
      </div>
      <h1>Random-Walk Discharge Lab — calibrated with NASA RW1/RW2/RW7/RW8</h1>
      <div class="sub">
        One HTML page to sketch lifetime under randomized use. Plug in reference-cycle
        capacity points extracted from the NASA random walk dataset, then tune to your
        own duty-cycle. The maths is light, the assumptions are explicit.
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: INPUTS -->
      <div class="stack">
        <div class="card">
          <div class="card-inner">
            <div class="card-header">
              <div>
                <div class="card-title">Cell & duty profile</div>
                <div class="card-tagline">Basic physics knobs — everything else is derived.</div>
              </div>
              <div class="badge badge-soft">
                <span class="badge-dot"></span> live estimate
              </div>
            </div>

            <div class="fields">
              <div class="field">
                <label for="nominalCapacity">
                  Nominal capacity
                  <span><strong id="nominalCapacityEcho">2.0</strong> Ah</span>
                </label>
                <input id="nominalCapacity" type="number" step="0.05" min="0.5" max="5"
                       value="2.0" />
                <small>Manufacturer / fresh-cell spec (Ah).</small>
              </div>

              <div class="field">
                <label for="eolThreshold">
                  End-of-life threshold
                  <span><strong id="eolThresholdEcho">80</strong>%</span>
                </label>
                <input id="eolThreshold" type="number" step="1" min="50" max="100" value="80" />
                <small>Capacity where you decide “this cell is done”.</small>
              </div>

              <div class="field">
                <label for="cyclesPerDay">
                  Typical random-walk cycles per day
                  <span><strong id="cyclesPerDayEcho">5</strong> RW</span>
                </label>
                <input id="cyclesPerDay" type="number" step="1" min="0.5" max="40" value="5" />
                <small>How many NASA-style RW discharge + recharge blocks per day.</small>
              </div>

              <div class="field">
                <label for="intensity">
                  Usage intensity slider
                  <span id="intensityEcho">NASA-like</span>
                </label>
                <input id="intensity" type="range" min="0.6" max="1.6" step="0.1" value="1.0" />
                <small>
                  0.6: gentler than NASA (cooler / lower C-rate). 1.6: harsher (hotter / higher C-rate).
                </small>
              </div>
            </div>

            <div class="hint-row">
              <span><strong>Tip:</strong> NASA RW cells were cycled at 0.5–4A between 4.2V ↔ 3.2V with
              randomized charge durations. If your profile is milder, lifetime stretches; harsher, it shrinks.</span>
            </div>
          </div>
        </div>

        <div class="card compact">
          <div class="card-inner">
            <div class="card-header">
              <div>
                <div class="card-title">NASA reference calibration</div>
                <div class="card-tagline">Fit a simple capacity-vs-cycle curve from real data.</div>
              </div>
              <div class="badge">
                <span class="badge-dot" style="background: var(--accent-2); box-shadow: 0 0 8px rgba(255,184,59,0.9);"></span>
                RW1 / RW2 / RW7 / RW8
              </div>
            </div>

            <div class="fields">
              <div class="field">
                <label>
                  Point A (early reference)
                  <span>cycle &amp; capacity</span>
                </label>
                <div style="display:flex; gap:6px;">
                  <input id="c1_cycles" type="number" step="1" min="0" value="50"
                         style="flex:0 0 40%;" />
                  <input id="c1_cap" type="number" step="0.02" min="0.3" value="1.95"
                         style="flex:1;" />
                </div>
                <small>Example only — replace with your extracted NASA value (Ah).</small>
              </div>

              <div class="field">
                <label>
                  Point B (mid experiment)
                  <span>cycle &amp; capacity</span>
                </label>
                <div style="display:flex; gap:6px;">
                  <input id="c2_cycles" type="number" step="1" min="1" value="600"
                         style="flex:0 0 40%;" />
                  <input id="c2_cap" type="number" step="0.02" min="0.3" value="1.75"
                         style="flex:1;" />
                </div>
                <small>Reference discharge capacity around the mid-life region.</small>
              </div>

              <div class="field">
                <label>
                  Point C (late reference)
                  <span>cycle &amp; capacity</span>
                </label>
                <div style="display:flex; gap:6px;">
                  <input id="c3_cycles" type="number" step="1" min="1" value="1150"
                         style="flex:0 0 40%;" />
                  <input id="c3_cap" type="number" step="0.02" min="0.3" value="1.55"
                         style="flex:1;" />
                </div>
                <small>Use the last valid reference discharge you trust.</small>
              </div>

              <div class="field">
                <label for="fitShape">
                  Degradation curve shape
                  <span></span>
                </label>
                <select id="fitShape">
                  <option value="linear">Linear fade (good first pass)</option>
                  <option value="exp">Exponential fade (slightly faster later)</option>
                </select>
                <small>Both are simple approximations, not full electrochemistry.</small>
              </div>
            </div>

            <div class="hint-row">
              <span><strong>How to use:</strong> run the NASA example code (or your own) to
              compute capacity from each reference discharge, then drop three representative
              points here. This page just fits the curve and projects forwards.</span>
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT: OUTPUTS & NASA MAP -->
      <div class="stack">
        <div class="card">
          <div class="card-inner">
            <div class="card-header">
              <div>
                <div class="card-title">Lifetime snapshot</div>
                <div class="card-tagline">Derived directly from your calibration + duty sliders.</div>
              </div>
              <div class="badge">
                <span class="badge-dot" style="background: var(--good); box-shadow: 0 0 8px rgba(90,247,142,0.9);"></span>
                physics-bounded guess
              </div>
            </div>

            <div class="metric-grid">
              <div class="metric">
                <label>Cycles to end-of-life</label>
                <div class="metric-value" id="mv_cycles">
                  <span>—</span><span class="unit">RW cycles</span>
                </div>
                <div class="metric-foot" id="mf_cycles">
                  Waiting for valid calibration points…
                </div>
              </div>

              <div class="metric">
                <label>Calendar life at current usage</label>
                <div class="metric-value" id="mv_days">
                  <span>—</span><span class="unit">days</span>
                </div>
                <div class="metric-foot" id="mf_days">
                  Based on cycles/day × intensity vs NASA.
                </div>
              </div>

              <div class="metric">
                <label>Fade rate</label>
                <div class="metric-value" id="mv_faderate">
                  <span>—</span><span class="unit">% / 100 RW</span>
                </div>
                <div class="metric-foot" id="mf_faderate">
                  Effective capacity drop over 100 random-walk cycles.
                </div>
              </div>

              <div class="metric">
                <label>Stress vs NASA baseline</label>
                <div class="metric-value" id="mv_stress">
                  <span>—</span><span class="unit">× NASA</span>
                </div>
                <div class="metric-foot" id="mf_stress">
                  1.0 ≈ NASA profile; &lt;1.0 is gentler, &gt;1.0 is harsher.
                </div>
              </div>
            </div>

            <div style="margin-top:10px;">
              <canvas id="capChart" width="500" height="200"></canvas>
              <div class="legend">
                <span><span class="legend-dot base"></span> Modelled capacity curve</span>
                <span><span class="legend-dot nasa"></span> NASA calibration points</span>
                <span><span class="legend-dot target"></span> End-of-life threshold</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card compact">
          <div class="card-inner">
            <div class="card-header">
              <div>
                <div class="card-title">NASA experiment map</div>
                <div class="card-tagline">What the RW dataset actually did, in human words.</div>
              </div>
              <div class="badge">
                <span class="badge-dot" style="background: var(--accent); box-shadow: 0 0 8px rgba(0,245,255,0.9);"></span>
                reference → random walk → reference
              </div>
            </div>

            <div class="exp-blocks">
              <div class="exp-block">
                <div class="exp-title">Reference cycles (health beacons)</div>
                <div class="exp-tag">comments like “reference charge / discharge”, “low current charge / discharge”</div>
                <ul>
                  <li>Slow 0.04A charge / discharge passes map open-circuit voltage vs SOC.</li>
                  <li>2A reference charge to 4.2V + 2A discharge to 3.2V every 50 RW cycles benchmarks capacity.</li>
                  <li>Pulsed 1A charge / discharge (10 min on / 20 min rest) every 100 RW cycles tracks transient response &amp; internal resistance.</li>
                </ul>
              </div>

              <div class="exp-block">
                <div class="exp-title">Random-walk cycles (real-world abuse)</div>
                <div class="exp-tag">comments like “charge (random walk)”, “discharge (random walk)”</div>
                <ul>
                  <li>Charge at 2A for a random time (0.5–2.5 h) or until full, sometimes with CV tail.</li>
                  <li>Then discharge in 5-minute chunks between 0.5–4A, with &lt;1s rests while the next current is chosen.</li>
                  <li>Hit 3.2V → rest (later in the test) → random-length recharge. Repeat hundreds of times.</li>
                </ul>
              </div>
            </div>

            <div class="footnote">
              <strong>How this page fits in:</strong> the heavy lifting (integrating current, handling all the comment
              codes, fitting detailed models) belongs in Python / R with the raw NASA <code>.mat</code> / <code>.Rda</code>
              files. This HTML is the fast “habitat view” — once you have a few calibration points, you can explore
              “what if we changed duty / casing / cooling?” without re-running the full analysis every time.
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="footnote">
      <strong>Note:</strong> The default calibration values here are illustrative only, not official NASA numbers.
      Replace them with capacities you compute from the real RW reference cycles if you want hard accuracy.
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const inputs = [
      "nominalCapacity","eolThreshold","cyclesPerDay","intensity",
      "c1_cycles","c1_cap","c2_cycles","c2_cap","c3_cycles","c3_cap","fitShape"
    ];

    function linearFit(xs, ys) {
      const n = xs.length;
      if (n < 2) return null;
      let sumx = 0, sumy = 0, sumxy = 0, sumx2 = 0;
      for (let i = 0; i < n; i++) {
        const x = xs[i], y = ys[i];
        sumx += x; sumy += y;
        sumxy += x * y;
        sumx2 += x * x;
      }
      const denom = n * sumx2 - sumx * sumx;
      if (Math.abs(denom) < 1e-9) return null;
      const m = (n * sumxy - sumx * sumy) / denom;
      const b = (sumy - m * sumx) / n;
      return { m, b };
    }

    function expFit(xs, ys) {
      // crude exponential fit: C(N) = a * exp(kN)
      const n = xs.length;
      if (n < 2) return null;
      let sumx = 0, sumlny = 0, sumxlny = 0, sumx2 = 0;
      let valid = 0;
      for (let i = 0; i < n; i++) {
        const x = xs[i], y = ys[i];
        if (y <= 0) continue;
        const ly = Math.log(y);
        sumx += x; sumlny += ly;
        sumxlny += x * ly;
        sumx2 += x * x;
        valid++;
      }
      if (valid < 2) return null;
      const denom = valid * sumx2 - sumx * sumx;
      if (Math.abs(denom) < 1e-9) return null;
      const k = (valid * sumxlny - sumx * sumlny) / denom;
      const lnA = (sumlny - k * sumx) / valid;
      const a = Math.exp(lnA);
      return { a, k };
    }

    function computeModel() {
      const C_nom = parseFloat($("nominalCapacity").value) || 2.0;
      const eolPct = Math.min(100, Math.max(10, parseFloat($("eolThreshold").value) || 80));
      const cyclesPerDay = Math.max(0, parseFloat($("cyclesPerDay").value) || 0);
      const intensity = parseFloat($("intensity").value) || 1.0;

      $("nominalCapacityEcho").textContent = C_nom.toFixed(2);
      $("eolThresholdEcho").textContent = eolPct.toFixed(0);
      $("cyclesPerDayEcho").textContent = cyclesPerDay.toFixed(1);

      let intensityLabel = "NASA-like";
      if (intensity < 0.8) intensityLabel = "gentler than NASA";
      else if (intensity > 1.2) intensityLabel = "harsher than NASA";
      $("intensityEcho").textContent = intensityLabel;

      const xs = [];
      const ys = [];

      ["1","2","3"].forEach(idx => {
        const c = parseFloat($("c" + idx + "_cycles").value);
        const cap = parseFloat($("c" + idx + "_cap").value);
        if (Number.isFinite(c) && Number.isFinite(cap) && c >= 0 && cap > 0) {
          xs.push(c);
          ys.push(cap);
        }
      });

      let cyclesToEol = null;
      let fadePer100 = null;
      const C_eol = C_nom * eolPct / 100;

      let curveFn = null, maxCycle = null;

      if (xs.length >= 2) {
        const shape = $("fitShape").value;
        if (shape === "exp") {
          const p = expFit(xs, ys);
          if (p) {
            curveFn = (N) => p.a * Math.exp(p.k * N);
            // rough bracket for EOL search
            maxCycle = Math.max(...xs) * 2.0;
            const f0 = curveFn(0);
            const fEnd = curveFn(maxCycle);
            // if already below threshold, assume EOL within dataset
            if (f0 <= C_eol) {
              cyclesToEol = 0;
            } else if (fEnd > C_eol) {
              // fade too gentle; no EOL within bracket
              cyclesToEol = Infinity;
            } else {
              // bisection search
              let lo = 0, hi = maxCycle;
              for (let i = 0; i < 40; i++) {
                const mid = 0.5 * (lo + hi);
                if (curveFn(mid) > C_eol) lo = mid; else hi = mid;
              }
              cyclesToEol = 0.5 * (lo + hi);
            }

            // effective fade per 100 cycles near centre
            const Nmid = (Math.min(...xs) + Math.max(...xs)) / 2;
            const cA = curveFn(Nmid);
            const cB = curveFn(Nmid + 100);
            if (cA > 0) fadePer100 = 100 * (cA - cB) / C_nom;
          }
        } else {
          const p = linearFit(xs, ys);
          if (p) {
            curveFn = (N) => p.m * N + p.b;
            maxCycle = Math.max(...xs) * 2.0;
            if (Math.abs(p.m) < 1e-9) {
              cyclesToEol = Infinity;
            } else {
              const N_eol = (C_eol - p.b) / p.m;
              cyclesToEol = N_eol;
            }
            const cA = curveFn(0);
            const cB = curveFn(100);
            if (Number.isFinite(cA) && Number.isFinite(cB)) {
              fadePer100 = 100 * (cA - cB) / C_nom;
            }
          }
        }
      }

      const stressVsNasa = intensity; // direct mapping; can tweak later.

      // Update metrics
      const mvCycles = $("mv_cycles");
      const mvDays = $("mv_days");
      const mvFade = $("mv_faderate");
      const mvStress = $("mv_stress");

      const mfCycles = $("mf_cycles");
      const mfDays = $("mf_days");
      const mfFade = $("mf_faderate");
      const mfStress = $("mf_stress");

      function setMetric(el, cls, text) {
        el.classList.remove("good","warn","bad");
        if (cls) el.classList.add(cls);
        el.firstElementChild.textContent = text;
      }

      if (!curveFn || !Number.isFinite(cyclesToEol) || cyclesToEol <= 0) {
        setMetric(mvCycles, null, "—");
        mfCycles.textContent = "Need at least two sensible calibration points.";
        setMetric(mvDays, null, "—");
        mfDays.textContent = "Lifetime in days shows once cycles to EOL is known.";
        setMetric(mvFade, null, "—");
        mfFade.textContent = "Fade per 100 cycles appears once a curve is fitted.";
      } else {
        const cycClean = Math.max(0, cyclesToEol);
        let cls = "good";
        if (cycClean < 400) cls = "bad";
        else if (cycClean < 800) cls = "warn";

        setMetric(mvCycles, cls, cycClean.toFixed(0));
        mfCycles.textContent = "From NASA-style calibration → " + eolPct.toFixed(0) + "% of nominal.";

        if (cyclesPerDay > 0) {
          const days = cycClean / (cyclesPerDay * stressVsNasa);
          let clsD = "good";
          if (days < 365) clsD = "bad";
          else if (days < 730) clsD = "warn";
          setMetric(mvDays, clsD, days.toFixed(0));
          mfDays.textContent = "If you keep cycling at ~" +
            cyclesPerDay.toFixed(1) + " RW/day and intensity " + stressVsNasa.toFixed(2) + "× NASA.";
        } else {
          setMetric(mvDays, null, "—");
          mfDays.textContent = "Set cycles/day to see calendar life.";
        }

        if (fadePer100 != null && Number.isFinite(fadePer100)) {
          let clsF = "good";
          if (fadePer100 > 4) clsF = "bad";
          else if (fadePer100 > 2) clsF = "warn";
          setMetric(mvFade, clsF, fadePer100.toFixed(2));
          mfFade.textContent = "Average drop in usable capacity per 100 RW cycles (relative to nominal).";
        } else {
          setMetric(mvFade, null, "—");
          mfFade.textContent = "Fade per 100 cycles appears once a curve is fitted.";
        }
      }

      // Stress metric
      let clsS = "good";
      if (stressVsNasa > 1.25) clsS = "bad";
      else if (stressVsNasa > 1.05) clsS = "warn";
      setMetric(mvStress, clsS, stressVsNasa.toFixed(2));
      mfStress.textContent = "1.0 ≈ NASA random walk. <1.0 = softer use, >1.0 = harder.";

      // Draw chart
      drawChart(curveFn, xs, ys, C_nom, C_eol, cyclesToEol);
    }

    function drawChart(curveFn, xs, ys, C_nom, C_eol, cyclesToEol) {
      const canvas = $("capChart");
      const ctx = canvas.getContext("2d");

      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);

      // background gradient
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, "rgba(5,10,40,1)");
      grad.addColorStop(1, "rgba(1,3,14,1)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);

      ctx.save();
      const padLeft = 38;
      const padRight = 10;
      const padTop = 10;
      const padBottom = 22;

      const plotW = w - padLeft - padRight;
      const plotH = h - padTop - padBottom;

      const allCycles = xs.slice();
      if (Number.isFinite(cyclesToEol) && cyclesToEol > 0 && cyclesToEol !== Infinity) {
        allCycles.push(cyclesToEol);
      }
      const maxX = allCycles.length ? Math.max(...allCycles) * 1.05 : 1200;
      const maxY = C_nom * 1.05;

      function xToPx(x) {
        return padLeft + (x / maxX) * plotW;
      }
      function yToPx(y) {
        return padTop + (1 - (y / maxY)) * plotH;
      }

      // Axes
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padLeft, padTop);
      ctx.lineTo(padLeft, padTop + plotH);
      ctx.lineTo(padLeft + plotW, padTop + plotH);
      ctx.stroke();

      // Threshold line
      if (C_eol > 0) {
        ctx.strokeStyle = "rgba(255,75,106,0.7)";
        ctx.setLineDash([4,4]);
        ctx.beginPath();
        ctx.moveTo(padLeft, yToPx(C_eol));
        ctx.lineTo(padLeft + plotW, yToPx(C_eol));
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Model curve
      if (curveFn && Number.isFinite(maxX) && maxX > 0) {
        ctx.strokeStyle = "rgba(0,245,255,0.85)";
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        const steps = 80;
        for (let i = 0; i <= steps; i++) {
          const frac = i / steps;
          const N = frac * maxX;
          let C = curveFn(N);
          if (!Number.isFinite(C)) continue;
          C = Math.max(0, Math.min(maxY, C));
          const px = xToPx(N);
          const py = yToPx(C);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }

      // NASA calibration points
      ctx.fillStyle = "#ffb83b";
      for (let i = 0; i < xs.length; i++) {
        const px = xToPx(xs[i]);
        const py = yToPx(ys[i]);
        ctx.beginPath();
        ctx.arc(px, py, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // Axes labels (simple ticks)
      ctx.fillStyle = "rgba(163,177,217,0.9)";
      ctx.font = "10px system-ui, -apple-system, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";

      const tickCount = 4;
      for (let i = 0; i <= tickCount; i++) {
        const cyc = (maxX * i) / tickCount;
        const x = xToPx(cyc);
        ctx.fillText(Math.round(cyc), x, padTop + plotH + 4);
      }
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for (let i = 0; i <= 4; i++) {
        const cap = (maxY * i) / 4;
        const y = yToPx(cap);
        ctx.fillText(cap.toFixed(1), padLeft - 4, y);
      }

      ctx.restore();
    }

    inputs.forEach(id => {
      const el = $(id);
      if (!el) return;
      el.addEventListener("input", computeModel);
      el.addEventListener("change", computeModel);
    });

    window.addEventListener("load", computeModel);
  </script>
</body>
</html>
