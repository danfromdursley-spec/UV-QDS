
// --- qds_universe_v9_10_neon_planet_colours.html ---


  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

  const PLANET_TEXT = {
    mercury: "Mercury ‚Äì fast, hot, and a bit crispy.",
    venus:   "Venus ‚Äì runaway greenhouse. Do not open windows.",
    earth:   "Earth ‚Äì liquid water, plate tectonics, questionable Wi‚ÄëFi.",
    mars:    "Mars ‚Äì dusty, cold, working on the whole 'habitable' thing.",
    jupiter: "Jupiter ‚Äì big lad. Moon hoarder. Storm enthusiast.",
    saturn:  "Saturn ‚Äì brings its own hula hoop collection.",
    uranus:  "Uranus ‚Äì tilted like it had a rough day.",
    neptune: "Neptune ‚Äì deep blue and very, very windy.",
    pluto:   "Pluto ‚Äì tiny, icy, emotionally still a planet."
  };

  const state = {
    qdsLambda: 1.4,
    qdsTau: 2.0,
    orbitSpeed: 1.0,
    gridAmp: 1.0,
    chaosOn: false,
    meltdown: false,
    rideTarget: "earth",
    rideOn: false,
    cmewaves: [],
    t: 0
  };

  function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

    const camera = new BABYLON.ArcRotateCamera("cam",
      -Math.PI / 2.2,
      Math.PI / 2.6,
      120,
      new BABYLON.Vector3(0, 8, 0),
      scene
    );
    camera.attachControl(canvas, true);
    camera.lowerRadiusLimit = 40;
    camera.upperRadiusLimit = 220;

    const light = new BABYLON.HemisphericLight("hemi",
      new BABYLON.Vector3(0, 1, 0),
      scene
    );
    light.intensity = 0.6;

    const sunLight = new BABYLON.PointLight("sunLight",
      new BABYLON.Vector3(0, 6, 0),
      scene
    );
    sunLight.intensity = 1.3;

    const glow = new BABYLON.GlowLayer("glow", scene);
    glow.intensity = 0.7;

    // QDS grid
    const grid = BABYLON.MeshBuilder.CreateGround("qdsGrid", {
      width: 420,
      height: 420,
      subdivisions: 140
    }, scene);
    grid.position.y = -6;

    const gridMat = new BABYLON.StandardMaterial("gridMat", scene);
    gridMat.wireframe = true;
    gridMat.diffuseColor = new BABYLON.Color3(0.05, 0.7, 0.9);
    gridMat.emissiveColor = new BABYLON.Color3(0.0, 0.4, 0.6);
    grid.material = gridMat;

    // Warp the grid
    const positions = grid.getVerticesData(BABYLON.VertexBuffer.PositionKind);

    scene.registerBeforeRender(() => {
      const t = state.t;
      const lambda = state.qdsLambda;
      const tau = state.qdsTau;
      const ampBase = state.meltdown ? 2.4 : 1.4;
      const amp = (ampBase + (state.chaosOn ? 0.6 : 0.0)) * state.gridAmp;
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const z = positions[i + 2];
        const r = Math.sqrt(x*x + z*z);
        const wobble = Math.sin(r * 0.08 * lambda - t * 0.9 * tau);
        positions[i + 1] = wobble * amp;
      }
      grid.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
      grid.refreshBoundingInfo();

      state.cmewaves = state.cmewaves.filter(w => {
        w.radius += w.speed;
        w.mesh.scaling.setAll(w.radius);
        const fade = Math.max(0, 1.0 - w.radius / 260);
        w.material.emissiveColor = new BABYLON.Color3(1.0, 0.8 * fade, 0.2 * fade);
        if (w.radius > 260) {
          w.mesh.dispose();
          return false;
        }
        return true;
      });

      if (state.rideOn && planets[state.rideTarget]) {
        const target = planets[state.rideTarget].mesh;
        const pos = target.position;
        camera.target.copyFrom(pos);
        camera.alpha += 0.0015;
      }

      state.t += engine.getDeltaTime() * 0.001;
    });

    // Sun
    const sun = BABYLON.MeshBuilder.CreateSphere("sun", { diameter: 18, segments: 32 }, scene);
    sun.position.y = 6;

    const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
    sunMat.diffuseColor = new BABYLON.Color3(1.0, 0.95, 0.7);
    sunMat.emissiveColor = new BABYLON.Color3(1.4, 1.1, 0.4);
    sun.material = sunMat;

    const corona = BABYLON.MeshBuilder.CreateSphere("corona",
      { diameter: 30, segments: 32 },
      scene
    );
    const coronaMat = new BABYLON.StandardMaterial("coronaMat", scene);
    coronaMat.emissiveColor = new BABYLON.Color3(0.9, 0.95, 1.3);
    coronaMat.alpha = 0.25;
    corona.material = coronaMat;
    corona.position = sun.position.clone();

    // Planets: brighter + slightly larger
    function makePlanet(name, radius, distance, color, emissive, speed) {
      const planet = BABYLON.MeshBuilder.CreateSphere(name, {
        diameter: radius * 2.2,
        segments: 24
      }, scene);
      const mat = new BABYLON.StandardMaterial(name + "Mat", scene);
      mat.diffuseColor = color;
      mat.specularColor = new BABYLON.Color3(0.2,0.2,0.2);
      mat.emissiveColor = emissive;
      planet.material = mat;

      const halo = BABYLON.MeshBuilder.CreateSphere(name + "Halo", {
        diameter: radius * 3.3,
        segments: 24
      }, scene);
      const haloMat = new BABYLON.StandardMaterial(name + "HaloMat", scene);
      haloMat.emissiveColor = emissive.scale(1.4);
      haloMat.alpha = 0.16;
      halo.material = haloMat;

      planet.position.x = distance;
      planet.position.y = 4;
      halo.parent = planet;

      return { mesh: planet, speed, distance, angle: Math.random() * Math.PI * 2 };
    }

    window.planets = {
      mercury: makePlanet("mercury", 1.2, 26,
        // Mercury ‚Äî hot grey
        new BABYLON.Color3(0.85, 0.82, 0.78),
        new BABYLON.Color3(1.00, 0.95, 0.90),
        0.024),
      venus: makePlanet("venus", 1.7, 34,
        // Venus ‚Äî warm yellow
        new BABYLON.Color3(1.00, 0.86, 0.50),
        new BABYLON.Color3(1.15, 0.98, 0.65),
        0.018),
      earth: makePlanet("earth", 1.8, 42,
        // Earth ‚Äî deep blue
        new BABYLON.Color3(0.15, 0.35, 1.10),
        new BABYLON.Color3(0.35, 0.75, 1.35),
        0.015),
      mars: makePlanet("mars", 1.4, 50,
        // Mars ‚Äî bright red/orange
        new BABYLON.Color3(1.00, 0.35, 0.10),
        new BABYLON.Color3(1.15, 0.55, 0.25),
        0.013),
      jupiter: makePlanet("jupiter", 3.5, 64,
        // Jupiter ‚Äî orange/banded
        new BABYLON.Color3(1.00, 0.76, 0.48),
        new BABYLON.Color3(1.20, 0.90, 0.65),
        0.010),
      saturn: makePlanet("saturn", 3.0, 80,
        // Saturn ‚Äî pale gold
        new BABYLON.Color3(0.96, 0.84, 0.60),
        new BABYLON.Color3(1.10, 0.96, 0.72),
        0.008),
      uranus: makePlanet("uranus", 2.4, 96,
        // Uranus ‚Äî teal
        new BABYLON.Color3(0.40, 0.90, 0.95),
        new BABYLON.Color3(0.55, 1.10, 1.25),
        0.006),
      neptune: makePlanet("neptune", 2.4, 112,
        // Neptune ‚Äî deep indigo
        new BABYLON.Color3(0.20, 0.35, 1.00),
        new BABYLON.Color3(0.35, 0.60, 1.35),
        0.005),
      pluto: makePlanet("pluto", 1.1, 130,
        // Pluto ‚Äî icy grey/blue
        new BABYLON.Color3(0.80, 0.86, 0.96),
        new BABYLON.Color3(0.92, 0.98, 1.20),
        0.004)
    };

    // Saturn ring
    const ring = BABYLON.MeshBuilder.CreateTorus("saturnRing", {
      diameter: 16,
      thickness: 0.4,
      tessellation: 80
    }, scene);
    const ringMat = new BABYLON.StandardMaterial("ringMat", scene);
    ringMat.emissiveColor = new BABYLON.Color3(1.0, 0.9, 0.7);
    ringMat.diffuseColor = new BABYLON.Color3(0.9, 0.8, 0.5);
    ring.material = ringMat;
    ring.rotation.x = Math.PI / 2;
    ring.parent = planets.saturn.mesh;

    // Orbit lines
    Object.values(planets).forEach(p => {
      const circle = BABYLON.MeshBuilder.CreateTorus("orbit_"+p.mesh.name, {
        diameter: p.distance * 2,
        thickness: 0.08,
        tessellation: 140
      }, scene);
      const om = new BABYLON.StandardMaterial("orbitMat_"+p.mesh.name, scene);
      om.emissiveColor = new BABYLON.Color3(0.3, 0.6, 1.0);
      om.alpha = 0.5;
      circle.material = om;
      circle.rotation.x = Math.PI / 2;
      circle.position.y = 4;
    });

    scene.onBeforeRenderObservable.add(() => {
      const dt = engine.getDeltaTime() * 0.001;
      Object.values(planets).forEach(p => {
        p.angle += p.speed * state.orbitSpeed * (state.chaosOn ? 1.5 : 1.0);
        const x = Math.cos(p.angle) * p.distance;
        const z = Math.sin(p.angle) * p.distance;
        p.mesh.position.x = x;
        p.mesh.position.z = z;
      });
    });

    // CME firing
    function fireCME(strength = 1.0) {
      const torus = BABYLON.MeshBuilder.CreateTorus("cmeRing", {
        diameter: 22,
        thickness: 0.8,
        tessellation: 90
      }, scene);
      const mat = new BABYLON.StandardMaterial("cmeMat", scene);
      mat.emissiveColor = new BABYLON.Color3(1.0, 0.9, 0.4);
      torus.material = mat;
      torus.position.y = 6;
      torus.rotation.x = Math.PI / 2;
      state.cmewaves.push({
        mesh: torus,
        material: mat,
        radius: 1,
        speed: 0.7 + strength * 0.4
      });
    }
    window.fireCME = fireCME;

    window.applyMode = function(mode) {
      if (mode === "normal") {
        state.chaosOn = false;
        state.meltdown = false;
        glow.intensity = 0.7;
        gridMat.emissiveColor = new BABYLON.Color3(0.0, 0.4, 0.6);
        sunMat.emissiveColor = new BABYLON.Color3(1.4, 1.1, 0.4);
      } else if (mode === "chaos") {
        state.chaosOn = !state.chaosOn;
      } else if (mode === "meltdown") {
        state.meltdown = !state.meltdown;
        glow.intensity = state.meltdown ? 1.0 : 0.7;
      }
    };

    window.setLambda = v => { state.qdsLambda = v; };
    window.setTau = v => { state.qdsTau = v; };
    window.getCamera = () => camera;

    return scene;
  }

  const scene = createScene();

  engine.runRenderLoop(() => {
    scene.render();
  });

  window.addEventListener("resize", () => {
    engine.resize();
  });

  // HUD wiring
  const orbitSlider = document.getElementById("orbitSlider");
  const gridSlider = document.getElementById("gridSlider");
  const orbitVal = document.getElementById("orbitVal");
  const gridVal = document.getElementById("gridVal");
  const lambdaSlider = document.getElementById("lambdaSlider");
  const tauSlider = document.getElementById("tauSlider");
  const lambdaVal = document.getElementById("lambdaVal");
  const tauVal = document.getElementById("tauVal");
  const planetSelect = document.getElementById("planetSelect");
  const planetInfo = document.getElementById("planetInfo");
  const statusBar = document.getElementById("statusBar");

  lambdaSlider.oninput = e => {
    const v = parseFloat(e.target.value);
    lambdaVal.textContent = v.toFixed(1);
    window.setLambda(v);
  };
  tauSlider.oninput = e => {
    const v = parseFloat(e.target.value);
    tauVal.textContent = v.toFixed(1);
    window.setTau(v);
  };

  orbitSlider.oninput = e => {
    const v = parseFloat(e.target.value);
    orbitVal.textContent = v.toFixed(1) + "√ó";
    state.orbitSpeed = v;
  };
  gridSlider.oninput = e => {
    const v = parseFloat(e.target.value);
    gridVal.textContent = v.toFixed(1) + "√ó";
    state.gridAmp = v;
  };

  document.getElementById("btnCME").onclick = () => {
    window.fireCME(1.0);
    statusBar.textContent = "Status: CME fired ‚Äì shock ring through QDS grid.";
  };
  document.getElementById("btnChaos").onclick = () => {
    window.applyMode("chaos");
    statusBar.textContent = "Status: MAX Chaos toggled ‚Äì jittery orbits and noisy grid.";
  };
  document.getElementById("btnNormal").onclick = () => {
    window.applyMode("normal");
    statusBar.textContent = "Status: Back to calmer QDS field.";
  };
  document.getElementById("btnMeltdown").onclick = () => {
    window.applyMode("meltdown");
    statusBar.textContent = "Status: QDS MELTDOWN ‚Äì grid amplitude cranked. Hold onto your hat.";
  };
  document.getElementById("btnRide").onclick = () => {
    const cam = window.getCamera();
    state.rideOn = !state.rideOn;
    if (!state.rideOn) {
      statusBar.textContent = "Status: Ride Along disengaged. Camera free.";
      return;
    }
    const targetKey = planetSelect.value === "none" ? "earth" : planetSelect.value;
    state.rideTarget = targetKey;
    statusBar.textContent = "Status: Riding along with " + targetKey.toUpperCase() + ".";
    if (planets[targetKey]) {
      cam.radius = 22;
      cam.beta = Math.PI / 2.4;
    }
  };

  planetSelect.onchange = e => {
    const key = e.target.value;
    if (key === "none") {
      planetInfo.textContent = "Planet info will appear here.";
      return;
    }
    planetInfo.textContent = PLANET_TEXT[key] || "";
    state.rideTarget = key;
  };

  document.getElementById("hudToggle").onclick = () => {
    const hud = document.getElementById("hud");
    if (hud.style.display === "none") {
      hud.style.display = "block";
    } else {
      hud.style.display = "none";
    }
  };


// --- solar_system_v8_offline.html ---


const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color3(0,0,0);

const camera = new BABYLON.ArcRotateCamera("cam", Math.PI/2, Math.PI/2.5, 120, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);

new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1,1,0), scene);


// --- indus_atlas_v1_qds_language_lab.html ---

    // --- Sample Indus dataset (can be swapped for a real JSON export later) ---
    const INDUS_DATA = [
      {
        id: "M-001",
        glyph: "êì£",
        nickname: "Unicorn",
        role: "marker",
        rolesHuman: "Harbour / standard marker; often anchors a sequence.",
        freq: 96,
        positions: ["start", "middle"],
        tags: ["unicorn", "standard", "harbour", "marker"],
        keyGlyph: true,
        qds: { entropy: 0.34, tau_c: 0.36, lambda_c: 2.5, K: 0.74 },
        sequences: [
          ["M-001","N-010","V-023","R-045"],
          ["M-001","N-004","C-031"],
          ["M-001","V-015","R-020"]
        ],
        gloss: "Behaves like a port-flag: tells you 'this inscription belongs to X route / house / standard' before the details.",
        notes: "Extremely stable across the corpus. Low entropy and tight œÑc cluster: classic QDS 'anchor' behaviour."
      },
      {
        id: "N-004",
        glyph: "êì§",
        nickname: "Grain stack",
        role: "number",
        rolesHuman: "Count / capacity marker; like '3 sacks' or '5 units'.",
        freq: 88,
        positions: ["middle","end"],
        tags: ["grain","number","count","capacity"],
        keyGlyph: true,
        qds: { entropy: 0.37, tau_c: 0.34, lambda_c: 2.2, K: 0.72 },
        sequences: [
          ["M-001","N-004","C-031"],
          ["B-012","N-004","V-019"],
          ["R-020","N-004","C-008"]
        ],
        gloss: "Pairs naturally with containers and route signs; behaves like a quantity field in a database.",
        notes: "Frequency profile peaks in mid‚Äìend positions, matching 'amount then stop' behaviour in living trade languages."
      },
      {
        id: "C-031",
        glyph: "êì•",
        nickname: "Jar / vessel",
        role: "vessel",
        rolesHuman: "Container / goods type; often follows a number.",
        freq: 61,
        positions: ["middle","end"],
        tags: ["jar","vessel","goods","container"],
        keyGlyph: true,
        qds: { entropy: 0.39, tau_c: 0.32, lambda_c: 2.1, K: 0.71 },
        sequences: [
          ["M-001","N-004","C-031"],
          ["C-031","R-045"],
          ["B-012","N-008","C-031"]
        ],
        gloss: "Reads like 'jar / container of X'; the workhorse for cargo-type marking.",
        notes: "Co-occurrence stats with numbers and route signs are strong; screams 'logistics paperwork' more than myth."
      },
      {
        id: "R-045",
        glyph: "êìß",
        nickname: "Forked path",
        role: "route",
        rolesHuman: "Route / direction marker; likely indicates a branch or crossing.",
        freq: 53,
        positions: ["end"],
        tags: ["route","path","fork","harbour-exit"],
        keyGlyph: false,
        qds: { entropy: 0.41, tau_c: 0.33, lambda_c: 2.3, K: 0.70 },
        sequences: [
          ["M-001","N-010","V-023","R-045"],
          ["C-031","R-045"],
          ["U-018","R-045"]
        ],
        gloss: "Regularly seals a line: 'this shipment goes via route Y' kind of behaviour.",
        notes: "Almost never at the start; QDS position weights mark it as a classic 'line full stop with direction flavour'."
      },
      {
        id: "D-011",
        glyph: "êì™",
        nickname: "Twin peaks",
        role: "deity",
        rolesHuman: "Clan / deity / patron marker; low frequency but very stable when used.",
        freq: 18,
        positions: ["start"],
        tags: ["deity","clan","elite","patron"],
        keyGlyph: false,
        qds: { entropy: 0.29, tau_c: 0.40, lambda_c: 2.6, K: 0.76 },
        sequences: [
          ["D-011","M-001","N-004","C-031"],
          ["D-011","B-012","N-010"],
          ["D-011","U-018","R-020"]
        ],
        gloss: "Behaves like a house name or divine header: 'by authority of X' above an otherwise normal trade line.",
        notes: "Despite low count, the kernel sees it as hyper-coherent: appears in tight clusters with specific standards."
      },
      {
        id: "B-012",
        glyph: "êì¨",
        nickname: "Boat hull",
        role: "vessel",
        rolesHuman: "Water-craft / shipping container; favours riverine / coastal sites.",
        freq: 42,
        positions: ["start","middle"],
        tags: ["boat","shipping","river","vessel"],
        keyGlyph: false,
        qds: { entropy: 0.38, tau_c: 0.33, lambda_c: 2.0, K: 0.71 },
        sequences: [
          ["B-012","N-004","V-019"],
          ["D-011","B-012","N-010"],
          ["B-012","C-031","R-020"]
        ],
        gloss: "Looks like a special case of 'vessel' tuned for boats or barges ‚Äî an Indus shipping line marker.",
        notes: "Spatial distribution lines up suspiciously well with known ports and river mouths."
      },
      {
        id: "U-018",
        glyph: "êì∞",
        nickname: "Upstream curve",
        role: "route",
        rolesHuman: "Journey / upriver indicator; likely a directional modifier.",
        freq: 37,
        positions: ["middle","end"],
        tags: ["route","upstream","journey"],
        keyGlyph: false,
        qds: { entropy: 0.40, tau_c: 0.35, lambda_c: 2.3, K: 0.71 },
        sequences: [
          ["U-018","R-045"],
          ["D-011","U-018","R-020"],
          ["B-012","N-006","U-018"]
        ],
        gloss: "Acts as a directional accent; 'this one goes upriver / inland' layered on top of the base route.",
        notes: "Pairs nicely with forked-path and boat hull in specific site clusters."
      },
      {
        id: "V-023",
        glyph: "êì±",
        nickname: "Stacked wedge",
        role: "number",
        rolesHuman: "Count / tally; distribution skewed towards inland sites.",
        freq: 44,
        positions: ["middle","end"],
        tags: ["number","tally","count"],
        keyGlyph: false,
        qds: { entropy: 0.36, tau_c: 0.34, lambda_c: 2.1, K: 0.72 },
        sequences: [
          ["M-001","N-010","V-023","R-045"],
          ["B-012","V-023","C-031"],
          ["V-023","U-018","R-020"]
        ],
        gloss: "Numeral-like behaviour; probably a count that complements other numeric signs in specific trade contexts.",
        notes: "Coherence profile suggests a modular number system rather than pure pictographs."
      },
      {
        id: "N-010",
        glyph: "êì≤",
        nickname: "Tall stack",
        role: "number",
        rolesHuman: "Higher-order count; like 'bundle' or 'lot'.",
        freq: 39,
        positions: ["middle"],
        tags: ["number","bundle","lot"],
        keyGlyph: false,
        qds: { entropy: 0.37, tau_c: 0.34, lambda_c: 2.0, K: 0.72 },
        sequences: [
          ["M-001","N-010","V-023","R-045"],
          ["D-011","B-012","N-010"],
          ["N-010","C-031","R-020"]
        ],
        gloss: "Comes in between marker and goods; behaves like 'X lots of...', then a container / route.",
        notes: "Position stats show very strong mid-line anchoring, rarely at extremes."
      },
      {
        id: "R-020",
        glyph: "êìµ",
        nickname: "River line",
        role: "route",
        rolesHuman: "Straight route / mainline; contrasts with forked path.",
        freq: 47,
        positions: ["end"],
        tags: ["route","river","mainline"],
        keyGlyph: false,
        qds: { entropy: 0.39, tau_c: 0.33, lambda_c: 2.2, K: 0.71 },
        sequences: [
          ["C-031","R-020"],
          ["D-011","U-018","R-020"],
          ["B-012","C-031","R-020"]
        ],
        gloss: "Neatly terminates many inscriptions; reads like 'via main route' marker.",
        notes: "Sits in the same information 'slot' as R-045 but with a simpler, straighter distribution."
      }
    ];

    // --- State ---
    let selectedId = null;

    const gridEl = document.getElementById("glyphGrid");
    const glyphCountEl = document.getElementById("glyphCount");
    const detailScrollEl = document.getElementById("detailScroll");
    const detailHeaderEl = document.getElementById("detailHeader");

    const roleFilterEl = document.getElementById("roleFilter");
    const freqFilterEl = document.getElementById("freqFilter");
    const freqFilterLabelEl = document.getElementById("freqFilterLabel");
    const searchInputEl = document.getElementById("searchInput");

    // --- Rendering helpers ---

    function filterData() {
      const role = roleFilterEl.value;
      const minFreq = parseInt(freqFilterEl.value, 10) || 1;
      const query = searchInputEl.value.trim().toLowerCase();

      freqFilterLabelEl.textContent = "‚â• " + minFreq;

      return INDUS_DATA.filter(g => {
        if (role !== "all" && g.role !== role) return false;
        if (g.freq < minFreq) return false;
        if (query) {
          const hay = [
            g.id,
            g.nickname,
            g.role,
            (g.tags || []).join(" "),
            (g.rolesHuman || ""),
            (g.gloss || "")
          ].join(" ").toLowerCase();
          if (!hay.includes(query)) return false;
        }
        return true;
      });
    }

    function renderGrid() {
      const data = filterData();
      glyphCountEl.textContent = data.length;
      gridEl.innerHTML = "";

      if (!selectedId && data.length > 0) {
        selectedId = data[0].id;
        renderDetails();
      }

      data.forEach(g => {
        const card = document.createElement("article");
        card.className = "glyph-card";
        card.dataset.id = g.id;
        if (g.id === selectedId) card.classList.add("selected");

        const headerRow = document.createElement("div");
        headerRow.className = "glyph-header-row";

        const idEl = document.createElement("div");
        idEl.className = "glyph-id";
        idEl.textContent = g.id;

        const rolePill = document.createElement("div");
        rolePill.className = "glyph-role-pill";
        rolePill.dataset.role = g.role;
        rolePill.textContent = g.role;

        headerRow.appendChild(idEl);
        headerRow.appendChild(rolePill);

        const sign = document.createElement("div");
        sign.className = "glyph-sign";
        const signInner = document.createElement("span");
        signInner.textContent = g.glyph || "êåÄ";
        sign.appendChild(signInner);

        const metaRow = document.createElement("div");
        metaRow.className = "glyph-meta";
        const leftMeta = document.createElement("div");
        leftMeta.innerHTML = "<strong>" + (g.nickname || "‚Äî") + "</strong>";
        const freqEl = document.createElement("div");
        freqEl.className = "freq";
        freqEl.textContent = "f=" + g.freq;
        metaRow.appendChild(leftMeta);
        metaRow.appendChild(freqEl);

        const posRow = document.createElement("div");
        posRow.className = "glyph-pos";
        (g.positions || []).forEach(p => {
          const span = document.createElement("span");
          span.textContent = p;
          posRow.appendChild(span);
        });

        card.appendChild(headerRow);
        card.appendChild(sign);
        card.appendChild(metaRow);
        card.appendChild(posRow);

        card.addEventListener("click", () => {
          selectedId = g.id;
          renderGrid();
          renderDetails();
        });

        gridEl.appendChild(card);
      });

      if (data.length === 0) {
        const empty = document.createElement("div");
        empty.className = "para";
        empty.style.padding = "0.2rem 0.1rem 0.3rem";
        empty.textContent = "No glyphs match this filter. Ease off the sliders a bit, old chap.";
        gridEl.appendChild(empty);
      }
    }

    function renderDetails() {
      const glyph = INDUS_DATA.find(g => g.id === selectedId) || INDUS_DATA[0];
      if (!glyph) return;

      detailHeaderEl.textContent = glyph.id + " ¬∑ " + glyph.nickname + " ‚Äî " + glyph.role;

      detailScrollEl.innerHTML = "";

      // Block 1: main glyph & QDS stats
      const b1 = document.createElement("section");
      b1.className = "detail-block";

      const title1 = document.createElement("div");
      title1.className = "detail-block-title";
      const h3 = document.createElement("h3");
      h3.textContent = "Glyph summary";
      const spanMeta = document.createElement("span");
      spanMeta.textContent = "Frequency f=" + glyph.freq + " ¬∑ positions: " + (glyph.positions || []).join(", ");
      title1.appendChild(h3);
      title1.appendChild(spanMeta);

      const mainRow = document.createElement("div");
      mainRow.className = "detail-glyph-main";

      const box = document.createElement("div");
      box.className = "detail-glyph-box";
      box.textContent = glyph.glyph || "êåÄ";

      const meta = document.createElement("div");
      meta.className = "detail-glyph-meta";
      const strongLabel = document.createElement("strong");
      strongLabel.textContent = glyph.id + " ¬∑ " + glyph.nickname;
      const spanRole = document.createElement("span");
      spanRole.textContent = glyph.rolesHuman || glyph.role;
      meta.appendChild(strongLabel);
      meta.appendChild(spanRole);

      const badges = document.createElement("div");
      badges.className = "detail-badges";
      if (glyph.keyGlyph) {
        const bKey = document.createElement("span");
        bKey.className = "badge badge-key";
        bKey.textContent = "Key glyph";
        badges.appendChild(bKey);
      }
      const bFreq = document.createElement("span");
      bFreq.className = "badge";
      bFreq.textContent = glyph.freq > 60 ? "High frequency" : glyph.freq < 25 ? "Rare" : "Medium frequency";
      badges.appendChild(bFreq);

      const bQds = document.createElement("span");
      bQds.className = "badge badge-qds";
      bQds.textContent = "QDS-coherent (K ‚âà " + glyph.qds.K.toFixed(2) + ")";
      badges.appendChild(bQds);

      meta.appendChild(badges);

      mainRow.appendChild(box);
      mainRow.appendChild(meta);

      const gridMetaRow = document.createElement("div");
      gridMetaRow.className = "grid-meta-row";

      const mkPill = (label, value) => {
        const p = document.createElement("div");
        p.className = "grid-meta-pill";
        const s = document.createElement("strong");
        s.textContent = label;
        p.appendChild(s);
        const t = document.createTextNode(value);
        p.appendChild(t);
        return p;
      };
      gridMetaRow.appendChild(mkPill("H (entropy)", glyph.qds.entropy.toFixed(2)));
      gridMetaRow.appendChild(mkPill("œÑc", glyph.qds.tau_c.toFixed(2) + " s"));
      gridMetaRow.appendChild(mkPill("Œªc", glyph.qds.lambda_c.toFixed(1) + " glyphs"));
      gridMetaRow.appendChild(mkPill("K", glyph.qds.K.toFixed(2)));

      const roleExplainer = document.createElement("div");
      roleExplainer.className = "role-explainer";
      roleExplainer.textContent = glyph.rolesHuman || "";

      b1.appendChild(title1);
      b1.appendChild(mainRow);
      b1.appendChild(gridMetaRow);
      b1.appendChild(roleExplainer);

      detailScrollEl.appendChild(b1);

      // Block 2: sequences
      const b2 = document.createElement("section");
      b2.className = "detail-block";

      const title2 = document.createElement("div");
      title2.className = "detail-block-title";
      const h32 = document.createElement("h3");
      h32.textContent = "Example sequences";
      const spanMeta2 = document.createElement("span");
      spanMeta2.textContent = (glyph.sequences || []).length + " sample lines";
      title2.appendChild(h32);
      title2.appendChild(spanMeta2);
      b2.appendChild(title2);

      const seqLabel = document.createElement("div");
      seqLabel.className = "seq-label";
      seqLabel.textContent = "Tap different glyphs in the grid; they light up here when present.";
      b2.appendChild(seqLabel);

      (glyph.sequences || []).forEach((seq, idx) => {
        const row = document.createElement("div");
        row.className = "sequence-row";
        seq.forEach(id => {
          const chip = document.createElement("span");
          chip.className = "glyph-chip";
          if (id === glyph.id) chip.classList.add("highlight");
          chip.textContent = id;
          row.appendChild(chip);
        });
        b2.appendChild(row);
      });

      if (!glyph.sequences || glyph.sequences.length === 0) {
        const para = document.createElement("div");
        para.className = "para";
        para.textContent = "No example sequences stored yet for this glyph in the Atlas stub.";
        b2.appendChild(para);
      }

      detailScrollEl.appendChild(b2);

      // Block 3: narrative / gloss
      const b3 = document.createElement("section");
      b3.className = "detail-block";

      const title3 = document.createElement("div");
      title3.className = "detail-block-title";
      const h33 = document.createElement("h3");
      h33.textContent = "Interpretation";
      const spanMeta3 = document.createElement("span");
      spanMeta3.textContent = "Blunt English, QDS-aware.";
      title3.appendChild(h33);
      title3.appendChild(spanMeta3);

      const p1 = document.createElement("p");
      p1.className = "para";
      p1.innerHTML = "<strong>Working gloss:</strong> " + (glyph.gloss || "");

      const p2 = document.createElement("p");
      p2.className = "para";
      p2.style.marginTop = "0.25rem";
      p2.innerHTML = "<strong>QDS note:</strong> " + (glyph.notes || "");

      b3.appendChild(title3);
      b3.appendChild(p1);
      b3.appendChild(p2);

      detailScrollEl.appendChild(b3);

      // ensure scroll starts at top for new glyph
      detailScrollEl.scrollTop = 0;
    }

    // --- Event wiring ---
    roleFilterEl.addEventListener("change", () => {
      renderGrid();
    });
    freqFilterEl.addEventListener("input", () => {
      renderGrid();
    });
    searchInputEl.addEventListener("input", () => {
      renderGrid();
    });

    // Init
    if (INDUS_DATA.length > 0) {
      selectedId = INDUS_DATA[0].id;
    }
    renderGrid();
    renderDetails();
  

// --- stinchcombe_map.html ---


var map = L.map('map', {
    zoomControl: true
}).setView([51.687, -2.375], 13);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: '&copy; OpenStreetMap'
}).addTo(map);

// Drakestone approx centre
var drakeLat = 51.680120;
var drakeLon = -2.382320;

// Taits Hill approx centre
var taitsLat = 51.695400;
var taitsLon = -2.379860;

var meta = {"drake": {"popup": "<b>HER records: 23</b><br>By period: Unknown: 11, Industrial / Modern: 5, Prehistoric: 5, Medieval: 1, Roman: 1"}, "taits": {"popup": "<b>HER records: 8</b><br>By period: Unknown: 4, Medieval: 2, Industrial / Modern: 1, Roman: 1"}};

// Drakestone bubble
var drakeMarker = L.circleMarker([drakeLat, drakeLon], {
    radius: 7,
    color: '#4fd1c5',
    weight: 2,
    fillColor: '#4fd1c5',
    fillOpacity: 0.9
}).addTo(map).bindPopup(meta.drake.popup);

// Radius ring 800 m
L.circle([drakeLat, drakeLon], {
    radius: 800,
    color: '#4fd1c5',
    weight: 1,
    dashArray: '4,4',
    fillColor: '#4fd1c5',
    fillOpacity: 0.10
}).addTo(map);

// Taits Hill bubble
var taitsMarker = L.circleMarker([taitsLat, taitsLon], {
    radius: 7,
    color: '#f6ad55',
    weight: 2,
    fillColor: '#f6ad55',
    fillOpacity: 0.9
}).addTo(map).bindPopup(meta.taits.popup);

// Radius ring 600 m
L.circle([taitsLat, taitsLon], {
    radius: 600,
    color: '#f6ad55',
    weight: 1,
    dashArray: '4,4',
    fillColor: '#f6ad55',
    fillOpacity: 0.10
}).addTo(map);

// Fit bounds to both markers
var group = L.featureGroup([drakeMarker, taitsMarker]);
map.fitBounds(group.getBounds().pad(0.25));


// --- catapult_balloon_pop_v1.html ---

(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const comboEl = document.getElementById("combo");
  const windEl  = document.getElementById("wind");
  const windVal = document.getElementById("windVal");
  const violentEl = document.getElementById("violent");
  const modeTxt = document.getElementById("modeTxt");
  const resetBtn = document.getElementById("reset");

  let W, H, DPR;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // ====== GAME STATE ======
  let balloons = [];
  let projectiles = [];
  let score = 0;
  let best = Number(localStorage.getItem("catapult_best") || 0);
  let combo = 1;
  let lastPopT = 0;

  bestEl.textContent = best;

  const catapult = {
    baseX: 0, baseY: 0,
    x: 0, y: 0,
    radius: 26,
    dragging: false,
    pullX: 0, pullY: 0,
    maxPull: 120
  };

  function reset(){
    score = 0; combo = 1; lastPopT = 0;
    scoreEl.textContent = score;
    comboEl.textContent = "x1";
    projectiles = [];
    spawnBalloons();
    placeCatapult();
  }

  function placeCatapult(){
    catapult.baseX = Math.max(60, W * 0.12);
    catapult.baseY = Math.min(H - 80, H * 0.86);
    catapult.x = catapult.baseX;
    catapult.y = catapult.baseY;
    catapult.pullX = 0; catapult.pullY = 0;
  }

  function spawnBalloons(){
    balloons = [];
    const count = Math.max(10, Math.floor((W*H) / 45000));
    for(let i=0;i<count;i++){
      const r = 18 + Math.random()*18;
      const x = r + 20 + Math.random()*(W - r*2 - 40);
      const y = r + 70 + Math.random()*(H * 0.65);
      const hue = 200 + Math.random()*120;
      balloons.push({x,y,r,hue,popped:false});
    }
  }

  function fireProjectile(vx, vy){
    const speedCap = violentEl.value === "1" ? 22 : 16;
    const mag = Math.hypot(vx, vy);
    if(mag > speedCap){
      vx = vx/mag * speedCap;
      vy = vy/mag * speedCap;
    }
    projectiles.push({
      x: catapult.baseX, y: catapult.baseY,
      vx, vy,
      r: 8,
      life: 0
    });
  }

  // ====== INPUT ======
  function getPos(e){
    const t = e.touches ? e.touches[0] : e;
    return {x: t.clientX, y: t.clientY};
  }

  function startDrag(e){
    const p = getPos(e);
    const dx = p.x - catapult.baseX;
    const dy = p.y - catapult.baseY;
    if(Math.hypot(dx,dy) < catapult.radius*2.2){
      catapult.dragging = true;
      e.preventDefault();
    }
  }

  function moveDrag(e){
    if(!catapult.dragging) return;
    const p = getPos(e);
    let dx = p.x - catapult.baseX;
    let dy = p.y - catapult.baseY;
    const d = Math.hypot(dx,dy);
    if(d > catapult.maxPull){
      dx = dx/d * catapult.maxPull;
      dy = dy/d * catapult.maxPull;
    }
    catapult.pullX = dx;
    catapult.pullY = dy;
    catapult.x = catapult.baseX + dx;
    catapult.y = catapult.baseY + dy;
    e.preventDefault();
  }

  function endDrag(){
    if(!catapult.dragging) return;
    catapult.dragging = false;
    // Launch opposite of pull
    const power = violentEl.value === "1" ? 0.22 : 0.18;
    const vx = -catapult.pullX * power;
    const vy = -catapult.pullY * power;
    if(Math.hypot(vx,vy) > 1.2) fireProjectile(vx, vy);

    catapult.pullX = 0; catapult.pullY = 0;
    catapult.x = catapult.baseX; catapult.y = catapult.baseY;
  }

  canvas.addEventListener("mousedown", startDrag);
  canvas.addEventListener("mousemove", moveDrag);
  window.addEventListener("mouseup", endDrag);

  canvas.addEventListener("touchstart", startDrag, {passive:false});
  canvas.addEventListener("touchmove", moveDrag, {passive:false});
  canvas.addEventListener("touchend", endDrag);

  resetBtn.addEventListener("click", reset);

  windEl.addEventListener("input", () => windVal.textContent = Number(windEl.value).toFixed(2));
  violentEl.addEventListener("input", () => {
    modeTxt.textContent = violentEl.value === "1" ? "Violent" : "Normal";
  });

  windVal.textContent = "0.00";

  // ====== PHYSICS + COLLISIONS ======
  function update(dt){
    const violent = violentEl.value === "1";
    const g = violent ? 0.75 : 0.52;
    const drag = violent ? 0.995 : 0.992;
    const wind = Number(windEl.value) * (violent ? 0.20 : 0.12);

    for(const p of projectiles){
      p.vx += wind;
      p.vy += g;
      p.vx *= drag; p.vy *= drag;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life += dt;

      // soft floor bounce
      if(p.y > H - 10){
        p.y = H - 10;
        p.vy *= -0.45;
        p.vx *= 0.85;
      }
    }

    // remove old/offscreen
    projectiles = projectiles.filter(p =>
      p.life < 240 &&
      p.x > -80 && p.x < W + 80 &&
      p.y > -120 && p.y < H + 120
    );

    // collision with balloons
    const now = performance.now();
    for(const b of balloons){
      if(b.popped) continue;
      for(const p of projectiles){
        const dx = b.x - p.x;
        const dy = b.y - p.y;
        const d = Math.hypot(dx,dy);
        if(d < b.r + p.r){
          b.popped = true;

          // combo logic
          const dtPop = now - lastPopT;
          if(dtPop < 900) combo = Math.min(10, combo + 1);
          else combo = 1;
          lastPopT = now;

          const add = 10 * combo * (violent ? 2 : 1);
          score += add;
          best = Math.max(best, score);

          scoreEl.textContent = score;
          comboEl.textContent = "x" + combo;
          bestEl.textContent = best;
          localStorage.setItem("catapult_best", String(best));

          // micro impulse
          p.vx *= 0.7; p.vy *= 0.7;
        }
      }
    }

    // respawn if all popped
    if(balloons.length && balloons.every(b => b.popped)){
      spawnBalloons();
    }
  }

  // ====== RENDER ======
  function drawBG(){
    ctx.fillStyle = "#070b14";
    ctx.fillRect(0,0,W,H);

    // faint stars
    ctx.globalAlpha = 0.12;
    for(let i=0;i<40;i++){
      const x = (i*97) % W;
      const y = (i*173) % H;
      ctx.fillStyle = "#bcd7ff";
      ctx.fillRect(x, y, 1.5, 1.5);
    }
    ctx.globalAlpha = 1;
  }

  function drawBalloons(){
    for(const b of balloons){
      if(b.popped) continue;
      const grad = ctx.createRadialGradient(b.x-b.r*0.3, b.y-b.r*0.3, 2, b.x, b.y, b.r);
      grad.addColorStop(0, `hsla(${b.hue},90%,75%,0.95)`);
      grad.addColorStop(1, `hsla(${b.hue},90%,45%,0.85)`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  function drawProjectiles(){
    for(const p of projectiles){
      ctx.fillStyle = "rgba(200,230,255,0.9)";
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fill();
    }
  }

  function drawCatapult(){
    // base
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.beginPath();
    ctx.arc(catapult.baseX, catapult.baseY, catapult.radius*1.25, 0, Math.PI*2);
    ctx.fill();

    // elastic line
    if(catapult.dragging){
      ctx.strokeStyle = "rgba(140,190,255,0.45)";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(catapult.baseX, catapult.baseY);
      ctx.lineTo(catapult.x, catapult.y);
      ctx.stroke();
    }

    // handle
    const g = ctx.createRadialGradient(catapult.x-6, catapult.y-6, 2, catapult.x, catapult.y, catapult.radius);
    g.addColorStop(0,"rgba(160,220,255,0.95)");
    g.addColorStop(1,"rgba(120,140,255,0.65)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(catapult.x, catapult.y, catapult.radius, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // ====== LOOP ======
  let last = performance.now();
  function loop(t){
    const dt = Math.min(2.2, (t - last) / 16.666);
    last = t;

    update(dt);
    drawBG();
    drawBalloons();
    drawProjectiles();
    drawCatapult();

    requestAnimationFrame(loop);
  }

  // init
  placeCatapult();
  spawnBalloons();
  requestAnimationFrame(loop);
})();


// --- qds_battery_lab.html ---

/* ============================
   QDS Battery Lab (Showcase)
   No deps ‚Ä¢ Mobile-safe
   ============================ */

const $ = (id)=>document.getElementById(id);

const els = {
  baseDrain:$("baseDrain"), noiseAmp:$("noiseAmp"), rho:$("rho"),
  cells:$("cells"), maxCycles:$("maxCycles"), threshold:$("threshold"),
  vBase:$("vBase"), vAmp:$("vAmp"), vRho:$("vRho"),
  vN:$("vN"), vMax:$("vMax"), vThr:$("vThr"),
  runBtn:$("runBtn"), resetBtn:$("resetBtn"),
  presetReal:$("presetReal"), presetQDS:$("presetQDS"), presetChaos:$("presetChaos"),
  whiteMean:$("whiteMean"), whiteStd:$("whiteStd"),
  qdsMean:$("qdsMean"), qdsStd:$("qdsStd"),
  relChange:$("relChange"), runsOut:$("runsOut"),
  runNote:$("runNote"), profileCanvas:$("profileCanvas"), histCanvas:$("histCanvas"),
  profileNote:$("profileNote"),
  copyBtn:$("copyBtn"), exportBtn:$("exportBtn"),
  clearHistBtn:$("clearHistBtn"),
  historyList:$("historyList")
};

const HIST_KEY = "QDS_BATTERY_HISTORY_V1";

function fmt(n, d=1){ return Number.isFinite(n) ? n.toFixed(d) : "‚Äî"; }

function syncLabels(){
  els.vBase.textContent = fmt(parseFloat(els.baseDrain.value),1);
  els.vAmp.textContent  = fmt(parseFloat(els.noiseAmp.value),1);
  els.vRho.textContent  = fmt(parseFloat(els.rho.value),2);
  els.vN.textContent    = parseInt(els.cells.value,10);
  els.vMax.textContent  = parseInt(els.maxCycles.value,10);
  els.vThr.textContent  = parseInt(els.threshold.value,10);
}
["input","change"].forEach(evt=>{
  [els.baseDrain, els.noiseAmp, els.rho, els.cells, els.maxCycles, els.threshold]
    .forEach(x=>x.addEventListener(evt, syncLabels));
});
syncLabels();

/* ---- Random helpers ---- */
function randn(){
  // Box-Muller
  let u=0, v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

/* ---- Core simulation ----
   health_{t+1} = health_t - baseDrain - noise_t
   white: noise_t = amp * N(0,1)
   qds:   noise_t = rho*noise_{t-1} + sqrt(1-rho^2)*amp*N(0,1)
*/
function simulateOneCell(baseDrain, amp, rho, maxCycles, threshold, correlated){
  let h=100;
  let noisePrev=0;
  const series=[];
  let failAt=null;

  for(let c=1; c<=maxCycles; c++){
    let noise;
    if(!correlated){
      noise = amp * randn();
    }else{
      const eps = amp * randn();
      const k = Math.sqrt(Math.max(0, 1 - rho*rho));
      noise = rho*noisePrev + k*eps;
      noisePrev = noise;
    }
    // drain is always positive on average; noise can add/subtract
    h = h - baseDrain - noise;

    if(h<0) h=0;
    if(h>100) h=100;

    series.push({c, h});

    if(failAt===null && h<=threshold){
      failAt = c;
      // we keep series for profile plotting even after fail,
      // but for lifetime we record first-crossing.
    }
    if(h===0 && failAt!==null){
      // allow loop to continue for profile shape, but early stop for speed
      // for bulk sims:
      // (handled separately below)
    }
  }
  if(failAt===null) failAt = maxCycles;
  return {failAt, series};
}

function simulateBulk(params){
  const {baseDrain, amp, rho, maxCycles, threshold, n} = params;
  const whiteFails = new Array(n);
  const qdsFails   = new Array(n);

  // representative profiles
  const whiteProfile = simulateOneCell(baseDrain, amp, rho, maxCycles, threshold, false);
  const qdsProfile   = simulateOneCell(baseDrain, amp, rho, maxCycles, threshold, true);

  // bulk loops with early stop
  for(let i=0; i<n; i++){
    // white
    let h=100, fail=null;
    for(let c=1; c<=maxCycles; c++){
      const noise = amp * randn();
      h = h - baseDrain - noise;
      if(h<0) h=0; if(h>100) h=100;
      if(fail===null && h<=threshold) fail=c;
      if(h===0 && fail!==null){ break; }
    }
    if(fail===null) fail=maxCycles;
    whiteFails[i]=fail;

    // qds correlated
    h=100; fail=null;
    let noisePrev=0;
    for(let c=1; c<=maxCycles; c++){
      const eps = amp * randn();
      const k = Math.sqrt(Math.max(0, 1 - rho*rho));
      const noise = rho*noisePrev + k*eps;
      noisePrev = noise;
      h = h - baseDrain - noise;
      if(h<0) h=0; if(h>100) h=100;
      if(fail===null && h<=threshold) fail=c;
      if(h===0 && fail!==null){ break; }
    }
    if(fail===null) fail=maxCycles;
    qdsFails[i]=fail;
  }

  return {whiteFails, qdsFails, whiteProfile, qdsProfile};
}

/* ---- Stats ---- */
function mean(arr){
  let s=0; for(const x of arr) s+=x; return s/arr.length;
}
function std(arr){
  const m=mean(arr);
  let s=0; for(const x of arr){ const d=x-m; s+=d*d; }
  return Math.sqrt(s/Math.max(1, arr.length-1));
}

/* ---- Simple canvas plotting ---- */
function clearCanvas(ctx){
  const {width:w, height:h} = ctx.canvas;
  ctx.clearRect(0,0,w,h);
  // background grid hint
  ctx.globalAlpha=0.25;
  ctx.strokeStyle="#223155";
  ctx.lineWidth=1;
  for(let i=1;i<6;i++){
    ctx.beginPath();
    ctx.moveTo(0, h*i/6);
    ctx.lineTo(w, h*i/6);
    ctx.stroke();
  }
  for(let i=1;i<8;i++){
    ctx.beginPath();
    ctx.moveTo(w*i/8, 0);
    ctx.lineTo(w*i/8, h);
    ctx.stroke();
  }
  ctx.globalAlpha=1;
}

function plotProfile(canvas, whiteSeries, qdsSeries, threshold){
  const ctx = canvas.getContext("2d");
  clearCanvas(ctx);
  const w=canvas.width, h=canvas.height;

  const maxC = Math.max(
    whiteSeries[whiteSeries.length-1]?.c||1,
    qdsSeries[qdsSeries.length-1]?.c||1
  );

  function mapX(c){ return (c/maxC)* (w-40) + 30; }
  function mapY(health){ return h-30 - (health/100)*(h-60); }

  // threshold line
  ctx.strokeStyle = "#ff7a7a";
  ctx.globalAlpha = 0.5;
  ctx.beginPath();
  ctx.moveTo(30, mapY(threshold));
  ctx.lineTo(w-10, mapY(threshold));
  ctx.stroke();
  ctx.globalAlpha = 1;

  // white
  ctx.strokeStyle = "#4cc9f0";
  ctx.lineWidth = 2;
  ctx.beginPath();
  whiteSeries.forEach((p, i)=>{
    const x=mapX(p.c), y=mapY(p.h);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  // qds
  ctx.strokeStyle = "#7cf2c8";
  ctx.lineWidth = 2;
  ctx.beginPath();
  qdsSeries.forEach((p,i)=>{
    const x=mapX(p.c), y=mapY(p.h);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  // axes labels (minimal)
  ctx.fillStyle="#9bb0d6";
  ctx.font="12px system-ui";
  ctx.fillText("Health (%)", 6, 14);
  ctx.fillText("Cycles ‚Üí", w-70, h-8);
}

function plotHistogram(canvas, whiteFails, qdsFails){
  const ctx = canvas.getContext("2d");
  clearCanvas(ctx);
  const w=canvas.width, h=canvas.height;

  const all = whiteFails.concat(qdsFails);
  const maxV = Math.max(...all);
  const minV = Math.min(...all);

  const bins = 14;
  const binSize = Math.max(1, Math.ceil((maxV-minV+1)/bins));

  function buildHist(arr){
    const counts = new Array(bins).fill(0);
    for(const v of arr){
      let idx = Math.floor((v-minV)/binSize);
      if(idx<0) idx=0; if(idx>=bins) idx=bins-1;
      counts[idx]++;
    }
    return counts;
  }

  const hcW = buildHist(whiteFails);
  const hcQ = buildHist(qdsFails);
  const maxCount = Math.max(...hcW, ...hcQ, 1);

  const padL=30, padB=26, padT=10, padR=10;
  const plotW = w - padL - padR;
  const plotH = h - padT - padB;
  const barW = plotW / bins;

  for(let i=0;i<bins;i++){
    const x = padL + i*barW;

    const hW = (hcW[i]/maxCount)*plotH;
    const hQ = (hcQ[i]/maxCount)*plotH;

    // white bar
    ctx.globalAlpha=0.9;
    ctx.fillStyle="#4cc9f0";
    ctx.fillRect(x + 2, padT + (plotH - hW), barW*0.45, hW);

    // qds bar
    ctx.fillStyle="#ff7ab6";
    ctx.fillRect(x + barW*0.5, padT + (plotH - hQ), barW*0.45, hQ);
    ctx.globalAlpha=1;
  }

  ctx.fillStyle="#9bb0d6";
  ctx.font="11px system-ui";
  ctx.fillText("Count", 6, 14);
  ctx.fillText("Cycles to failure (binned)", w/2 - 70, h-6);
}

/* ---- History ---- */
function loadHistory(){
  try{
    const raw = localStorage.getItem(HIST_KEY);
    return raw ? JSON.parse(raw) : [];
  }catch(e){ return []; }
}
function saveHistory(arr){
  localStorage.setItem(HIST_KEY, JSON.stringify(arr.slice(0,50)));
}
function renderHistory(){
  const hist = loadHistory();
  const last5 = hist.slice(0,5);
  els.historyList.innerHTML = last5.length ? "" : "<div class='hist-item small'>(No runs yet)</div>";

  last5.forEach(h=>{
    const div=document.createElement("div");
    div.className="hist-item";
    div.innerHTML = `
      <div><b>${h.time}</b></div>
      <div class="small">
        base=${h.base}% ‚Ä¢ amp=${h.amp}% ‚Ä¢ œÅ=${h.rho} ‚Ä¢ thr=${h.threshold}% ‚Ä¢ n=${h.n}
      </div>
      <div class="small">
        white Œº=${h.whiteMean} œÉ=${h.whiteStd} ‚Ä¢ QDS Œº=${h.qdsMean} œÉ=${h.qdsStd}
        ‚Ä¢ Œî=${h.relChange}
      </div>
    `;
    els.historyList.appendChild(div);
  });
}
renderHistory();

/* ---- Presets ---- */
function setPreset(p){
  els.baseDrain.value = p.base;
  els.noiseAmp.value  = p.amp;
  els.rho.value       = p.rho;
  els.cells.value     = p.n;
  els.maxCycles.value = p.max;
  els.threshold.value = p.thr;
  syncLabels();
}
els.presetReal.onclick = ()=>setPreset({base:0.5, amp:0.4, rho:0.35, n:500, max:1200, thr:80});
els.presetQDS.onclick  = ()=>setPreset({base:1.5, amp:3.0, rho:0.9,  n:500, max:1200, thr:80});
els.presetChaos.onclick= ()=>setPreset({base:2.0, amp:5.0, rho:0.95, n:800, max:1500, thr:85});
els.resetBtn.onclick   = ()=>setPreset({base:2.0, amp:3.0, rho:0.90, n:500, max:1200, thr:80});

/* ---- Main run ---- */
let lastRunData = null;

function runSimulation(){
  const params = {
    baseDrain: parseFloat(els.baseDrain.value),
    amp: parseFloat(els.noiseAmp.value),
    rho: parseFloat(els.rho.value),
    n: parseInt(els.cells.value,10),
    maxCycles: parseInt(els.maxCycles.value,10),
    threshold: parseFloat(els.threshold.value)
  };

  const out = simulateBulk(params);

  const wMean = mean(out.whiteFails);
  const wStd  = std(out.whiteFails);
  const qMean = mean(out.qdsFails);
  const qStd  = std(out.qdsFails);

  const rel = (qMean - wMean) / Math.max(1e-9, wMean) * 100;

  els.whiteMean.textContent = fmt(wMean,1) + " cycles";
  els.whiteStd.textContent  = fmt(wStd,1);
  els.qdsMean.textContent   = fmt(qMean,1) + " cycles";
  els.qdsStd.textContent    = fmt(qStd,1);
  els.relChange.textContent = (rel>=0?"+":"") + fmt(rel,1) + "%";
  els.runsOut.textContent   = params.n + " per model";

  // Profile plot + early failure messaging
  plotProfile(els.profileCanvas,
    out.whiteProfile.series, out.qdsProfile.series, params.threshold
  );

  const wFail = out.whiteProfile.failAt;
  const qFail = out.qdsProfile.failAt;

  const wMsg = (wFail < params.maxCycles)
    ? `White: failed at cycle ${wFail} (profile may clamp afterwards).`
    : `White: no threshold crossing within ${params.maxCycles} cycles.`;

  const qMsg = (qFail < params.maxCycles)
    ? `QDS: failed at cycle ${qFail} (profile may clamp afterwards).`
    : `QDS: no threshold crossing within ${params.maxCycles} cycles.`;

  els.profileNote.innerHTML = `<span class="small">${wMsg} ${qMsg}</span>`;

  // Histogram
  plotHistogram(els.histCanvas, out.whiteFails, out.qdsFails);

  // Narrative note
  let note = "";
  if(params.amp===0){
    note = "Noise amplitude is 0 ‚Üí models converge. This is a good sanity baseline.";
  }else if(params.rho < 0.1){
    note = "œÅ near 0 ‚Üí QDS-style behaves like white noise. Expect similar lifetimes.";
  }else if(params.rho > 0.8){
    note = "High œÅ ‚Üí correlated noise can create larger spread and occasional long-tail survivors.";
  }else{
    note = "Moderate œÅ ‚Üí subtle but visible widening of lifetime distribution.";
  }
  els.runNote.innerHTML = `<span class="note">${note}</span>`;

  // Save lastRunData for export/copy
  lastRunData = {
    meta:{
      tool:"QDS Battery Lab ‚Äî Showcase",
      timeISO: new Date().toISOString(),
      params
    },
    stats:{
      whiteMean:wMean, whiteStd:wStd,
      qdsMean:qMean, qdsStd:qStd,
      relChangePct: rel
    },
    samples:{
      whiteProfile: out.whiteProfile,
      qdsProfile: out.qdsProfile
    },
    distributions:{
      whiteFails: out.whiteFails,
      qdsFails: out.qdsFails
    }
  };

  // Push history (latest-first)
  const hist = loadHistory();
  const stamp = new Date();
  const entry = {
    time: stamp.toLocaleString(),
    base: fmt(params.baseDrain,1),
    amp: fmt(params.amp,1),
    rho: fmt(params.rho,2),
    threshold: fmt(params.threshold,0),
    n: params.n,
    whiteMean: fmt(wMean,1),
    whiteStd: fmt(wStd,1),
    qdsMean: fmt(qMean,1),
    qdsStd: fmt(qStd,1),
    relChange: (rel>=0?"+":"") + fmt(rel,1) + "%"
  };
  hist.unshift(entry);
  saveHistory(hist);
  renderHistory();
}

els.runBtn.onclick = runSimulation;

/* ---- Copy summary ---- */
async function copySummary(){
  if(!lastRunData){
    // try to run quickly with current params
    runSimulation();
  }
  const p = lastRunData.meta.params;
  const s = lastRunData.stats;

  const text =
`QDS Battery Lab ‚Äî Run Summary
Time: ${new Date().toLocaleString()}
Params: base=${p.baseDrain}%/cycle, amp=${p.amp}%, rho=${p.rho}, threshold=${p.threshold}%, n=${p.n}, max=${p.maxCycles}
White: mean=${s.whiteMean.toFixed(1)} cycles, sd=${s.whiteStd.toFixed(1)}
QDS:   mean=${s.qdsMean.toFixed(1)} cycles, sd=${s.qdsStd.toFixed(1)}
Relative change (QDS vs white): ${s.relChangePct>=0?"+":""}${s.relChangePct.toFixed(1)}%`;

  try{
    await navigator.clipboard.writeText(text);
    els.runNote.innerHTML = `<span class="note accent">Summary copied to clipboard.</span>`;
  }catch(e){
    // fallback
    const ta=document.createElement("textarea");
    ta.value=text; document.body.appendChild(ta);
    ta.select(); document.execCommand("copy");
    document.body.removeChild(ta);
    els.runNote.innerHTML = `<span class="note accent">Summary copied (fallback).</span>`;
  }
}
els.copyBtn.onclick = copySummary;

/* ---- Export JSON ---- */
function exportJSON(){
  if(!lastRunData) runSimulation();
  const blob = new Blob([JSON.stringify(lastRunData, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  const t = new Date().toISOString().replace(/[:.]/g,"-");
  a.download = `qds_battery_lab_run_${t}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  els.runNote.innerHTML = `<span class="note accent">Exported JSON of last run.</span>`;
}
els.exportBtn.onclick = exportJSON;

/* ---- Clear history ---- */
els.clearHistBtn.onclick = ()=>{
  localStorage.removeItem(HIST_KEY);
  renderHistory();
  els.runNote.innerHTML = `<span class="note warntext">History cleared.</span>`;
};

/* Auto-run a light first render for showcase feel */
setTimeout(()=>{
  // gentle default run so page isn't empty
  try{ runSimulation(); }catch(e){}
}, 120);


// --- qds_battery_noise_toy_v1.html ---


(function() {
  const baseDrain = document.getElementById('baseDrain');
  const noiseAmp  = document.getElementById('noiseAmp');
  const corr      = document.getElementById('corr');
  const runs      = document.getElementById('runs');
  const cycles    = document.getElementById('cycles');
  const thresh    = document.getElementById('thresh');

  const baseDrainVal = document.getElementById('baseDrainVal');
  const noiseAmpVal  = document.getElementById('noiseAmpVal');
  const corrVal      = document.getElementById('corrVal');
  const runsVal      = document.getElementById('runsVal');
  const cyclesVal    = document.getElementById('cyclesVal');
  const threshVal    = document.getElementById('threshVal');

  function syncLabels() {
    baseDrainVal.textContent = baseDrain.value + '%';
    noiseAmpVal.textContent  = noiseAmp.value + '%';
    corrVal.textContent      = Number(corr.value).toFixed(2);
    runsVal.textContent      = runs.value;
    cyclesVal.textContent    = cycles.value;
    threshVal.textContent    = thresh.value + '%';
  }
  [baseDrain, noiseAmp, corr, runs, cycles, thresh].forEach(el => {
    el.addEventListener('input', syncLabels);
  });
  syncLabels();

  const healthCtx = document.getElementById('healthChart');
  const histCtx   = document.getElementById('histChart');
  let healthChart, histChart;

  function makeHealthChart(labels, whiteData, qdsData) {
    if (healthChart) healthChart.destroy();
    healthChart = new Chart(healthCtx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          {
            label: 'White noise',
            data: whiteData,
            borderWidth: 2,
            fill: false,
            tension: 0.02
          },
          {
            label: 'QDS-style correlated noise',
            data: qdsData,
            borderWidth: 2,
            borderDash: [4,3],
            fill: false,
            tension: 0.02
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            title: { display: true, text: 'Cycles', color: '#ccc' },
            ticks: { color: '#ccc' },
            grid: { color: 'rgba(255,255,255,0.05)' }
          },
          y: {
            title: { display: true, text: 'Health (%)', color: '#ccc' },
            min: 0,
            max: 100,
            ticks: { color: '#ccc' },
            grid: { color: 'rgba(255,255,255,0.05)' }
          }
        },
        plugins: {
          legend: {
            labels: { color: '#eee', boxWidth: 14 }
          }
        }
      }
    });
  }

  function makeHistChart(bins, countsWhite, countsQds) {
    if (histChart) histChart.destroy();
    histChart = new Chart(histCtx, {
      type: 'bar',
      data: {
        labels: bins.map(b => b.toString()),
        datasets: [
          {
            label: 'White noise',
            data: countsWhite,
          },
          {
            label: 'QDS-style',
            data: countsQds,
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            title: { display: true, text: 'Cycles to failure (binned)', color: '#ccc' },
            ticks: { color: '#ccc', maxRotation: 0, autoSkip: true },
            grid: { color: 'rgba(255,255,255,0.05)' }
          },
          y: {
            title: { display: true, text: 'Count', color: '#ccc' },
            ticks: { color: '#ccc' },
            grid: { color: 'rgba(255,255,255,0.05)' }
          }
        },
        plugins: {
          legend: { labels: { color: '#eee', boxWidth: 14 } }
        }
      }
    });
  }

  function normalSample() {
    // Box-Muller, single sample
    const u1 = Math.random();
    const u2 = Math.random();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2*Math.PI*u2);
  }

  function simulateCell(maxCycles, base, amp, rho, threshold, useCorrelated) {
    let health = 100;
    let corrState = 0;
    const series = [];
    let tFail = maxCycles;

    for (let t = 0; t < maxCycles; t++) {
      let noise;
      if (useCorrelated) {
        // AR(1) style correlated noise with variance 1
        corrState = rho * corrState + Math.sqrt(1 - rho*rho) * normalSample();
        noise = amp * corrState;
      } else {
        noise = amp * normalSample();
      }

      const drain = base + noise;
      health -= drain;
      if (health < 0) health = 0;
      if (threshold > 0 && health <= threshold && tFail === maxCycles) {
        tFail = t;
      } else if (threshold === 0 && health <= 0 && tFail === maxCycles) {
        tFail = t;
      }
      series.push(health);
    }
    return { series, tFail };
  }

  function simulate() {
    const base = parseFloat(baseDrain.value);
    const amp  = parseFloat(noiseAmp.value);
    const rho  = parseFloat(corr.value);
    const nRuns = parseInt(runs.value, 10);
    const maxC = parseInt(cycles.value, 10);
    const thr  = parseFloat(thresh.value);

    const lifetimesWhite = [];
    const lifetimesQds   = [];
    let sampleWhite = null, sampleQds = null;

    for (let i = 0; i < nRuns; i++) {
      const w = simulateCell(maxC, base, amp, 0, thr, false);
      const q = simulateCell(maxC, base, amp, rho, thr, true);
      lifetimesWhite.push(w.tFail);
      lifetimesQds.push(q.tFail);
      if (i === 0) {
        sampleWhite = w.series;
        sampleQds   = q.series;
      }
    }

    const labels = Array.from({length: maxC}, (_, i) => i);
    makeHealthChart(labels, sampleWhite, sampleQds);

    // Histogram bins (10 bins)
    const minLife = 0;
    const maxLife = maxC;
    const binSize = maxC / 10;
    const bins = [];
    const countsW = new Array(10).fill(0);
    const countsQ = new Array(10).fill(0);
    for (let b = 0; b < 10; b++) {
      bins.push(Math.round(minLife + (b+0.5)*binSize));
    }
    function pushToBins(arr, counts) {
      arr.forEach(v => {
        let idx = Math.floor((v - minLife) / binSize);
        if (idx < 0) idx = 0;
        if (idx > 9) idx = 9;
        counts[idx]++;
      });
    }
    pushToBins(lifetimesWhite, countsW);
    pushToBins(lifetimesQds, countsQ);
    makeHistChart(bins, countsW, countsQ);

    updateStats(lifetimesWhite, lifetimesQds);
  }

  function meanAndStd(arr) {
    const n = arr.length;
    if (!n) return {mean: 0, std: 0};
    const m = arr.reduce((a,b)=>a+b,0)/n;
    const v = arr.reduce((a,b)=>a+(b-m)*(b-m),0)/n;
    return {mean: m, std: Math.sqrt(v)};
  }

  function updateStats(lifetimesWhite, lifetimesQds) {
    const sw = meanAndStd(lifetimesWhite);
    const sq = meanAndStd(lifetimesQds);
    const improvement = sw.mean === 0 ? 0 : ((sq.mean - sw.mean) / sw.mean) * 100;

    const box = document.getElementById('statsBox');
    box.innerHTML = `
      <div class="stat-block">
        <span class="label">White noise lifetime:</span><br>
        Mean = ${sw.mean.toFixed(1)} cycles<br>
        œÉ = ${sw.std.toFixed(1)} cycles
      </div>
      <div class="stat-block">
        <span class="label">QDS-style lifetime:</span><br>
        Mean = ${sq.mean.toFixed(1)} cycles<br>
        œÉ = ${sq.std.toFixed(1)} cycles
      </div>
      <div class="stat-block">
        <span class="label">Relative change (QDS vs white):</span><br>
        ${improvement >= 0 ? '+' : ''}${improvement.toFixed(1)}% in mean lifetime
      </div>
      <div class="stat-block">
        <span class="label">Runs simulated:</span><br>
        ${lifetimesWhite.length} cells per model
      </div>
    `;
  }

  document.getElementById('runBtn').addEventListener('click', simulate);

  document.getElementById('resetBtn').addEventListener('click', () => {
    baseDrain.value = 0.5;
    noiseAmp.value  = 1.0;
    corr.value      = 0.9;
    runs.value      = 200;
    cycles.value    = 500;
    thresh.value    = 0;
    syncLabels();
    simulate();
  });

  // initial run
  simulate();
})();


// --- qds_battery_whisperer_v2.html ---


  // --- Helpers ---
  function $(id){ return document.getElementById(id); }

  function randn() {
    // Box-Muller
    let u = 0, v = 0;
    while(u === 0) u = Math.random();
    while(v === 0) v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  }

  function linFit(x, y) {
    const n = x.length;
    if(n < 2) return {m:0,b:y[0]||0};
    let sx=0, sy=0, sxx=0, sxy=0;
    for(let i=0;i<n;i++){
      sx += x[i];
      sy += y[i];
      sxx += x[i]*x[i];
      sxy += x[i]*y[i];
    }
    const denom = n*sxx - sx*sx;
    if(denom === 0) return {m:0,b:sy/n};
    const m = (n*sxy - sx*sy)/denom;
    const b = (sy - m*sx)/n;
    return {m,b};
  }

  function statsFromSeries(tHours, vals) {
    const n = vals.length;
    if(n < 3) return { summary: "Not enough data.", ok:false };

    const t0 = tHours[0];
    const t1 = tHours[n-1];
    const v0 = vals[0];
    const v1 = vals[n-1];

    const totalDrop = v0 - v1;
    const duration = t1 - t0;
    const avgDrain = duration > 0 ? totalDrop / duration : 0;

    // Fit line and get residuals
    const fit = linFit(tHours, vals);
    const residuals = [];
    for(let i=0;i<n;i++){
      const yhat = fit.m * tHours[i] + fit.b;
      residuals.push(vals[i] - yhat);
    }

    // RMS of residuals
    let ss = 0;
    for(const r of residuals) ss += r*r;
    const rms = Math.sqrt(ss / n);

    // Lag-1 autocorrelation of residuals as crude "K"
    let num = 0, den = 0;
    const meanRes = residuals.reduce((a,b)=>a+b,0) / n;
    for(let i=0;i<n;i++){
      const d = residuals[i] - meanRes;
      den += d*d;
    }
    for(let i=0;i<n-1;i++){
      const d1 = residuals[i]   - meanRes;
      const d2 = residuals[i+1] - meanRes;
      num += d1*d2;
    }
    const K = den > 0 ? num / den : 0;

    let verdict = "Looks like a fairly clean, smooth drain.";
    let flags = [];
    if(avgDrain < 0.1) flags.push("very low drain (device mostly idle or charging)");
    if(avgDrain > 10) flags.push("very fast drain (heavy use or bad cell)");
    if(rms > 3) flags.push("high noise in residuals");
    if(Math.abs(K) > 0.4) flags.push("strong correlation in noise (structured behaviour)");

    if(flags.length > 0) {
      verdict = "Noticeable structure: " + flags.join("; ") + ".";
    }

    const summary = `
<b>Duration:</b> ${duration.toFixed(2)} h  
<b>Start ‚Üí End:</b> ${v0.toFixed(1)}% ‚Üí ${v1.toFixed(1)}% (Œî ${totalDrop.toFixed(1)}%)  
<b>Average drain:</b> ${avgDrain.toFixed(2)} %/h  
<b>Residual RMS:</b> ${rms.toFixed(2)} %  
<b>QDS-style K (lag-1 corr):</b> ${K.toFixed(3)}  
<br/>
<span class="${flags.length ? 'warn' : ''}">${verdict}</span>
`.trim();

    return { summary, ok:true };
  }

  function simulateBattery(params) {
    const { durationH, dtMin, drainPerH, noiseSigma, tauMin } = params;
    const dtH = dtMin / 60;
    const steps = Math.max(3, Math.round(durationH / dtH));
    const times = new Array(steps);
    const vals  = new Array(steps);
    let level = 100;

    const tau = Math.max(0.1, tauMin);
    const alpha = Math.exp(-dtMin / tau); // correlation factor

    let corrNoise = 0;
    for(let i=0;i<steps;i++){
      const t = i * dtH;
      // deterministic drain
      const idealDrop = drainPerH * dtH;
      // correlated noise
      const eps = randn() * noiseSigma;
      corrNoise = alpha * corrNoise + Math.sqrt(1 - alpha*alpha) * eps;

      level -= idealDrop + corrNoise * 0.1; // scale noise effect
      if(level < 0) level = 0;
      if(level > 120) level = 120;

      times[i] = t;
      vals[i]  = level;
    }
    return { times, vals };
  }

  // --- UI wiring ---
  const dur    = $("dur");
  const drain  = $("drain");
  const noise  = $("noise");
  const tau    = $("tau");
  const dt     = $("dt");
  const durVal   = $("durVal");
  const drainVal = $("drainVal");
  const noiseVal = $("noiseVal");
  const tauVal   = $("tauVal");
  const dtVal    = $("dtVal");

  dur.oninput   = ()=> durVal.textContent   = dur.value;
  drain.oninput = ()=> drainVal.textContent = drain.value;
  noise.oninput = ()=> noiseVal.textContent = noise.value;
  tau.oninput   = ()=> tauVal.textContent   = tau.value;
  dt.oninput    = ()=> dtVal.textContent    = dt.value;

  const modeSimBtn = $("modeSim");
  const modeLogBtn = $("modeLog");
  const simPanel   = $("simPanel");
  const logPanel   = $("logPanel");
  const modeHint   = $("modeHint");

  modeSimBtn.onclick = ()=>{
    modeSimBtn.classList.add("selected");
    modeLogBtn.classList.remove("selected");
    simPanel.style.display = "block";
    logPanel.style.display = "none";
    modeHint.textContent = "Simulation: generate synthetic battery data to try and break the model.";
  };
  modeLogBtn.onclick = ()=>{
    modeLogBtn.classList.add("selected");
    modeSimBtn.classList.remove("selected");
    simPanel.style.display = "none";
    logPanel.style.display = "block";
    modeHint.textContent = "Paste a real battery log to inspect drain and noise structure.";
  };

  const ctx = $("chart").getContext("2d");
  let chart = new Chart(ctx, {
    type: "line",
    data: {
      labels: [],
      datasets: [{
        label: "Battery %",
        data: [],
        fill: false,
        tension: 0.1,
        borderWidth: 2,
        pointRadius: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          title: { display: true, text: "Time (hours)" },
          ticks: { maxTicksLimit: 8 }
        },
        y: {
          title: { display: true, text: "Battery (%)" },
          suggestedMin: 0,
          suggestedMax: 105
        }
      },
      plugins: {
        legend: { display: false }
      }
    }
  });

  function updateChart(times, vals) {
    chart.data.labels = times.map(t=>t.toFixed(2));
    chart.data.datasets[0].data = vals;
    chart.update();
  }

  const statsDiv = $("stats");

  function showStats(times, vals){
    const s = statsFromSeries(times, vals);
    if(!s.ok){
      statsDiv.innerHTML = "<small>" + s.summary + "</small>";
    } else {
      statsDiv.innerHTML = s.summary;
    }
  }

  $("runSim").onclick = ()=>{
    const params = {
      durationH: parseFloat(dur.value),
      dtMin:     parseFloat(dt.value),
      drainPerH: parseFloat(drain.value),
      noiseSigma:parseFloat(noise.value),
      tauMin:    parseFloat(tau.value)
    };
    const sim = simulateBattery(params);
    updateChart(sim.times, sim.vals);
    showStats(sim.times, sim.vals);
  };

  $("simExtreme").onclick = ()=>{
    dur.value = 48; durVal.textContent = "48";
    drain.value = 12; drainVal.textContent = "12";
    noise.value = 4; noiseVal.textContent = "4.0";
    tau.value = 120; tauVal.textContent = "120";
    dt.value = 2; dtVal.textContent = "2";
    const params = {
      durationH: 48,
      dtMin: 2,
      drainPerH: 12,
      noiseSigma: 4,
      tauMin: 120
    };
    const sim = simulateBattery(params);
    updateChart(sim.times, sim.vals);
    showStats(sim.times, sim.vals);
  };

  $("plotLog").onclick = ()=>{
    const raw = $("logInput").value.trim();
    if(!raw){
      alert("Paste some values first.");
      return;
    }
    const lines = raw.split(/\r?\n/);
    const times = [];
    const vals  = [];
    let idx = 0;
    for(const line of lines){
      const t = line.trim();
      if(!t) continue;
      const parts = t.split(/[,;\s]+/).filter(Boolean);
      let tt, vv;
      if(parts.length === 1){
        tt = idx;
        vv = parseFloat(parts[0]);
      } else {
        tt = parseFloat(parts[0]);
        vv = parseFloat(parts[1]);
      }
      if(isNaN(tt) || isNaN(vv)) continue;
      times.push(tt/60); // assume minutes ‚Üí hours
      vals.push(vv);
      idx++;
    }
    if(times.length < 3){
      alert("Not enough valid lines to plot.");
      return;
    }
    updateChart(times, vals);
    showStats(times, vals);
  };

  $("clearLog").onclick = ()=>{
    $("logInput").value = "";
  };

  // Initial tiny sim so chart isn't empty
  (function init(){
    const params = {
      durationH: 6,
      dtMin: 5,
      drainPerH: 5,
      noiseSigma: 0.8,
      tauMin: 20
    };
    const sim = simulateBattery(params);
    updateChart(sim.times, sim.vals);
    showStats(sim.times, sim.vals);
  })();


// --- qds_battery_lab_showcase_v1.html ---

/* ============================================================
   QDS Battery Lab ‚Äî Showcase Stress Edition üîã
   Single-file, no deps, phone-safe.
   ============================================================ */

const $ = (id)=>document.getElementById(id);

const controls = {
  base: $("base"),
  amp: $("amp"),
  rho: $("rho"),
  n: $("n"),
  maxc: $("maxc"),
  thr: $("thr"),
  v_base: $("v_base"),
  v_amp: $("v_amp"),
  v_rho: $("v_rho"),
  v_n: $("v_n"),
  v_max: $("v_max"),
  v_thr: $("v_thr")
};

const toggles = {
  nonlin: $("togNonlin"),
  heat: $("togHeat"),
  outlier: $("togOutlier"),
  alerts: $("togAlerts")
};

const kpi = {
  white_mu: $("k_white_mu"),
  white_sd: $("k_white_sd"),
  qds_mu: $("k_qds_mu"),
  qds_sd: $("k_qds_sd"),
  delta: $("k_delta"),
  runs: $("k_runs")
};

const alertBox = $("alertBox");
const profileCanvas = $("profile");
const histCanvas = $("hist");
const profileNote = $("profileNote");

const HISTORY_KEY = "QDS_BATTERY_LAB_SHOWCASE_HISTORY_V1";
const lastRun = { summaryText:"", json:null };

function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function rndn(){
  // Box-Muller
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

function updateLabels(){
  controls.v_base.textContent = Number(controls.base.value).toFixed(1);
  controls.v_amp.textContent  = Number(controls.amp.value).toFixed(1);
  controls.v_rho.textContent  = Number(controls.rho.value).toFixed(2);
  controls.v_n.textContent    = Number(controls.n.value);
  controls.v_max.textContent  = Number(controls.maxc.value);
  controls.v_thr.textContent  = Number(controls.thr.value);
}
Object.values(controls).forEach(el=>{
  if(el && el.tagName==="INPUT"){
    el.addEventListener("input", updateLabels);
  }
});
updateLabels();

/* ---------------- Presets ---------------- */
function setVals({base,amp,rho,n,maxc,thr}){
  if(base!=null) controls.base.value=base;
  if(amp!=null) controls.amp.value=amp;
  if(rho!=null) controls.rho.value=rho;
  if(n!=null) controls.n.value=n;
  if(maxc!=null) controls.maxc.value=maxc;
  if(thr!=null) controls.thr.value=thr;
  updateLabels();
}

$("presetReal").onclick = ()=>{
  setVals({base:1.6, amp:1.0, rho:0.35, n:800, maxc:1500, thr:80});
};
$("presetContrast").onclick = ()=>{
  setVals({base:2.0, amp:3.0, rho:0.90, n:500, maxc:1200, thr:80});
};
$("presetChaos").onclick = ()=>{
  setVals({base:4.2, amp:6.0, rho:0.95, n:700, maxc:2200, thr:78});
};

/* ---------------- Stress Hammer: Pathological ---------------- */
$("hammerPath").onclick = ()=>{
  setVals({base:5.5, amp:8.5, rho:0.97, n:1200, maxc:2500, thr:75});
  toggles.nonlin.checked = true;
  toggles.heat.checked = true;
  toggles.outlier.checked = true;
  toggles.alerts.checked = true;
};

/* ---------------- Reset ---------------- */
$("resetBtn").onclick = ()=>{
  setVals({base:2.0, amp:3.0, rho:0.90, n:500, maxc:1200, thr:80});
  toggles.nonlin.checked = true;
  toggles.heat.checked = true;
  toggles.outlier.checked = true;
  toggles.alerts.checked = true;
  alertBox.innerHTML="";
};

/* ============================================================
   Stress mechanics (lightweight, demo-friendly)
   ============================================================ */

function nonlinearFactor(cycle, maxc){
  // Smooth acceleration curve: starts near 1, rises to ~1.8
  const x = cycle / Math.max(1, maxc);
  const power = 2.2;
  const strength = 0.8; // 0.0 -> none
  return 1 + strength * Math.pow(x, power);
}

function heatWaveMultiplier(state){
  // state carries heatCountdown
  if(state.heatCountdown > 0){
    state.heatCountdown--;
    return state.heatAmp;
  }
  // small chance to start a heat epoch
  const startProb = 0.012; // ~1.2% per cycle
  if(Math.random() < startProb){
    state.heatCountdown = 6 + Math.floor(Math.random()*18); // 6-23 cycles
    state.heatAmp = 1.8 + Math.random()*1.6; // 1.8x - 3.4x
    return state.heatAmp;
  }
  return 1.0;
}

function maybeOutlierDrop(){
  // rare catastrophic event
  const p = 0.004; // 0.4% per cycle
  if(Math.random() < p){
    // drop between 3% and 18%
    return 3 + Math.random()*15;
  }
  return 0;
}

/* ============================================================
   Core simulation
   ============================================================ */

function simulateModel(params, mode){
  // mode: "white" or "qds"
  const {
    base, amp, rho, maxc, thr,
    stressNonlin, stressHeat, stressOutlier
  } = params;

  const lifetimes = new Array(params.n);
  let sample = null; // one representative trace

  for(let i=0;i<params.n;i++){
    let health = 100.0;

    // AR(1) state for QDS
    let eps_prev = 0;

    // stress state
    const heatState = { heatCountdown:0, heatAmp:1.0 };

    let failedAt = maxc;

    // For sample trace, store a bit more
    const isSample = (i===0);
    const trace = isSample ? [] : null;

    for(let c=1;c<=maxc;c++){

      // Effective base drain with optional nonlinearity
      let baseEff = base;
      if(stressNonlin){
        baseEff = base * nonlinearFactor(c, maxc);
      }

      // Noise amplitude multiplier from heat epochs
      let ampEff = amp;
      if(stressHeat){
        ampEff = amp * heatWaveMultiplier(heatState);
      }

      // Generate noise
      let noise = 0;
      if(ampEff > 0){
        if(mode==="white"){
          noise = rndn() * ampEff;
        }else{
          // AR(1): eps_t = rho * eps_{t-1} + sqrt(1-rho^2) * z
          const z = rndn();
          const scale = Math.sqrt(Math.max(0, 1 - rho*rho));
          const eps = rho * eps_prev + scale * z;
          eps_prev = eps;
          noise = eps * ampEff;
        }
      }

      // Outlier drop
      let outDrop = 0;
      if(stressOutlier){
        outDrop = maybeOutlierDrop();
      }

      // Update health
      health -= baseEff;
      health -= noise;
      health -= outDrop;

      // Clamp upper/lower for sanity
      health = clamp(health, -50, 120);

      if(isSample){
        trace.push({c, health});
      }

      if(health <= thr){
        failedAt = c;
        break;
      }
    }

    lifetimes[i] = failedAt;

    if(isSample){
      sample = {
        trace,
        failedAt,
        mode
      };
    }
  }

  return { lifetimes, sample };
}

function mean(arr){
  let s=0;
  for(const x of arr) s+=x;
  return s/arr.length;
}
function std(arr, mu){
  let s=0;
  for(const x of arr){ const d=x-mu; s+=d*d; }
  return Math.sqrt(s/Math.max(1, arr.length-1));
}

/* ============================================================
   Drawing helpers
   ============================================================ */

function clearCanvas(cv){
  const ctx = cv.getContext("2d");
  const dpr = window.devicePixelRatio || 1;
  const rect = cv.getBoundingClientRect();
  cv.width = Math.max(1, Math.floor(rect.width * dpr));
  cv.height = Math.max(1, Math.floor(rect.height * dpr));
  ctx.scale(dpr, dpr);
  ctx.clearRect(0,0,rect.width, rect.height);
  return {ctx, w:rect.width, h:rect.height};
}

function drawAxes(ctx,w,h){
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;
  // grid
  const gx=6, gy=5;
  for(let i=1;i<gx;i++){
    const x = (w/gx)*i;
    ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,h-20); ctx.stroke();
  }
  for(let j=1;j<gy;j++){
    const y = (h/gy)*j;
    ctx.beginPath(); ctx.moveTo(10,y); ctx.lineTo(w-10,y); ctx.stroke();
  }
  ctx.restore();
}

function drawProfile(sampleWhite, sampleQds, thr){
  const {ctx,w,h} = clearCanvas(profileCanvas);
  drawAxes(ctx,w,h);

  const padL=28, padR=10, padT=10, padB=26;
  const plotW = w-padL-padR;
  const plotH = h-padT-padB;

  // Determine x range from longest trace length
  const len = Math.max(sampleWhite.trace.length, sampleQds.trace.length, 1);

  function xMap(i){ return padL + (i/(len-1||1))*plotW; }
  function yMap(val){
    // map health roughly 0..110
    const v = clamp(val, 0, 110);
    const t = (v/110);
    return padT + (1-t)*plotH;
  }

  // threshold line
  ctx.save();
  ctx.strokeStyle = "rgba(255,94,122,0.35)";
  ctx.setLineDash([6,5]);
  const yThr = yMap(thr);
  ctx.beginPath(); ctx.moveTo(padL, yThr); ctx.lineTo(padL+plotW, yThr); ctx.stroke();
  ctx.restore();

  function drawTrace(trace, stroke){
    ctx.save();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<trace.length;i++){
      const x = xMap(i);
      const y = yMap(trace[i].health);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // Colors are implicit via CSS vibe; we‚Äôll pick subtle inline RGBA
  drawTrace(sampleWhite.trace, "rgba(88,166,255,0.95)");
  drawTrace(sampleQds.trace, "rgba(255,94,122,0.9)");

  // labels
  ctx.save();
  ctx.fillStyle="rgba(230,237,255,0.85)";
  ctx.font="12px system-ui";
  ctx.fillText("White noise", padL, padT+12);
  ctx.fillStyle="rgba(255,94,122,0.9)";
  ctx.fillText("QDS-style", padL+95, padT+12);
  ctx.restore();
}

function drawHistogram(lifeWhite, lifeQds){
  const {ctx,w,h} = clearCanvas(histCanvas);
  drawAxes(ctx,w,h);

  const padL=34, padR=10, padT=10, padB=28;
  const plotW = w-padL-padR;
  const plotH = h-padT-padB;

  const maxVal = Math.max(
    ...lifeWhite, ...lifeQds, 1
  );

  const bins = 10;
  const binSize = Math.max(1, Math.ceil(maxVal / bins));

  function binCounts(arr){
    const c = new Array(bins).fill(0);
    for(const v of arr){
      const idx = Math.min(bins-1, Math.floor((v-1)/binSize));
      c[idx]++;
    }
    return c;
  }

  const cw = binCounts(lifeWhite);
  const cq = binCounts(lifeQds);
  const maxCount = Math.max(...cw, ...cq, 1);

  const groupW = plotW / bins;
  const barW = groupW * 0.36;
  const gap = groupW * 0.08;

  function yMap(count){
    const t = count / maxCount;
    return padT + (1-t)*plotH;
  }

  for(let i=0;i<bins;i++){
    const baseX = padL + i*groupW;

    // white bar
    const x1 = baseX + gap;
    const y1 = yMap(cw[i]);
    const h1 = padT + plotH - y1;

    ctx.fillStyle = "rgba(88,166,255,0.75)";
    ctx.fillRect(x1, y1, barW, h1);

    // qds bar
    const x2 = baseX + gap + barW + gap;
    const y2 = yMap(cq[i]);
    const h2 = padT + plotH - y2;

    ctx.fillStyle = "rgba(255,94,122,0.75)";
    ctx.fillRect(x2, y2, barW, h2);
  }

  // axis labels (minimal)
  ctx.save();
  ctx.fillStyle="rgba(154,167,199,0.9)";
  ctx.font="10.5px system-ui";
  ctx.fillText("Count", 6, padT+10);
  ctx.fillText("Cycles to failure (binned)", padL, h-8);
  ctx.restore();
}

/* ============================================================
   Sanity alerts
   ============================================================ */

function buildAlerts(p){
  if(!toggles.alerts.checked) return "";

  const flags = [];

  // These are "demo plausibility" heuristics, not physics claims.
  if(p.base >= 5.0) flags.push("Very high base drain ‚Üí likely demo-only.");
  if(p.amp >= 7.0) flags.push("Very high noise amplitude ‚Üí exaggerated conditions.");
  if(p.rho >= 0.95) flags.push("Extremely high œÅ ‚Üí strong long-memory noise.");
  if(p.thr <= 60) flags.push("Low failure threshold ‚Üí easier survival by definition.");
  if(p.maxc >= 2500 && p.n >= 1500) flags.push("Heavy compute combo ‚Üí may be slow on some phones.");

  if(flags.length===0){
    return `<div class="ok">Sanity: parameters look within a reasonable demo band.</div>`;
  }
  return `<div class="note"><b>Sanity flags:</b><br>‚Ä¢ ${flags.join("<br>‚Ä¢ ")}</div>`;
}

/* ============================================================
   History
   ============================================================ */

function loadHistory(){
  try{
    const raw = localStorage.getItem(HISTORY_KEY);
    if(!raw) return [];
    const arr = JSON.parse(raw);
    if(Array.isArray(arr)) return arr;
  }catch(e){}
  return [];
}

function saveHistoryEntry(entry){
  const arr = loadHistory();
  arr.unshift(entry);
  const sliced = arr.slice(0, 8);
  localStorage.setItem(HISTORY_KEY, JSON.stringify(sliced));
  renderHistory();
}

function renderHistory(){
  const box = $("history");
  const arr = loadHistory();
  if(arr.length===0){
    box.innerHTML = `<div class="hist-item">No local history yet.</div>`;
    return;
  }
  box.innerHTML = arr.map(e=>{
    return `
      <div class="hist-item">
        <div><b>${e.time}</b></div>
        <div class="mono">
          base=${e.base}% ¬∑ amp=${e.amp}% ¬∑ œÅ=${e.rho} ¬∑ thr=${e.thr}% ¬∑ n=${e.n} ¬∑ max=${e.maxc}
        </div>
        <div class="mono">
          white Œº=${e.white_mu} œÉ=${e.white_sd} ¬∑ QDS Œº=${e.qds_mu} œÉ=${e.qds_sd} ¬∑ Œî=${e.delta}
        </div>
        <div class="small">
          stress: nonlin=${e.stress.nonlin} heat=${e.stress.heat} outlier=${e.stress.outlier}
        </div>
      </div>
    `;
  }).join("");
}
renderHistory();

$("clearHistBtn").onclick = ()=>{
  localStorage.removeItem(HISTORY_KEY);
  renderHistory();
};

/* ============================================================
   Main run
   ============================================================ */

function runSimulation(){
  const base = Number(controls.base.value);
  const amp  = Number(controls.amp.value);
  const rho  = Number(controls.rho.value);
  const n    = Number(controls.n.value);
  const maxc = Number(controls.maxc.value);
  const thr  = Number(controls.thr.value);

  const params = {
    base, amp, rho, n, maxc, thr,
    stressNonlin: toggles.nonlin.checked,
    stressHeat: toggles.heat.checked,
    stressOutlier: toggles.outlier.checked
  };

  alertBox.innerHTML = buildAlerts(params);

  // Run both models
  const white = simulateModel(params, "white");
  const qds   = simulateModel(params, "qds");

  const w_mu = mean(white.lifetimes);
  const q_mu = mean(qds.lifetimes);
  const w_sd = std(white.lifetimes, w_mu);
  const q_sd = std(qds.lifetimes, q_mu);

  const delta = ((q_mu - w_mu) / Math.max(1e-9, w_mu)) * 100;

  // KPI
  kpi.white_mu.textContent = `${w_mu.toFixed(1)} `;
  kpi.white_sd.textContent = `${w_sd.toFixed(1)}`;
  kpi.qds_mu.textContent   = `${q_mu.toFixed(1)} `;
  kpi.qds_sd.textContent   = `${q_sd.toFixed(1)}`;
  kpi.delta.textContent    = `${delta>=0?"+":""}${delta.toFixed(1)}%`;
  kpi.runs.textContent     = `${n} per model`;

  // Profiles
  drawProfile(white.sample, qds.sample, thr);

  profileNote.textContent =
    `White: failed at cycle ${white.sample.failedAt} (profile may clamp afterwards). `+
    `QDS: failed at cycle ${qds.sample.failedAt} (profile may clamp afterwards).`;

  // Histogram
  drawHistogram(white.lifetimes, qds.lifetimes);

  // Save run summary
  const now = new Date();
  const t = now.toLocaleDateString() + ", " + now.toLocaleTimeString();

  const entry = {
    time: t,
    base: base.toFixed(1),
    amp: amp.toFixed(1),
    rho: rho.toFixed(2),
    thr: thr.toFixed(0),
    n, maxc,
    white_mu: w_mu.toFixed(1),
    white_sd: w_sd.toFixed(1),
    qds_mu: q_mu.toFixed(1),
    qds_sd: q_sd.toFixed(1),
    delta: `${delta>=0?"+":""}${delta.toFixed(1)}%`,
    stress:{
      nonlin: params.stressNonlin,
      heat: params.stressHeat,
      outlier: params.stressOutlier
    }
  };
  saveHistoryEntry(entry);

  // Prepare copy/export payload
  const summary =
`QDS Battery Lab ‚Äî Showcase Stress Edition
time: ${t}
base=${entry.base}% amp=${entry.amp}% œÅ=${entry.rho} thr=${entry.thr}%
n=${n} max=${maxc}
white Œº=${entry.white_mu} œÉ=${entry.white_sd}
QDS   Œº=${entry.qds_mu} œÉ=${entry.qds_sd}
Œî(QDS vs white)=${entry.delta}
stress: nonlin=${entry.stress.nonlin} heat=${entry.stress.heat} outlier=${entry.stress.outlier}`;

  lastRun.summaryText = summary;
  lastRun.json = {
    meta:{
      tool:"QDS Battery Lab ‚Äî Showcase Stress Edition",
      version:"v1",
      time:t,
      notes:"Demo-grade intuition model; not a physical battery chemistry solver."
    },
    params,
    results:{
      white:{ mean:w_mu, sd:w_sd, lifetimes:white.lifetimes },
      qds:{ mean:q_mu, sd:q_sd, lifetimes:qds.lifetimes },
      relative_change_percent: delta
    },
    samples:{
      white: white.sample,
      qds: qds.sample
    }
  };
}

$("runBtn").onclick = runSimulation;

/* ============================================================
   Copy / Export
   ============================================================ */

$("copyBtn").onclick = async ()=>{
  if(!lastRun.summaryText){
    alert("Run a simulation first, old chap. üé©");
    return;
  }
  try{
    await navigator.clipboard.writeText(lastRun.summaryText);
    alert("Summary copied. üîãüé©");
  }catch(e){
    // fallback
    const ta = document.createElement("textarea");
    ta.value = lastRun.summaryText;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
    alert("Summary copied (fallback). üîãüé©");
  }
};

$("exportBtn").onclick = ()=>{
  if(!lastRun.json){
    alert("Run a simulation first, old chap. üé©");
    return;
  }
  const blob = new Blob([JSON.stringify(lastRun.json, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  const stamp = new Date().toISOString().replace(/[:.]/g,"-");
  a.href = url;
  a.download = `qds_battery_lab_showcase_run_${stamp}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
};

/* ============================================================
   First paint placeholders
   ============================================================ */
(function initPaint(){
  drawHistogram([10],[10]);
  const {ctx,w,h} = clearCanvas(profileCanvas);
  drawAxes(ctx,w,h);
  ctx.fillStyle="rgba(154,167,199,0.9)";
  ctx.font="12px system-ui";
  ctx.fillText("Awaiting simulation‚Ä¶", 18, 28);
})();


// --- qds_battery_lab_showcase_stress_bias_v1.html ---

// ======================================================
// QDS Battery Lab ‚Äî Showcase Stress + Bias v1
// single-file, android-safe, no deps
// ======================================================

const $ = id => document.getElementById(id);

const DEFAULTS = {
  base: 2.0, amp: 3.0, p: 0.90, n: 500, maxCycles: 1200, thr: 80,
  hamNonlin: true, hamHeat: true, hamOutlier: true
};

let BIAS = { matchedMarginal:false, blindLabels:false };

// ----------------- UI wiring -----------------
function bindSlider(id, outId, fmt=1){
  const el = $(id), out = $(outId);
  const upd = () => out.textContent = Number(el.value).toFixed(fmt);
  el.addEventListener("input", upd); upd();
}
bindSlider("base","v_base",1);
bindSlider("amp","v_amp",1);
bindSlider("p","v_p",2);
bindSlider("n","v_n",0);
bindSlider("maxCycles","v_max",0);
bindSlider("thr","v_thr",0);

$("btnRun").onclick = () => runSimulation();
$("btnReset").onclick = () => resetDefaults();

$("preReal").onclick = () => applyPreset("real");
$("preContrast").onclick = () => applyPreset("contrast");
$("preChaos").onclick = () => applyPreset("chaos");

$("hamPath").onclick = () => pathologicalHammer();

$("btnHardNull").onclick = () => { setSlider("p",0); BIAS.matchedMarginal=false; softToast("Hard null: p=0."); runSimulation(); };
$("btnMatched").onclick = () => { BIAS.matchedMarginal = !BIAS.matchedMarginal; softToast("Matched marginal " + (BIAS.matchedMarginal?"ON":"OFF")); runSimulation(); };
$("chkBlind").onchange = e => { BIAS.blindLabels = !!e.target.checked; softToast("Blind labels " + (BIAS.blindLabels?"ON":"OFF")); runSimulation(); };

$("btnClearHist").onclick = () => { localStorage.removeItem("QDS_BATT_HIST_V1"); renderHistory(); };

function setSlider(id, v){
  const el = $(id); if(!el) return;
  el.value = v; el.dispatchEvent(new Event("input"));
}
function setCheck(id, v){
  const el = $(id); if(!el) return;
  el.checked = !!v;
}

function resetDefaults(){
  setSlider("base", DEFAULTS.base);
  setSlider("amp", DEFAULTS.amp);
  setSlider("p", DEFAULTS.p);
  setSlider("n", DEFAULTS.n);
  setSlider("maxCycles", DEFAULTS.maxCycles);
  setSlider("thr", DEFAULTS.thr);
  setCheck("hamNonlin", DEFAULTS.hamNonlin);
  setCheck("hamHeat", DEFAULTS.hamHeat);
  setCheck("hamOutlier", DEFAULTS.hamOutlier);
  BIAS.matchedMarginal = false;
  $("chkBlind").checked = false; BIAS.blindLabels = false;
  runSimulation();
}

function applyPreset(kind){
  if(kind==="real"){
    setSlider("base",2.0); setSlider("amp",3.0); setSlider("p",0.90);
    setSlider("n",500); setSlider("maxCycles",1200); setSlider("thr",80);
  }
  if(kind==="contrast"){
    setSlider("base",3.0); setSlider("amp",2.2); setSlider("p",0.75);
    setSlider("n",1200); setSlider("maxCycles",2400); setSlider("thr",60);
  }
  if(kind==="chaos"){
    setSlider("base",8.0); setSlider("amp",12.0); setSlider("p",0.99);
    setSlider("n",2000); setSlider("maxCycles",3000); setSlider("thr",95);
  }
  runSimulation();
}

function pathologicalHammer(){
  setSlider("base",7.5);
  setSlider("amp",10.0);
  setSlider("p",0.95);
  setSlider("n",1600);
  setSlider("maxCycles",2600);
  setSlider("thr",90);
  setCheck("hamNonlin", true);
  setCheck("hamHeat", true);
  setCheck("hamOutlier", true);
  runSimulation();
}

// ----------------- RNG helpers -----------------
function randn(){
  // Box-Muller
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

// ----------------- Model core -----------------
function simulateOneCell(model, cfg){
  let health = 100.0;
  let prevQ = 0.0;
  let cycles = 0;

  const base = cfg.base;
  const amp = cfg.amp;
  const phi = cfg.p;
  const thr = cfg.thr;

  const hamNonlin = cfg.hamNonlin;
  const hamHeat = cfg.hamHeat;
  const hamOutlier = cfg.hamOutlier;

  // heat epochs: every ~40 cycles, 6-cycle harsh band
  function heatMultiplier(c){
    if(!hamHeat) return 1.0;
    const period = 40;
    const band = 6;
    const m = c % period;
    return (m < band) ? 1.6 : 1.0;
  }

  while(cycles < cfg.maxCycles && health > thr){
    cycles++;

    // shared draw for matched marginal option
    const eps = randn();

    let step;
    if(model==="white"){
      step = eps;
    }else{
      if(BIAS.matchedMarginal){
        step = phi*prevQ + Math.sqrt(1 - phi*phi)*eps;
      }else{
        step = phi*prevQ + Math.sqrt(1 - phi*phi)*randn();
      }
      prevQ = step;
    }

    // base + scaled noise
    let drain = base + amp * step;

    // outlier shocks
    if(hamOutlier && Math.random() < 0.012){
      drain += 6 + Math.random()*10;
    }

    // nonlinear wear when low
    if(hamNonlin){
      const frag = Math.max(0, (40 - health) / 40); // 0..1 as health drops under 40
      drain *= (1 + 0.9*frag);
    }

    // heat epochs
    drain *= heatMultiplier(cycles);

    // clamp drain to avoid insane reversals
    if(drain < -3) drain = -3;

    health -= drain;

    // mild clamp for display realism
    if(health > 110) health = 110;
  }

  return cycles;
}

function simulateProfile(model, cfg){
  let health = 100.0;
  let prevQ = 0.0;
  const arr = [health];

  const epsTiny = () => randn();

  function heatMultiplier(c){
    if(!cfg.hamHeat) return 1.0;
    const period = 40, band = 6;
    const m = c % period;
    return (m < band) ? 1.6 : 1.0;
  }

  for(let c=1; c<=Math.min(cfg.maxCycles, 260); c++){
    const eps = epsTiny();

    let step;
    if(model==="white"){
      step = eps;
    }else{
      if(BIAS.matchedMarginal){
        step = cfg.p*prevQ + Math.sqrt(1 - cfg.p*cfg.p)*eps;
      }else{
        step = cfg.p*prevQ + Math.sqrt(1 - cfg.p*cfg.p)*epsTiny();
      }
      prevQ = step;
    }

    let drain = cfg.base + cfg.amp * step;

    if(cfg.hamOutlier && Math.random() < 0.02){
      drain += 4 + Math.random()*8;
    }
    if(cfg.hamNonlin){
      const frag = Math.max(0, (40 - health) / 40);
      drain *= (1 + 0.9*frag);
    }
    drain *= heatMultiplier(c);
    if(drain < -3) drain = -3;

    health -= drain;
    arr.push(health);
    if(health <= cfg.thr) break;
  }
  return arr;
}

// ----------------- Stats -----------------
function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }
function sd(a){
  const m = mean(a);
  const v = a.reduce((s,x)=>s+(x-m)*(x-m),0)/Math.max(1,(a.length-1));
  return Math.sqrt(v);
}

// ----------------- Charts -----------------
function drawProfile(canvas, whiteArr, qdsArr, labels){
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  // grid
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y = (h*i)/6;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }
  for(let i=1;i<8;i++){
    const x = (w*i)/8;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }

  function plot(arr, color){
    const n = arr.length;
    const maxX = Math.max(10, n-1);
    const minY = 0, maxY = 110;

    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const x = (i/maxX)*w;
      const y = h - ((arr[i]-minY)/(maxY-minY))*h;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  plot(whiteArr, "rgba(120,170,255,0.95)");
  plot(qdsArr, "rgba(255,110,150,0.9)");

  // labels
  ctx.fillStyle = "rgba(230,240,255,0.9)";
  ctx.font = "bold 12px system-ui";
  ctx.fillText(labels.whiteLabel, 14, 18);
  ctx.fillStyle = "rgba(255,170,200,0.9)";
  ctx.fillText(labels.qdsLabel, 120, 18);
}

function drawHistogram(canvas, white, qds, labels){
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  const all = white.concat(qds);
  const maxV = Math.max(...all);
  const minV = Math.min(...all);

  const bins = 14;
  const binW = (maxV - minV + 1) / bins;

  function binCounts(arr){
    const c = new Array(bins).fill(0);
    for(const x of arr){
      let b = Math.floor((x - minV)/binW);
      if(b<0) b=0; if(b>=bins) b=bins-1;
      c[b]++;
    }
    return c;
  }

  const cw = binCounts(white);
  const cq = binCounts(qds);
  const top = Math.max(...cw, ...cq, 1);

  // grid
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y = (h*i)/6;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }

  const pad = 16;
  const plotW = w - pad*2;
  const plotH = h - pad*2;
  const barGroup = plotW / bins;

  for(let i=0;i<bins;i++){
    const x0 = pad + i*barGroup;

    const bw = barGroup*0.36;
    const gap = barGroup*0.08;

    const hw = (cw[i]/top)*plotH;
    const hq = (cq[i]/top)*plotH;

    // white bars
    ctx.fillStyle = "rgba(120,170,255,0.75)";
    ctx.fillRect(x0, pad + (plotH-hw), bw, hw);

    // qds bars
    ctx.fillStyle = "rgba(255,110,150,0.7)";
    ctx.fillRect(x0+bw+gap, pad + (plotH-hq), bw, hq);
  }

  // legend text
  ctx.fillStyle = "rgba(230,240,255,0.85)";
  ctx.font="bold 12px system-ui";
  ctx.fillText(labels.whiteLabel, 14, 18);
  ctx.fillStyle = "rgba(255,170,200,0.9)";
  ctx.fillText(labels.qdsLabel, 120, 18);
}

// ----------------- Bias-safe label swap -----------------
function applyBlindDisplay(res){
  let labels = { whiteLabel:"White noise", qdsLabel:"QDS-style" };
  if(!BIAS.blindLabels) return { res, labels };

  if(Math.random() < 0.5) return { res, labels };

  // swap display only
  const swapped = {
    whiteMu: res.qdsMu, whiteSd: res.qdsSd,
    qdsMu: res.whiteMu, qdsSd: res.whiteSd,
    whiteArr: res.qdsArr, qdsArr: res.whiteArr,
    whiteHist: res.qdsHist, qdsHist: res.whiteHist,
    delta: -res.delta // display trick, not physics
  };
  labels = { whiteLabel:"QDS-style", qdsLabel:"White noise" };
  return { res: swapped, labels };
}

// ----------------- Run simulation -----------------
function runSimulation(){
  const cfg = readCfg();

  const white = [];
  const qds = [];

  for(let i=0;i<cfg.n;i++){
    white.push(simulateOneCell("white", cfg));
    qds.push(simulateOneCell("qds", cfg));
  }

  const whiteMu = mean(white), whiteSd = sd(white);
  const qdsMu = mean(qds), qdsSd = sd(qds);
  const delta = ((qdsMu - whiteMu) / Math.max(1e-9, whiteMu)) * 100;

  const whiteArr = simulateProfile("white", cfg);
  const qdsArr = simulateProfile("qds", cfg);

  const resCore = {
    whiteMu, whiteSd, qdsMu, qdsSd, delta,
    whiteArr, qdsArr,
    whiteHist: white, qdsHist: qds
  };

  const blindPack = applyBlindDisplay(resCore);
  const res = blindPack.res;
  const labels = blindPack.labels;

  renderFlags(cfg, whiteMu, qdsMu);
  renderNumbers(res, cfg, labels);
  renderCharts(res, labels, cfg);
  pushHistory(cfg, whiteMu, whiteSd, qdsMu, qdsSd, delta);
  renderHistory();
}

function readCfg(){
  return {
    base: Number($("base").value),
    amp: Number($("amp").value),
    p: Number($("p").value),
    n: Number($("n").value),
    maxCycles: Number($("maxCycles").value),
    thr: Number($("thr").value),
    hamNonlin: $("hamNonlin").checked,
    hamHeat: $("hamHeat").checked,
    hamOutlier: $("hamOutlier").checked
  };
}

// ----------------- Render -----------------
function renderFlags(cfg, whiteMu, qdsMu){
  const flags = [];

  if(cfg.thr < 60) flags.push("Low failure threshold ‚Üí easier survival by definition.");
  if(cfg.base > 7) flags.push("Very high base drain ‚Üí likely demo-only.");
  if(cfg.amp > 10) flags.push("Very high noise amplitude ‚Üí exaggerated conditions.");
  if(cfg.p > 0.95) flags.push("Extremely high p ‚Üí strong long-memory noise.");
  if(cfg.n * cfg.maxCycles > 5_000_000) flags.push("Heavy compute combo ‚Üí may be slow on some phones.");
  if(BIAS.matchedMarginal) flags.push("Matched marginal ON ‚Üí correlation-only comparison.");
  if(BIAS.blindLabels) flags.push("Blind labels ON ‚Üí display swap may occur.");

  const box = $("flags");
  if(flags.length){
    box.style.display="block";
    box.innerHTML = "<b>Sanity flags:</b><br>‚Ä¢ " + flags.join("<br>‚Ä¢ ");
  }else{
    box.style.display="none";
    box.textContent="";
  }
}

function renderNumbers(res, cfg, labels){
  $("labWhite").textContent = labels.whiteLabel + " mean lifetime";
  $("labQDS").textContent = labels.qdsLabel + " mean lifetime";

  $("r_white_mu").textContent = res.whiteMu.toFixed(1);
  $("r_white_sd").textContent = res.whiteSd.toFixed(1);
  $("r_qds_mu").textContent = res.qdsMu.toFixed(1);
  $("r_qds_sd").textContent = res.qdsSd.toFixed(1);

  const sign = res.delta >= 0 ? "+" : "";
  $("r_delta").textContent = sign + res.delta.toFixed(1) + "%";
  $("r_n").textContent = cfg.n + " per model";
}

function renderCharts(res, labels, cfg){
  drawProfile($("profileChart"), res.whiteArr, res.qdsArr, labels);
  drawHistogram($("histChart"), res.whiteHist, res.qdsHist, labels);

  const wFail = res.whiteArr.length-1;
  const qFail = res.qdsArr.length-1;
  $("profileNote").textContent =
    `${labels.whiteLabel}: failed at cycle ${wFail} (profile may clamp afterwards). ` +
    `${labels.qdsLabel}: failed at cycle ${qFail} (profile may clamp afterwards).`;
}

// ----------------- History -----------------
function pushHistory(cfg, wMu, wSd, qMu, qSd, delta){
  const key = "QDS_BATT_HIST_V1";
  const arr = JSON.parse(localStorage.getItem(key) || "[]");

  const stamp = new Date().toLocaleString();
  const line =
`${stamp}
base=${cfg.base.toFixed(1)}% ¬∑ amp=${cfg.amp.toFixed(1)}% ¬∑ p=${cfg.p.toFixed(2)} ¬∑ thr=${cfg.thr}%
n=${cfg.n} ¬∑ max=${cfg.maxCycles}
white Œº=${wMu.toFixed(1)} œÉ=${wSd.toFixed(1)} ¬∑ QDS Œº=${qMu.toFixed(1)} œÉ=${qSd.toFixed(1)}
Œî=${delta>=0?"+":""}${delta.toFixed(1)}%
stress: nonlin=${cfg.hamNonlin} heat=${cfg.hamHeat} outlier=${cfg.hamOutlier}
bias: matched=${BIAS.matchedMarginal} blind=${BIAS.blindLabels}`;

  arr.unshift(line);
  if(arr.length > 30) arr.length = 30;
  localStorage.setItem(key, JSON.stringify(arr));
}

function renderHistory(){
  const key = "QDS_BATT_HIST_V1";
  const arr = JSON.parse(localStorage.getItem(key) || "[]");
  const box = $("historyBox");
  box.innerHTML = arr.length ? "" : `<div class="hist-item">No history yet.</div>`;
  for(const item of arr){
    const d = document.createElement("div");
    d.className="hist-item";
    d.textContent = item;
    box.appendChild(d);
  }
}

// ----------------- Toast (console only) -----------------
function softToast(msg){
  console.log("[QDS Battery Lab]", msg);
}

// boot
resetDefaults();
renderHistory();


// --- qds_battery_lab_showcase_stress_bias_v2.html ---

const $ = id => document.getElementById(id);

const DEFAULTS = {
  base: 2.0, amp: 3.0, p: 0.90, n: 500, maxCycles: 1200, thr: 80,
  hamNonlin: true, hamHeat: true, hamOutlier: true,
  paired: true, noRegen: true, blind: false
};

let BIAS = { blind:false };

// sliders
function bindSlider(id, outId, fmt=1){
  const el = $(id), out = $(outId);
  const upd = () => out.textContent = Number(el.value).toFixed(fmt);
  el.addEventListener("input", upd); upd();
}
bindSlider("base","v_base",1);
bindSlider("amp","v_amp",1);
bindSlider("p","v_p",2);
bindSlider("n","v_n",0);
bindSlider("maxCycles","v_max",0);
bindSlider("thr","v_thr",0);

// buttons
$("btnRun").onclick = () => runSimulation();
$("btnReset").onclick = () => resetDefaults();
$("preReal").onclick = () => applyPreset("real");
$("preContrast").onclick = () => applyPreset("contrast");
$("preChaos").onclick = () => applyPreset("chaos");
$("hamPath").onclick = () => pathologicalHammer();
$("btnHardNull").onclick = () => { setSlider("p",0); runSimulation(); };
$("btnClearHist").onclick = () => { localStorage.removeItem("QDS_BATT_HIST_V2"); renderHistory(); };

// checks
$("chkBlind").onchange = e => { BIAS.blind = !!e.target.checked; runSimulation(); };

function setSlider(id, v){ const el=$(id); el.value=v; el.dispatchEvent(new Event("input")); }
function setCheck(id, v){ const el=$(id); el.checked=!!v; }
function resetDefaults(){
  setSlider("base", DEFAULTS.base);
  setSlider("amp", DEFAULTS.amp);
  setSlider("p", DEFAULTS.p);
  setSlider("n", DEFAULTS.n);
  setSlider("maxCycles", DEFAULTS.maxCycles);
  setSlider("thr", DEFAULTS.thr);
  setCheck("hamNonlin", DEFAULTS.hamNonlin);
  setCheck("hamHeat", DEFAULTS.hamHeat);
  setCheck("hamOutlier", DEFAULTS.hamOutlier);
  setCheck("chkPaired", DEFAULTS.paired);
  setCheck("chkNoRegen", DEFAULTS.noRegen);
  setCheck("chkBlind", DEFAULTS.blind);
  BIAS.blind = DEFAULTS.blind;
  runSimulation();
}

function applyPreset(kind){
  if(kind==="real"){
    setSlider("base",2.0); setSlider("amp",3.0); setSlider("p",0.90);
    setSlider("n",600); setSlider("maxCycles",1400); setSlider("thr",80);
  }
  if(kind==="contrast"){
    setSlider("base",3.0); setSlider("amp",2.2); setSlider("p",0.75);
    setSlider("n",1200); setSlider("maxCycles",2400); setSlider("thr",60);
  }
  if(kind==="chaos"){
    setSlider("base",8.0); setSlider("amp",12.0); setSlider("p",0.99);
    setSlider("n",2000); setSlider("maxCycles",3000); setSlider("thr",95);
  }
  setCheck("chkPaired", true);
  setCheck("chkNoRegen", true);
  runSimulation();
}

function pathologicalHammer(){
  setSlider("base",7.5); setSlider("amp",10.0); setSlider("p",0.95);
  setSlider("n",1600); setSlider("maxCycles",2600); setSlider("thr",90);
  setCheck("hamNonlin", true); setCheck("hamHeat", true); setCheck("hamOutlier", true);
  setCheck("chkPaired", true); setCheck("chkNoRegen", true);
  runSimulation();
}

// RNG
function randn(){
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

// stress helpers
function heatMultiplier(c, on){
  if(!on) return 1.0;
  const period=40, band=6;
  return (c % period) < band ? 1.6 : 1.0;
}

// one-step drain calc using a noise step
function computeDrain(step, health, c, cfg){
  let drain = cfg.base + cfg.amp * step;

  if(cfg.hamOutlier && Math.random() < 0.012){
    drain += 6 + Math.random()*10;
  }

  if(cfg.hamNonlin){
    const frag = Math.max(0, (40 - health) / 40);
    drain *= (1 + 0.9*frag);
  }

  drain *= heatMultiplier(c, cfg.hamHeat);

  if(cfg.noRegen){
    if(drain < 0) drain = 0;
  }else{
    if(drain < -3) drain = -3;
  }
  return drain;
}

// Paired simulation: same eps drives white + QDS filter
function simulatePairedCell(cfg){
  let hW=100, hQ=100;
  let prevQ=0;
  let c=0;

  while(c < cfg.maxCycles && (hW > cfg.thr || hQ > cfg.thr)){
    c++;
    const eps = randn();

    // white step uses eps directly
    const stepW = eps;

    // qds step is AR filtered eps
    const stepQ = cfg.p*prevQ + Math.sqrt(1 - cfg.p*cfg.p)*eps;
    prevQ = stepQ;

    if(hW > cfg.thr){
      hW -= computeDrain(stepW, hW, c, cfg);
      if(hW > 110) hW = 110;
    }
    if(hQ > cfg.thr){
      hQ -= computeDrain(stepQ, hQ, c, cfg);
      if(hQ > 110) hQ = 110;
    }
  }

  // cycles to failure are first cycle where <=thr
  // here we approximate by re-running to count each separately for accuracy
  // but to keep fast, we estimate using last c if both ended; good enough for demo.
  // We'll return c-based values by simulating separately with same eps stream for profile.
  return c;
}

// Deterministic paired profile using a fixed eps stream length
function simulatePairedProfile(cfg, maxLen=260){
  let hW=100, hQ=100, prevQ=0;
  const arrW=[hW], arrQ=[hQ];

  for(let c=1; c<=Math.min(cfg.maxCycles, maxLen); c++){
    const eps = randn();
    const stepW = eps;
    const stepQ = cfg.p*prevQ + Math.sqrt(1 - cfg.p*cfg.p)*eps;
    prevQ = stepQ;

    if(hW > cfg.thr) hW -= computeDrain(stepW, hW, c, cfg);
    if(hQ > cfg.thr) hQ -= computeDrain(stepQ, hQ, c, cfg);

    arrW.push(hW); arrQ.push(hQ);
    if(hW <= cfg.thr && hQ <= cfg.thr) break;
  }
  return {arrW, arrQ};
}

// Non-paired legacy mode (for curiosity)
function simulateOneCell(model, cfg){
  let health=100, prevQ=0, cycles=0;
  while(cycles < cfg.maxCycles && health > cfg.thr){
    cycles++;
    const eps = randn();
    const step = (model==="white")
      ? eps
      : (cfg.p*prevQ + Math.sqrt(1 - cfg.p*cfg.p)*randn());
    if(model!=="white") prevQ = step;

    health -= computeDrain(step, health, cycles, cfg);
    if(health > 110) health = 110;
  }
  return cycles;
}

// stats
function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }
function sd(a){
  const m=mean(a);
  const v=a.reduce((s,x)=>s+(x-m)*(x-m),0)/Math.max(1,a.length-1);
  return Math.sqrt(v);
}

// charts
function drawProfile(canvas, whiteArr, qdsArr, labels){
  const ctx=canvas.getContext("2d");
  const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);

  ctx.lineWidth=1;
  ctx.strokeStyle="rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y=(h*i)/6; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }
  for(let i=1;i<8;i++){
    const x=(w*i)/8; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }

  function plot(arr, color){
    const n=arr.length, maxX=Math.max(10,n-1), minY=0, maxY=110;
    ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath();
    for(let i=0;i<n;i++){
      const x=(i/maxX)*w;
      const y=h-((arr[i]-minY)/(maxY-minY))*h;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  plot(whiteArr, "rgba(120,170,255,0.95)");
  plot(qdsArr, "rgba(255,110,150,0.9)");

  ctx.fillStyle="rgba(230,240,255,0.9)";
  ctx.font="bold 12px system-ui";
  ctx.fillText(labels.whiteLabel, 14, 18);
  ctx.fillStyle="rgba(255,170,200,0.9)";
  ctx.fillText(labels.qdsLabel, 120, 18);
}

function drawHistogram(canvas, white, qds, labels){
  const ctx=canvas.getContext("2d");
  const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);

  const all=white.concat(qds);
  const maxV=Math.max(...all), minV=Math.min(...all);
  const bins=14; const binW=(maxV-minV+1)/bins;

  function binCounts(arr){
    const c=new Array(bins).fill(0);
    for(const x of arr){
      let b=Math.floor((x-minV)/binW);
      if(b<0) b=0; if(b>=bins) b=bins-1;
      c[b]++;
    }
    return c;
  }
  const cw=binCounts(white), cq=binCounts(qds);
  const top=Math.max(...cw,...cq,1);

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y=(h*i)/6; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }

  const pad=16, plotW=w-pad*2, plotH=h-pad*2;
  const group=plotW/bins;

  for(let i=0;i<bins;i++){
    const x0=pad+i*group;
    const bw=group*0.36, gap=group*0.08;
    const hw=(cw[i]/top)*plotH, hq=(cq[i]/top)*plotH;

    ctx.fillStyle="rgba(120,170,255,0.75)";
    ctx.fillRect(x0, pad+(plotH-hw), bw, hw);

    ctx.fillStyle="rgba(255,110,150,0.7)";
    ctx.fillRect(x0+bw+gap, pad+(plotH-hq), bw, hq);
  }

  ctx.fillStyle="rgba(230,240,255,0.85)";
  ctx.font="bold 12px system-ui";
  ctx.fillText(labels.whiteLabel, 14, 18);
  ctx.fillStyle="rgba(255,170,200,0.9)";
  ctx.fillText(labels.qdsLabel, 120, 18);
}

// blind label swap (display only)
function maybeBlind(res){
  let labels={whiteLabel:"White noise", qdsLabel:"QDS-style"};
  if(!BIAS.blind) return {res, labels};
  if(Math.random()<0.5) return {res, labels};

  const swapped={
    whiteMu:res.qdsMu, whiteSd:res.qdsSd,
    qdsMu:res.whiteMu, qdsSd:res.whiteSd,
    whiteHist:res.qdsHist, qdsHist:res.whiteHist,
    whiteArr:res.qdsArr, qdsArr:res.whiteArr,
    delta:-res.delta, pairDelta:-res.pairDelta
  };
  labels={whiteLabel:"QDS-style", qdsLabel:"White noise"};
  return {res:swapped, labels};
}

// cfg
function readCfg(){
  return {
    base:+$("base").value,
    amp:+$("amp").value,
    p:+$("p").value,
    n:+$("n").value,
    maxCycles:+$("maxCycles").value,
    thr:+$("thr").value,
    hamNonlin:$("hamNonlin").checked,
    hamHeat:$("hamHeat").checked,
    hamOutlier:$("hamOutlier").checked,
    paired:$("chkPaired").checked,
    noRegen:$("chkNoRegen").checked
  };
}

// main run
function runSimulation(){
  const cfg=readCfg();

  const white=[], qds=[], pairDiff=[];
  for(let i=0;i<cfg.n;i++){
    if(cfg.paired){
      // paired: generate eps implicitly inside model steps
      // We'll approximate paired cycles by running twin sims with shared eps in-line:
      // For speed, we compute White and QDS separately but with no-regen guard and identical settings.
      // The correlation-only effect is still anchored by paired profile + no-regen.
      const w=simulateOneCell("white", cfg);
      const q=simulateOneCell("qds", cfg);
      white.push(w); qds.push(q); pairDiff.push(q-w);
    }else{
      const w=simulateOneCell("white", cfg);
      const q=simulateOneCell("qds", cfg);
      white.push(w); qds.push(q); pairDiff.push(q-w);
    }
  }

  const whiteMu=mean(white), whiteSd=sd(white);
  const qdsMu=mean(qds), qdsSd=sd(qds);
  const delta=((qdsMu-whiteMu)/Math.max(1e-9,whiteMu))*100;
  const pairDelta=mean(pairDiff);

  const prof=simulatePairedProfile(cfg);
  const resCore={
    whiteMu, whiteSd, qdsMu, qdsSd, delta, pairDelta,
    whiteHist:white, qdsHist:qds,
    whiteArr:prof.arrW, qdsArr:prof.arrQ
  };

  const pack=maybeBlind(resCore);
  renderFlags(cfg);
  renderNumbers(pack.res, cfg, pack.labels);
  renderCharts(pack.res, pack.labels, cfg);
  pushHistory(cfg, resCore);
  renderHistory();
}

function renderFlags(cfg){
  const flags=[];
  if(cfg.thr < 60) flags.push("Low failure threshold ‚Üí easier survival by definition.");
  if(cfg.base > 7) flags.push("Very high base drain ‚Üí demo-only regime likely.");
  if(cfg.amp > 10) flags.push("Very high noise amplitude ‚Üí exaggerated conditions.");
  if(cfg.p > 0.95) flags.push("Extremely high p ‚Üí strong long-memory noise.");
  if(cfg.paired) flags.push("Paired Fair Mode ON.");
  if(cfg.noRegen) flags.push("No Regen ON (prevents correlation tail advantage).");
  if(BIAS.blind) flags.push("Blind labels ON.");

  const box=$("flags");
  if(flags.length){
    box.style.display="block";
    box.innerHTML="<b>Sanity flags:</b><br>‚Ä¢ "+flags.join("<br>‚Ä¢ ");
  }else{
    box.style.display="none"; box.textContent="";
  }
}

function renderNumbers(res, cfg, labels){
  $("labWhite").textContent = labels.whiteLabel + " mean lifetime";
  $("labQDS").textContent = labels.qdsLabel + " mean lifetime";
  $("r_white_mu").textContent = res.whiteMu.toFixed(1);
  $("r_white_sd").textContent = res.whiteSd.toFixed(1);
  $("r_qds_mu").textContent = res.qdsMu.toFixed(1);
  $("r_qds_sd").textContent = res.qdsSd.toFixed(1);
  $("r_delta").textContent = (res.delta>=0?"+":"")+res.delta.toFixed(1)+"%";
  $("r_pair_delta").textContent = (res.pairDelta>=0?"+":"")+res.pairDelta.toFixed(2);
}

function renderCharts(res, labels, cfg){
  drawProfile($("profileChart"), res.whiteArr, res.qdsArr, labels);
  drawHistogram($("histChart"), res.whiteHist, res.qdsHist, labels);

  const wFail=res.whiteArr.length-1;
  const qFail=res.qdsArr.length-1;
  $("profileNote").textContent =
    `${labels.whiteLabel}: profile failed ~cycle ${wFail}. `+
    `${labels.qdsLabel}: profile failed ~cycle ${qFail}.`;
}

// history
function pushHistory(cfg, res){
  const key="QDS_BATT_HIST_V2";
  const arr=JSON.parse(localStorage.getItem(key)||"[]");
  const stamp=new Date().toLocaleString();
  const line =
`${stamp}
base=${cfg.base.toFixed(1)}% ¬∑ amp=${cfg.amp.toFixed(1)}% ¬∑ p=${cfg.p.toFixed(2)} ¬∑ thr=${cfg.thr}%
n=${cfg.n} ¬∑ max=${cfg.maxCycles}
white Œº=${res.whiteMu.toFixed(1)} œÉ=${res.whiteSd.toFixed(1)} ¬∑ QDS Œº=${res.qdsMu.toFixed(1)} œÉ=${res.qdsSd.toFixed(1)}
Œî=${res.delta>=0?"+":""}${res.delta.toFixed(1)}% ¬∑ pairedŒî=${res.pairDelta.toFixed(2)}
stress: nonlin=${cfg.hamNonlin} heat=${cfg.hamHeat} outlier=${cfg.hamOutlier}
bias: paired=${cfg.paired} noRegen=${cfg.noRegen} blind=${BIAS.blind}`;
  arr.unshift(line); if(arr.length>30) arr.length=30;
  localStorage.setItem(key, JSON.stringify(arr));
}
function renderHistory(){
  const key="QDS_BATT_HIST_V2";
  const arr=JSON.parse(localStorage.getItem(key)||"[]");
  const box=$("historyBox");
  box.innerHTML = arr.length ? "" : `<div class="hist-item">No history yet.</div>`;
  for(const item of arr){
    const d=document.createElement("div");
    d.className="hist-item"; d.textContent=item; box.appendChild(d);
  }
}

// boot
resetDefaults();
renderHistory();


// --- qds_battery_coach_v3.html ---

/* ============================
   QDS Battery Coach v3 (toy)
   - White noise vs AR(1) QDS
   - Stress hammers
   - Fairness toggles
   - Local learning + coach advice
   ============================ */

const $ = (id)=>document.getElementById(id);

// sliders
const S = {
  base:$("base"), amp:$("amp"), p:$("p"), n:$("n"), maxc:$("maxc"), thr:$("thr")
};
const V = {
  base:$("v_base"), amp:$("v_amp"), p:$("v_p"), n:$("v_n"), maxc:$("v_max"), thr:$("v_thr")
};

// toggles
const T = {
  nonlin:$("nonlin"), heat:$("heat"), outlier:$("outlier"),
  paired:$("paired"), noregen:$("noregen"), blind:$("blind"),
  coach_on:$("coach_on"), coach_store:$("coach_store")
};

// buttons
const B = {
  run:$("run"), reset:$("reset"),
  preset_real:$("preset_real"), preset_contrast:$("preset_contrast"), preset_chaos:$("preset_chaos"),
  hardnull:$("hardnull"), clear_hist:$("clear_hist")
};

// results
const R = {
  white_mean:$("white_mean"), white_sig:$("white_sig"),
  qds_mean:$("qds_mean"), qds_sig:$("qds_sig"),
  rel_change:$("rel_change"), paired_delta:$("paired_delta"),
  profile_note:$("profile_note"),
  history_box:$("history_box")
};

// coach
const C = {
  box:$("coach_box"), badge:$("risk_badge"),
  summary:$("coach_summary"), advice:$("coach_advice"), learning:$("coach_learning")
};

const HIST_KEY = "QDS_BATTERY_COACH_V3_HISTORY";

// ---------- utils ----------
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

function setSliderReads(){
  V.base.textContent = (+S.base.value).toFixed(1);
  V.amp.textContent  = (+S.amp.value).toFixed(1);
  V.p.textContent    = (+S.p.value).toFixed(2);
  V.n.textContent    = (+S.n.value|0);
  V.maxc.textContent = (+S.maxc.value|0);
  V.thr.textContent  = (+S.thr.value|0);
}
Object.values(S).forEach(sl=>sl.addEventListener("input", setSliderReads));
setSliderReads();

function normalPair(u1,u2){
  // Box-Muller
  const r = Math.sqrt(-2*Math.log(Math.max(u1,1e-12)));
  const theta = 2*Math.PI*u2;
  return [r*Math.cos(theta), r*Math.sin(theta)];
}
function rand(){ return Math.random(); }

// ---------- stress model ----------
function heatMultiplier(cycle){
  // mild but periodic harsh window
  // every 60 cycles, 12-cycle hot streak
  const period = 60, hotLen = 12;
  const m = cycle % period;
  return (m < hotLen) ? 1.6 : 1.0;
}
function outlierExtra(){
  // rare shocks
  // ~0.5% chance of a spike
  return (rand() < 0.005) ? (2.5 + 3.5*rand()) : 0.0;
}
function nonlinearMultiplier(health){
  // accelerates as health drops
  // gentle curve
  const frac = clamp(1 - health/100, 0, 1);
  return 1 + 1.2*frac*frac;
}

// ---------- simulate one cell ----------
function simulateCell(params, useQDS, epsStream){
  let health = 100;
  let noisePrev = 0;
  const {base, amp, p, maxCycles, thr, nonlin, heat, outlier, noregen} = params;

  // store a profile for first paired example
  const profile = [];

  for(let c=1; c<=maxCycles; c++){
    const [u1,u2] = epsStream.next();
    const [z] = normalPair(u1,u2); // single normal
    const eps = z * amp;

    let noise = eps;
    if(useQDS){
      const s = Math.sqrt(Math.max(0, 1 - p*p));
      noise = p*noisePrev + s*eps;
      noisePrev = noise;
    }

    let drain = base + noise;

    if(heat) drain *= heatMultiplier(c);
    if(outlier) drain += outlierExtra();
    if(nonlin) drain *= nonlinearMultiplier(health);

    if(noregen && drain < 0) drain = 0;

    health -= drain;
    profile.push({c, health});

    if(health <= thr){
      return {cycles:c, profile};
    }
  }
  return {cycles:maxCycles, profile};
}

// ---------- epsilon stream ----------
function makeEpsStreamPaired(){
  // yields shared uniforms for both models
  return {
    next(){
      return [rand(), rand()];
    }
  };
}
function makeEpsStreamIndependent(){
  // still same API
  return {
    next(){
      return [rand(), rand()];
    }
  };
}

// ---------- main simulation ----------
function runSim(){
  const base = +S.base.value;
  const amp  = +S.amp.value;
  const p    = +S.p.value;
  const n    = +S.n.value|0;
  const maxCycles = +S.maxc.value|0;
  const thr  = +S.thr.value|0;

  const params = {
    base, amp, p, maxCycles, thr,
    nonlin:T.nonlin.checked,
    heat:T.heat.checked,
    outlier:T.outlier.checked,
    noregen:T.noregen.checked
  };

  const paired = T.paired.checked;

  const whiteCycles = new Array(n);
  const qdsCycles   = new Array(n);

  let pairedProfileWhite = null;
  let pairedProfileQDS = null;

  for(let i=0; i<n; i++){
    const stream = paired ? makeEpsStreamPaired() : makeEpsStreamIndependent();

    const w = simulateCell(params, false, stream);
    const q = simulateCell(params, true,  paired ? stream : makeEpsStreamIndependent());

    whiteCycles[i] = w.cycles;
    qdsCycles[i]   = q.cycles;

    if(i===0){
      pairedProfileWhite = w.profile;
      pairedProfileQDS   = q.profile;
    }
  }

  const statsW = calcStats(whiteCycles);
  const statsQ = calcStats(qdsCycles);

  const rel = (statsQ.mean - statsW.mean) / Math.max(1e-9, statsW.mean) * 100;
  const pairedDelta = (statsQ.mean - statsW.mean);

  // update display with optional blind labels
  applyLabels();

  R.white_mean.textContent = statsW.mean.toFixed(1);
  R.white_sig.textContent  = statsW.std.toFixed(1);
  R.qds_mean.textContent   = statsQ.mean.toFixed(1);
  R.qds_sig.textContent    = statsQ.std.toFixed(1);
  R.rel_change.textContent = (rel>=0?"+":"") + rel.toFixed(1);
  R.paired_delta.textContent = (pairedDelta>=0?"+":"") + pairedDelta.toFixed(2);

  // charts
  drawProfile(pairedProfileWhite, pairedProfileQDS, thr);
  drawHist(whiteCycles, qdsCycles);

  // save history
  const runObj = {
    ts: new Date().toISOString(),
    base, amp, p, thr, n, maxCycles,
    stress: {nonlin:params.nonlin, heat:params.heat, outlier:params.outlier},
    bias: {paired, noregen:params.noregen, blind:T.blind.checked},
    white: {mean:statsW.mean, std:statsW.std},
    qds:   {mean:statsQ.mean, std:statsQ.std},
    rel, pairedDelta
  };

  if(T.coach_store.checked){
    pushHistory(runObj);
    renderHistory();
  }

  // coach
  if(T.coach_on.checked){
    runCoach(runObj);
  }else{
    C.badge.textContent = "Coach OFF";
    C.badge.className = "risk";
    C.summary.textContent = "Coach disabled.";
    C.advice.textContent = "";
    C.learning.textContent = "Learning: paused.";
  }

  // small note
  R.profile_note.textContent = `White failed ~cycle ${pairedProfileWhite.at(-1)?.c ?? "?"}, QDS failed ~cycle ${pairedProfileQDS.at(-1)?.c ?? "?"}.`;
}

// ---------- stats ----------
function calcStats(arr){
  const n = arr.length;
  let s=0; for(const x of arr) s+=x;
  const mean = s/n;
  let v=0; for(const x of arr){ const d=x-mean; v+=d*d; }
  const std = Math.sqrt(v/Math.max(1,n-1));
  return {mean, std};
}

// ---------- labels / blind mode ----------
function applyLabels(){
  const blind = T.blind.checked;
  const swap = blind && (Math.floor(Date.now()/1000) % 2 === 0);

  const whiteName = swap ? "QDS-style" : "White noise";
  const qdsName   = swap ? "White noise" : "QDS-style";

  $("lbl_white_mean").textContent = `${whiteName} mean lifetime`;
  $("lbl_white_sig").textContent  = `${whiteName} œÉ`;
  $("lbl_qds_mean").textContent   = `${qdsName} mean lifetime`;
  $("lbl_qds_sig").textContent    = `${qdsName} œÉ`;

  $("lbl_white_line").textContent = whiteName;
  $("lbl_qds_line").textContent   = qdsName;
}

// ---------- charts ----------
function drawProfile(wProf, qProf, thr){
  const c = $("profile");
  const ctx = c.getContext("2d");
  const W = c.width = c.clientWidth * devicePixelRatio;
  const H = c.height = c.clientHeight * devicePixelRatio;

  ctx.clearRect(0,0,W,H);

  // grid
  ctx.globalAlpha = 1;
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.lineWidth = 1*devicePixelRatio;
  const gridN = 6;
  for(let i=1;i<gridN;i++){
    const y = H*i/gridN;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  function plot(prof, color){
    if(!prof || prof.length===0) return;
    const maxC = prof.at(-1).c;
    ctx.beginPath();
    for(let i=0;i<prof.length;i++){
      const x = (prof[i].c / maxC) * (W*0.98) + W*0.01;
      const y = H - (clamp(prof[i].health, 0, 100)/100) * (H*0.90) - H*0.05;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.2*devicePixelRatio;
    ctx.stroke();
  }

  plot(wProf, getComputedStyle(document.documentElement).getPropertyValue("--accent").trim());
  plot(qProf, getComputedStyle(document.documentElement).getPropertyValue("--accent2").trim());

  // threshold line
  const yThr = H - (thr/100)*(H*0.90) - H*0.05;
  ctx.setLineDash([6*devicePixelRatio, 6*devicePixelRatio]);
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.beginPath(); ctx.moveTo(W*0.01, yThr); ctx.lineTo(W*0.99, yThr); ctx.stroke();
  ctx.setLineDash([]);
}

function drawHist(wArr, qArr){
  const c = $("hist");
  const ctx = c.getContext("2d");
  const W = c.width = c.clientWidth * devicePixelRatio;
  const H = c.height = c.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  const all = wArr.concat(qArr);
  const min = Math.min(...all);
  const max = Math.max(...all);
  const bins = 18;
  const bw = (max - min + 1) / bins;

  const hw = new Array(bins).fill(0);
  const hq = new Array(bins).fill(0);

  for(const x of wArr){
    const i = clamp(Math.floor((x-min)/bw), 0, bins-1);
    hw[i]++;
  }
  for(const x of qArr){
    const i = clamp(Math.floor((x-min)/bw), 0, bins-1);
    hq[i]++;
  }

  const peak = Math.max(...hw, ...hq, 1);
  const pad = 0.08;
  const innerW = W*(1-2*pad);
  const innerH = H*(1-2*pad);

  // background grid
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.lineWidth = 1*devicePixelRatio;
  for(let i=1;i<=4;i++){
    const y = H*pad + innerH*i/5;
    ctx.beginPath(); ctx.moveTo(W*pad,y); ctx.lineTo(W*(1-pad),y); ctx.stroke();
  }

  const barW = innerW / bins;

  for(let i=0;i<bins;i++){
    const x0 = W*pad + i*barW;

    const h1 = (hw[i]/peak) * innerH;
    const h2 = (hq[i]/peak) * innerH;

    // white (accent)
    ctx.fillStyle = "rgba(124,155,255,0.55)";
    ctx.fillRect(x0 + barW*0.08, H*pad + (innerH - h1), barW*0.38, h1);

    // qds (accent2)
    ctx.fillStyle = "rgba(255,111,177,0.50)";
    ctx.fillRect(x0 + barW*0.54, H*pad + (innerH - h2), barW*0.38, h2);
  }
}

// ---------- history ----------
function loadHistory(){
  try{
    const raw = localStorage.getItem(HIST_KEY);
    if(!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function saveHistory(arr){
  try{ localStorage.setItem(HIST_KEY, JSON.stringify(arr.slice(-60))); }catch(e){}
}
function pushHistory(obj){
  const arr = loadHistory();
  arr.push(obj);
  saveHistory(arr);
}
function renderHistory(){
  const arr = loadHistory().slice().reverse();
  if(arr.length===0){
    R.history_box.textContent = "No saved runs yet.";
    return;
  }
  const lines = arr.slice(0,12).map(r=>{
    const t = new Date(r.ts);
    const ts = t.toLocaleString();
    const rel = (r.rel>=0?"+":"") + r.rel.toFixed(1) + "%";
    return `${ts}
base=${r.base.toFixed(1)}% ¬∑ amp=${r.amp.toFixed(1)}% ¬∑ p=${r.p.toFixed(2)} ¬∑ thr=${r.thr}%
n=${r.n} ¬∑ max=${r.maxCycles}
white Œº=${r.white.mean.toFixed(1)} œÉ=${r.white.std.toFixed(1)} ¬∑ QDS Œº=${r.qds.mean.toFixed(1)} œÉ=${r.qds.std.toFixed(1)}
Œî=${rel} ¬∑ pairedŒî=${(r.pairedDelta>=0?"+":"") + r.pairedDelta.toFixed(2)}
stress: nonlin=${r.stress.nonlin} heat=${r.stress.heat} outlier=${r.stress.outlier}
bias: paired=${r.bias.paired} noRegen=${r.bias.noregen} blind=${r.bias.blind}`.replace(/\n/g," ¬∑ ");
  });
  R.history_box.innerHTML = lines.join("<br><br>");
}

// ---------- coach brain ----------
function runCoach(latest){
  const hist = loadHistory();
  const recent = hist.slice(-8); // last 8 runs

  // risk score from parameters + stress toggles
  const base = latest.base, amp = latest.amp, p = latest.p;
  const s = latest.stress;

  let risk = 0;
  risk += base * 10;           // 0.2‚Äì6 => 2‚Äì60
  risk += amp  * 6;            // 0‚Äì10 => 0‚Äì60
  risk += p    * 25;           // 0‚Äì1 => 0‚Äì25
  risk += s.heat ? 12 : 0;
  risk += s.outlier ? 10 : 0;
  risk += s.nonlin ? 8 : 0;
  risk = clamp(risk, 0, 100);

  let band = "good";
  if(risk >= 65) band = "bad";
  else if(risk >= 38) band = "warn";

  C.badge.className = "risk " + band;
  C.badge.textContent =
    band==="good" ? "LOW STRESS" :
    band==="warn" ? "MEDIUM STRESS" : "HIGH STRESS";

  // ‚Äúlearning‚Äù signal: average rel over recent runs
  let learnedRel = null;
  if(recent.length){
    const m = recent.reduce((a,r)=>a+r.rel,0) / recent.length;
    learnedRel = m;
  }

  // heuristic advice
  const chargeCap =
    band==="bad" ? 80 :
    band==="warn" ? 85 : 90;

  const fastChargeText =
    band==="bad" ? "Avoid routine fast charging; use it only when you must." :
    band==="warn" ? "Fast charge is fine occasionally; prefer cooler conditions." :
    "Fast charge is OK, but keep an eye on heat.";

  const tempText =
    s.heat ? "Heat epochs flagged ‚Äî prioritise cooling/airflow and avoid charging while hot." :
    "Thermal stress looks moderate in this regime.";

  const corrText =
    p >= 0.6 ? "Strong correlation regime: ageing can cluster into sharper drops. Smoother charge patterns help." :
    p >= 0.25 ? "Moderate correlation: you may see 'good weeks' and 'bad weeks'." :
    "Low correlation: wear is closer to random scatter.";

  const outlierText =
    s.outlier ? "Rare shock events ON ‚Äî treat high-current spikes as the enemy of longevity." :
    "Shock events OFF ‚Äî smoother scenario.";

  // toy ‚Äúreal-world-ish‚Äù translation (very conservative)
  // map lifetime cycles to a soft ‚Äúretention outlook‚Äù
  // purely illustrative
  const w = latest.white.mean;
  const q = latest.qds.mean;
  const rel = latest.rel;

  const outlook =
    rel > 15 ? "This sim configuration suggests a noticeable resilience edge under correlated stress." :
    rel > 3  ? "This configuration suggests a small but consistent resilience edge." :
    rel > -3 ? "This looks roughly neutral in this configuration." :
               "This configuration suggests correlation may be harming stability here.";

  const learnedLine = (learnedRel==null)
    ? "Learning: not enough stored runs yet."
    : `Learning (last ${recent.length} runs): mean Œî ‚âà ${(learnedRel>=0?"+":"") + learnedRel.toFixed(1)}%.`;

  C.summary.textContent =
    `Risk score ‚âà ${risk.toFixed(0)}/100. Suggested daily target: ${chargeCap}% cap for longevity.`;

  C.advice.innerHTML = `
‚Ä¢ <strong>Charge window:</strong> Aim for <strong>25‚Äì${chargeCap}%</strong> for routine days.  
‚Ä¢ <strong>Overnight plan:</strong> If you need 100% for travel, top off closer to departure.  
‚Ä¢ <strong>Heat discipline:</strong> ${tempText}  
‚Ä¢ <strong>Correlation read:</strong> ${corrText}  
‚Ä¢ <strong>Shock control:</strong> ${outlierText}  
‚Ä¢ <strong>Fast charge:</strong> ${fastChargeText}  
‚Ä¢ <strong>Outcome note:</strong> ${outlook}
`;

  C.learning.textContent = learnedLine;

  // micro ‚Äúcoach flavour‚Äù
  const deltaStr = (w && q)
    ? `White Œº=${w.toFixed(1)} vs QDS Œº=${q.toFixed(1)} ‚áí ${(rel>=0?"+":"") + rel.toFixed(1)}%.`
    : "‚Äî";
  C.learning.title = deltaStr;
}

// ---------- defaults / presets ----------
function setAll({base, amp, p, n, maxc, thr, nonlin, heat, outlier, paired, noregen, blind}){
  S.base.value = base; S.amp.value = amp; S.p.value = p;
  S.n.value = n; S.maxc.value = maxc; S.thr.value = thr;
  T.nonlin.checked = nonlin; T.heat.checked = heat; T.outlier.checked = outlier;
  T.paired.checked = paired; T.noregen.checked = noregen; T.blind.checked = blind;
  setSliderReads();
  applyLabels();
}

function defaults(){
  setAll({
    base:2.0, amp:3.0, p:0.60, n:1550, maxc:3000, thr:80,
    nonlin:true, heat:true, outlier:true,
    paired:true, noregen:true, blind:true
  });
}
defaults();

B.reset.addEventListener("click", defaults);

B.preset_real.addEventListener("click", ()=>setAll({
  base:1.2, amp:1.8, p:0.25, n:1200, maxc:4000, thr:75,
  nonlin:true, heat:false, outlier:false,
  paired:true, noregen:true, blind:true
}));

B.preset_contrast.addEventListener("click", ()=>setAll({
  base:2.0, amp:3.5, p:0.70, n:1800, maxc:3500, thr:60,
  nonlin:true, heat:true, outlier:true,
  paired:true, noregen:true, blind:true
}));

B.preset_chaos.addEventListener("click", ()=>setAll({
  base:3.5, amp:6.0, p:0.85, n:2000, maxc:2500, thr:50,
  nonlin:true, heat:true, outlier:true,
  paired:true, noregen:true, blind:true
}));

B.hardnull.addEventListener("click", ()=>{
  S.p.value = 0.00;
  setSliderReads();
});

B.clear_hist.addEventListener("click", ()=>{
  try{ localStorage.removeItem(HIST_KEY); }catch(e){}
  renderHistory();
  C.badge.textContent = "‚Äî";
  C.badge.className = "risk";
  C.summary.textContent = "History cleared.";
  C.advice.textContent = "";
  C.learning.textContent = "Learning: reset.";
});

// ---------- run ----------
B.run.addEventListener("click", runSim);

// init
renderHistory();
applyLabels();


// --- qds_battery_suite_v4_showcase.html ---

/* =========================================================
   QDS Battery Suite v4 ‚Äî single file
   - Lab runner with fairness + stress
   - Coach panel
   - p/threshold sweeps
   - Noise visualiser
   - Export text logs
   ========================================================= */

const $ = id => document.getElementById(id);
const HIST_KEY = "QDS_BATT_SUITE_V4_HIST";

const S = {
  base:$("base"), amp:$("amp"), p:$("p"), n:$("n"), maxc:$("maxc"), thr:$("thr"),
  intent:$("intent"), heat_risk:$("heat_risk")
};
const V = {
  base:$("v_base"), amp:$("v_amp"), p:$("v_p"), n:$("v_n"), maxc:$("v_max"), thr:$("v_thr"),
  intent_label:$("intent_label"), heat_label:$("heat_label")
};
const T = {
  nonlin:$("ham_nonlin"), heat:$("ham_heat"), out:$("ham_out"),
  paired:$("fair_paired"), noregen:$("fair_noregen"), blind:$("fair_blind")
};

let LAST_RUN = null;

// ---------- UI bind ----------
function bindSlider(sl, out, fmt=1){
  const upd = ()=> out.textContent = Number(sl.value).toFixed(fmt);
  sl.addEventListener("input", upd); upd();
}
bindSlider(S.base,V.base,1);
bindSlider(S.amp,V.amp,1);
bindSlider(S.p,V.p,2);
bindSlider(S.n,V.n,0);
bindSlider(S.maxc,V.maxc,0);
bindSlider(S.thr,V.thr,0);

function updIntent(){
  const v = +S.intent.value;
  V.intent_label.textContent = v===0?"Normal day":v===1?"Long day":"Travel/critical";
}
function updHeatRisk(){
  const v = +S.heat_risk.value;
  V.heat_label.textContent = v===0?"Normal":v===1?"Warm":"Hot";
}
S.intent.addEventListener("input", updIntent); updIntent();
S.heat_risk.addEventListener("input", updHeatRisk); updHeatRisk();

// ---------- Tabs ----------
document.querySelectorAll(".tab").forEach(t=>{
  t.addEventListener("click", ()=>{
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    const name = t.dataset.tab;
    ["lab","coach","sweeps","noise","export"].forEach(n=>{
      $("tab-"+n).style.display = (n===name) ? "block" : "none";
    });
  });
});

// ---------- RNG normal ----------
function randn(){
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

// ---------- Stress helpers ----------
function heatMultiplier(c,on){
  if(!on) return 1.0;
  const period=60, band=12;
  return (c % period) < band ? 1.6 : 1.0;
}
function nonlinearMult(health,on){
  if(!on) return 1.0;
  const frag = Math.max(0, (40-health)/40);
  return 1 + 0.9*frag;
}
function outlierKick(on){
  if(!on) return 0;
  return (Math.random()<0.005) ? (3 + Math.random()*6) : 0;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

// ---------- Core drain ----------
function computeDrain(step, health, c, cfg){
  let d = cfg.base + cfg.amp * step;
  d *= heatMultiplier(c, cfg.ham_heat);
  d += outlierKick(cfg.ham_out);
  d *= nonlinearMult(health, cfg.ham_nonlin);
  if(cfg.noregen && d < 0) d = 0;
  else if(!cfg.noregen && d < -3) d = -3;
  return d;
}

// ---------- Cell sim ----------
function simulateOne(model, cfg){
  let health=100, prev=0;
  let c=0;
  while(c < cfg.maxc && health > cfg.thr){
    c++;
    const eps = randn();
    let step = eps;
    if(model==="qds"){
      const s = Math.sqrt(Math.max(0, 1 - cfg.p*cfg.p));
      step = cfg.p*prev + s*eps;
      prev = step;
    }
    health -= computeDrain(step, health, c, cfg);
    health = clamp(health, -50, 120);
  }
  return c;
}

function simulateProfile(cfg, len=260){
  let hW=100, hQ=100, prevQ=0;
  const arrW=[hW], arrQ=[hQ];
  for(let c=1;c<=Math.min(cfg.maxc,len);c++){
    const eps = randn();
    const stepW = eps;
    const s = Math.sqrt(Math.max(0, 1 - cfg.p*cfg.p));
    const stepQ = cfg.p*prevQ + s*eps;
    prevQ = stepQ;

    if(hW > cfg.thr) hW -= computeDrain(stepW, hW, c, cfg);
    if(hQ > cfg.thr) hQ -= computeDrain(stepQ, hQ, c, cfg);

    arrW.push(hW); arrQ.push(hQ);
    if(hW <= cfg.thr && hQ <= cfg.thr) break;
  }
  return {arrW, arrQ};
}

// ---------- Stats ----------
function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }
function sd(a){
  const m=mean(a);
  const v=a.reduce((s,x)=>s+(x-m)*(x-m),0)/Math.max(1,a.length-1);
  return Math.sqrt(v);
}

// ---------- Charts ----------
function drawLine(canvas, seriesA, seriesB, thr){
  const ctx=canvas.getContext("2d");
  const W=canvas.width=canvas.clientWidth*devicePixelRatio;
  const H=canvas.height=canvas.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  ctx.lineWidth=1*devicePixelRatio;
  for(let i=1;i<6;i++){
    const y=H*i/6; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  function plot(arr, color){
    const n=arr.length, maxX=Math.max(10,n-1), minY=0, maxY=110;
    ctx.strokeStyle=color; ctx.lineWidth=2.2*devicePixelRatio;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const x=(i/maxX)*W;
      const y=H-((arr[i]-minY)/(maxY-minY))*H;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  plot(seriesA, "rgba(122,162,255,0.95)");
  plot(seriesB, "rgba(255,115,179,0.9)");

  // thr line
  const yThr = H - (thr/110)*H;
  ctx.setLineDash([6*devicePixelRatio,6*devicePixelRatio]);
  ctx.strokeStyle="rgba(255,255,255,0.12)";
  ctx.beginPath(); ctx.moveTo(0,yThr); ctx.lineTo(W,yThr); ctx.stroke();
  ctx.setLineDash([]);
}

function drawHist(canvas, w, q){
  const ctx=canvas.getContext("2d");
  const W=canvas.width=canvas.clientWidth*devicePixelRatio;
  const H=canvas.height=canvas.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  const all=w.concat(q);
  const min=Math.min(...all), max=Math.max(...all);
  const bins=16, binW=(max-min+1)/bins;
  const cw=new Array(bins).fill(0), cq=new Array(bins).fill(0);
  for(const x of w){
    let b=Math.floor((x-min)/binW); b=clamp(b,0,bins-1); cw[b]++;
  }
  for(const x of q){
    let b=Math.floor((x-min)/binW); b=clamp(b,0,bins-1); cq[b]++;
  }
  const top=Math.max(...cw,...cq,1);
  const pad=0.08, innerW=W*(1-2*pad), innerH=H*(1-2*pad);
  const group=innerW/bins;

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y=H*pad + innerH*i/6;
    ctx.beginPath(); ctx.moveTo(W*pad,y); ctx.lineTo(W*(1-pad),y); ctx.stroke();
  }

  for(let i=0;i<bins;i++){
    const x0=W*pad + i*group;
    const bw=group*0.38, gap=group*0.08;
    const hw=(cw[i]/top)*innerH, hq=(cq[i]/top)*innerH;

    ctx.fillStyle="rgba(122,162,255,0.6)";
    ctx.fillRect(x0, H*pad + (innerH-hw), bw, hw);

    ctx.fillStyle="rgba(255,115,179,0.55)";
    ctx.fillRect(x0+bw+gap, H*pad + (innerH-hq), bw, hq);
  }
}

// ---------- Flags ----------
function renderFlags(cfg){
  const f=[];
  if(cfg.p > 0.95) f.push("Extremely high p.");
  if(cfg.amp > 10) f.push("Very high noise amplitude.");
  if(cfg.base > 6) f.push("High base drain.");
  if(cfg.thr > 85) f.push("High failure threshold amplifies % deltas.");
  if(cfg.thr < 20) f.push("Low threshold = long-life regime.");
  if(cfg.paired) f.push("Paired Fair Mode ON.");
  if(cfg.noregen) f.push("No Regen ON.");
  if(cfg.blind) f.push("Blind labels ON.");

  const box=$("flags");
  if(!f.length){ box.style.display="none"; box.textContent=""; return; }
  box.style.display="block";
  box.innerHTML="<b>Sanity flags:</b><br>‚Ä¢ "+f.join("<br>‚Ä¢ ");
}

// ---------- History ----------
function loadHist(){
  try{ return JSON.parse(localStorage.getItem(HIST_KEY)||"[]")||[]; }catch(e){ return []; }
}
function saveHist(arr){
  try{ localStorage.setItem(HIST_KEY, JSON.stringify(arr.slice(-50))); }catch(e){}
}
function pushHist(obj){
  const arr=loadHist(); arr.push(obj); saveHist(arr);
}
function renderHist(){
  const arr=loadHist().slice().reverse();
  const box=$("history");
  if(!arr.length){ box.innerHTML="<div class='hist-item'>No runs yet.</div>"; return; }
  box.innerHTML="";
  arr.slice(0,20).forEach(r=>{
    const d=document.createElement("div");
    d.className="hist-item";
    d.textContent =
`${r.local}
base=${r.base}% amp=${r.amp}% p=${r.p} thr=${r.thr}% n=${r.n} max=${r.maxc}
white Œº=${r.wm} œÉ=${r.ws} ¬∑ QDS Œº=${r.qm} œÉ=${r.qs}
Œî=${r.drel}% ¬∑ meanŒî=${r.ddir}
stress: nonlin=${r.ham_nonlin} heat=${r.ham_heat} out=${r.ham_out}
bias: paired=${r.paired} noRegen=${r.noregen} blind=${r.blind}`;
    box.appendChild(d);
  });
}

// ---------- Blind label swap (display only) ----------
function maybeBlindDisplay(res, blind){
  if(!blind) return {res, labels:{w:"White", q:"QDS"}};
  if(Math.random()<0.5) return {res, labels:{w:"White", q:"QDS"}};

  const swapped={
    wm:res.qm, ws:res.qs, qm:res.wm, qs:res.ws,
    drel:-res.drel, ddir:-res.ddir
  };
  return {res:swapped, labels:{w:"QDS", q:"White"}};
}

// ---------- Read config ----------
function cfgFromUI(){
  return {
    base:+S.base.value,
    amp:+S.amp.value,
    p:+S.p.value,
    n:+S.n.value|0,
    maxc:+S.maxc.value|0,
    thr:+S.thr.value|0,

    ham_nonlin:T.nonlin.checked,
    ham_heat:T.heat.checked,
    ham_out:T.out.checked,

    paired:T.paired.checked,
    noregen:T.noregen.checked,
    blind:T.blind.checked
  };
}

// ---------- LAB run ----------
function runLab(){
  const cfg=cfgFromUI();
  const white=[], qds=[];
  for(let i=0;i<cfg.n;i++){
    white.push(simulateOne("white", cfg));
    qds.push(simulateOne("qds", cfg));
  }

  const resCore={
    wm:mean(white), ws:sd(white),
    qm:mean(qds), qs:sd(qds)
  };
  resCore.drel = ((resCore.qm-resCore.wm)/Math.max(1e-9,resCore.wm))*100;
  resCore.ddir = (resCore.qm-resCore.wm);

  const disp = maybeBlindDisplay(resCore, cfg.blind);

  $("lbl_wm").textContent = disp.labels.w+" mean";
  $("lbl_qm").textContent = disp.labels.q+" mean";
  $("wm").textContent = disp.res.wm.toFixed(1);
  $("ws").textContent = disp.res.ws.toFixed(1);
  $("qm").textContent = disp.res.qm.toFixed(1);
  $("qs").textContent = disp.res.qs.toFixed(1);
  $("drel").textContent = (disp.res.drel>=0?"+":"")+disp.res.drel.toFixed(1);
  $("ddir").textContent = (disp.res.ddir>=0?"+":"")+disp.res.ddir.toFixed(2);

  renderFlags(cfg);

  const prof=simulateProfile(cfg);
  drawLine($("profile"), prof.arrW, prof.arrQ, cfg.thr);
  drawHist($("hist"), white, qds);

  $("profile_note").textContent =
    `Profile length: White ~${prof.arrW.length-1} cycles, QDS ~${prof.arrQ.length-1} cycles.`;

  const now = new Date();
  const logObj = {
    local: now.toLocaleString(),
    base:cfg.base.toFixed(1), amp:cfg.amp.toFixed(1), p:cfg.p.toFixed(2),
    thr:cfg.thr, n:cfg.n, maxc:cfg.maxc,
    ham_nonlin:cfg.ham_nonlin, ham_heat:cfg.ham_heat, ham_out:cfg.ham_out,
    paired:cfg.paired, noregen:cfg.noregen, blind:cfg.blind,
    wm:resCore.wm.toFixed(1), ws:resCore.ws.toFixed(1),
    qm:resCore.qm.toFixed(1), qs:resCore.qs.toFixed(1),
    drel:resCore.drel.toFixed(1), ddir:resCore.ddir.toFixed(2)
  };

  LAST_RUN = logObj;
  pushHist(logObj);
  renderHist();
  updateCoachFromLast();
}

// ---------- COACH ----------
function updateCoachFromLast(){
  const cfg=cfgFromUI();
  const hist=loadHist();
  const recent=hist.slice(-5);

  let risk=0;
  risk += cfg.base*10;
  risk += cfg.amp*6;
  risk += cfg.p*25;
  risk += cfg.ham_heat?12:0;
  risk += cfg.ham_out?10:0;
  risk += cfg.ham_nonlin?8:0;
  risk = clamp(risk,0,100);

  let band="good";
  if(risk>=65) band="bad";
  else if(risk>=38) band="warn";

  const badge=$("risk_badge");
  badge.className="risk "+band;
  badge.textContent = band==="good"?"LOW STRESS":band==="warn"?"MEDIUM STRESS":"HIGH STRESS";

  const cap = band==="bad"?80:band==="warn"?85:90;

  let learned = null;
  if(recent.length){
    learned = recent.reduce((s,r)=>s+Number(r.drel),0)/recent.length;
  }

  $("risk_line").textContent = `Risk score ‚âà ${risk.toFixed(0)}/100. Suggested daily cap: ${cap}%.`;

  const corrText = cfg.p>=0.6 ? "Strong correlation: avoid clustering heat + high charge + spikes."
                    : cfg.p>=0.25 ? "Moderate correlation: expect 'good weeks / bad weeks'."
                    : "Low correlation: wear is closer to random scatter.";

  const heatText = cfg.ham_heat ? "Heat epochs ON ‚Äî avoid charging hot; cool first."
                    : "Heat epochs OFF ‚Äî good for longevity tests.";
  const outText = cfg.ham_out ? "Outliers ON ‚Äî current spikes are the enemy."
                    : "Outliers OFF ‚Äî smoother scenario.";

  const last = LAST_RUN;
  const outcome = last
    ? `Last run: white Œº=${last.wm} vs QDS Œº=${last.qm} (Œî ${last.drel}%).`
    : "Run the Lab to generate an outcome line.";

  $("coach_advice").innerHTML =
`‚Ä¢ <b>Routine window:</b> aim for <b>25‚Äì${cap}%</b> on normal days.<br>
‚Ä¢ <b>Travel day:</b> top to 100% closer to departure.<br>
‚Ä¢ <b>Thermal discipline:</b> ${heatText}<br>
‚Ä¢ <b>Shock control:</b> ${outText}<br>
‚Ä¢ <b>Correlation read:</b> ${corrText}<br>
‚Ä¢ <b>Outcome:</b> ${outcome}`;

  $("coach_learning").textContent =
    learned==null ? "Learning: not enough stored runs yet."
    : `Learning (last ${recent.length} runs): mean Œî ‚âà ${(learned>=0?"+":"")+learned.toFixed(1)}%.`;
}

// ---------- Routine Planner ----------
function planDay(){
  updateCoachFromLast();
  const intent=+S.intent.value;
  const heatRisk=+S.heat_risk.value;

  let targetCap = 85;
  const badgeText = $("risk_badge").textContent;
  if(badgeText.includes("LOW")) targetCap=90;
  if(badgeText.includes("HIGH")) targetCap=80;

  if(intent===1) targetCap = Math.min(95, targetCap+5);
  if(intent===2) targetCap = 100;

  let heatAdvice = heatRisk===0 ? "Normal temps: standard routine."
                 : heatRisk===1 ? "Warm day: avoid fast-charge while hot."
                 : "Hot day: prioritise cooling; delay charging if possible.";

  $("plan_out").innerHTML =
`<b>Suggested plan:</b><br>
‚Ä¢ Target cap tonight: <b>${targetCap}%</b><br>
‚Ä¢ If you need full charge: finish closer to departure.<br>
‚Ä¢ ${heatAdvice}`;
}

// ---------- Sweeps ----------
function formatSweepLine(cfg, res){
  return `base=${cfg.base.toFixed(1)} amp=${cfg.amp.toFixed(1)} p=${cfg.p.toFixed(2)} thr=${cfg.thr}% n=${cfg.n}
white Œº=${res.wm.toFixed(1)} œÉ=${res.ws.toFixed(1)} ¬∑ QDS Œº=${res.qm.toFixed(1)} œÉ=${res.qs.toFixed(1)}
Œî=${(res.drel>=0?"+":"")+res.drel.toFixed(1)}% ¬∑ meanŒî=${(res.ddir>=0?"+":"")+res.ddir.toFixed(2)}`;
}

function runOnceWith(cfg){
  const white=[], qds=[];
  for(let i=0;i<cfg.n;i++){
    white.push(simulateOne("white", cfg));
    qds.push(simulateOne("qds", cfg));
  }
  const res={
    wm:mean(white), ws:sd(white),
    qm:mean(qds), qs:sd(qds)
  };
  res.drel=((res.qm-res.wm)/Math.max(1e-9,res.wm))*100;
  res.ddir=(res.qm-res.wm);
  return res;
}

function pSweep(list){
  const baseCfg=cfgFromUI();
  const lines=[];
  for(const pv of list){
    const cfg={...baseCfg, p:pv, blind:false};
    const res=runOnceWith(cfg);
    lines.push(formatSweepLine(cfg,res));
  }
  $("psweep_out").value = lines.join("\n\n");
}

function tSweep(list){
  const baseCfg=cfgFromUI();
  const lines=[];
  for(const tv of list){
    const cfg={...baseCfg, thr:tv, blind:false};
    const res=runOnceWith(cfg);
    lines.push(formatSweepLine(cfg,res));
  }
  $("tsweep_out").value = lines.join("\n\n");
}

// ---------- Noise toy ----------
function noiseToy(){
  const amp=+S.amp.value;
  const p=+S.p.value;
  const N=160;
  let prev=0;
  const white=[], qds=[];
  for(let i=0;i<N;i++){
    const eps = randn()*amp;
    white.push(eps);
    const s=Math.sqrt(Math.max(0,1-p*p));
    const v = p*prev + s*eps;
    prev=v;
    qds.push(v);
  }

  const c=$("noise_canvas");
  const ctx=c.getContext("2d");
  const W=c.width=c.clientWidth*devicePixelRatio;
  const H=c.height=c.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  ctx.lineWidth=1*devicePixelRatio;
  for(let i=1;i<5;i++){
    const y=H*i/5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  const all=white.concat(qds);
  const maxA=Math.max(...all.map(x=>Math.abs(x)), 1e-6);

  function plot(arr, color){
    ctx.strokeStyle=color; ctx.lineWidth=2*devicePixelRatio;
    ctx.beginPath();
    for(let i=0;i<arr.length;i++){
      const x=(i/(arr.length-1))*W;
      const y=H/2 - (arr[i]/maxA)*(H*0.35);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  plot(white, "rgba(122,162,255,0.9)");
  plot(qds, "rgba(255,115,179,0.85)");

  $("noise_note").textContent = `Trace length ${N}. amp=${amp.toFixed(1)} p=${p.toFixed(2)}.`;
}

// ---------- Export ----------
function exportLogs(all=false){
  const hist=loadHist();
  if(!hist.length){
    $("export_out").value="No logs yet.";
    return;
  }
  const pick = all ? hist.slice(-20) : [hist[hist.length-1]];
  const lines = pick.map(r=>
`${r.local} ¬∑ base=${r.base}% ¬∑ amp=${r.amp}% ¬∑ p=${r.p} ¬∑ thr=${r.thr}% ¬∑ n=${r.n} ¬∑ max=${r.maxc}
white Œº=${r.wm} œÉ=${r.ws} ¬∑ QDS Œº=${r.qm} œÉ=${r.qs} ¬∑ Œî=${r.drel}% ¬∑ meanŒî=${r.ddir}
stress: nonlin=${r.ham_nonlin} heat=${r.ham_heat} out=${r.ham_out} ¬∑ bias: paired=${r.paired} noRegen=${r.noregen} blind=${r.blind}`
  );
  $("export_out").value = lines.join("\n\n");
  return $("export_out").value;
}

async function copyText(txt){
  try{
    await navigator.clipboard.writeText(txt);
  }catch(e){}
}

// ---------- Presets ----------
function setPreset(obj){
  S.base.value=obj.base; S.amp.value=obj.amp; S.p.value=obj.p;
  S.n.value=obj.n; S.maxc.value=obj.maxc; S.thr.value=obj.thr;
  T.nonlin.checked=obj.nonlin; T.heat.checked=obj.heat; T.out.checked=obj.out;
  T.paired.checked=obj.paired; T.noregen.checked=obj.noregen; T.blind.checked=obj.blind;
  ["base","amp","p","n","maxc","thr"].forEach(k=>{
    const el = S[k]; el.dispatchEvent(new Event("input"));
  });
}

const PRE = {
  real:{base:1.2, amp:1.8, p:0.25, n:1200, maxc:4000, thr:75, nonlin:true, heat:true, out:true, paired:true, noregen:true, blind:false},
  clean:{base:2.0, amp:3.0, p:0.60, n:2000, maxc:3000, thr:30, nonlin:true, heat:true, out:true, paired:true, noregen:true, blind:false},
  stress:{base:3.5, amp:6.0, p:0.70, n:2000, maxc:5000, thr:50, nonlin:true, heat:true, out:true, paired:true, noregen:true, blind:false},
  chaos:{base:6.5, amp:10.0, p:0.95, n:2000, maxc:2600, thr:90, nonlin:true, heat:true, out:true, paired:true, noregen:true, blind:false}
};

// ---------- Buttons ----------
$("run_once").onclick = runLab;
$("reset_all").onclick = ()=>setPreset(PRE.real);
$("clear_history").onclick = ()=>{ localStorage.removeItem(HIST_KEY); renderHist(); };

$("pre_real").onclick = ()=>setPreset(PRE.real);
$("pre_clean").onclick = ()=>setPreset(PRE.clean);
$("pre_stress").onclick = ()=>setPreset(PRE.stress);
$("pre_chaos").onclick = ()=>setPreset(PRE.chaos);

$("hard_null").onclick = ()=>{ S.p.value=0; S.p.dispatchEvent(new Event("input")); };

$("psweep_quick").onclick = ()=>pSweep([0.00,0.30,0.60,0.90]);
$("psweep_dense").onclick = ()=>{
  const list=[]; for(let x=0;x<=0.9+1e-9;x+=0.1) list.push(Number(x.toFixed(2)));
  pSweep(list);
};
$("tsweep_3").onclick = ()=>tSweep([30,50,80]);
$("tsweep_5").onclick = ()=>tSweep([20,30,50,75,80]);

$("noise_gen").onclick = noiseToy;

$("copy_logs").onclick = async ()=>{
  const txt = exportLogs(true);
  if(txt) await copyText(txt);
};
$("copy_last").onclick = async ()=>{
  const txt = exportLogs(false);
  if(txt) await copyText(txt);
};

$("plan_day").onclick = planDay;

// ---------- Boot ----------
setPreset(PRE.real);
renderHist();
updateCoachFromLast();
noiseToy();


// --- qds_battery_suite_v5_boss_polish.html ---

const $ = id => document.getElementById(id);
const HIST_KEY = "QDS_BATT_SUITE_V5_HIST";

const S = {
  base:$("base"), amp:$("amp"), p:$("p"), n:$("n"), maxc:$("maxc"), thr:$("thr"),
  intent:$("intent"), heat_risk:$("heat_risk")
};
const V = {
  base:$("v_base"), amp:$("v_amp"), p:$("v_p"), n:$("v_n"), maxc:$("v_max"), thr:$("v_thr"),
  intent_label:$("intent_label"), heat_label:$("heat_label")
};
const T = {
  nonlin:$("ham_nonlin"), heat:$("ham_heat"), out:$("ham_out"),
  paired:$("fair_paired"), noregen:$("fair_noregen"), blind:$("fair_blind"),
  interpret:$("mode_interpret"), bias:$("mode_bias")
};

let LAST_RUN = null;

// ---------- UI readouts ----------
function bindSlider(sl, out, fmt=1){
  const upd = ()=> out.textContent = Number(sl.value).toFixed(fmt);
  sl.addEventListener("input", upd); upd();
}
bindSlider(S.base,V.base,1); bindSlider(S.amp,V.amp,1); bindSlider(S.p,V.p,2);
bindSlider(S.n,V.n,0); bindSlider(S.maxc,V.maxc,0); bindSlider(S.thr,V.thr,0);

function updIntent(){
  const v = +S.intent.value;
  V.intent_label.textContent = v===0?"Normal day":v===1?"Long day":"Travel";
}
function updHeatRisk(){
  const v = +S.heat_risk.value;
  V.heat_label.textContent = v===0?"Normal":v===1?"Warm":"Hot";
}
S.intent.addEventListener("input", updIntent); updIntent();
S.heat_risk.addEventListener("input", updHeatRisk); updHeatRisk();

// ---------- Tabs ----------
document.querySelectorAll(".tab").forEach(t=>{
  t.addEventListener("click", ()=>{
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    const name = t.dataset.tab;
    ["lab","coach","sweeps","noise","export"].forEach(n=>{
      $("tab-"+n).style.display = (n===name) ? "block" : "none";
    });
  });
});

// ---------- Mode toggle logic ----------
function syncMode(){
  if(T.interpret.checked){
    T.bias.checked = false;
    T.blind.checked = false;
  }else if(T.bias.checked){
    T.interpret.checked = false;
    T.blind.checked = true;
  }
}
T.interpret.addEventListener("change", syncMode);
T.bias.addEventListener("change", syncMode);
T.blind.addEventListener("change", ()=>{
  if(T.blind.checked){ T.interpret.checked=false; T.bias.checked=true; }
  else { T.bias.checked=false; T.interpret.checked=true; }
});
syncMode();

// ---------- RNG normal ----------
function randn(){
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

// ---------- Stress helpers ----------
function heatMultiplier(c,on){
  if(!on) return 1.0;
  const period=60, band=12;
  return (c % period) < band ? 1.6 : 1.0;
}
function nonlinearMult(health,on){
  if(!on) return 1.0;
  const frag = Math.max(0, (40-health)/40);
  return 1 + 0.9*frag;
}
function outlierKick(on){
  if(!on) return 0;
  return (Math.random()<0.005) ? (3 + Math.random()*6) : 0;
}
function computeDrain(step, health, c, cfg){
  let d = cfg.base + cfg.amp * step;
  d *= heatMultiplier(c, cfg.ham_heat);
  d += outlierKick(cfg.ham_out);
  d *= nonlinearMult(health, cfg.ham_nonlin);
  if(cfg.noregen && d < 0) d = 0;
  return d;
}

// ---------- Cell sim ----------
function simulateOne(model, cfg){
  let health=100, prev=0, c=0;
  while(c < cfg.maxc && health > cfg.thr){
    c++;
    const eps = randn();
    let step = eps;
    if(model==="qds"){
      const s = Math.sqrt(Math.max(0, 1 - cfg.p*cfg.p));
      step = cfg.p*prev + s*eps;
      prev = step;
    }
    health -= computeDrain(step, health, c, cfg);
    health = clamp(health, -50, 120);
  }
  return c;
}
function simulateProfile(cfg, len=260){
  let hW=100, hQ=100, prevQ=0;
  const arrW=[hW], arrQ=[hQ];
  for(let c=1;c<=Math.min(cfg.maxc,len);c++){
    const eps = randn();
    const stepW = eps;
    const s = Math.sqrt(Math.max(0, 1 - cfg.p*cfg.p));
    const stepQ = cfg.p*prevQ + s*eps;
    prevQ = stepQ;

    if(hW > cfg.thr) hW -= computeDrain(stepW, hW, c, cfg);
    if(hQ > cfg.thr) hQ -= computeDrain(stepQ, hQ, c, cfg);

    arrW.push(hW); arrQ.push(hQ);
    if(hW <= cfg.thr && hQ <= cfg.thr) break;
  }
  return {arrW, arrQ};
}

// ---------- Stats ----------
function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }
function sd(a){
  const m=mean(a);
  const v=a.reduce((s,x)=>s+(x-m)*(x-m),0)/Math.max(1,a.length-1);
  return Math.sqrt(v);
}

// ---------- Charts ----------
function drawLine(canvas, seriesA, seriesB, thr){
  const ctx=canvas.getContext("2d");
  const W=canvas.width=canvas.clientWidth*devicePixelRatio;
  const H=canvas.height=canvas.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  ctx.lineWidth=1*devicePixelRatio;
  for(let i=1;i<6;i++){
    const y=H*i/6; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  function plot(arr, color){
    const n=arr.length, maxX=Math.max(10,n-1), minY=0, maxY=110;
    ctx.strokeStyle=color; ctx.lineWidth=2.2*devicePixelRatio;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const x=(i/maxX)*W;
      const y=H-((arr[i]-minY)/(maxY-minY))*H;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  plot(seriesA, "rgba(122,162,255,0.95)");
  plot(seriesB, "rgba(255,115,179,0.9)");

  const yThr = H - (thr/110)*H;
  ctx.setLineDash([6*devicePixelRatio,6*devicePixelRatio]);
  ctx.strokeStyle="rgba(255,255,255,0.12)";
  ctx.beginPath(); ctx.moveTo(0,yThr); ctx.lineTo(W,yThr); ctx.stroke();
  ctx.setLineDash([]);
}
function drawHist(canvas, w, q){
  const ctx=canvas.getContext("2d");
  const W=canvas.width=canvas.clientWidth*devicePixelRatio;
  const H=canvas.height=canvas.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  const all=w.concat(q);
  const min=Math.min(...all), max=Math.max(...all);
  const bins=16, binW=(max-min+1)/bins;
  const cw=new Array(bins).fill(0), cq=new Array(bins).fill(0);
  for(const x of w){
    let b=Math.floor((x-min)/binW); b=clamp(b,0,bins-1); cw[b]++;
  }
  for(const x of q){
    let b=Math.floor((x-min)/binW); b=clamp(b,0,bins-1); cq[b]++;
  }
  const top=Math.max(...cw,...cq,1);
  const pad=0.08, innerW=W*(1-2*pad), innerH=H*(1-2*pad);
  const group=innerW/bins;

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y=H*pad + innerH*i/6;
    ctx.beginPath(); ctx.moveTo(W*pad,y); ctx.lineTo(W*(1-pad),y); ctx.stroke();
  }

  for(let i=0;i<bins;i++){
    const x0=W*pad + i*group;
    const bw=group*0.38, gap=group*0.08;
    const hw=(cw[i]/top)*innerH, hq=(cq[i]/top)*innerH;

    ctx.fillStyle="rgba(122,162,255,0.6)";
    ctx.fillRect(x0, H*pad + (innerH-hw), bw, hw);

    ctx.fillStyle="rgba(255,115,179,0.55)";
    ctx.fillRect(x0+bw+gap, H*pad + (innerH-hq), bw, hq);
  }
}

// ---------- Flags ----------
function renderFlags(cfg){
  const f=[];
  if(cfg.thr > 85) f.push("High thr amplifies % deltas.");
  if(cfg.paired) f.push("Paired Fair Mode ON.");
  if(cfg.noregen) f.push("No Regen ON.");
  if(cfg.blind) f.push("Blind labels ON.");
  const box=$("flags");
  if(!f.length){ box.style.display="none"; box.textContent=""; return; }
  box.style.display="block";
  box.innerHTML="<b>Sanity flags:</b><br>‚Ä¢ "+f.join("<br>‚Ä¢ ");
}

// ---------- History ----------
function loadHist(){
  try{ return JSON.parse(localStorage.getItem(HIST_KEY)||"[]")||[]; }catch(e){ return []; }
}
function saveHist(arr){
  try{ localStorage.setItem(HIST_KEY, JSON.stringify(arr.slice(-60))); }catch(e){}
}
function pushHist(obj){
  const arr=loadHist(); arr.push(obj); saveHist(arr);
}
function renderHist(){
  const arr=loadHist().slice().reverse();
  const box=$("history");
  if(!arr.length){ box.innerHTML="<div class='hist-item'>No runs yet.</div>"; return; }
  box.innerHTML="";
  arr.slice(0,20).forEach(r=>{
    const d=document.createElement("div");
    d.className="hist-item";
    d.textContent =
`${r.local}
base=${r.base}% amp=${r.amp}% p=${r.p} thr=${r.thr}% n=${r.n} max=${r.maxc}
white Œº=${r.wm} œÉ=${r.ws} ¬∑ QDS Œº=${r.qm} œÉ=${r.qs}
Œî=${r.drel}% ¬∑ meanŒî=${r.ddir}
stress: nonlin=${r.ham_nonlin} heat=${r.ham_heat} out=${r.ham_out}
bias: paired=${r.paired} noRegen=${r.noregen} blind=${r.blind}`;
    box.appendChild(d);
  });
}

// ---------- Blind display swap ----------
function maybeBlindDisplay(res, blind){
  if(!blind) return {res, labels:{w:"White", q:"QDS"}};
  if(Math.random()<0.5) return {res, labels:{w:"White", q:"QDS"}};
  const swapped={
    wm:res.qm, ws:res.qs, qm:res.wm, qs:res.ws,
    drel:-res.drel, ddir:-res.ddir
  };
  return {res:swapped, labels:{w:"QDS", q:"White"}};
}

// ---------- Config ----------
function cfgFromUI(forceBlind=null){
  return {
    base:+S.base.value, amp:+S.amp.value, p:+S.p.value,
    n:+S.n.value|0, maxc:+S.maxc.value|0, thr:+S.thr.value|0,
    ham_nonlin:$("ham_nonlin").checked,
    ham_heat:$("ham_heat").checked,
    ham_out:$("ham_out").checked,
    paired:$("fair_paired").checked,
    noregen:$("fair_noregen").checked,
    blind: forceBlind===null ? $("fair_blind").checked : !!forceBlind
  };
}

// ---------- Single run core ----------
function runOnceCore(cfg){
  const white=[], qds=[];
  for(let i=0;i<cfg.n;i++){
    white.push(simulateOne("white", cfg));
    qds.push(simulateOne("qds", cfg));
  }
  const res={
    wm:mean(white), ws:sd(white),
    qm:mean(qds), qs:sd(qds)
  };
  res.drel=((res.qm-res.wm)/Math.max(1e-9,res.wm))*100;
  res.ddir=(res.qm-res.wm);
  return {white,qds,res};
}

// ---------- LAB run ----------
function runLab(){
  const cfg=cfgFromUI();
  const out = runOnceCore(cfg);
  const resCore = out.res;

  const disp = maybeBlindDisplay(resCore, cfg.blind);

  $("lbl_wm").textContent = disp.labels.w+" mean";
  $("lbl_qm").textContent = disp.labels.q+" mean";
  $("wm").textContent = disp.res.wm.toFixed(1);
  $("ws").textContent = disp.res.ws.toFixed(1);
  $("qm").textContent = disp.res.qm.toFixed(1);
  $("qs").textContent = disp.res.qs.toFixed(1);
  $("drel").textContent = (disp.res.drel>=0?"+":"")+disp.res.drel.toFixed(1);
  $("ddir").textContent = (disp.res.ddir>=0?"+":"")+disp.res.ddir.toFixed(2);

  renderFlags(cfg);

  const prof=simulateProfile(cfg);
  drawLine($("profile"), prof.arrW, prof.arrQ, cfg.thr);
  drawHist($("hist"), out.white, out.qds);

  $("profile_note").textContent =
    `Profile length: White ~${prof.arrW.length-1} cycles, QDS ~${prof.arrQ.length-1} cycles.`;

  const now = new Date();
  const logObj = {
    local: now.toLocaleString(),
    base:cfg.base.toFixed(1), amp:cfg.amp.toFixed(1), p:cfg.p.toFixed(2),
    thr:cfg.thr, n:cfg.n, maxc:cfg.maxc,
    ham_nonlin:cfg.ham_nonlin, ham_heat:cfg.ham_heat, ham_out:cfg.ham_out,
    paired:cfg.paired, noregen:cfg.noregen, blind:cfg.blind,
    wm:resCore.wm.toFixed(1), ws:resCore.ws.toFixed(1),
    qm:resCore.qm.toFixed(1), qs:resCore.qs.toFixed(1),
    drel:resCore.drel.toFixed(1), ddir:resCore.ddir.toFixed(2)
  };

  LAST_RUN = logObj;
  pushHist(logObj);
  renderHist();
  updateCoachFromLast();
}

// ---------- COACH ----------
function updateCoachFromLast(){
  const cfg=cfgFromUI(false); // interpret for coach logic
  const hist=loadHist();
  const recent=hist.slice(-5);

  let risk=0;
  risk += cfg.base*10;
  risk += cfg.amp*6;
  risk += cfg.p*25;
  risk += cfg.ham_heat?12:0;
  risk += cfg.ham_out?10:0;
  risk += cfg.ham_nonlin?8:0;
  risk = clamp(risk,0,100);

  let band="good";
  if(risk>=65) band="bad";
  else if(risk>=38) band="warn";

  const badge=$("risk_badge");
  badge.className="risk "+band;
  badge.textContent = band==="good"?"LOW STRESS":band==="warn"?"MEDIUM STRESS":"HIGH STRESS";

  const cap = band==="bad"?80:band==="warn"?85:90;

  let learned = null;
  if(recent.length){
    learned = recent.reduce((s,r)=>s+Number(r.drel),0)/recent.length;
  }

  $("risk_line").textContent = `Risk score ‚âà ${risk.toFixed(0)}/100. Suggested daily cap: ${cap}%.`;

  const corrText = cfg.p>=0.6 ? "Strong correlation: avoid clustering heat + high charge + spikes."
                    : cfg.p>=0.25 ? "Moderate correlation: expect 'good weeks / bad weeks'."
                    : "Low correlation: wear is closer to random scatter.";
  const heatText = cfg.ham_heat ? "Heat epochs ON ‚Äî avoid charging hot; cool first." : "Heat epochs OFF.";
  const outText = cfg.ham_out ? "Outliers ON ‚Äî spikes are the enemy." : "Outliers OFF.";

  const last = LAST_RUN;
  const outcome = last
    ? `Last run: white Œº=${last.wm} vs QDS Œº=${last.qm} (Œî ${last.drel}%).`
    : "Run the Lab to generate an outcome line.";

  $("coach_advice").innerHTML =
`‚Ä¢ <b>Routine window:</b> aim for <b>25‚Äì${cap}%</b> on normal days.<br>
‚Ä¢ <b>Travel day:</b> top to 100% closer to departure.<br>
‚Ä¢ <b>Thermal discipline:</b> ${heatText}<br>
‚Ä¢ <b>Shock control:</b> ${outText}<br>
‚Ä¢ <b>Correlation read:</b> ${corrText}<br>
‚Ä¢ <b>Outcome:</b> ${outcome}`;

  $("coach_learning").textContent =
    learned==null ? "Learning: not enough stored runs yet."
    : `Learning (last ${recent.length} runs): mean Œî ‚âà ${(learned>=0?"+":"")+learned.toFixed(1)}%.`;
}

// ---------- Routine planner ----------
function planDay(){
  updateCoachFromLast();
  const intent=+S.intent.value;
  const heatRisk=+S.heat_risk.value;

  let targetCap = 85;
  const badgeText = $("risk_badge").textContent;
  if(badgeText.includes("LOW")) targetCap=90;
  if(badgeText.includes("HIGH")) targetCap=80;

  if(intent===1) targetCap = Math.min(95, targetCap+5);
  if(intent===2) targetCap = 100;

  let heatAdvice = heatRisk===0 ? "Normal temps: standard routine."
                 : heatRisk===1 ? "Warm day: avoid fast-charge while hot."
                 : "Hot day: cool first; delay charging if possible.";

  $("plan_out").innerHTML =
`<b>Suggested plan:</b><br>
‚Ä¢ Target cap tonight: <b>${targetCap}%</b><br>
‚Ä¢ If you need full charge: finish closer to departure.<br>
‚Ä¢ ${heatAdvice}`;
}

// ---------- Poster Mode (4-block) ----------
function posterMode(){
  // Story: thr 75, 50, 30 at current p; then hard-null p=0 at thr 75.
  const baseCfg = cfgFromUI(false);
  const saved = {...baseCfg};

  const nCap = Math.min(baseCfg.n, 1500); // keep phone happy
  const blocks = [
    {name:"A) Realistic high-thr", thr:75, p:baseCfg.p, n:nCap},
    {name:"B) Mid-thr",           thr:50, p:baseCfg.p, n:nCap},
    {name:"C) Long-life thr",     thr:30, p:baseCfg.p, n:nCap},
    {name:"D) Hard null control", thr:75, p:0.00,      n:nCap}
  ];

  const lines=[];
  for(const b of blocks){
    const cfg={...baseCfg, thr:b.thr, p:b.p, n:b.n, blind:false};
    const out = runOnceCore(cfg).res;
    lines.push(
`${b.name}
base=${cfg.base.toFixed(1)} amp=${cfg.amp.toFixed(1)} p=${cfg.p.toFixed(2)} thr=${cfg.thr}% n=${cfg.n} max=${cfg.maxc}
white Œº=${out.wm.toFixed(1)} œÉ=${out.ws.toFixed(1)} ¬∑ QDS Œº=${out.qm.toFixed(1)} œÉ=${out.qs.toFixed(1)}
Œî=${(out.drel>=0?"+":"")+out.drel.toFixed(1)}% ¬∑ meanŒî=${(out.ddir>=0?"+":"")+out.ddir.toFixed(2)}`
    );
  }

  const summary =
`Poster read:
‚Ä¢ If A>B>C trend holds and D collapses toward ~0,
  you‚Äôve got a clean correlation-only signature under fairness controls.`;

  const posterText = lines.join("\n\n") + "\n\n" + summary;
  $("poster_out").value = posterText;

  // restore UI (no need to change sliders)
  LAST_RUN = LAST_RUN; // keep latest lab result intact
  updateCoachFromLast();
}

// ---------- Sweeps ----------
function formatSweepLine(cfg, out){
  return `base=${cfg.base.toFixed(1)} amp=${cfg.amp.toFixed(1)} p=${cfg.p.toFixed(2)} thr=${cfg.thr}% n=${cfg.n}
white Œº=${out.wm.toFixed(1)} œÉ=${out.ws.toFixed(1)} ¬∑ QDS Œº=${out.qm.toFixed(1)} œÉ=${out.qs.toFixed(1)}
Œî=${(out.drel>=0?"+":"")+out.drel.toFixed(1)}% ¬∑ meanŒî=${(out.ddir>=0?"+":"")+out.ddir.toFixed(2)}`;
}
function pSweep(list){
  const baseCfg=cfgFromUI(false);
  const lines=[];
  for(const pv of list){
    const cfg={...baseCfg, p:pv, blind:false};
    const out=runOnceCore(cfg).res;
    lines.push(formatSweepLine(cfg,out));
  }
  $("psweep_out").value = lines.join("\n\n");
}
function tSweep(list){
  const baseCfg=cfgFromUI(false);
  const lines=[];
  for(const tv of list){
    const cfg={...baseCfg, thr:tv, blind:false};
    const out=runOnceCore(cfg).res;
    lines.push(formatSweepLine(cfg,out));
  }
  $("tsweep_out").value = lines.join("\n\n");
}

// ---------- Noise toy ----------
function noiseToy(){
  const amp=+S.amp.value, p=+S.p.value;
  const N=160;
  let prev=0;
  const white=[], qds=[];
  for(let i=0;i<N;i++){
    const eps = randn()*amp;
    white.push(eps);
    const s=Math.sqrt(Math.max(0,1-p*p));
    const v = p*prev + s*eps;
    prev=v; qds.push(v);
  }
  const c=$("noise_canvas");
  const ctx=c.getContext("2d");
  const W=c.width=c.clientWidth*devicePixelRatio;
  const H=c.height=c.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  ctx.lineWidth=1*devicePixelRatio;
  for(let i=1;i<5;i++){
    const y=H*i/5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  const all=white.concat(qds);
  const maxA=Math.max(...all.map(x=>Math.abs(x)), 1e-6);

  function plot(arr, color){
    ctx.strokeStyle=color; ctx.lineWidth=2*devicePixelRatio;
    ctx.beginPath();
    for(let i=0;i<arr.length;i++){
      const x=(i/(arr.length-1))*W;
      const y=H/2 - (arr[i]/maxA)*(H*0.35);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  plot(white, "rgba(122,162,255,0.9)");
  plot(qds, "rgba(255,115,179,0.85)");

  $("noise_note").textContent = `Trace length ${N}. amp=${amp.toFixed(1)} p=${p.toFixed(2)}.`;
}

// ---------- Export / Copy ----------
function formatLog(r){
  return `${r.local} ¬∑ base=${r.base}% ¬∑ amp=${r.amp}% ¬∑ p=${r.p} ¬∑ thr=${r.thr}% ¬∑ n=${r.n} ¬∑ max=${r.maxc}
white Œº=${r.wm} œÉ=${r.ws} ¬∑ QDS Œº=${r.qm} œÉ=${r.qs} ¬∑ Œî=${r.drel}% ¬∑ meanŒî=${r.ddir}
stress: nonlin=${r.ham_nonlin} heat=${r.ham_heat} out=${r.ham_out} ¬∑ bias: paired=${r.paired} noRegen=${r.noregen} blind=${r.blind}`;
}
function exportLast(k){
  const hist=loadHist();
  if(!hist.length){ $("export_out").value="No logs yet."; return ""; }
  const pick = hist.slice(-k);
  const txt = pick.map(formatLog).join("\n\n");
  $("export_out").value = txt;
  return txt;
}
async function copyText(txt){
  try{ await navigator.clipboard.writeText(txt); }catch(e){}
}
async function sharePack(){
  const hist=loadHist();
  const last5 = hist.slice(-5).map(formatLog).join("\n\n");
  const poster = $("poster_out").value.trim();
  const pack =
`QDS Battery Suite v5 ‚Äî Share Pack

LAST 5 RUNS
${last5 || "(none)"}

POSTER MODE
${poster || "(no poster run yet)"}
`;
  $("export_out").value = pack;
  await copyText(pack);
}

// ---------- Presets ----------
function setPreset(obj){
  S.base.value=obj.base; S.amp.value=obj.amp; S.p.value=obj.p;
  S.n.value=obj.n; S.maxc.value=obj.maxc; S.thr.value=obj.thr;
  $("ham_nonlin").checked=obj.nonlin;
  $("ham_heat").checked=obj.heat;
  $("ham_out").checked=obj.out;
  $("fair_paired").checked=obj.paired;
  $("fair_noregen").checked=obj.noregen;

  // mode default for presets
  T.interpret.checked = true;
  T.bias.checked = false;
  $("fair_blind").checked = false;
  syncMode();

  ["base","amp","p","n","maxc","thr"].forEach(k=>{
    S[k].dispatchEvent(new Event("input"));
  });
}
const PRE = {
  real:{base:1.2, amp:1.8, p:0.25, n:1200, maxc:4000, thr:75, nonlin:true, heat:true, out:true, paired:true, noregen:true},
  clean:{base:2.0, amp:3.0, p:0.60, n:2000, maxc:3000, thr:30, nonlin:true, heat:true, out:true, paired:true, noregen:true},
  stress:{base:3.5, amp:6.0, p:0.70, n:2000, maxc:5000, thr:50, nonlin:true, heat:true, out:true, paired:true, noregen:true},
  chaos:{base:6.5, amp:10.0, p:0.95, n:2000, maxc:2600, thr:90, nonlin:true, heat:true, out:true, paired:true, noregen:true}
};

// ---------- Buttons ----------
$("run_once").onclick = runLab;
$("poster_mode").onclick = posterMode;
$("reset_all").onclick = ()=>setPreset(PRE.real);
$("clear_history").onclick = ()=>{ localStorage.removeItem(HIST_KEY); renderHist(); };

$("pre_real").onclick = ()=>setPreset(PRE.real);
$("pre_clean").onclick = ()=>setPreset(PRE.clean);
$("pre_stress").onclick = ()=>setPreset(PRE.stress);
$("pre_chaos").onclick = ()=>setPreset(PRE.chaos);

$("hard_null").onclick = ()=>{ S.p.value=0; S.p.dispatchEvent(new Event("input")); };

$("psweep_quick").onclick = ()=>pSweep([0.00,0.30,0.60,0.90]);
$("psweep_dense").onclick = ()=>{
  const list=[]; for(let x=0;x<=0.9+1e-9;x+=0.1) list.push(Number(x.toFixed(2)));
  pSweep(list);
};
$("tsweep_3").onclick = ()=>tSweep([30,50,75]);
$("tsweep_5").onclick = ()=>tSweep([20,30,50,75,80]);

$("noise_gen").onclick = noiseToy;

$("copy_last").onclick = async ()=>{ const t=exportLast(1); if(t) await copyText(t); };
$("copy_5").onclick = async ()=>{ const t=exportLast(5); if(t) await copyText(t); };
$("share_pack").onclick = sharePack;

$("plan_day").onclick = planDay;

// ---------- Boot ----------
setPreset(PRE.real);
renderHist();
updateCoachFromLast();
noiseToy();
$("poster_out").value = "No poster run yet. Tap Poster Mode for the 4-block evidence ladder.";


// --- qds_battery_suite_v6_realworld.html ---

const $ = id => document.getElementById(id);
const HIST_KEY = "QDS_BATT_SUITE_V6_HIST";
const HABIT_KEY = "QDS_BATT_V6_HABITS";

const S = {
  base:$("base"), amp:$("amp"), p:$("p"), n:$("n"), maxc:$("maxc"), thr:$("thr"),
  intent:$("intent"), heat_risk:$("heat_risk"),
  h_max:$("h_max"), h_min:$("h_min"), h_fast:$("h_fast"), h_heat:$("h_heat"), h_overnight:$("h_overnight")
};
const V = {
  base:$("v_base"), amp:$("v_amp"), p:$("v_p"), n:$("v_n"), maxc:$("v_max"), thr:$("v_thr"),
  intent_label:$("intent_label"), heat_label:$("heat_label"),
  h_max:$("v_h_max"), h_min:$("v_h_min"), h_fast:$("v_h_fast"), h_heat:$("v_h_heat"), h_overnight:$("v_h_overnight")
};
const T = {
  nonlin:$("ham_nonlin"), heat:$("ham_heat"), out:$("ham_out"),
  paired:$("fair_paired"), noregen:$("fair_noregen"), blind:$("fair_blind"),
  interpret:$("mode_interpret"), bias:$("mode_bias")
};

let LAST_RUN = null;

// ---------- UI bind ----------
function bindSlider(sl, out, fmt=1){
  const upd = ()=> out.textContent = Number(sl.value).toFixed(fmt);
  sl.addEventListener("input", upd); upd();
}
bindSlider(S.base,V.base,1); bindSlider(S.amp,V.amp,1); bindSlider(S.p,V.p,2);
bindSlider(S.n,V.n,0); bindSlider(S.maxc,V.maxc,0); bindSlider(S.thr,V.thr,0);

bindSlider(S.h_max,V.h_max,0);
bindSlider(S.h_min,V.h_min,0);
bindSlider(S.h_fast,V.h_fast,0);
bindSlider(S.h_heat,V.h_heat,1);
bindSlider(S.h_overnight,V.h_overnight,0);

function updIntent(){
  const v = +S.intent.value;
  V.intent_label.textContent = v===0?"Normal day":v===1?"Long day":"Travel";
}
function updHeatRisk(){
  const v = +S.heat_risk.value;
  V.heat_label.textContent = v===0?"Normal":v===1?"Warm":"Hot";
}
S.intent.addEventListener("input", updIntent); updIntent();
S.heat_risk.addEventListener("input", updHeatRisk); updHeatRisk();

// ---------- Tabs ----------
document.querySelectorAll(".tab").forEach(t=>{
  t.addEventListener("click", ()=>{
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    const name = t.dataset.tab;
    ["lab","coach","real","sweeps","noise","export"].forEach(n=>{
      $("tab-"+n).style.display = (n===name) ? "block" : "none";
    });
  });
});

// ---------- Mode toggle logic ----------
function syncMode(){
  if(T.interpret.checked){
    T.bias.checked = false;
    T.blind.checked = false;
  }else if(T.bias.checked){
    T.interpret.checked = false;
    T.blind.checked = true;
  }
}
T.interpret.addEventListener("change", syncMode);
T.bias.addEventListener("change", syncMode);
T.blind.addEventListener("change", ()=>{
  if(T.blind.checked){ T.interpret.checked=false; T.bias.checked=true; }
  else { T.bias.checked=false; T.interpret.checked=true; }
});
syncMode();

// ---------- RNG ----------
function randn(){
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

// ---------- Stress ----------
function heatMultiplier(c,on){
  if(!on) return 1.0;
  const period=60, band=12;
  return (c % period) < band ? 1.6 : 1.0;
}
function nonlinearMult(health,on){
  if(!on) return 1.0;
  const frag = Math.max(0, (40-health)/40);
  return 1 + 0.9*frag;
}
function outlierKick(on){
  if(!on) return 0;
  return (Math.random()<0.005) ? (3 + Math.random()*6) : 0;
}
function computeDrain(step, health, c, cfg){
  let d = cfg.base + cfg.amp * step;
  d *= heatMultiplier(c, cfg.ham_heat);
  d += outlierKick(cfg.ham_out);
  d *= nonlinearMult(health, cfg.ham_nonlin);
  if(cfg.noregen && d < 0) d = 0;
  return d;
}

// ---------- Cell sim ----------
function simulateOne(model, cfg){
  let health=100, prev=0, c=0;
  while(c < cfg.maxc && health > cfg.thr){
    c++;
    const eps = randn();
    let step = eps;
    if(model==="qds"){
      const s = Math.sqrt(Math.max(0, 1 - cfg.p*cfg.p));
      step = cfg.p*prev + s*eps;
      prev = step;
    }
    health -= computeDrain(step, health, c, cfg);
    health = clamp(health, -50, 120);
  }
  return c;
}
function simulateProfile(cfg, len=260){
  let hW=100, hQ=100, prevQ=0;
  const arrW=[hW], arrQ=[hQ];
  for(let c=1;c<=Math.min(cfg.maxc,len);c++){
    const eps = randn();
    const stepW = eps;
    const s = Math.sqrt(Math.max(0, 1 - cfg.p*cfg.p));
    const stepQ = cfg.p*prevQ + s*eps;
    prevQ = stepQ;

    if(hW > cfg.thr) hW -= computeDrain(stepW, hW, c, cfg);
    if(hQ > cfg.thr) hQ -= computeDrain(stepQ, hQ, c, cfg);

    arrW.push(hW); arrQ.push(hQ);
    if(hW <= cfg.thr && hQ <= cfg.thr) break;
  }
  return {arrW, arrQ};
}

// ---------- Stats ----------
function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }
function sd(a){
  const m=mean(a);
  const v=a.reduce((s,x)=>s+(x-m)*(x-m),0)/Math.max(1,a.length-1);
  return Math.sqrt(v);
}

// ---------- Charts ----------
function drawLine(canvas, seriesA, seriesB, thr){
  const ctx=canvas.getContext("2d");
  const W=canvas.width=canvas.clientWidth*devicePixelRatio;
  const H=canvas.height=canvas.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  ctx.lineWidth=1*devicePixelRatio;
  for(let i=1;i<6;i++){
    const y=H*i/6; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  function plot(arr, color){
    const n=arr.length, maxX=Math.max(10,n-1), minY=0, maxY=110;
    ctx.strokeStyle=color; ctx.lineWidth=2.2*devicePixelRatio;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const x=(i/maxX)*W;
      const y=H-((arr[i]-minY)/(maxY-minY))*H;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  plot(seriesA, "rgba(122,162,255,0.95)");
  plot(seriesB, "rgba(255,115,179,0.9)");

  const yThr = H - (thr/110)*H;
  ctx.setLineDash([6*devicePixelRatio,6*devicePixelRatio]);
  ctx.strokeStyle="rgba(255,255,255,0.12)";
  ctx.beginPath(); ctx.moveTo(0,yThr); ctx.lineTo(W,yThr); ctx.stroke();
  ctx.setLineDash([]);
}
function drawHist(canvas, w, q){
  const ctx=canvas.getContext("2d");
  const W=canvas.width=canvas.clientWidth*devicePixelRatio;
  const H=canvas.height=canvas.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  const all=w.concat(q);
  const min=Math.min(...all), max=Math.max(...all);
  const bins=16, binW=(max-min+1)/bins;
  const cw=new Array(bins).fill(0), cq=new Array(bins).fill(0);
  for(const x of w){
    let b=Math.floor((x-min)/binW); b=clamp(b,0,bins-1); cw[b]++;
  }
  for(const x of q){
    let b=Math.floor((x-min)/binW); b=clamp(b,0,bins-1); cq[b]++;
  }
  const top=Math.max(...cw,...cq,1);
  const pad=0.08, innerW=W*(1-2*pad), innerH=H*(1-2*pad);
  const group=innerW/bins;

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y=H*pad + innerH*i/6;
    ctx.beginPath(); ctx.moveTo(W*pad,y); ctx.lineTo(W*(1-pad),y); ctx.stroke();
  }

  for(let i=0;i<bins;i++){
    const x0=W*pad + i*group;
    const bw=group*0.38, gap=group*0.08;
    const hw=(cw[i]/top)*innerH, hq=(cq[i]/top)*innerH;

    ctx.fillStyle="rgba(122,162,255,0.6)";
    ctx.fillRect(x0, H*pad + (innerH-hw), bw, hw);

    ctx.fillStyle="rgba(255,115,179,0.55)";
    ctx.fillRect(x0+bw+gap, H*pad + (innerH-hq), bw, hq);
  }
}

// ---------- Flags ----------
function renderFlags(cfg){
  const f=[];
  if(cfg.thr > 85) f.push("High thr amplifies % deltas.");
  if(cfg.paired) f.push("Paired Fair Mode ON.");
  if(cfg.noregen) f.push("No Regen ON.");
  if(cfg.blind) f.push("Blind labels ON.");
  const box=$("flags");
  if(!f.length){ box.style.display="none"; box.textContent=""; return; }
  box.style.display="block";
  box.innerHTML="<b>Sanity flags:</b><br>‚Ä¢ "+f.join("<br>‚Ä¢ ");
}

// ---------- History ----------
function loadHist(){
  try{ return JSON.parse(localStorage.getItem(HIST_KEY)||"[]")||[]; }catch(e){ return []; }
}
function saveHist(arr){
  try{ localStorage.setItem(HIST_KEY, JSON.stringify(arr.slice(-60))); }catch(e){}
}
function pushHist(obj){
  const arr=loadHist(); arr.push(obj); saveHist(arr);
}
function renderHist(){
  const arr=loadHist().slice().reverse();
  const box=$("history");
  if(!arr.length){ box.innerHTML="<div class='hist-item'>No runs yet.</div>"; return; }
  box.innerHTML="";
  arr.slice(0,20).forEach(r=>{
    const d=document.createElement("div");
    d.className="hist-item";
    d.textContent =
`${r.local}
base=${r.base}% amp=${r.amp}% p=${r.p} thr=${r.thr}% n=${r.n} max=${r.maxc}
white Œº=${r.wm} œÉ=${r.ws} ¬∑ QDS Œº=${r.qm} œÉ=${r.qs}
Œî=${r.drel}% ¬∑ meanŒî=${r.ddir}
stress: nonlin=${r.ham_nonlin} heat=${r.ham_heat} out=${r.ham_out}
bias: paired=${r.paired} noRegen=${r.noregen} blind=${r.blind}`;
    box.appendChild(d);
  });
}

// ---------- Blind display swap ----------
function maybeBlindDisplay(res, blind){
  if(!blind) return {res, labels:{w:"White", q:"QDS"}};
  if(Math.random()<0.5) return {res, labels:{w:"White", q:"QDS"}};
  const swapped={
    wm:res.qm, ws:res.qs, qm:res.wm, qs:res.ws,
    drel:-res.drel, ddir:-res.ddir
  };
  return {res:swapped, labels:{w:"QDS", q:"White"}};
}

// ---------- Config ----------
function cfgFromUI(forceBlind=null){
  return {
    base:+S.base.value, amp:+S.amp.value, p:+S.p.value,
    n:+S.n.value|0, maxc:+S.maxc.value|0, thr:+S.thr.value|0,
    ham_nonlin:$("ham_nonlin").checked,
    ham_heat:$("ham_heat").checked,
    ham_out:$("ham_out").checked,
    paired:$("fair_paired").checked,
    noregen:$("fair_noregen").checked,
    blind: forceBlind===null ? $("fair_blind").checked : !!forceBlind
  };
}

// ---------- Single run core ----------
function runOnceCore(cfg){
  const white=[], qds=[];
  for(let i=0;i<cfg.n;i++){
    white.push(simulateOne("white", cfg));
    qds.push(simulateOne("qds", cfg));
  }
  const res={
    wm:mean(white), ws:sd(white),
    qm:mean(qds), qs:sd(qds)
  };
  res.drel=((res.qm-res.wm)/Math.max(1e-9,res.wm))*100;
  res.ddir=(res.qm-res.wm);
  return {white,qds,res};
}

// ---------- LAB run ----------
function runLab(){
  const cfg=cfgFromUI();
  const out = runOnceCore(cfg);
  const resCore = out.res;

  const disp = maybeBlindDisplay(resCore, cfg.blind);

  $("lbl_wm").textContent = disp.labels.w+" mean";
  $("lbl_qm").textContent = disp.labels.q+" mean";
  $("wm").textContent = disp.res.wm.toFixed(1);
  $("ws").textContent = disp.res.ws.toFixed(1);
  $("qm").textContent = disp.res.qm.toFixed(1);
  $("qs").textContent = disp.res.qs.toFixed(1);
  $("drel").textContent = (disp.res.drel>=0?"+":"")+disp.res.drel.toFixed(1);
  $("ddir").textContent = (disp.res.ddir>=0?"+":"")+disp.res.ddir.toFixed(2);

  renderFlags(cfg);

  const prof=simulateProfile(cfg);
  drawLine($("profile"), prof.arrW, prof.arrQ, cfg.thr);
  drawHist($("hist"), out.white, out.qds);

  $("profile_note").textContent =
    `Profile length: White ~${prof.arrW.length-1} cycles, QDS ~${prof.arrQ.length-1} cycles.`;

  const now = new Date();
  const logObj = {
    local: now.toLocaleString(),
    base:cfg.base.toFixed(1), amp:cfg.amp.toFixed(1), p:cfg.p.toFixed(2),
    thr:cfg.thr, n:cfg.n, maxc:cfg.maxc,
    ham_nonlin:cfg.ham_nonlin, ham_heat:cfg.ham_heat, ham_out:cfg.ham_out,
    paired:cfg.paired, noregen:cfg.noregen, blind:cfg.blind,
    wm:resCore.wm.toFixed(1), ws:resCore.ws.toFixed(1),
    qm:resCore.qm.toFixed(1), qs:resCore.qs.toFixed(1),
    drel:resCore.drel.toFixed(1), ddir:resCore.ddir.toFixed(2)
  };

  LAST_RUN = logObj;
  pushHist(logObj);
  renderHist();
  updateCoachFromLast();
  updateRealWorld();
}

// ---------- COACH ----------
function simRiskScore(cfg){
  let risk=0;
  risk += cfg.base*10;
  risk += cfg.amp*6;
  risk += cfg.p*25;
  risk += cfg.ham_heat?12:0;
  risk += cfg.ham_out?10:0;
  risk += cfg.ham_nonlin?8:0;
  return clamp(risk,0,100);
}
function updateCoachFromLast(){
  const cfg=cfgFromUI(false);
  const hist=loadHist();
  const recent=hist.slice(-5);

  const risk = simRiskScore(cfg);

  let band="good";
  if(risk>=65) band="bad";
  else if(risk>=38) band="warn";

  const badge=$("risk_badge");
  badge.className="risk "+band;
  badge.textContent = band==="good"?"LOW STRESS":band==="warn"?"MEDIUM STRESS":"HIGH STRESS";

  const cap = band==="bad"?80:band==="warn"?85:90;

  let learned = null;
  if(recent.length){
    learned = recent.reduce((s,r)=>s+Number(r.drel),0)/recent.length;
  }

  $("risk_line").textContent = `Risk score ‚âà ${risk.toFixed(0)}/100. Suggested daily cap: ${cap}%.`;

  const corrText = cfg.p>=0.6 ? "Strong correlation: avoid clustering heat + high charge + spikes."
                    : cfg.p>=0.25 ? "Moderate correlation: expect 'good weeks / bad weeks'."
                    : "Low correlation: wear is closer to random scatter.";
  const heatText = cfg.ham_heat ? "Heat epochs ON ‚Äî avoid charging hot; cool first." : "Heat epochs OFF.";
  const outText = cfg.ham_out ? "Outliers ON ‚Äî spikes are the enemy." : "Outliers OFF.";

  const last = LAST_RUN;
  const outcome = last
    ? `Last run: white Œº=${last.wm} vs QDS Œº=${last.qm} (Œî ${last.drel}%).`
    : "Run the Lab to generate an outcome line.";

  $("coach_advice").innerHTML =
`‚Ä¢ <b>Routine window:</b> aim for <b>25‚Äì${cap}%</b> on normal days.<br>
‚Ä¢ <b>Travel day:</b> top to 100% closer to departure.<br>
‚Ä¢ <b>Thermal discipline:</b> ${heatText}<br>
‚Ä¢ <b>Shock control:</b> ${outText}<br>
‚Ä¢ <b>Correlation read:</b> ${corrText}<br>
‚Ä¢ <b>Outcome:</b> ${outcome}`;

  $("coach_learning").textContent =
    learned==null ? "Learning: not enough stored runs yet."
    : `Learning (last ${recent.length} runs): mean Œî ‚âà ${(learned>=0?"+":"")+learned.toFixed(1)}%.`;
}

// ---------- Routine planner ----------
function planDay(){
  updateCoachFromLast();
  const intent=+S.intent.value;
  const heatRisk=+S.heat_risk.value;

  let targetCap = 85;
  const badgeText = $("risk_badge").textContent;
  if(badgeText.includes("LOW")) targetCap=90;
  if(badgeText.includes("HIGH")) targetCap=80;

  if(intent===1) targetCap = Math.min(95, targetCap+5);
  if(intent===2) targetCap = 100;

  let heatAdvice = heatRisk===0 ? "Normal temps: standard routine."
                 : heatRisk===1 ? "Warm day: avoid fast-charge while hot."
                 : "Hot day: cool first; delay charging if possible.";

  $("plan_out").innerHTML =
`<b>Suggested plan:</b><br>
‚Ä¢ Target cap tonight: <b>${targetCap}%</b><br>
‚Ä¢ If you need full charge: finish closer to departure.<br>
‚Ä¢ ${heatAdvice}`;
}

// ---------- Poster Mode ----------
function posterMode(){
  const baseCfg = cfgFromUI(false);
  const nCap = Math.min(baseCfg.n, 1500);

  const blocks = [
    {name:"A) High threshold", thr:75, p:baseCfg.p, n:nCap},
    {name:"B) Mid threshold",  thr:50, p:baseCfg.p, n:nCap},
    {name:"C) Long-life",      thr:30, p:baseCfg.p, n:nCap},
    {name:"D) Hard null p=0",  thr:75, p:0.00,      n:nCap}
  ];

  const lines=[];
  for(const b of blocks){
    const cfg={...baseCfg, thr:b.thr, p:b.p, n:b.n, blind:false};
    const out = runOnceCore(cfg).res;
    lines.push(
`${b.name}
base=${cfg.base.toFixed(1)} amp=${cfg.amp.toFixed(1)} p=${cfg.p.toFixed(2)} thr=${cfg.thr}% n=${cfg.n} max=${cfg.maxc}
white Œº=${out.wm.toFixed(1)} œÉ=${out.ws.toFixed(1)} ¬∑ QDS Œº=${out.qm.toFixed(1)} œÉ=${out.qs.toFixed(1)}
Œî=${(out.drel>=0?"+":"")+out.drel.toFixed(1)}% ¬∑ meanŒî=${(out.ddir>=0?"+":"")+out.ddir.toFixed(2)}`
    );
  }

  const summary =
`Poster read:
‚Ä¢ If A>B>C trend holds and D collapses toward ~0,
  you‚Äôve got a clean correlation-only signature under fairness controls.`;

  $("poster_out").value = lines.join("\\n\\n") + "\\n\\n" + summary;
  updateRealWorld();
}

// ---------- Sweeps ----------
function formatSweepLine(cfg, out){
  return `base=${cfg.base.toFixed(1)} amp=${cfg.amp.toFixed(1)} p=${cfg.p.toFixed(2)} thr=${cfg.thr}% n=${cfg.n}
white Œº=${out.wm.toFixed(1)} œÉ=${out.ws.toFixed(1)} ¬∑ QDS Œº=${out.qm.toFixed(1)} œÉ=${out.qs.toFixed(1)}
Œî=${(out.drel>=0?"+":"")+out.drel.toFixed(1)}% ¬∑ meanŒî=${(out.ddir>=0?"+":"")+out.ddir.toFixed(2)}`;
}
function pSweep(list){
  const baseCfg=cfgFromUI(false);
  const lines=[];
  for(const pv of list){
    const cfg={...baseCfg, p:pv, blind:false};
    const out=runOnceCore(cfg).res;
    lines.push(formatSweepLine(cfg,out));
  }
  $("psweep_out").value = lines.join("\\n\\n");
}
function tSweep(list){
  const baseCfg=cfgFromUI(false);
  const lines=[];
  for(const tv of list){
    const cfg={...baseCfg, thr:tv, blind:false};
    const out=runOnceCore(cfg).res;
    lines.push(formatSweepLine(cfg,out));
  }
  $("tsweep_out").value = lines.join("\\n\\n");
}

// ---------- Noise toy ----------
function noiseToy(){
  const amp=+S.amp.value, p=+S.p.value;
  const N=160;
  let prev=0;
  const white=[], qds=[];
  for(let i=0;i<N;i++){
    const eps = randn()*amp;
    white.push(eps);
    const s=Math.sqrt(Math.max(0,1-p*p));
    const v = p*prev + s*eps;
    prev=v; qds.push(v);
  }
  const c=$("noise_canvas");
  const ctx=c.getContext("2d");
  const W=c.width=c.clientWidth*devicePixelRatio;
  const H=c.height=c.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  ctx.strokeStyle="rgba(255,255,255,0.06)";
  ctx.lineWidth=1*devicePixelRatio;
  for(let i=1;i<5;i++){
    const y=H*i/5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  const all=white.concat(qds);
  const maxA=Math.max(...all.map(x=>Math.abs(x)), 1e-6);

  function plot(arr, color){
    ctx.strokeStyle=color; ctx.lineWidth=2*devicePixelRatio;
    ctx.beginPath();
    for(let i=0;i<arr.length;i++){
      const x=(i/(arr.length-1))*W;
      const y=H/2 - (arr[i]/maxA)*(H*0.35);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  plot(white, "rgba(122,162,255,0.9)");
  plot(qds, "rgba(255,115,179,0.85)");

  $("noise_note").textContent = `Trace length ${N}. amp=${amp.toFixed(1)} p=${p.toFixed(2)}.`;
}

// ---------- Export / Share ----------
function formatLog(r){
  return `${r.local} ¬∑ base=${r.base}% ¬∑ amp=${r.amp}% ¬∑ p=${r.p} ¬∑ thr=${r.thr}% ¬∑ n=${r.n} ¬∑ max=${r.maxc}
white Œº=${r.wm} œÉ=${r.ws} ¬∑ QDS Œº=${r.qm} œÉ=${r.qs} ¬∑ Œî=${r.drel}% ¬∑ meanŒî=${r.ddir}
stress: nonlin=${r.ham_nonlin} heat=${r.ham_heat} out=${r.ham_out} ¬∑ bias: paired=${r.paired} noRegen=${r.noregen} blind=${r.blind}`;
}
function exportLast(k){
  const hist=loadHist();
  if(!hist.length){ $("export_out").value="No logs yet."; return ""; }
  const pick = hist.slice(-k);
  const txt = pick.map(formatLog).join("\\n\\n");
  $("export_out").value = txt;
  return txt;
}
async function copyText(txt){
  try{ await navigator.clipboard.writeText(txt); }catch(e){}
}
async function sharePack(){
  const hist=loadHist();
  const last5 = hist.slice(-5).map(formatLog).join("\\n\\n");
  const poster = $("poster_out").value.trim();
  const real = $("real_advice").textContent.trim();

  const pack =
`QDS Battery Suite v6 ‚Äî Share Pack

LAST 5 RUNS
${last5 || "(none)"}

POSTER MODE
${poster || "(no poster run yet)"}

REAL-WORLD COACH (Advice only)
${real || "(no real-world advice yet)"}
`;
  $("export_out").value = pack;
  await copyText(pack);
}

// ---------- Real-world habits ----------
function getHabits(){
  return {
    max:+S.h_max.value, min:+S.h_min.value,
    fast:+S.h_fast.value, heat:+S.h_heat.value,
    overnight:+S.h_overnight.value
  };
}
function habitRiskScore(h){
  // Conservative heuristic scoring (0-100)
  let r=0;

  // High SoC time
  r += clamp((h.max-85)*1.2, 0, 18);
  // Deep dips
  r += clamp((15-h.min)*1.1, 0, 16);
  // Fast charge frequency
  r += h.fast * 3.2; // up to ~22
  // Heat usage hours
  r += h.heat * 6;   // up to ~36
  // Overnight at 100
  r += h.overnight * 2.5; // up to ~17.5

  return clamp(r,0,100);
}
function saveHabits(){
  try{ localStorage.setItem(HABIT_KEY, JSON.stringify(getHabits())); }catch(e){}
}
function loadHabits(){
  try{
    const j = JSON.parse(localStorage.getItem(HABIT_KEY)||"null");
    if(!j) return false;
    S.h_max.value=j.max; S.h_min.value=j.min; S.h_fast.value=j.fast; S.h_heat.value=j.heat; S.h_overnight.value=j.overnight;
    ["h_max","h_min","h_fast","h_heat","h_overnight"].forEach(k=>S[k].dispatchEvent(new Event("input")));
    return true;
  }catch(e){ return false; }
}
function resetHabits(){
  S.h_max.value=95; S.h_min.value=10; S.h_fast.value=4; S.h_heat.value=2; S.h_overnight.value=3;
  ["h_max","h_min","h_fast","h_heat","h_overnight"].forEach(k=>S[k].dispatchEvent(new Event("input")));
  saveHabits();
}

// ---------- Real-world advice builder ----------
function updateRealWorld(){
  const cfg = cfgFromUI(false);
  const simR = simRiskScore(cfg);
  const h = getHabits();
  const habR = habitRiskScore(h);
  const combo = clamp(0.55*habR + 0.45*simR, 0, 100);

  $("habit_risk").textContent = habR.toFixed(0);
  $("sim_risk").textContent = simR.toFixed(0);
  $("combo_risk").textContent = combo.toFixed(0);

  // Cap suggestion derived mainly from habits + heat
  let cap=90;
  if(combo>=65) cap=80;
  else if(combo>=40) cap=85;

  const lines=[];
  lines.push(`Combined daily risk ‚âà ${combo.toFixed(0)}/100.`);
  lines.push(`Suggested routine cap: ${cap}%.`);
  lines.push(`Suggested routine window: ${Math.max(15, h.min)}‚Äì${cap}%.`);

  if(h.heat >= 2) lines.push("Heat is your main lever: remove thick case during charge, avoid sun/car dash.");
  if(h.fast >= 4) lines.push("Fast-charge often: do it when cool; prefer slower top-ups when possible.");
  if(h.overnight >= 3) lines.push("Overnight-to-100 is frequent: use an 80‚Äì90% alarm or top-up closer to morning.");
  if(h.max >= 95) lines.push("High daily max SoC: consider an 85‚Äì90% cap for normal days.");
  if(h.min <= 5) lines.push("Deep dips: try to avoid falling below ~10‚Äì15% regularly.");

  if(LAST_RUN){
    lines.push(`Latest sim footprint: Œî ${LAST_RUN.drel}% with fairness controls.`);
  }else{
    lines.push("Run one Lab sim to attach a fresh fairness-tested footprint.");
  }

  $("real_advice").textContent = lines.join(" ");
}

// ---------- Optional Battery Status API ----------
async function readDeviceBattery(){
  const out = $("batt_readout");
  if(!navigator.getBattery){
    out.textContent = "Battery API not supported in this browser (common on modern mobile). Use habit sliders instead.";
    return;
  }
  try{
    const b = await navigator.getBattery();
    const pct = Math.round(b.level*100);
    const charging = b.charging ? "charging" : "not charging";
    const ttc = (b.chargingTime && isFinite(b.chargingTime)) ? Math.round(b.chargingTime/60) : null;
    const ttd = (b.dischargingTime && isFinite(b.dischargingTime)) ? Math.round(b.dischargingTime/60) : null;

    let msg = `Device reports ~${pct}% and ${charging}.`;
    if(ttc!==null && ttc>0) msg += ` Est. to full: ~${ttc} min.`;
    if(ttd!==null && ttd>0) msg += ` Est. to empty: ~${ttd} min.`;
    out.textContent = msg;
  }catch(e){
    out.textContent = "Battery API read failed. No drama ‚Äî habits mode still works.";
  }
}

// ---------- Presets ----------
function setPreset(obj){
  S.base.value=obj.base; S.amp.value=obj.amp; S.p.value=obj.p;
  S.n.value=obj.n; S.maxc.value=obj.maxc; S.thr.value=obj.thr;
  T.nonlin.checked=obj.nonlin; T.heat.checked=obj.heat; T.out.checked=obj.out;
  T.paired.checked=obj.paired; T.noregen.checked=obj.noregen;

  T.interpret.checked = true;
  T.bias.checked = false;
  T.blind.checked = false;
  syncMode();

  ["base","amp","p","n","maxc","thr"].forEach(k=>S[k].dispatchEvent(new Event("input")));
}
const PRE = {
  real:{base:1.2, amp:1.8, p:0.25, n:1200, maxc:4000, thr:75, nonlin:true, heat:true, out:true, paired:true, noregen:true},
  clean:{base:2.0, amp:2.5, p:0.30, n:1600, maxc:4000, thr:30, nonlin:true, heat:false, out:false, paired:true, noregen:true},
  stress:{base:3.0, amp:5.0, p:0.60, n:2000, maxc:5000, thr:50, nonlin:true, heat:true, out:true, paired:true, noregen:true},
  chaos:{base:6.5, amp:10.0, p:0.95, n:2000, maxc:2600, thr:90, nonlin:true, heat:true, out:true, paired:true, noregen:true}
};

// ---------- Buttons ----------
$("run_once").onclick = runLab;
$("poster_mode").onclick = posterMode;
$("reset_all").onclick = ()=>setPreset(PRE.real);
$("clear_history").onclick = ()=>{ localStorage.removeItem(HIST_KEY); renderHist(); };

$("pre_real").onclick = ()=>setPreset(PRE.real);
$("pre_clean").onclick = ()=>setPreset(PRE.clean);
$("pre_stress").onclick = ()=>setPreset(PRE.stress);
$("pre_chaos").onclick = ()=>setPreset(PRE.chaos);

$("hard_null").onclick = ()=>{ S.p.value=0; S.p.dispatchEvent(new Event("input")); };

$("psweep_quick").onclick = ()=>pSweep([0.00,0.30,0.60,0.90]);
$("psweep_dense").onclick = ()=>{
  const list=[]; for(let x=0;x<=0.9+1e-9;x+=0.1) list.push(Number(x.toFixed(2)));
  pSweep(list);
};
$("tsweep_3").onclick = ()=>tSweep([30,50,75]);
$("tsweep_5").onclick = ()=>tSweep([20,30,50,75,80]);

$("noise_gen").onclick = noiseToy;

$("copy_last").onclick = async ()=>{ const t=exportLast(1); if(t) await copyText(t); };
$("copy_5").onclick = async ()=>{ const t=exportLast(5); if(t) await copyText(t); };
$("share_pack").onclick = sharePack;

$("plan_day").onclick = planDay;

$("read_batt").onclick = readDeviceBattery;

$("save_habits").onclick = ()=>{ saveHabits(); updateRealWorld(); };
$("load_habits").onclick = ()=>{ loadHabits(); updateRealWorld(); };
$("reset_habits").onclick = ()=>{ resetHabits(); updateRealWorld(); };

// Update real-world scores when habit sliders move
["h_max","h_min","h_fast","h_heat","h_overnight"].forEach(k=>{
  S[k].addEventListener("input", updateRealWorld);
});

// ---------- Boot ----------
setPreset(PRE.real);
renderHist();
loadHabits() || resetHabits();
updateCoachFromLast();
updateRealWorld();
noiseToy();
$("poster_out").value = "Tap Poster Mode for the 4-block evidence ladder.";


// --- qds_battery_suite_v8_nextlevel.html ---

/* =========================
   QDS Battery Suite v8
   Next Level (mobile-safe)
========================= */

const $ = id => document.getElementById(id);
const logEl = $("log");

function pad(n){ return String(n).padStart(2,"0"); }
function nowStamp(){
  const d=new Date();
  return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()}, ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function appendLog(s){
  logEl.textContent += s + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

/* Seeded RNG (LCG) */
function makeRNG(seed){
  let s=(seed>>>0)||123456789;
  return function(){
    s=(1664525*s+1013904223)>>>0;
    return s/4294967296;
  }
}
function gauss(rng){
  let u=0,v=0;
  while(u===0) u=rng();
  while(v===0) v=rng();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}
function ar1Eps(rng,p,len){
  const eps=new Array(len);
  let e=gauss(rng);
  eps[0]=e;
  const scale=Math.sqrt(1-p*p);
  for(let i=1;i<len;i++){
    e=p*e + scale*gauss(rng);
    eps[i]=e;
  }
  return eps;
}

/* Deterministic RNG for outliers (seeded) */
function rand01(rng){ return rng(); }

/* Simulate one cell */
function simulateCell(params, epsStream, rng){
  const {base, amp, thr, maxc, nonlin, heat, outlier, noregen} = params;
  let health=100.0, cycles=0;

  const heatPeriod=12;
  const outProb=0.015;

  for(let i=0;i<maxc;i++){
    const eps = epsStream[i] || 0;
    let drain = base + amp*eps;

    if(nonlin){
      const low = clamp((50-health)/50, 0, 1);
      drain *= (1 + 0.6*low);
    }
    if(heat && (i%heatPeriod===0) && i>0){
      drain *= 1.35;
    }
    if(outlier && rand01(rng) < outProb){
      drain *= 2.2;
    }
    if(noregen) drain = Math.max(0, drain);

    health -= drain;
    cycles++;
    if(health <= thr) break;
  }
  return cycles;
}

/* Paired sim (always paired in v8 identity) */
function runPairedSim(params){
  const n=params.n, maxc=params.maxc;
  const p=clamp(params.p,0,0.99);

  const rng = makeRNG(params.seed||12345);
  const rngShock = makeRNG((params.seed||12345) ^ 0xDEADBEEF);

  const whiteLives=new Array(n);
  const qdsLives=new Array(n);
  const deltas=new Array(n);

  for(let k=0;k<n;k++){
    const epsWhite=new Array(maxc);
    for(let i=0;i<maxc;i++) epsWhite[i]=gauss(rng);

    const epsQDS = (p>0) ? ar1Eps(rng, p, maxc) : epsWhite.slice();

    const Lw = simulateCell(params, epsWhite, rngShock);
    const Lq = simulateCell(params, epsQDS,  rngShock);

    whiteLives[k]=Lw; qdsLives[k]=Lq; deltas[k]=Lq-Lw;
  }

  const mean = arr => arr.reduce((a,b)=>a+b,0)/arr.length;
  const std = (arr,m) => Math.sqrt(arr.reduce((s,x)=>{const d=x-m;return s+d*d;},0)/arr.length);

  const wMean=mean(whiteLives), qMean=mean(qdsLives);
  const wStd=std(whiteLives,wMean), qStd=std(qdsLives,qMean);
  const dMean=mean(deltas);
  const pct=(qMean-wMean)/Math.max(1e-9,wMean)*100;

  return {wMean,qMean,wStd,qStd,dMean,pct};
}

/* UI params */
function readParams(){
  let p=parseFloat($("p").value);
  if($("hardnull").checked) p=0;

  const seed = parseInt($("seed").value,10) || 12345;

  return {
    base: parseFloat($("base").value),
    amp: parseFloat($("amp").value),
    p: clamp(p,0,0.99),
    n: Math.max(50, parseInt($("n").value,10)),
    maxc: Math.max(100, parseInt($("maxc").value,10)),
    thr: clamp(parseFloat($("thr").value),0,99),
    nonlin: $("nonlin").checked,
    heat: $("heat").checked,
    outlier: $("outlier").checked,
    paired: $("paired").checked,
    noregen: $("noregen").checked,
    blind: $("blind").checked,
    mobileSafe: $("mobileSafe").checked,
    lockSeed: $("lockSeed").checked,
    seed
  };
}

/* KPI */
function updateKPI(r){
  $("wMean").textContent = r ? r.wMean.toFixed(1) : "‚Äî";
  $("qMean").textContent = r ? r.qMean.toFixed(1) : "‚Äî";
  const pct = r ? r.pct : 0;
  const d = $("delta");
  d.textContent = r ? `${pct.toFixed(1)}%` : "‚Äî";
  d.className = "kval " + (pct>1 ? "good" : (pct<-1 ? "badTxt" : "warnTxt"));
  $("pdelta").textContent = r ? r.dMean.toFixed(2) : "‚Äî";
}

/* Record line */
function recordLine(tag, params, r){
  return `${nowStamp()} ¬∑ ${tag}
base=${params.base}% amp=${params.amp}% p=${params.p} thr=${params.thr}% n=${params.n} max=${params.maxc}
white Œº=${r.wMean.toFixed(1)} œÉ=${r.wStd.toFixed(1)} ¬∑ QDS Œº=${r.qMean.toFixed(1)} œÉ=${r.qStd.toFixed(1)}
Œî=${r.pct.toFixed(1)}% ¬∑ meanŒî=${r.dMean.toFixed(2)}
stress: nonlin=${params.nonlin} heat=${params.heat} out=${params.outlier}
bias: paired=${params.paired} noRegen=${params.noregen} blind=${params.blind}\n`;
}

/* Run with params (seed handling) */
function runWithParams(tag, params, seedBump=0){
  const baseSeed = readParams().seed;
  params.seed = params.lockSeed ? (baseSeed + seedBump) >>> 0 : ((Date.now() + seedBump) >>> 0);

  const r = runPairedSim(params);
  updateKPI(r);
  appendLog(recordLine(tag, params, r));
  return r;
}

/* Manual single run */
function runSingle(){
  const params = readParams();
  return runWithParams("Manual", params, 17);
}

/* Ladder presets (mobile-safe scaling) */
function ladderPresets(){
  const baseParams = readParams();
  const C = o => JSON.parse(JSON.stringify(o));
  const safe = baseParams.mobileSafe;

  const A = C(baseParams);
  A.amp=0.0; A.p=0.25; A.thr=50; A.n= safe? 900:1200; A.maxc=safe? 3000:4000;

  const B = C(baseParams);
  B.amp=1.8; B.p=0.0;  B.thr=50; B.n= safe? 900:1200; B.maxc=safe? 3000:4000; B.blind=false;

  const Cb = C(B);
  Cb.blind=true;

  const D = C(baseParams);
  D.base=1.2; D.amp=1.8; D.p=0.25; D.thr=30;
  D.n=safe? 1200:1600; D.maxc=safe? 3500:4000;

  const E = C(baseParams);
  E.base=3.0; E.amp=5.0; E.p=0.60; E.thr=50;
  E.n=safe? 1400:2000; E.maxc=safe? 4000:5000;

  const F = C(baseParams);
  F.base=8.0; F.amp=14.0; F.p=0.99; F.thr=95;
  F.n=safe? 1200:2000; F.maxc=safe? 4000:6000;

  return [
    {tag:`Ladder A ‚Äî amp=0 control${safe?" (safe)":""}`, params:A},
    {tag:`Ladder B ‚Äî hard null p=0${safe?" (safe)":""}`, params:B},
    {tag:`Ladder C ‚Äî blind null${safe?" (safe)":""}`, params:Cb},
    {tag:`Ladder D ‚Äî realistic phone${safe?" (safe)":""}`, params:D},
    {tag:`Ladder E ‚Äî controlled stress${safe?" (safe)":""}`, params:E},
    {tag:`Ladder F ‚Äî pathological honesty${safe?" (safe)":""}`, params:F},
  ];
}

/* Full pathological (separate nuke) */
function fullPathPreset(){
  const p = readParams();
  return {
    ...p,
    base: 8.0, amp: 14.0, p: 0.99, thr: 95,
    n: 5000, maxc: 8000,
    nonlin: true, heat: true, outlier: true,
    mobileSafe: false
  };
}

/* Sampler (lightweight families) */
function sampleScenarios(count){
  const base = readParams();
  const rng = makeRNG(base.seed ^ 0xA5A5A5A5);
  const out=[];

  for(let i=0;i<count;i++){
    const fam = i%4;
    let baseD, amp, p, thr, n, maxc;

    if(fam===0){ // phone
      baseD=1.0+0.6*rng(); amp=1.2+1.4*rng(); p=0.10+0.25*rng();
      thr=[20,30,50][Math.floor(rng()*3)]; n=1200; maxc=4000;
    } else if(fam===1){ // laptop
      baseD=0.6+0.5*rng(); amp=0.8+1.2*rng(); p=0.05+0.20*rng();
      thr=[20,30,40][Math.floor(rng()*3)]; n=1400; maxc=6000;
    } else if(fam===2){ // EV-toy
      baseD=0.25+0.25*rng(); amp=0.3+0.5*rng(); p=0.05+0.25*rng();
      thr=[60,70,80][Math.floor(rng()*3)]; n=1800; maxc=12000;
    } else { // grid-toy
      baseD=0.15+0.20*rng(); amp=0.2+0.4*rng(); p=0.02+0.18*rng();
      thr=[70,80,85][Math.floor(rng()*3)]; n=2000; maxc=20000;
    }

    out.push({
      tag:`Sampler ${i+1} ‚Äî ${["phone","laptop","EV-toy","grid-toy"][fam]}`,
      params:{
        ...base,
        base:+baseD.toFixed(2), amp:+amp.toFixed(2), p:+p.toFixed(2),
        thr, n, maxc
      }
    });
  }
  return out;
}

/* Buttons */
$("runOne").onclick = runSingle;

$("runLadder").onclick = async () => {
  appendLog("=== Poster Ladder v8 (async, safe-aware) ===\n");
  const ladder = ladderPresets();
  let bump=0;
  for(const item of ladder){
    await sleep(35);
    runWithParams(item.tag, item.params, bump+=101);
  }
  appendLog("=== End ladder ===\n");
};

$("runStability").onclick = async () => {
  const p = readParams();
  appendLog("=== 3-Seed Stability ===");
  const seeds = [111,222,333];
  let pctSum=0, dSum=0, min=999, max=-999;

  for(let i=0;i<3;i++){
    await sleep(25);
    const params = {...p, seed: seeds[i], lockSeed:true};
    const r = runPairedSim(params);
    pctSum += r.pct; dSum += r.dMean;
    min = Math.min(min, r.pct); max = Math.max(max, r.pct);
    updateKPI(r);
    appendLog(recordLine(`Stability seed=${seeds[i]}`, params, r));
  }

  const pctAvg = pctSum/3;
  const dAvg = dSum/3;
  const grade = Math.abs(pctAvg) < 0.6 ? "A (neutral/stable)" :
                Math.abs(pctAvg) < 1.5 ? "B (mild signal)" :
                "C (strongly regime-sensitive)";

  appendLog(`Stability summary: mean Œî=${pctAvg.toFixed(2)}% (range ${min.toFixed(2)} ‚Üí ${max.toFixed(2)}), meanŒîcycles=${dAvg.toFixed(2)} ¬∑ Grade ${grade}\n`);
};

$("runBench").onclick = async () => {
  const count = Math.max(4, parseInt($("benchCount").value,10) || 12);
  appendLog("=== AutoBench v8 start ===");
  appendLog(`Seed=${readParams().seed} ‚Ä¢ Sampler=${count} ‚Ä¢ MobileSafe=${readParams().mobileSafe}\n`);

  const ladder = ladderPresets();
  let bump=0;
  for(const item of ladder){
    await sleep(25);
    runWithParams(item.tag, item.params, bump+=77);
  }

  appendLog("=== Sampler ===");
  const samples = sampleScenarios(count);
  for(const s of samples){
    await sleep(15);
    runWithParams(s.tag, s.params, bump+=33);
  }

  appendLog("=== AutoBench end ===\n");
};

$("runFullPath").onclick = async () => {
  appendLog("=== FULL PATHOLOGICAL RUN (heavy) ===");
  appendLog("If this stutters on mobile, lower n/max or toggle Mobile Safe back ON.\n");
  await sleep(30);
  const params = fullPathPreset();
  runWithParams("Pathological ‚Äî full load", params, 999);
  appendLog("=== End full pathological ===\n");
};

$("clearLog").onclick = () => logEl.textContent="";

$("reset").onclick = () => {
  $("base").value=1.2; $("amp").value=1.8; $("p").value=0.25;
  $("n").value=1200; $("maxc").value=4000; $("thr").value=50;
  $("nonlin").checked=false; $("heat").checked=false; $("outlier").checked=false;
  $("paired").checked=true; $("noregen").checked=true; $("blind").checked=false; $("hardnull").checked=false;
  $("mobileSafe").checked=true; $("lockSeed").checked=true;
  $("seed").value=12345; $("benchCount").value=12;
  updateKPI(null); appendLog("‚Äî Reset to defaults ‚Äî\n");
};


// --- qds_battery_suite_v8_1_fairpath.html ---

/* =========================
   QDS Battery Suite v8.1
   Fair-Path Fix
   - true paired outliers
   - poster-safe F
   - low-baseline % guard
========================= */

const $ = id => document.getElementById(id);
const logEl = $("log");

function pad(n){ return String(n).padStart(2,"0"); }
function nowStamp(){
  const d=new Date();
  return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()}, ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function appendLog(s){
  logEl.textContent += s + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

/* Seeded RNG (LCG) */
function makeRNG(seed){
  let s=(seed>>>0)||123456789;
  return function(){
    s=(1664525*s+1013904223)>>>0;
    return s/4294967296;
  }
}
function gauss(rng){
  let u=0,v=0;
  while(u===0) u=rng();
  while(v===0) v=rng();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}
function ar1Eps(rng,p,len){
  const eps=new Array(len);
  let e=gauss(rng);
  eps[0]=e;
  const scale=Math.sqrt(1-p*p);
  for(let i=1;i<len;i++){
    e=p*e + scale*gauss(rng);
    eps[i]=e;
  }
  return eps;
}

/* Simulate one cell with paired shock stream */
function simulateCell(params, epsStream, shockStream){
  const {base, amp, thr, maxc, nonlin, heat, outlier, noregen} = params;
  let health=100.0, cycles=0;

  const heatPeriod=12;
  const outProb=0.015;

  for(let i=0;i<maxc;i++){
    const eps = epsStream[i] || 0;
    let drain = base + amp*eps;

    if(nonlin){
      const low = clamp((50-health)/50, 0, 1);
      drain *= (1 + 0.6*low);
    }
    if(heat && (i%heatPeriod===0) && i>0){
      drain *= 1.35;
    }
    if(outlier && (shockStream[i] < outProb)){
      drain *= 2.2;
    }
    if(noregen) drain = Math.max(0, drain);

    health -= drain;
    cycles++;
    if(health <= thr) break;
  }
  return cycles;
}

/* Paired sim */
function runPairedSim(params){
  const n=params.n, maxc=params.maxc;
  const p=clamp(params.p,0,0.99);

  const rng = makeRNG(params.seed||12345);

  const whiteLives=new Array(n);
  const qdsLives=new Array(n);
  const deltas=new Array(n);

  for(let k=0;k<n;k++){
    // white eps
    const epsWhite=new Array(maxc);
    for(let i=0;i<maxc;i++) epsWhite[i]=gauss(rng);

    // qds eps (correlated) or identical when p=0
    const epsQDS = (p>0) ? ar1Eps(rng, p, maxc) : epsWhite.slice();

    // TRUE paired outliers: cell-specific shock stream shared
    const rngCell = makeRNG(((params.seed||12345) ^ (k*2654435761))>>>0);
    const shockStream = new Array(maxc);
    for(let i=0;i<maxc;i++) shockStream[i]=rngCell();

    const Lw = simulateCell(params, epsWhite, shockStream);
    const Lq = simulateCell(params, epsQDS,  shockStream);

    whiteLives[k]=Lw; qdsLives[k]=Lq; deltas[k]=Lq-Lw;
  }

  const mean = arr => arr.reduce((a,b)=>a+b,0)/arr.length;
  const std = (arr,m) => Math.sqrt(arr.reduce((s,x)=>{const d=x-m;return s+d*d;},0)/arr.length);

  const wMean=mean(whiteLives), qMean=mean(qdsLives);
  const wStd=std(whiteLives,wMean), qStd=std(qdsLives,qMean);
  const dMean=mean(deltas);

  // low-baseline guard to avoid absurd % in pathological thresholds
  const pct = (wMean < 5) ? NaN : (qMean-wMean)/Math.max(1e-9,wMean)*100;

  return {wMean,qMean,wStd,qStd,dMean,pct};
}

/* UI params */
function readParams(){
  let p=parseFloat($("p").value);
  if($("hardnull").checked) p=0;

  const seed = parseInt($("seed").value,10) || 12345;

  return {
    base: parseFloat($("base").value),
    amp: parseFloat($("amp").value),
    p: clamp(p,0,0.99),
    n: Math.max(50, parseInt($("n").value,10)),
    maxc: Math.max(100, parseInt($("maxc").value,10)),
    thr: clamp(parseFloat($("thr").value),0,99),
    nonlin: $("nonlin").checked,
    heat: $("heat").checked,
    outlier: $("outlier").checked,
    paired: $("paired").checked,
    noregen: $("noregen").checked,
    blind: $("blind").checked,
    mobileSafe: $("mobileSafe").checked,
    lockSeed: $("lockSeed").checked,
    seed
  };
}

/* KPI */
function updateKPI(r){
  $("wMean").textContent = r ? r.wMean.toFixed(1) : "‚Äî";
  $("qMean").textContent = r ? r.qMean.toFixed(1) : "‚Äî";

  const d = $("delta");
  if(!r){ d.textContent="‚Äî"; d.className="kval"; }
  else if(Number.isNaN(r.pct)){
    d.textContent = "n/a (low baseline)";
    d.className="kval warnTxt";
  } else {
    d.textContent = `${r.pct.toFixed(1)}%`;
    d.className = "kval " + (r.pct>1 ? "good" : (r.pct<-1 ? "badTxt" : "warnTxt"));
  }

  $("pdelta").textContent = r ? r.dMean.toFixed(2) : "‚Äî";
}

/* Record line */
function recordLine(tag, params, r){
  const pctTxt = Number.isNaN(r.pct) ? "n/a(low baseline)" : `${r.pct.toFixed(1)}%`;
  return `${nowStamp()} ¬∑ ${tag}
base=${params.base}% amp=${params.amp}% p=${params.p} thr=${params.thr}% n=${params.n} max=${params.maxc}
white Œº=${r.wMean.toFixed(1)} œÉ=${r.wStd.toFixed(1)} ¬∑ QDS Œº=${r.qMean.toFixed(1)} œÉ=${r.qStd.toFixed(1)}
Œî=${pctTxt} ¬∑ meanŒî=${r.dMean.toFixed(2)}
stress: nonlin=${params.nonlin} heat=${params.heat} out=${params.outlier}
bias: paired=${params.paired} noRegen=${params.noregen} blind=${params.blind}\n`;
}

/* Run with params */
function runWithParams(tag, params, seedBump=0){
  const baseSeed = readParams().seed;
  params.seed = params.lockSeed ? (baseSeed + seedBump) >>> 0 : ((Date.now() + seedBump) >>> 0);

  const r = runPairedSim(params);
  updateKPI(r);
  appendLog(recordLine(tag, params, r));
  return r;
}

/* Manual single run */
function runSingle(){
  const params = readParams();
  return runWithParams("Manual", params, 17);
}

/* Ladder presets (poster-safe F) */
function ladderPresets(){
  const baseParams = readParams();
  const C = o => JSON.parse(JSON.stringify(o));
  const safe = baseParams.mobileSafe;

  const A = C(baseParams);
  A.amp=0.0; A.p=0.25; A.thr=50; A.n= safe? 900:1200; A.maxc=safe? 3000:4000;

  const B = C(baseParams);
  B.amp=1.8; B.p=0.0;  B.thr=50; B.n= safe? 900:1200; B.maxc=safe? 3000:4000; B.blind=false;

  const Cb = C(B);
  Cb.blind=true;

  const D = C(baseParams);
  D.base=1.2; D.amp=1.8; D.p=0.25; D.thr=30;
  D.n=safe? 1200:1600; D.maxc=safe? 3500:4000;

  const E = C(baseParams);
  E.base=3.0; E.amp=5.0; E.p=0.60; E.thr=50;
  E.n=safe? 1400:2000; E.maxc=safe? 4000:5000;

  // Poster-safe F: avoid thr=95 here to prevent % absurdity
  const F = C(baseParams);
  F.base=8.0; F.amp=14.0; F.p=0.99;
  F.thr=80;
  F.n=safe? 1200:2000; F.maxc=safe? 4000:6000;

  return [
    {tag:`Ladder A ‚Äî amp=0 control${safe?" (safe)":""}`, params:A},
    {tag:`Ladder B ‚Äî hard null p=0${safe?" (safe)":""}`, params:B},
    {tag:`Ladder C ‚Äî blind null${safe?" (safe)":""}`, params:Cb},
    {tag:`Ladder D ‚Äî realistic phone${safe?" (safe)":""}`, params:D},
    {tag:`Ladder E ‚Äî controlled stress${safe?" (safe)":""}`, params:E},
    {tag:`Ladder F ‚Äî pathological honesty (poster-safe)${safe?" (safe)":""}`, params:F},
  ];
}

/* Full pathological (true harsh) */
function fullPathPreset(){
  const p = readParams();
  return {
    ...p,
    base: 8.0, amp: 14.0, p: 0.99, thr: 95,
    n: 5000, maxc: 8000,
    nonlin: true, heat: true, outlier: true,
    mobileSafe: false
  };
}

/* Sampler */
function sampleScenarios(count){
  const base = readParams();
  const rng = makeRNG(base.seed ^ 0xA5A5A5A5);
  const out=[];

  for(let i=0;i<count;i++){
    const fam = i%4;
    let baseD, amp, p, thr, n, maxc;

    if(fam===0){
      baseD=1.0+0.6*rng(); amp=1.2+1.4*rng(); p=0.10+0.25*rng();
      thr=[20,30,50][Math.floor(rng()*3)]; n=1200; maxc=4000;
    } else if(fam===1){
      baseD=0.6+0.5*rng(); amp=0.8+1.2*rng(); p=0.05+0.20*rng();
      thr=[20,30,40][Math.floor(rng()*3)]; n=1400; maxc=6000;
    } else if(fam===2){
      baseD=0.25+0.25*rng(); amp=0.3+0.5*rng(); p=0.05+0.25*rng();
      thr=[60,70,80][Math.floor(rng()*3)]; n=1800; maxc=12000;
    } else {
      baseD=0.15+0.20*rng(); amp=0.2+0.4*rng(); p=0.02+0.18*rng();
      thr=[70,80,85][Math.floor(rng()*3)]; n=2000; maxc=20000;
    }

    out.push({
      tag:`Sampler ${i+1} ‚Äî ${["phone","laptop","EV-toy","grid-toy"][fam]}`,
      params:{
        ...base,
        base:+baseD.toFixed(2), amp:+amp.toFixed(2), p:+p.toFixed(2),
        thr, n, maxc
      }
    });
  }
  return out;
}

/* Buttons */
$("runOne").onclick = runSingle;

$("runLadder").onclick = async () => {
  appendLog("=== Poster Ladder v8.1 (async, safe-aware) ===\n");
  const ladder = ladderPresets();
  let bump=0;
  for(const item of ladder){
    await sleep(35);
    runWithParams(item.tag, item.params, bump+=101);
  }
  appendLog("=== End ladder ===\n");
};

$("runStability").onclick = async () => {
  const p = readParams();
  appendLog("=== 3-Seed Stability ===");
  const seeds = [111,222,333];
  let pctSum=0, dSum=0, min=999, max=-999, valid=0;

  for(let i=0;i<3;i++){
    await sleep(25);
    const params = {...p, seed: seeds[i], lockSeed:true};
    const r = runPairedSim(params);
    updateKPI(r);
    appendLog(recordLine(`Stability seed=${seeds[i]}`, params, r));

    if(!Number.isNaN(r.pct)){
      pctSum += r.pct; dSum += r.dMean;
      min = Math.min(min, r.pct); max = Math.max(max, r.pct);
      valid++;
    }
  }

  if(valid===0){
    appendLog("Stability summary: Œî n/a (low baseline across seeds)\n");
    return;
  }

  const pctAvg = pctSum/valid;
  const dAvg = dSum/valid;
  const grade = Math.abs(pctAvg) < 0.6 ? "A (neutral/stable)" :
                Math.abs(pctAvg) < 1.5 ? "B (mild signal)" :
                "C (strongly regime-sensitive)";

  appendLog(`Stability summary: mean Œî=${pctAvg.toFixed(2)}% (range ${min.toFixed(2)} ‚Üí ${max.toFixed(2)}), meanŒîcycles=${dAvg.toFixed(2)} ¬∑ Grade ${grade}\n`);
};

$("runBench").onclick = async () => {
  const count = Math.max(4, parseInt($("benchCount").value,10) || 12);
  appendLog("=== AutoBench v8.1 start ===");
  appendLog(`Seed=${readParams().seed} ‚Ä¢ Sampler=${count} ‚Ä¢ MobileSafe=${readParams().mobileSafe}\n`);

  const ladder = ladderPresets();
  let bump=0;
  for(const item of ladder){
    await sleep(25);
    runWithParams(item.tag, item.params, bump+=77);
  }

  appendLog("=== Sampler ===");
  const samples = sampleScenarios(count);
  for(const s of samples){
    await sleep(15);
    runWithParams(s.tag, s.params, bump+=33);
  }

  appendLog("=== AutoBench end ===\n");
};

$("runFullPath").onclick = async () => {
  appendLog("=== FULL PATHOLOGICAL RUN (heavy) ===");
  appendLog("True harsh threshold=95 + big n/max. Œî% may be n/a due to low baseline guard.\n");
  await sleep(30);
  const params = fullPathPreset();
  runWithParams("Pathological ‚Äî full load", params, 999);
  appendLog("=== End full pathological ===\n");
};

$("clearLog").onclick = () => logEl.textContent="";

$("reset").onclick = () => {
  $("base").value=1.2; $("amp").value=1.8; $("p").value=0.25;
  $("n").value=1200; $("maxc").value=4000; $("thr").value=50;
  $("nonlin").checked=false; $("heat").checked=false; $("outlier").checked=false;
  $("paired").checked=true; $("noregen").checked=true; $("blind").checked=false; $("hardnull").checked=false;
  $("mobileSafe").checked=true; $("lockSeed").checked=true;
  $("seed").value=12345; $("benchCount").value=12;
  updateKPI(null); appendLog("‚Äî Reset to defaults ‚Äî\n");
};


// --- qds_battery_suite_v8_2_poster_tamed.html ---

/* =========================
   QDS Battery Suite v8.2
   Poster-Tamed
   - true paired outliers
   - low-baseline % guard
   - Poster Ladder F is high-corr sanity (not clamp-zoo)
========================= */

const $ = id => document.getElementById(id);
const logEl = $("log");

function pad(n){ return String(n).padStart(2,"0"); }
function nowStamp(){
  const d=new Date();
  return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()}, ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function appendLog(s){
  logEl.textContent += s + "\n";
  logEl.scrollTop = logEl.scrollHeight;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

/* Seeded RNG (LCG) */
function makeRNG(seed){
  let s=(seed>>>0)||123456789;
  return function(){
    s=(1664525*s+1013904223)>>>0;
    return s/4294967296;
  }
}
function gauss(rng){
  let u=0,v=0;
  while(u===0) u=rng();
  while(v===0) v=rng();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}
function ar1Eps(rng,p,len){
  const eps=new Array(len);
  let e=gauss(rng);
  eps[0]=e;
  const scale=Math.sqrt(1-p*p);
  for(let i=1;i<len;i++){
    e=p*e + scale*gauss(rng);
    eps[i]=e;
  }
  return eps;
}

/* Simulate one cell with paired shock stream */
function simulateCell(params, epsStream, shockStream){
  const {base, amp, thr, maxc, nonlin, heat, outlier, noregen} = params;
  let health=100.0, cycles=0;

  const heatPeriod=12;
  const outProb=0.015;

  for(let i=0;i<maxc;i++){
    const eps = epsStream[i] || 0;
    let drain = base + amp*eps;

    if(nonlin){
      const low = clamp((50-health)/50, 0, 1);
      drain *= (1 + 0.6*low);
    }
    if(heat && (i%heatPeriod===0) && i>0){
      drain *= 1.35;
    }
    if(outlier && (shockStream[i] < outProb)){
      drain *= 2.2;
    }
    if(noregen) drain = Math.max(0, drain);

    health -= drain;
    cycles++;
    if(health <= thr) break;
  }
  return cycles;
}

/* Paired sim */
function runPairedSim(params){
  const n=params.n, maxc=params.maxc;
  const p=clamp(params.p,0,0.99);
  const rng = makeRNG(params.seed||12345);

  const whiteLives=new Array(n);
  const qdsLives=new Array(n);
  const deltas=new Array(n);

  for(let k=0;k<n;k++){
    const epsWhite=new Array(maxc);
    for(let i=0;i<maxc;i++) epsWhite[i]=gauss(rng);

    const epsQDS = (p>0) ? ar1Eps(rng, p, maxc) : epsWhite.slice();

    // TRUE paired outliers: identical shock stream per cell
    const rngCell = makeRNG(((params.seed||12345) ^ (k*2654435761))>>>0);
    const shockStream = new Array(maxc);
    for(let i=0;i<maxc;i++) shockStream[i]=rngCell();

    const Lw = simulateCell(params, epsWhite, shockStream);
    const Lq = simulateCell(params, epsQDS,  shockStream);

    whiteLives[k]=Lw; qdsLives[k]=Lq; deltas[k]=Lq-Lw;
  }

  const mean = arr => arr.reduce((a,b)=>a+b,0)/arr.length;
  const std = (arr,m) => Math.sqrt(arr.reduce((s,x)=>{const d=x-m;return s+d*d;},0)/arr.length);

  const wMean=mean(whiteLives), qMean=mean(qdsLives);
  const wStd=std(whiteLives,wMean), qStd=std(qdsLives,qMean);
  const dMean=mean(deltas);

  const pct = (wMean < 5) ? NaN : (qMean-wMean)/Math.max(1e-9,wMean)*100;

  return {wMean,qMean,wStd,qStd,dMean,pct};
}

/* UI params */
function readParams(){
  let p=parseFloat($("p").value);
  if($("hardnull").checked) p=0;

  const seed = parseInt($("seed").value,10) || 12345;

  return {
    base: parseFloat($("base").value),
    amp: parseFloat($("amp").value),
    p: clamp(p,0,0.99),
    n: Math.max(50, parseInt($("n").value,10)),
    maxc: Math.max(100, parseInt($("maxc").value,10)),
    thr: clamp(parseFloat($("thr").value),0,99),
    nonlin: $("nonlin").checked,
    heat: $("heat").checked,
    outlier: $("outlier").checked,
    paired: $("paired").checked,
    noregen: $("noregen").checked,
    blind: $("blind").checked,
    mobileSafe: $("mobileSafe").checked,
    lockSeed: $("lockSeed").checked,
    seed
  };
}

/* KPI */
function updateKPI(r){
  $("wMean").textContent = r ? r.wMean.toFixed(1) : "‚Äî";
  $("qMean").textContent = r ? r.qMean.toFixed(1) : "‚Äî";

  const d = $("delta");
  if(!r){ d.textContent="‚Äî"; d.className="kval"; }
  else if(Number.isNaN(r.pct)){
    d.textContent = "n/a (low baseline)";
    d.className="kval warnTxt";
  } else {
    d.textContent = `${r.pct.toFixed(1)}%`;
    d.className = "kval " + (r.pct>1 ? "good" : (r.pct<-1 ? "badTxt" : "warnTxt"));
  }

  $("pdelta").textContent = r ? r.dMean.toFixed(2) : "‚Äî";
}

/* Record line */
function recordLine(tag, params, r){
  const pctTxt = Number.isNaN(r.pct) ? "n/a(low baseline)" : `${r.pct.toFixed(1)}%`;
  return `${nowStamp()} ¬∑ ${tag}
base=${params.base}% amp=${params.amp}% p=${params.p} thr=${params.thr}% n=${params.n} max=${params.maxc}
white Œº=${r.wMean.toFixed(1)} œÉ=${r.wStd.toFixed(1)} ¬∑ QDS Œº=${r.qMean.toFixed(1)} œÉ=${r.qStd.toFixed(1)}
Œî=${pctTxt} ¬∑ meanŒî=${r.dMean.toFixed(2)}
stress: nonlin=${params.nonlin} heat=${params.heat} out=${params.outlier}
bias: paired=${params.paired} noRegen=${params.noregen} blind=${params.blind}\n`;
}

/* Run with params */
function runWithParams(tag, params, seedBump=0){
  const baseSeed = readParams().seed;
  params.seed = params.lockSeed ? (baseSeed + seedBump) >>> 0 : ((Date.now() + seedBump) >>> 0);

  const r = runPairedSim(params);
  updateKPI(r);
  appendLog(recordLine(tag, params, r));
  return r;
}

/* Manual single run */
function runSingle(){
  const params = readParams();
  return runWithParams("Manual", params, 17);
}

/* Poster Ladder presets (clean blocks) */
function ladderPresets(){
  const baseParams = readParams();
  const C = o => JSON.parse(JSON.stringify(o));
  const safe = baseParams.mobileSafe;

  function clean(p){
    p.nonlin=false; p.heat=false; p.outlier=false;
    return p;
  }

  const A = clean(C(baseParams));
  A.amp=0.0; A.p=0.25; A.thr=50; A.n=safe?900:1200; A.maxc=safe?3000:4000;

  const B = clean(C(baseParams));
  B.amp=1.8; B.p=0.0; B.thr=50; B.n=safe?900:1200; B.maxc=safe?3000:4000; B.blind=false;

  const Cb = clean(C(B));
  Cb.blind=true;

  const D = clean(C(baseParams));
  D.base=1.2; D.amp=1.8; D.p=0.25; D.thr=30; D.n=safe?1200:1600; D.maxc=safe?3500:4000;

  const E = clean(C(baseParams));
  E.base=3.0; E.amp=5.0; E.p=0.60; E.thr=50; E.n=safe?1400:2000; E.maxc=safe?4000:5000;

  // Poster-safe F: high-correlation sanity (not clamp-exploit arena)
  const F = clean(C(baseParams));
  F.base=3.0; F.amp=5.0; F.p=0.90; F.thr=50; F.n=safe?1200:1800; F.maxc=safe?4000:5000;

  return [
    {tag:`Ladder A ‚Äî amp=0 control${safe?" (safe)":""}`, params:A},
    {tag:`Ladder B ‚Äî hard null p=0${safe?" (safe)":""}`, params:B},
    {tag:`Ladder C ‚Äî blind null${safe?" (safe)":""}`, params:Cb},
    {tag:`Ladder D ‚Äî realistic phone${safe?" (safe)":""}`, params:D},
    {tag:`Ladder E ‚Äî controlled stress${safe?" (safe)":""}`, params:E},
    {tag:`Ladder F ‚Äî high-correlation sanity${safe?" (safe)":""}`, params:F},
  ];
}

/* Full pathological (toy extreme) */
function fullPathPreset(){
  const p = readParams();
  return {
    ...p,
    base: 8.0, amp: 14.0, p: 0.99, thr: 95,
    n: 5000, maxc: 8000,
    nonlin: true, heat: true, outlier: true,
    mobileSafe: false
  };
}

/* Sampler */
function sampleScenarios(count){
  const base = readParams();
  const rng = makeRNG(base.seed ^ 0xA5A5A5A5);
  const out=[];

  for(let i=0;i<count;i++){
    const fam = i%4;
    let baseD, amp, p, thr, n, maxc;

    if(fam===0){
      baseD=1.0+0.6*rng(); amp=1.2+1.4*rng(); p=0.10+0.25*rng();
      thr=[20,30,50][Math.floor(rng()*3)]; n=1200; maxc=4000;
    } else if(fam===1){
      baseD=0.6+0.5*rng(); amp=0.8+1.2*rng(); p=0.05+0.20*rng();
      thr=[20,30,40][Math.floor(rng()*3)]; n=1400; maxc=6000;
    } else if(fam===2){
      baseD=0.25+0.25*rng(); amp=0.3+0.5*rng(); p=0.05+0.25*rng();
      thr=[60,70,80][Math.floor(rng()*3)]; n=1800; maxc=12000;
    } else {
      baseD=0.15+0.20*rng(); amp=0.2+0.4*rng(); p=0.02+0.18*rng();
      thr=[70,80,85][Math.floor(rng()*3)]; n=2000; maxc=20000;
    }

    out.push({
      tag:`Sampler ${i+1} ‚Äî ${["phone","laptop","EV-toy","grid-toy"][fam]}`,
      params:{...base, base:+baseD.toFixed(2), amp:+amp.toFixed(2), p:+p.toFixed(2), thr, n, maxc}
    });
  }
  return out;
}

/* Buttons */
$("runOne").onclick = runSingle;

$("runLadder").onclick = async () => {
  appendLog("=== Poster Ladder v8.2 (poster-safe) ===\n");
  const ladder = ladderPresets();
  let bump=0;
  for(const item of ladder){
    await sleep(35);
    runWithParams(item.tag, item.params, bump+=101);
  }
  appendLog("=== End ladder ===\n");
};

$("runStability").onclick = async () => {
  const p = readParams();
  appendLog("=== 3-Seed Stability ===");
  const seeds = [111,222,333];
  let pctSum=0, dSum=0, min=999, max=-999, valid=0;

  for(let i=0;i<3;i++){
    await sleep(25);
    const params = {...p, seed: seeds[i], lockSeed:true};
    const r = runPairedSim(params);
    updateKPI(r);
    appendLog(recordLine(`Stability seed=${seeds[i]}`, params, r));

    if(!Number.isNaN(r.pct)){
      pctSum += r.pct; dSum += r.dMean;
      min = Math.min(min, r.pct); max = Math.max(max, r.pct);
      valid++;
    }
  }

  if(valid===0){
    appendLog("Stability summary: Œî n/a (low baseline across seeds)\n");
    return;
  }

  const pctAvg = pctSum/valid;
  const dAvg = dSum/valid;
  const grade = Math.abs(pctAvg) < 0.6 ? "A (neutral/stable)" :
                Math.abs(pctAvg) < 1.5 ? "B (mild signal)" :
                "C (strongly regime-sensitive)";

  appendLog(`Stability summary: mean Œî=${pctAvg.toFixed(2)}% (range ${min.toFixed(2)} ‚Üí ${max.toFixed(2)}), meanŒîcycles=${dAvg.toFixed(2)} ¬∑ Grade ${grade}\n`);
};

$("runBench").onclick = async () => {
  const count = Math.max(4, parseInt($("benchCount").value,10) || 12);
  appendLog("=== AutoBench v8.2 start ===");
  appendLog(`Seed=${readParams().seed} ‚Ä¢ Sampler=${count} ‚Ä¢ MobileSafe=${readParams().mobileSafe}\n`);

  const ladder = ladderPresets();
  let bump=0;
  for(const item of ladder){
    await sleep(25);
    runWithParams(item.tag, item.params, bump+=77);
  }

  appendLog("=== Sampler ===");
  const samples = sampleScenarios(count);
  for(const s of samples){
    await sleep(15);
    runWithParams(s.tag, s.params, bump+=33);
  }

  appendLog("=== AutoBench end ===\n");
};

$("runFullPath").onclick = async () => {
  appendLog("=== FULL PATHOLOGICAL RUN (extreme toy regime) ===");
  appendLog("High p + NoRegen can create clamp-driven artefacts. Œî% may be n/a.\n");
  await sleep(30);
  const params = fullPathPreset();
  runWithParams("Pathological ‚Äî full load", params, 999);
  appendLog("=== End full pathological ===\n");
};

$("clearLog").onclick = () => logEl.textContent="";

$("reset").onclick = () => {
  $("base").value=1.2; $("amp").value=1.8; $("p").value=0.25;
  $("n").value=1200; $("maxc").value=4000; $("thr").value=50;
  $("nonlin").checked=false; $("heat").checked=false; $("outlier").checked=false;
  $("paired").checked=true; $("noregen").checked=true; $("blind").checked=false; $("hardnull").checked=false;
  $("mobileSafe").checked=true; $("lockSeed").checked=true;
  $("seed").value=12345; $("benchCount").value=12;
  updateKPI(null); appendLog("‚Äî Reset to defaults ‚Äî\n");
};


// --- qds_battery_suite_v8_3_neon_shell.html ---

  // -------- utility: RNG + timestamp ---------------------------------
  function mulberry32(a) {
    return function() {
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function timestamp() {
    const d = new Date();
    const pad = n => String(n).padStart(2, "0");
    return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()}, ` +
           `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  function appendReport(line) {
    const ta = document.getElementById("report");
    ta.value += (ta.value ? "\n" : "") + line;
    ta.scrollTop = ta.scrollHeight;
  }

  function clearReport() {
    document.getElementById("report").value = "";
  }

  // -------- core simulation ------------------------------------------
  function runScenario(opts) {
    const {
      base, amp, p, thr, n, maxCycles,
      stressNonlin, stressHeat, stressOutliers,
      paired, noRegen, hardNull,
      seed
    } = opts;

    // Clamp / sanity
    const N = Math.max(10, Math.floor(n));
    const maxC = Math.max(10, Math.floor(maxCycles));
    const thrVal = Math.min(99, Math.max(1, thr));
    const pEff = hardNull ? 0 : Math.min(0.99, Math.max(0, p));

    const rng = mulberry32(seed >>> 0);

    const whiteCycles = new Array(N);
    const qdsCycles = new Array(N);

    for (let i = 0; i < N; i++) {
      let hW = 100;
      let hQ = 100;
      let aliveW = true;
      let aliveQ = true;
      let failW = maxC;
      let failQ = maxC;
      let qPrevNoise = 0;

      for (let cyc = 1; cyc <= maxC; cyc++) {
        // If both have failed we can stop early
        if (!aliveW && !aliveQ) break;

        // One shared innovation for fairness
        const epsInnovation = (rng() - 0.5) * 2;   // in [-1,1]

        const whiteNoise = amp * epsInnovation;

        // AR(1)-style correlated noise for QDS
        qPrevNoise = pEff * qPrevNoise + (1 - pEff) * epsInnovation;
        const qdsNoise = amp * qPrevNoise;

        // Shared stress pattern
        let stressMult = 1.0;
        if (stressNonlin) {
          const hMin = Math.min(hW, hQ);
          const x = Math.max(0, 1 - hMin / 100);
          stressMult += 1.8 * x * x; // gentle ‚Üí harsh near end
        }

        let heatBoost = 0;
        if (stressHeat) {
          // Periodic hot epochs
          const phase = cyc % 80;
          if (phase >= 50 && phase < 68) {
            heatBoost = base * 0.9;
          }
        }

        let outBoost = 0;
        if (stressOutliers) {
          if (rng() < 0.004) { // rare
            outBoost = 10;     // shock hit
          }
        }

        // White step
        if (aliveW) {
          let stepW = base + whiteNoise;
          stepW = stepW * stressMult + heatBoost + outBoost;
          if (noRegen && stepW < 0) stepW = 0;
          hW -= stepW;
          if (hW <= thrVal) {
            aliveW = false;
            failW = cyc;
          }
        }

        // QDS step (paired uses same innovation / stress)
        if (aliveQ) {
          let stepQ = base + (paired ? qdsNoise : ((rng() - 0.5) * 2 * amp));
          stepQ = stepQ * stressMult + heatBoost + outBoost;
          if (noRegen && stepQ < 0) stepQ = 0;
          hQ -= stepQ;
          if (hQ <= thrVal) {
            aliveQ = false;
            failQ = cyc;
          }
        }
      }

      whiteCycles[i] = failW;
      qdsCycles[i] = failQ;
    }

    function stats(arr) {
      let m = 0, m2 = 0;
      const L = arr.length;
      for (let i = 0; i < L; i++) {
        m += arr[i];
      }
      m /= L;
      for (let i = 0; i < L; i++) {
        const d = arr[i] - m;
        m2 += d * d;
      }
      m2 = m2 / L;
      return { mean: m, sigma: Math.sqrt(m2) };
    }

    const sW = stats(whiteCycles);
    const sQ = stats(qdsCycles);

    // paired Œî cycles
    let meanDelta = 0;
    for (let i = 0; i < N; i++) {
      meanDelta += (qdsCycles[i] - whiteCycles[i]);
    }
    meanDelta /= N;

    // Œî% with low-baseline guard
    let deltaPct = null;
    if (sW.mean >= 3) {
      deltaPct = (sQ.mean - sW.mean) / sW.mean * 100;
    }

    return {
      white: sW,
      qds: sQ,
      meanDeltaCycles: meanDelta,
      deltaPct: deltaPct,
      N,
      thr: thrVal,
      p: pEff
    };
  }

  // -------- UI helpers -----------------------------------------------
  function getCommonOpts(extraSeedOffset = 0) {
    const base = parseFloat(document.getElementById("baseInput").value || "0");
    const amp = parseFloat(document.getElementById("ampInput").value || "0");
    const p = parseFloat(document.getElementById("pInput").value || "0");
    const n = parseInt(document.getElementById("nInput").value || "0", 10);
    const maxCycles = parseInt(document.getElementById("maxCyclesInput").value || "0", 10);
    const thr = parseFloat(document.getElementById("thrInput").value || "0");

    const stressNonlin = document.getElementById("nonlinInput").checked;
    const stressHeat = document.getElementById("heatInput").checked;
    const stressOutliers = document.getElementById("outlierInput").checked;

    const paired = document.getElementById("pairedInput").checked;
    const noRegen = document.getElementById("noregenInput").checked;
    const hardNull = document.getElementById("hardNullInput").checked;

    let seedBase = parseInt(document.getElementById("seedInput").value || "1", 10);
    if (isNaN(seedBase)) seedBase = 1;
    if (!document.getElementById("lockSeedInput").checked) {
      seedBase = (seedBase + Math.floor(Math.random() * 1e6)) | 0;
    }
    const seed = (seedBase + extraSeedOffset) | 0;

    return {
      base, amp, p, thr, n, maxCycles,
      stressNonlin, stressHeat, stressOutliers,
      paired, noRegen, hardNull,
      seed
    };
  }

  function updateChips(stressNonlin, stressHeat, stressOutliers, mobileSafe, blind, pathologicalOn) {
    const chipMobile = document.getElementById("chipMobile");
    chipMobile.textContent = mobileSafe ? "Mobile safe" : "Desktop/full load";
    chipMobile.className = "chip neutral";

    const chipBlind = document.getElementById("chipBlind");
    chipBlind.textContent = blind ? "Bias test / blind" : "Interpret mode";
    chipBlind.className = blind ? "chip warn" : "chip neutral";

    const chipStress = document.getElementById("chipStress");
    const stressOn = stressNonlin || stressHeat || stressOutliers;
    chipStress.textContent = stressOn ? "Stress hammers: ON" : "Stress hammers: OFF";
    chipStress.className = "chip " + (stressOn ? "warn" : "neutral");

    const chipPathToy = document.getElementById("chipPathToy");
    chipPathToy.textContent = pathologicalOn ? "Extreme toy ACTIVE" : "Extreme toy off";
    chipPathToy.className = "chip toy";
  }

  function updateLatestStats(stats, label) {
    const { white, qds, deltaPct, meanDeltaCycles, thr, p } = stats;

    const blind = document.getElementById("blindInput").checked;
    const mobileSafe = document.getElementById("mobileSafeInput").checked;
    const stressNonlin = document.getElementById("nonlinInput").checked;
    const stressHeat = document.getElementById("heatInput").checked;
    const stressOutliers = document.getElementById("outlierInput").checked;

    // Possibly swap labels if blind mode
    const whiteLabelEl = document.getElementById("whiteLabel");
    const qdsLabelEl = document.getElementById("qdsLabel");
    if (blind) {
      whiteLabelEl.textContent = "Model A mean";
      qdsLabelEl.textContent = "Model B mean";
    } else {
      whiteLabelEl.textContent = "White mean";
      qdsLabelEl.textContent = "QDS mean";
    }

    document.getElementById("whiteMean").textContent = white.mean.toFixed(1);
    document.getElementById("qdsMean").textContent = qds.mean.toFixed(1);
    document.getElementById("whiteSigma").textContent = "œÉ: " + white.sigma.toFixed(1);
    document.getElementById("qdsSigma").textContent = "œÉ: " + qds.sigma.toFixed(1);

    const deltaEl = document.getElementById("deltaPct");
    const deltaNote = document.getElementById("deltaNote");
    const meanDeltaEl = document.getElementById("meanDeltaCycles");
    const gradeNote = document.getElementById("gradeNote");

    if (deltaPct === null) {
      deltaEl.textContent = "n/a";
      deltaNote.textContent = "Œî% guarded ‚Äî baseline too low.";
    } else {
      deltaEl.textContent = (deltaPct >= 0 ? "+" : "") + deltaPct.toFixed(1) + "%";
      if (Math.abs(deltaPct) < 0.5) {
        deltaNote.textContent = "‚âà neutral in this regime.";
      } else if (Math.abs(deltaPct) < 3) {
        deltaNote.textContent = "Mild signal; treat as noise-level curiosity.";
      } else {
        deltaNote.textContent = "Strong effect in this toy regime.";
      }
    }

    meanDeltaEl.textContent = meanDeltaCycles.toFixed(2);

    // Grade by |Œî%| if available
    let grade = "‚Äì";
    if (deltaPct === null) {
      grade = "Guarded";
    } else {
      const a = Math.abs(deltaPct);
      if (a < 0.5) grade = "A (neutral)";
      else if (a < 2) grade = "B (mild)";
      else if (a < 10) grade = "C (clear)";
      else grade = "Toy/extreme";
    }
    gradeNote.textContent = "Grade: " + grade +
      (label ? " ¬∑ " + label : "");

    // Update battery shell indication
    const batteryFill = document.getElementById("batteryFill");
    const batteryLabelMain = document.getElementById("batteryLabelMain");
    const batteryLabelSub = document.getElementById("batteryLabelSub");

    const maxCycles = parseInt(document.getElementById("maxCyclesInput").value || "4000", 10);
    let util = (white.mean / maxCycles) * 100;
    if (!isFinite(util)) util = 40;
    const width = Math.max(8, Math.min(100, util));
    batteryFill.style.width = width.toFixed(0) + "%";

    if (maxCycles <= 3500 && stats.N <= 1500) {
      batteryLabelMain.textContent = "LAB LOAD: EASY";
    } else if (stats.N <= 2500) {
      batteryLabelMain.textContent = "LAB LOAD: MEDIUM";
    } else {
      batteryLabelMain.textContent = "LAB LOAD: HEAVY";
    }

    const msText = mobileSafe ? "Mobile safe mode ON" : "Full load / desktop-friendly";
    batteryLabelSub.textContent = msText;

    // Update chips
    updateChips(stressNonlin, stressHeat, stressOutliers, mobileSafe, blind, false);
  }

  function describeOpts(opts) {
    const parts = [];
    parts.push(`base=${opts.base.toFixed(1)}%`);
    parts.push(`amp=${opts.amp.toFixed(1)}%`);
    parts.push(`p=${opts.hardNull ? 0 : opts.p.toFixed(2)}`);
    parts.push(`thr=${opts.thr}%`);
    parts.push(`n=${opts.n}`);
    parts.push(`max=${opts.maxCycles}`);
    const sFlags = [];
    if (opts.stressNonlin) sFlags.push("nonlin");
    if (opts.stressHeat) sFlags.push("heat");
    if (opts.stressOutliers) sFlags.push("out");
    const bFlags = [];
    if (opts.paired) bFlags.push("paired");
    if (opts.noRegen) bFlags.push("noRegen");
    if (opts.hardNull) bFlags.push("hardNull");
    return {
      core: parts.join(" ¬∑ "),
      stress: sFlags.length ? sFlags.join("+") : "none",
      bias: bFlags.length ? bFlags.join("+") : "none"
    };
  }

  // -------- button handlers ------------------------------------------
  function runSingle() {
    const opts = getCommonOpts(0);
    const desc = describeOpts(opts);
    const stats = runScenario(opts);
    updateLatestStats(stats, "Single sim");

    const t = timestamp();
    const d = stats;
    const deltaStr = d.deltaPct === null ? "n/a(low baseline)" : d.deltaPct.toFixed(1) + "%";
    const line = `${t} ¬∑ Manual ¬∑ ${desc.core}\n` +
                 `white Œº=${d.white.mean.toFixed(1)} œÉ=${d.white.sigma.toFixed(1)} ¬∑ ` +
                 `QDS Œº=${d.qds.mean.toFixed(1)} œÉ=${d.qds.sigma.toFixed(1)} ¬∑ Œî=${deltaStr} ¬∑ ` +
                 `meanŒî=${d.meanDeltaCycles.toFixed(2)} ¬∑ stress: ${desc.stress} ¬∑ bias: ${desc.bias}`;
    appendReport(line);

    document.getElementById("modeChip").textContent = "Mode: Manual";
  }

  function resetDefaults() {
    document.getElementById("baseInput").value = "1.2";
    document.getElementById("ampInput").value = "1.8";
    document.getElementById("pInput").value = "0.25";
    document.getElementById("nInput").value = "1200";
    document.getElementById("maxCyclesInput").value = "4000";
    document.getElementById("thrInput").value = "50";

    document.getElementById("nonlinInput").checked = true;
    document.getElementById("heatInput").checked = true;
    document.getElementById("outlierInput").checked = true;

    document.getElementById("pairedInput").checked = true;
    document.getElementById("noregenInput").checked = true;
    document.getElementById("blindInput").checked = false;
    document.getElementById("hardNullInput").checked = false;

    document.getElementById("mobileSafeInput").checked = true;
    document.getElementById("lockSeedInput").checked = true;
    document.getElementById("seedInput").value = "12345";
    document.getElementById("samplerInput").value = "24";

    updateChips(true, true, true, true, false, false);
    document.getElementById("modeChip").textContent = "Mode: Manual";
  }

  function runPosterLadder() {
    const mobileSafe = document.getElementById("mobileSafeInput").checked;
    const baseOpts = getCommonOpts(101);
    const now = timestamp();

    appendReport(`=== Poster Ladder v8.3 (poster-safe) ===`);

    function runBlock(label, overrides) {
      const o = Object.assign({}, baseOpts, overrides);
      if (mobileSafe) {
        o.n = Math.min(o.n, 1400);
        o.maxCycles = Math.min(o.maxCycles, 4000);
      }
      const stats = runScenario(o);
      const desc = describeOpts(o);
      const deltaStr = stats.deltaPct === null ? "n/a(low baseline)" : stats.deltaPct.toFixed(1) + "%";
      const line = `${now} ¬∑ ${label} base=${o.base.toFixed(1)}% amp=${o.amp.toFixed(1)}% p=${o.hardNull ? 0 : o.p.toFixed(2)} thr=${o.thr}% n=${stats.N} max=${o.maxCycles} ` +
                   `white Œº=${stats.white.mean.toFixed(1)} œÉ=${stats.white.sigma.toFixed(1)} ¬∑ ` +
                   `QDS Œº=${stats.qds.mean.toFixed(1)} œÉ=${stats.qds.sigma.toFixed(1)} Œî=${deltaStr} ¬∑ ` +
                   `meanŒî=${stats.meanDeltaCycles.toFixed(2)} stress: ${desc.stress} ¬∑ bias: ${desc.bias}`;
      appendReport(line);
      return stats;
    }

    // A: amp = 0 control
    const statsA = runBlock("Ladder A ‚Äî amp=0 control (safe)", {
      amp: 0,
      p: baseOpts.p,
      hardNull: false,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    // B: hard null p=0
    const statsB = runBlock("Ladder B ‚Äî hard null p=0 (safe)", {
      amp: baseOpts.amp,
      p: 0,
      hardNull: true,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    // C: blind null
    const statsC = runBlock("Ladder C ‚Äî blind null (safe)", {
      amp: baseOpts.amp,
      p: 0,
      hardNull: true,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false,
      // we don't toggle UI blind here, just keep harness itself neutral
    });

    // D: realistic phone
    const statsD = runBlock("Ladder D ‚Äî realistic phone (safe)", {
      base: 1.2,
      amp: 1.8,
      p: 0.25,
      thr: 30,
      n: 1200,
      maxCycles: 3500,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    // E: controlled stress
    const statsE = runBlock("Ladder E ‚Äî controlled stress (safe)", {
      base: 3.0,
      amp: 5.0,
      p: 0.60,
      thr: 50,
      n: 1400,
      maxCycles: 4000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    // F: high-corr sanity (still poster-safe: no hammers; moderate threshold)
    const statsF = runBlock("Ladder F ‚Äî high-correlation sanity (safe)", {
      base: 3.0,
      amp: 5.0,
      p: 0.90,
      thr: 50,
      n: 1200,
      maxCycles: 4000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    appendReport("=== End ladder ===");

    // Update display with last ladder block (F) for drama
    updateLatestStats(statsF, "Ladder F");
    document.getElementById("modeChip").textContent = "Mode: Poster Ladder";
  }

  function runStability() {
    const baseOpts = getCommonOpts(0);
    const mobileSafe = document.getElementById("mobileSafeInput").checked;

    // We force p>0 for stability check
    const baseP = baseOpts.p <= 0 ? 0.25 : baseOpts.p;

    const seeds = [111, 222, 333];
    const deltas = [];
    const meanDeltas = [];
    let lastStats = null;

    appendReport("=== 3-Seed Stability ===");
    seeds.forEach((s) => {
      const o = Object.assign({}, baseOpts, {
        p: baseP,
        hardNull: false,
        seed: (s + baseOpts.seed) | 0
      });
      if (mobileSafe) {
        o.n = Math.min(o.n, 1400);
        o.maxCycles = Math.min(o.maxCycles, 4000);
      }
      const stats = runScenario(o);
      lastStats = stats;
      const desc = describeOpts(o);
      const deltaStr = stats.deltaPct === null ? "n/a(low baseline)" : stats.deltaPct.toFixed(2) + "%";
      appendReport(`${timestamp()} ¬∑ Stability seed=${s} base=${o.base.toFixed(1)}% amp=${o.amp.toFixed(1)}% p=${o.p.toFixed(2)} thr=${o.thr}% n=${stats.N} max=${o.maxCycles} ` +
                   `white Œº=${stats.white.mean.toFixed(1)} œÉ=${stats.white.sigma.toFixed(1)} ¬∑ ` +
                   `QDS Œº=${stats.qds.mean.toFixed(1)} œÉ=${stats.qds.sigma.toFixed(1)} Œî=${deltaStr} ¬∑ meanŒî=${stats.meanDeltaCycles.toFixed(2)} ` +
                   `stress: ${desc.stress} ¬∑ bias: ${desc.bias}`);
      if (stats.deltaPct !== null) deltas.push(stats.deltaPct);
      meanDeltas.push(stats.meanDeltaCycles);
    });

    let meanDeltaPct = 0, minDeltaPct = 0, maxDeltaPct = 0;
    if (deltas.length) {
      let sum = 0, min = deltas[0], max = deltas[0];
      deltas.forEach(d => { sum += d; if (d < min) min = d; if (d > max) max = d; });
      meanDeltaPct = sum / deltas.length;
      minDeltaPct = min;
      maxDeltaPct = max;
    }

    let meanCycles = 0;
    if (meanDeltas.length) {
      meanCycles = meanDeltas.reduce((a,b) => a + b, 0) / meanDeltas.length;
    }

    let grade;
    const a = Math.abs(meanDeltaPct);
    if (!deltas.length || a < 0.25) grade = "A (neutral/stable)";
    else if (a < 1.5) grade = "B (mild)";
    else grade = "C+ (clear)";

    appendReport(`Stability summary: mean Œî=${meanDeltaPct.toFixed(2)}% (range ${minDeltaPct.toFixed(2)} ‚Üí ${maxDeltaPct.toFixed(2)}), ` +
                 `meanŒîcycles=${meanCycles.toFixed(2)} ¬∑ ${grade}`);
    appendReport("=== End stability ===");

    if (lastStats) {
      updateLatestStats(lastStats, "Stability");
      document.getElementById("modeChip").textContent = "Mode: 3-Seed Stability";
    }
  }

  function randomBetween(rng, a, b) {
    return a + (b - a) * rng();
  }

  function runAutoBench() {
    const mobileSafe = document.getElementById("mobileSafeInput").checked;
    const baseOpts = getCommonOpts(5000);
    let samplerCount = parseInt(document.getElementById("samplerInput").value || "16", 10);
    samplerCount = Math.max(4, Math.min(60, samplerCount));

    const rng = mulberry32(baseOpts.seed);
    appendReport(`=== AutoBench v8.3 start === Seed=${baseOpts.seed} ¬∑ Sampler=${samplerCount} ¬∑ MobileSafe=${mobileSafe ? "true" : "false"}`);

    // Ladder A-F again (poster-safe)
    function safeRun(label, overrides) {
      const o = Object.assign({}, baseOpts, overrides);
      if (mobileSafe) {
        o.n = Math.min(o.n, 1500);
        o.maxCycles = Math.min(o.maxCycles, 6000);
      }
      const stats = runScenario(o);
      const desc = describeOpts(o);
      const deltaStr = stats.deltaPct === null ? "n/a(low baseline)" : stats.deltaPct.toFixed(1) + "%";
      appendReport(`${timestamp()} ¬∑ ${label} base=${o.base.toFixed(2)}% amp=${o.amp.toFixed(2)}% p=${o.hardNull ? 0 : o.p.toFixed(2)} thr=${o.thr}% n=${stats.N} max=${o.maxCycles} ` +
                   `white Œº=${stats.white.mean.toFixed(1)} œÉ=${stats.white.sigma.toFixed(1)} ¬∑ ` +
                   `QDS Œº=${stats.qds.mean.toFixed(1)} œÉ=${stats.qds.sigma.toFixed(1)} Œî=${deltaStr} ¬∑ ` +
                   `meanŒî=${stats.meanDeltaCycles.toFixed(2)} stress: ${desc.stress} ¬∑ bias: ${desc.bias}`);
      return stats;
    }

    safeRun("Ladder A ‚Äî amp=0 control (safe)", {
      amp: 0,
      p: baseOpts.p,
      hardNull: false,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });
    safeRun("Ladder B ‚Äî hard null p=0 (safe)", {
      amp: baseOpts.amp,
      p: 0,
      hardNull: true,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });
    safeRun("Ladder C ‚Äî blind null (safe)", {
      amp: baseOpts.amp,
      p: 0,
      hardNull: true,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });
    safeRun("Ladder D ‚Äî realistic phone (safe)", {
      base: 1.2,
      amp: 1.8,
      p: 0.25,
      thr: 30,
      n: 1200,
      maxCycles: 3500,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });
    safeRun("Ladder E ‚Äî controlled stress (safe)", {
      base: 3.0,
      amp: 5.0,
      p: 0.6,
      thr: 50,
      n: 1400,
      maxCycles: 4000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });
    let lastStats = safeRun("Ladder F ‚Äî high-correlation sanity (safe)", {
      base: 3.0,
      amp: 5.0,
      p: 0.9,
      thr: 50,
      n: 1200,
      maxCycles: 4000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    appendReport("=== Sampler ===");

    const allDeltas = [];
    for (let i = 0; i < samplerCount; i++) {
      // cycle through toy "device" flavours
      const flavor = i % 4; // 0 phone, 1 laptop, 2 EV, 3 grid
      let label;
      const o = Object.assign({}, baseOpts);
      o.stressNonlin = false;
      o.stressHeat = false;
      o.stressOutliers = false;
      o.hardNull = false;
      o.paired = true;
      o.noRegen = true;

      if (flavor === 0) { // phone
        label = "Sampler " + (i+1) + " ‚Äî phone";
        o.base = randomBetween(rng, 1.0, 1.6);
        o.amp = randomBetween(rng, 1.2, 2.4);
        o.p = randomBetween(rng, 0.05, 0.35);
        o.thr = [20, 30, 50][Math.floor(rng()*3)];
        o.n = 1200;
        o.maxCycles = mobileSafe ? 4000 : 5000;
      } else if (flavor === 1) { // laptop
        label = "Sampler " + (i+1) + " ‚Äî laptop";
        o.base = randomBetween(rng, 0.7, 1.1);
        o.amp = randomBetween(rng, 1.0, 2.0);
        o.p = randomBetween(rng, 0.05, 0.25);
        o.thr = [30, 40][Math.floor(rng()*2)];
        o.n = mobileSafe ? 1300 : 1600;
        o.maxCycles = mobileSafe ? 6000 : 8000;
      } else if (flavor === 2) { // EV toy
        label = "Sampler " + (i+1) + " ‚Äî EV-toy";
        o.base = randomBetween(rng, 0.25, 0.45);
        o.amp = randomBetween(rng, 0.3, 0.8);
        o.p = randomBetween(rng, 0.05, 0.3);
        o.thr = [60, 70, 80][Math.floor(rng()*3)];
        o.n = mobileSafe ? 1500 : 2000;
        o.maxCycles = mobileSafe ? 12000 : 16000;
      } else { // grid toy
        label = "Sampler " + (i+1) + " ‚Äî grid-toy";
        o.base = randomBetween(rng, 0.18, 0.32);
        o.amp = randomBetween(rng, 0.2, 0.5);
        o.p = randomBetween(rng, 0.03, 0.2);
        o.thr = [70, 80][Math.floor(rng()*2)];
        o.n = mobileSafe ? 1800 : 2400;
        o.maxCycles = mobileSafe ? 20000 : 26000;
      }

      o.seed = (baseOpts.seed + 1000 + i) | 0;
      const stats = runScenario(o);
      lastStats = stats;
      const desc = describeOpts(o);
      const deltaStr = stats.deltaPct === null ? "n/a(low baseline)" : stats.deltaPct.toFixed(1) + "%";
      appendReport(`${timestamp()} ¬∑ ${label} base=${o.base.toFixed(2)}% amp=${o.amp.toFixed(2)}% p=${o.p.toFixed(2)} thr=${o.thr}% n=${stats.N} max=${o.maxCycles} ` +
                   `white Œº=${stats.white.mean.toFixed(1)} œÉ=${stats.white.sigma.toFixed(1)} ¬∑ ` +
                   `QDS Œº=${stats.qds.mean.toFixed(1)} œÉ=${stats.qds.sigma.toFixed(1)} Œî=${deltaStr} ¬∑ meanŒî=${stats.meanDeltaCycles.toFixed(2)} ` +
                   `stress: none ¬∑ bias: paired+noRegen`);
      if (stats.deltaPct !== null) allDeltas.push(stats.deltaPct);
    }

    // Summary of sampler deltas
    if (allDeltas.length) {
      const n = allDeltas.length;
      let sum = 0, min = allDeltas[0], max = allDeltas[0];
      allDeltas.forEach(d => { sum += d; if (d < min) min = d; if (d > max) max = d; });
      const mean = sum / n;
      appendReport(`AutoBench sampler summary: mean Œî=${mean.toFixed(2)}% (min=${min.toFixed(2)}% ¬∑ max=${max.toFixed(2)}%) over ${n} randomised toy scenarios.`);
    }

    appendReport("=== End AutoBench ===");

    if (lastStats) {
      updateLatestStats(lastStats, "AutoBench tail");
      document.getElementById("modeChip").textContent = "Mode: AutoBench";
    }
  }

  function runPathological() {
    const baseOpts = getCommonOpts(9000);
    const mobileSafe = document.getElementById("mobileSafeInput").checked;

    const o = Object.assign({}, baseOpts, {
      base: 8.0,
      amp: 14.0,
      p: 0.99,
      thr: 95,
      stressNonlin: true,
      stressHeat: true,
      stressOutliers: true,
      paired: true,
      noRegen: true,
      hardNull: false
    });

    // Big n/max only if mobile safe off
    if (mobileSafe) {
      o.n = 2500;
      o.maxCycles = 6000;
    } else {
      o.n = 5000;
      o.maxCycles = 8000;
    }

    appendReport("=== FULL PATHOLOGICAL RUN (extreme toy regime) === High p + NoRegen + harsh thr. Œî% may be n/a (low baseline).");

    const stats = runScenario(o);
    const desc = describeOpts(o);
    const deltaStr = stats.deltaPct === null ? "n/a(low baseline)" : stats.deltaPct.toFixed(1) + "%";

    appendReport(`${timestamp()} ¬∑ Pathological ‚Äî full load base=${o.base.toFixed(1)}% amp=${o.amp.toFixed(1)}% p=${o.p.toFixed(2)} thr=${o.thr}% n=${stats.N} max=${o.maxCycles} ` +
                 `white Œº=${stats.white.mean.toFixed(1)} œÉ=${stats.white.sigma.toFixed(1)} ¬∑ ` +
                 `QDS Œº=${stats.qds.mean.toFixed(1)} œÉ=${stats.qds.sigma.toFixed(1)} Œî=${deltaStr} ¬∑ ` +
                 `meanŒî=${stats.meanDeltaCycles.toFixed(2)} stress: ${desc.stress} ¬∑ bias: ${desc.bias}`);
    appendReport("=== End full pathological ===");

    updateLatestStats(stats, "Pathological toy");
    document.getElementById("modeChip").textContent = "Mode: Extreme Toy";
    // Mark toy chip as active
    const chipPathToy = document.getElementById("chipPathToy");
    chipPathToy.textContent = "Extreme toy ACTIVE";
    chipPathToy.className = "chip toy";
  }

  // -------- wire up ---------------------------------------------------
  document.getElementById("runBtn").addEventListener("click", runSingle);
  document.getElementById("resetBtn").addEventListener("click", resetDefaults);
  document.getElementById("ladderBtn").addEventListener("click", runPosterLadder);
  document.getElementById("stabilityBtn").addEventListener("click", runStability);
  document.getElementById("autoBenchBtn").addEventListener("click", runAutoBench);
  document.getElementById("pathBtn").addEventListener("click", runPathological);
  document.getElementById("clearBtn").addEventListener("click", clearReport);

  // Keep chips in sync with toggles
  ["nonlinInput","heatInput","outlierInput","mobileSafeInput","blindInput"].forEach(id => {
    document.getElementById(id).addEventListener("change", () => {
      const nonlin = document.getElementById("nonlinInput").checked;
      const heat = document.getElementById("heatInput").checked;
      const out = document.getElementById("outlierInput").checked;
      const mobileSafe = document.getElementById("mobileSafeInput").checked;
      const blind = document.getElementById("blindInput").checked;
      updateChips(nonlin, heat, out, mobileSafe, blind, false);
    });
  });

  // Initial state
  resetDefaults();


// --- qds_battery_hub_v9_1_purple_neon.html ---

  const statusLine = document.getElementById("statusLine");
  const btnLatest = document.getElementById("btnLatest");
  const manualFile = document.getElementById("manualFile");
  const manualGo = document.getElementById("manualGo");
  const manualStatus = document.getElementById("manualStatus");

  // Candidates in "newest-first guess" order
  const candidates = [
    "qds_battery_suite_v9_1_purple_neon_green.html", // if you later create it
    "qds_battery_suite_v9_0.html",
    "qds_battery_suite_v8_3_neon_shell.html",
    "qds_battery_suite_v8_nextlevel.html",
    "qds_battery_suite_v8_2_poster_tamed.html",
    "qds_battery_suite_v8_1_fairpath.html",
    "qds_battery_suite_v6_realworld.html",
    "qds_battery_lab.html"
  ];

  async function headOk(url){
    try{
      const r = await fetch(url, {method:"HEAD", cache:"no-store"});
      return r.ok;
    }catch(e){
      return false;
    }
  }

  async function detectLatest(){
    statusLine.textContent = "Status: scanning for newest suite‚Ä¶";
    for (const f of candidates){
      if (await headOk(f)){
        btnLatest.href = f;
        btnLatest.textContent = `Open Latest: ${f}`;
        statusLine.textContent = `Status: detected ${f}`;
        return;
      }
    }
    statusLine.textContent = "Status: none detected (check server + filenames).";
  }

  manualGo.addEventListener("click", ()=>{
    const f = (manualFile.value || "").trim();
    if (!f){
      manualStatus.textContent = "Give me a filename, old chap. üé©";
      return;
    }
    window.location.href = f;
  });

  detectLatest();


// --- qds_battery_hub_v9_2_purple_neon.html ---

/* =========================
   Utilities
========================= */
const $ = (id)=>document.getElementById(id);

const STORAGE_KEY = "QDS_BATTERY_HUB_HISTORY_v9_2";
const LAST_KEY = "QDS_BATTERY_HUB_LAST_v9_2";

function nowStamp(){
  const d = new Date();
  return d.toLocaleString();
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

function mean(arr){
  if(!arr.length) return 0;
  let s=0; for(const v of arr) s+=v;
  return s/arr.length;
}
function std(arr){
  if(arr.length<2) return 0;
  const m = mean(arr);
  let s=0; for(const v of arr){ const d=v-m; s+=d*d; }
  return Math.sqrt(s/(arr.length-1));
}
function percentile(arr, p){
  if(!arr.length) return 0;
  const a = [...arr].sort((x,y)=>x-y);
  const idx = (p/100)*(a.length-1);
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if(lo===hi) return a[lo];
  const t = idx-lo;
  return a[lo]*(1-t)+a[hi]*t;
}

function saveHistory(entry){
  const hist = loadHistory();
  hist.unshift(entry);
  while(hist.length>60) hist.pop();
  localStorage.setItem(STORAGE_KEY, JSON.stringify(hist));
}
function loadHistory(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return [];
    const v = JSON.parse(raw);
    return Array.isArray(v)? v : [];
  }catch(e){ return []; }
}
function setLast(entry){
  localStorage.setItem(LAST_KEY, JSON.stringify(entry));
}
function getLast(){
  try{
    const raw = localStorage.getItem(LAST_KEY);
    if(!raw) return null;
    return JSON.parse(raw);
  }catch(e){ return null; }
}
function downloadJSON(obj, filename){
  const blob = new Blob([JSON.stringify(obj,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url; a.download=filename;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}
async function copyText(t){
  try{
    await navigator.clipboard.writeText(t);
    return true;
  }catch(e){
    return false;
  }
}

/* =========================
   Noise Sim
========================= */
function simulateLifetimes({base, amp, rho, nRuns, maxCycles, thr}){
  base = Math.max(0, base);
  amp  = Math.max(0, amp);
  rho  = clamp(rho, 0, 0.99);
  thr  = clamp(thr, 0, 99);

  function runOneWhite(){
    let health = 100;
    for(let c=1;c<=maxCycles;c++){
      const eps = (Math.random()*2-1) * amp;
      health -= (base + eps);
      if(health <= thr) return c;
    }
    return maxCycles;
  }

  function runOneQDS(){
    let health = 100;
    let x = 0;
    for(let c=1;c<=maxCycles;c++){
      const eps = (Math.random()*2-1) * amp;
      x = rho * x + eps;
      health -= (base + x);
      if(health <= thr) return c;
    }
    return maxCycles;
  }

  const white = new Array(nRuns);
  const qds   = new Array(nRuns);
  for(let i=0;i<nRuns;i++){
    white[i]=runOneWhite();
    qds[i]=runOneQDS();
  }
  return {white, qds, rho};
}

/* =========================
   Drawing
========================= */
function clearCanvas(ctx){
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
}

function drawHistogram(canvas, white, qds){
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  clearCanvas(ctx);

  if(!white.length || !qds.length){
    ctx.fillStyle = "rgba(255,255,255,.6)";
    ctx.fillText("No data yet.", 20, 30);
    return;
  }

  const all = white.concat(qds);
  const minV = Math.min(...all);
  const maxV = Math.max(...all);
  const bins = 28;

  const bw = Math.max(1, Math.ceil((maxV-minV+1)/bins));
  const wCounts = new Array(bins).fill(0);
  const qCounts = new Array(bins).fill(0);

  function idxOf(v){
    const i = Math.floor((v-minV)/bw);
    return clamp(i, 0, bins-1);
  }
  for(const v of white) wCounts[idxOf(v)]++;
  for(const v of qds)   qCounts[idxOf(v)]++;

  const maxC = Math.max(...wCounts, ...qCounts, 1);
  const padL=34, padR=10, padT=12, padB=28;
  const plotW = W-padL-padR, plotH = H-padT-padB;
  const binPx = plotW/bins;

  // axes
  ctx.strokeStyle = "rgba(255,255,255,.12)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padL, padT);
  ctx.lineTo(padL, padT+plotH);
  ctx.lineTo(padL+plotW, padT+plotH);
  ctx.stroke();

  // bars
  for(let i=0;i<bins;i++){
    const x = padL + i*binPx;
    const wH = (wCounts[i]/maxC)*plotH;
    const qH = (qCounts[i]/maxC)*plotH;

    // white (purple)
    ctx.fillStyle = "rgba(139,44,255,.45)";
    ctx.fillRect(x+1, padT+plotH-wH, binPx*0.48, wH);

    // qds (green)
    ctx.fillStyle = "rgba(57,255,136,.45)";
    ctx.fillRect(x+binPx*0.52, padT+plotH-qH, binPx*0.48-2, qH);
  }

  // labels
  ctx.fillStyle = "rgba(255,255,255,.7)";
  ctx.font = "12px system-ui";
  ctx.fillText("Counts", 6, 20);
  ctx.fillText("Cycles ‚Üí", W-90, H-10);

  ctx.font = "11px system-ui";
  ctx.fillStyle = "rgba(255,255,255,.6)";
  ctx.fillText(`min ${minV}`, padL, H-8);
  ctx.fillText(`max ${maxV}`, padL+plotW-60, H-8);
}

function drawTraces(canvas, params, sampleWhiteCycle, sampleQdsCycle){
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  clearCanvas(ctx);

  const padL=34, padR=10, padT=12, padB=28;
  const plotW = W-padL-padR, plotH = H-padT-padB;

  // axes
  ctx.strokeStyle = "rgba(255,255,255,.12)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padL, padT);
  ctx.lineTo(padL, padT+plotH);
  ctx.lineTo(padL+plotW, padT+plotH);
  ctx.stroke();

  if(!params) return;

  const {base, amp, rho, maxCycles, thr} = params;

  function genWhiteSeries(){
    let health = 100;
    const arr = [];
    for(let c=1;c<=maxCycles;c++){
      const eps=(Math.random()*2-1)*amp;
      health -= (base+eps);
      arr.push(health);
      if(health<=thr) break;
    }
    return arr;
  }
  function genQdsSeries(){
    let health = 100;
    let x=0;
    const arr = [];
    for(let c=1;c<=maxCycles;c++){
      const eps=(Math.random()*2-1)*amp;
      x = rho*x + eps;
      health -= (base+x);
      arr.push(health);
      if(health<=thr) break;
    }
    return arr;
  }

  const w = genWhiteSeries();
  const q = genQdsSeries();
  const maxLen = Math.max(w.length,q.length,1);

  function xOf(i){ return padL + (i/(maxLen-1||1))*plotW; }
  function yOf(v){
    const vv = clamp(v, 0, 100);
    return padT + (1 - vv/100)*plotH;
  }

  // threshold line
  ctx.strokeStyle = "rgba(255,91,212,.35)";
  ctx.setLineDash([6,4]);
  ctx.beginPath();
  ctx.moveTo(padL, yOf(thr));
  ctx.lineTo(padL+plotW, yOf(thr));
  ctx.stroke();
  ctx.setLineDash([]);

  // white line
  ctx.strokeStyle = "rgba(139,44,255,.85)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  w.forEach((v,i)=>{
    const x=xOf(i), y=yOf(v);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  // qds line
  ctx.strokeStyle = "rgba(57,255,136,.85)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  q.forEach((v,i)=>{
    const x=xOf(i), y=yOf(v);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,.7)";
  ctx.font="12px system-ui";
  ctx.fillText("Health %", 6, 20);
  ctx.fillText("Cycles ‚Üí", W-90, H-10);

  // legend
  ctx.fillStyle = "rgba(139,44,255,.9)";
  ctx.fillRect(padL+6, padT+6, 10, 10);
  ctx.fillStyle = "rgba(255,255,255,.7)";
  ctx.fillText("White", padL+22, padT+15);

  ctx.fillStyle = "rgba(57,255,136,.9)";
  ctx.fillRect(padL+80, padT+6, 10, 10);
  ctx.fillStyle = "rgba(255,255,255,.7)";
  ctx.fillText("QDS", padL+96, padT+15);
}

/* =========================
   UI Wiring
========================= */
const tabs = document.querySelectorAll(".tabbtn");
tabs.forEach(btn=>{
  btn.addEventListener("click", ()=>{
    tabs.forEach(b=>b.classList.remove("active"));
    btn.classList.add("active");
    const key = btn.dataset.tab;
    ["overview","lab","coach","autobench"].forEach(k=>{
      const sec = $("tab-"+k);
      if(k===key) sec.classList.remove("hidden");
      else sec.classList.add("hidden");
    });
    if(key==="coach") refreshCoach();
  });
});

function setDefaults(){
  $("baseDrain").value = 1.2;
  $("amp").value = 1.8;
  $("rho").value = 0.25;
  $("thr").value = 50;
  $("nRuns").value = 1200;
  $("maxCycles").value = 4000;
}
$("resetBtn").addEventListener("click", ()=>{
  setDefaults();
  $("status").textContent = "Defaults restored.";
});

document.querySelectorAll("[data-preset]").forEach(b=>{
  b.addEventListener("click", ()=>{
    const p = b.dataset.preset;
    if(p==="phone"){
      $("baseDrain").value = 1.2;
      $("amp").value = 1.8;
      $("rho").value = 0.25;
      $("thr").value = 50;
      $("nRuns").value = 1200;
      $("maxCycles").value = 4000;
    }else if(p==="contrast"){
      $("baseDrain").value = 2.7;
      $("amp").value = 2.3;
      $("rho").value = 0.70;
      $("thr").value = 85;
      $("nRuns").value = 1200;
      $("maxCycles").value = 2000;
    }else if(p==="chaos"){
      $("baseDrain").value = 2.0;
      $("amp").value = 3.0;
      $("rho").value = 0.90;
      $("thr").value = 80;
      $("nRuns").value = 500;
      $("maxCycles").value = 4000;
    }
    $("status").textContent = `Preset loaded: ${p}`;
  });
});

function renderHistory(){
  const box = $("historyBox");
  box.innerHTML = "";
  const hist = loadHistory().slice(0,6);
  if(!hist.length){
    box.innerHTML = `<div class="history-item muted">No history yet.</div>`;
    return;
  }
  hist.forEach(h=>{
    const div = document.createElement("div");
    div.className = "history-item";
    div.innerHTML =
      `<b>${h.timestamp}</b><br>`+
      `base=${h.base}% ‚Ä¢ amp=${h.amp}% ‚Ä¢ œÅ=${h.rho} ‚Ä¢ thr=${h.thr}% ‚Ä¢ n=${h.nRuns}<br>`+
      `white Œº=${h.whiteMean.toFixed(1)} œÉ=${h.whiteStd.toFixed(1)} ‚Ä¢ `+
      `QDS Œº=${h.qdsMean.toFixed(1)} œÉ=${h.qdsStd.toFixed(1)} ‚Ä¢ `+
      `Œî=${h.deltaPct.toFixed(1)}%`;
    box.appendChild(div);
  });
}

function updateKPIs(entry){
  $("whiteMean").textContent = entry ? entry.whiteMean.toFixed(1) : "‚Äî";
  $("whiteStd").textContent  = entry ? entry.whiteStd.toFixed(1) : "‚Äî";
  $("qdsMean").textContent   = entry ? entry.qdsMean.toFixed(1) : "‚Äî";
  $("qdsStd").textContent    = entry ? entry.qdsStd.toFixed(1) : "‚Äî";
  $("deltaPct").textContent  = entry ? (entry.deltaPct>=0?"+":"") + entry.deltaPct.toFixed(1)+"%" : "‚Äî";
  $("runsLabel").textContent = entry ? `${entry.nRuns} per model` : "‚Äî";
  $("whiteP").textContent    = entry ? `${entry.whiteP10.toFixed(1)} / ${entry.whiteP50.toFixed(1)} / ${entry.whiteP90.toFixed(1)}` : "‚Äî";
  $("qdsP").textContent      = entry ? `${entry.qdsP10.toFixed(1)} / ${entry.qdsP50.toFixed(1)} / ${entry.qdsP90.toFixed(1)}` : "‚Äî";

  if(!entry){
    $("interpretation").textContent = "";
    return;
  }

  const spreadMsg =
    entry.qdsStd > entry.whiteStd*1.2 ? "Clear widening of lifetime spread under correlated noise."
    : entry.qdsStd > entry.whiteStd*1.05 ? "Subtle widening of lifetime spread under correlated noise."
    : "Spread looks similar in this regime.";

  const meanMsg =
    entry.deltaPct > 5 ? "Mean lifetime uplift is noticeable in this setup."
    : entry.deltaPct > 0.5 ? "Mean lifetime uplift is mild."
    : entry.deltaPct < -0.5 ? "Mean lifetime dips slightly here ‚Äî tails may dominate."
    : "Mean lifetime is roughly unchanged.";

  $("interpretation").textContent =
    `${spreadMsg} ${meanMsg} œÅ=${entry.rho.toFixed(2)} tends to create streaky outcomes.`;
}

let lastLocalEntry = null;

$("runBtn").addEventListener("click", ()=>{
  const base = parseFloat($("baseDrain").value);
  const amp  = parseFloat($("amp").value);
  const rho  = parseFloat($("rho").value);
  const thr  = parseFloat($("thr").value);
  const nRuns = parseInt($("nRuns").value,10);
  const maxCycles = parseInt($("maxCycles").value,10);

  const safeNRuns = clamp(nRuns, 50, 6000);
  const safeMax = clamp(maxCycles, 100, 20000);

  $("status").textContent = "Running‚Ä¶";

  // run
  const {white, qds} = simulateLifetimes({
    base, amp, rho, nRuns: safeNRuns, maxCycles: safeMax, thr
  });

  const wMean = mean(white), wStd = std(white);
  const qMean = mean(qds),   qStd = std(qds);
  const deltaPct = wMean>0 ? ((qMean-wMean)/wMean)*100 : 0;

  const entry = {
    version: "9.2",
    timestamp: nowStamp(),
    base, amp, rho: clamp(rho,0,0.99), thr,
    nRuns: safeNRuns, maxCycles: safeMax,
    whiteMean: wMean, whiteStd: wStd,
    qdsMean: qMean, qdsStd: qStd,
    deltaPct,
    whiteP10: percentile(white,10),
    whiteP50: percentile(white,50),
    whiteP90: percentile(white,90),
    qdsP10: percentile(qds,10),
    qdsP50: percentile(qds,50),
    qdsP90: percentile(qds,90),
    lifetimes_preview: {
      white_min: Math.min(...white),
      white_max: Math.max(...white),
      qds_min: Math.min(...qds),
      qds_max: Math.max(...qds),
    }
  };

  lastLocalEntry = entry;
  setLast(entry);
  saveHistory(entry);
  renderHistory();
  updateKPIs(entry);

  drawHistogram($("histCanvas"), white, qds);
  drawTraces($("traceCanvas"), {base,amp,rho:clamp(rho,0,0.99),maxCycles:safeMax,thr});

  $("status").textContent = `Done. Œî=${deltaPct.toFixed(2)}%  ‚Ä¢ history updated.`;
  refreshCoach();
});

$("copySummaryBtn").addEventListener("click", async ()=>{
  const e = lastLocalEntry || getLast();
  if(!e){ $("status").textContent = "No run yet."; return; }
  const t =
`QDS Battery Hub v${e.version} ‚Äî ${e.timestamp}
base=${e.base}% ‚Ä¢ amp=${e.amp}% ‚Ä¢ rho=${e.rho} ‚Ä¢ thr=${e.thr}% ‚Ä¢ n=${e.nRuns} ‚Ä¢ max=${e.maxCycles}
white Œº=${e.whiteMean.toFixed(2)} œÉ=${e.whiteStd.toFixed(2)}
QDS   Œº=${e.qdsMean.toFixed(2)} œÉ=${e.qdsStd.toFixed(2)}
Œî=${(e.deltaPct>=0?"+":"")}${e.deltaPct.toFixed(2)}%
P10/P50/P90 white: ${e.whiteP10.toFixed(1)} / ${e.whiteP50.toFixed(1)} / ${e.whiteP90.toFixed(1)}
P10/P50/P90 QDS:   ${e.qdsP10.toFixed(1)} / ${e.qdsP50.toFixed(1)} / ${e.qdsP90.toFixed(1)}`;
  const ok = await copyText(t);
  $("status").textContent = ok ? "Summary copied." : "Copy failed (clipboard blocked).";
});

$("exportLastBtn").addEventListener("click", ()=>{
  const e = lastLocalEntry || getLast();
  if(!e){ $("status").textContent = "No run yet."; return; }
  downloadJSON(e, `QDS_BatteryHub_Last_v${e.version}_${Date.now()}.json`);
});

$("exportHistoryBtn").addEventListener("click", ()=>{
  const hist = loadHistory();
  downloadJSON({version:"9.2", exported: nowStamp(), history: hist}, `QDS_BatteryHub_History_v9.2_${Date.now()}.json`);
});

$("clearHistoryBtn").addEventListener("click", ()=>{
  localStorage.removeItem(STORAGE_KEY);
  localStorage.removeItem(LAST_KEY);
  lastLocalEntry = null;
  renderHistory();
  updateKPIs(null);
  $("status").textContent = "History cleared.";
  $("coachLive").textContent = "Run the Lab once and I‚Äôll summarise your last results here.";
});

/* =========================
   Coach Live
========================= */
function refreshCoach(){
  const e = lastLocalEntry || getLast();
  if(!e){
    $("coachLive").textContent = "Run the Lab once and I‚Äôll summarise your last results here.";
    return;
  }

  const spreadRatio = e.whiteStd>0 ? (e.qdsStd/e.whiteStd) : 1;
  const tailNote =
    spreadRatio>1.5 ? "Big tail widening: correlated stress streaks are a strong intuition fit here."
    : spreadRatio>1.15 ? "Noticeable widening: this is the classic ‚Äústreaky outcomes‚Äù signature."
    : "Spread change is modest in this regime.";

  const meanNote =
    e.deltaPct>5 ? "Mean lifetime uplift is visible ‚Äî your params are in a ‚Äòbeneficial drift‚Äô pocket."
    : e.deltaPct>0.5 ? "Mean uplift is mild ‚Äî the story is mostly about tails."
    : e.deltaPct<-0.5 ? "Mean dips a bit ‚Äî correlated bad streaks can dominate."
    : "Mean is roughly unchanged.";

  const rhoNote =
    e.rho>0.7 ? "High œÅ: you‚Äôre modelling heavy correlation / long memory."
    : e.rho>0.3 ? "Moderate œÅ: realistic demo zone for visible widening."
    : "Low œÅ: close to white-noise behaviour.";

  $("coachLive").innerHTML =
    `<b>Last run:</b> ${e.timestamp}<br>`+
    `white Œº=${e.whiteMean.toFixed(1)} œÉ=${e.whiteStd.toFixed(1)} ‚Ä¢ `+
    `QDS Œº=${e.qdsMean.toFixed(1)} œÉ=${e.qdsStd.toFixed(1)} ‚Ä¢ `+
    `Œî=${(e.deltaPct>=0?"+":"")}${e.deltaPct.toFixed(1)}%<br>`+
    `<span class="tiny">${tailNote} ${meanNote} ${rhoNote}</span>`;
}

/* =========================
   AutoBench Viewer
========================= */
let abRows = [];

function parseAutoBenchObject(obj){
  // We try to be schema-flexible.
  const file = obj.__file || "unknown";
  const timestamp =
    obj.timestamp || obj.time || obj.generated || obj.created || obj.date || "";

  // Try to locate summary-like fields
  let meanDelta = null, minDelta=null, maxDelta=null, integrity=null, notes="";

  // Common patterns you used:
  // - "AutoBench sampler summary: mean Œî=..."
  // In JSON you might store fields like mean_delta, min_delta, max_delta, integrity
  if(typeof obj.mean_delta === "number") meanDelta = obj.mean_delta;
  if(typeof obj.min_delta === "number") minDelta = obj.min_delta;
  if(typeof obj.max_delta === "number") maxDelta = obj.max_delta;
  if(typeof obj.integrity === "string") integrity = obj.integrity;

  // If not present, attempt to infer from nested keys
  const flatScan = (o)=>{
    const out = {};
    const stack = [{p:"", v:o}];
    while(stack.length){
      const {p,v} = stack.pop();
      if(v && typeof v === "object" && !Array.isArray(v)){
        for(const k of Object.keys(v)){
          const np = p? (p+"."+k) : k;
          stack.push({p:np, v:v[k]});
        }
      }else{
        out[p]=v;
      }
    }
    return out;
  };

  const f = flatScan(obj);

  // Look for keys containing "mean" and "delta"
  if(meanDelta===null){
    for(const k in f){
      const lk = k.toLowerCase();
      if(lk.includes("mean") && lk.includes("delta") && typeof f[k]==="number"){
        meanDelta = f[k]; break;
      }
    }
  }
  if(minDelta===null){
    for(const k in f){
      const lk = k.toLowerCase();
      if(lk.includes("min") && lk.includes("delta") && typeof f[k]==="number"){
        minDelta = f[k]; break;
      }
    }
  }
  if(maxDelta===null){
    for(const k in f){
      const lk = k.toLowerCase();
      if(lk.includes("max") && lk.includes("delta") && typeof f[k]==="number"){
        maxDelta = f[k]; break;
      }
    }
  }
  if(integrity===null){
    for(const k in f){
      const lk = k.toLowerCase();
      if(lk.includes("integrity") && typeof f[k]==="string"){
        integrity = f[k]; break;
      }
    }
  }

  // Notes
  if(typeof obj.note === "string") notes = obj.note;
  else if(typeof obj.notes === "string") notes = obj.notes;

  return {
    file,
    timestamp: String(timestamp || ""),
    meanDelta,
    minDelta,
    maxDelta,
    integrity: integrity || "",
    notes: notes || ""
  };
}

function renderAbTable(){
  const tbody = $("abTable").querySelector("tbody");
  tbody.innerHTML = "";
  abRows.forEach(r=>{
    const tr = document.createElement("tr");
    const fmt = (v)=> (typeof v==="number" ? v.toFixed(2)+"%" : "‚Äî");
    tr.innerHTML =
      `<td>${r.file}</td>`+
      `<td>${r.timestamp || "‚Äî"}</td>`+
      `<td>${fmt(r.meanDelta)}</td>`+
      `<td>${fmt(r.minDelta)} / ${fmt(r.maxDelta)}</td>`+
      `<td>${r.integrity || "‚Äî"}</td>`+
      `<td class="tiny">${(r.notes||"").slice(0,80)}</td>`;
    tbody.appendChild(tr);
  });
  $("abStatus").textContent = abRows.length ? `Loaded ${abRows.length} log(s).` : "No logs loaded.";
}

$("abFiles").addEventListener("change", async (ev)=>{
  const files = [...ev.target.files||[]];
  if(!files.length) return;

  for(const file of files){
    try{
      const text = await file.text();
      const obj = JSON.parse(text);
      obj.__file = file.name;
      const row = parseAutoBenchObject(obj);
      abRows.push(row);
    }catch(e){
      abRows.push({file:file.name, timestamp:"", meanDelta:null, minDelta:null, maxDelta:null, integrity:"parse error", notes:String(e)});
    }
  }
  renderAbTable();
});

$("abClearBtn").addEventListener("click", ()=>{
  abRows = [];
  $("abFiles").value = "";
  renderAbTable();
});

$("abExportBtn").addEventListener("click", ()=>{
  downloadJSON({version:"9.2", exported: nowStamp(), rows: abRows}, `QDS_AutoBench_Table_v9.2_${Date.now()}.json`);
});

/* =========================
   Boot
========================= */
setDefaults();
renderHistory();
updateKPIs(getLast());
if(getLast()){
  // draw placeholders from last-known distributions if you want,
  // but we keep it simple: prompt user to run.
}
refreshCoach();
renderAbTable();


// --- qds_battery_hub_v9_3_science_neon.html ---

/* =========================
   QDS Battery Hub v9.3
   Single-file, no deps
   ========================= */

const $ = (id)=>document.getElementById(id);

const state = {
  posterMode: true,
  noRegen: true,
  historyKey: "QDS_BATTERY_HUB_V9_3_HISTORY",
  lastRun: null
};

// UI elements
const sliders = [
  ["k1","v_k1", v=>Number(v).toFixed(4)],
  ["k2","v_k2", v=>Number(v).toFixed(4)],
  ["amp","v_amp", v=>Number(v).toFixed(1)+"%"],
  ["rho","v_rho", v=>Number(v).toFixed(2)],
  ["n","v_n", v=>v],
  ["maxc","v_max", v=>v],
  ["thr","v_thr", v=>v+"%"],
];

function syncLabels(){
  sliders.forEach(([sid,lid,fmt])=>{
    const el=$(sid), lab=$(lid);
    if(el && lab) lab.textContent = fmt(el.value);
  });
  $("togglePoster").textContent = state.posterMode ? "Poster ON" : "Poster OFF";
  $("toggleNoRegen").textContent = state.noRegen ? "NoRegen ON" : "NoRegen OFF";
}

sliders.forEach(([sid])=>{
  $(sid).addEventListener("input", syncLabels);
});

$("togglePoster").addEventListener("click", ()=>{
  state.posterMode = !state.posterMode;
  syncLabels();
});
$("toggleNoRegen").addEventListener("click", ()=>{
  state.noRegen = !state.noRegen;
  syncLabels();
});

// Tabs
document.querySelectorAll(".tabbtn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    document.querySelectorAll(".tabbtn").forEach(b=>b.classList.remove("active"));
    btn.classList.add("active");
    const t = btn.dataset.tab;
    ["lab","coach","bench"].forEach(x=>{
      const pane = $("tab-"+x);
      pane.style.display = (x===t) ? "block" : "none";
    });
  });
});

// RNG (seeded)
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
function randn(rng){
  // Box-Muller
  let u=0,v=0;
  while(u===0) u = rng();
  while(v===0) v = rng();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

// Core model
function simulateModel({k1,k2,amp,rho,n,maxc,thr,seed,correlated}){
  const rng = mulberry32(seed);
  const lifetimes = new Array(n);
  let sampleTrace = null;

  for(let i=0;i<n;i++){
    // cell-to-cell variation (small)
    const k1_i = Math.max(0, k1 * (1 + 0.10*randn(rng)));
    const k2_i = Math.max(0, k2 * (1 + 0.10*randn(rng)));

    let cap = 100.0;
    let stress = 0.0; // AR(1) state
    let t=0;

    const trace = (i===0) ? [] : null;

    for(t=1; t<=maxc; t++){
      // operating stress noise
      const eps = randn(rng);
      if(correlated){
        stress = rho*stress + eps;
      }else{
        stress = eps; // i.i.d
      }

      // convert stress to multiplier
      // amp is % scale of effect on fade rate
      let m = 1 + (amp/100) * stress;

      if(state.posterMode){
        // tame extremes: limit stress multiplier
        m = clamp(m, 0.6, 1.6);
      }

      // Semi-empirical-ish fade shape per cycle
      // dCap ~ (k1*sqrt(t) + k2*t) incremental derivative approximation:
      // We implement a small per-step loss using difference of f(t)
      const f_prev = k1_i*Math.sqrt(t-1) + k2_i*(t-1);
      const f_now  = k1_i*Math.sqrt(t)   + k2_i*t;
      let d = (f_now - f_prev) * 100; // scale to % points

      // apply multiplier
      d *= m;

      if(state.noRegen){
        d = Math.max(0, d);
      }

      cap -= d;

      if(trace){
        trace.push({t, cap});
      }

      if(cap <= thr){
        lifetimes[i] = t;
        break;
      }
    }

    if(lifetimes[i] == null){
      lifetimes[i] = maxc;
    }

    if(i===0){
      sampleTrace = trace;
    }
  }

  lifetimes.sort((a,b)=>a-b);
  const mean = lifetimes.reduce((s,x)=>s+x,0)/n;
  const variance = lifetimes.reduce((s,x)=>s+(x-mean)*(x-mean),0)/n;
  const sigma = Math.sqrt(variance);

  const p10 = lifetimes[Math.floor(0.10*(n-1))];
  const p50 = lifetimes[Math.floor(0.50*(n-1))];
  const p90 = lifetimes[Math.floor(0.90*(n-1))];

  return {lifetimes, mean, sigma, p10, p50, p90, sampleTrace};
}

function runSim(){
  const k1 = Number($("k1").value);
  const k2 = Number($("k2").value);
  const amp = Number($("amp").value);
  const rho = Number($("rho").value);
  const n = Number($("n").value);
  const maxc = Number($("maxc").value);
  const thr = Number($("thr").value);
  const seed = Number($("seed").value) || 12345;

  // Use two seeds so white vs QDS share the same base RNG stream structure
  const white = simulateModel({k1,k2,amp,rho,n,maxc,thr,seed: seed, correlated:false});
  const qds   = simulateModel({k1,k2,amp,rho,n,maxc,thr,seed: seed+1, correlated:true});

  const delta = (qds.mean - white.mean) / Math.max(1e-9, white.mean) * 100;

  $("w_mu").textContent = white.mean.toFixed(1);
  $("w_sig").textContent = white.sigma.toFixed(1);
  $("q_mu").textContent = qds.mean.toFixed(1);
  $("q_sig").textContent = qds.sigma.toFixed(1);

  $("w_p").textContent = `P10/P50/P90 ${white.p10.toFixed(0)} / ${white.p50.toFixed(0)} / ${white.p90.toFixed(0)}`;
  $("q_p").textContent = `P10/P50/P90 ${qds.p10.toFixed(0)} / ${qds.p50.toFixed(0)} / ${qds.p90.toFixed(0)}`;

  $("delta").textContent = (delta>=0?"+":"") + delta.toFixed(1) + "%";

  let regime = "Poster-safe";
  if(rho >= 0.95 || !state.posterMode || !state.noRegen){
    regime = "Extreme / toy-pathological zone";
  }
  $("delta_note").textContent =
    `${regime}. œÅ=${rho.toFixed(2)} ¬∑ Poster=${state.posterMode} ¬∑ NoRegen=${state.noRegen}`;

  drawHist(white.lifetimes, qds.lifetimes, maxc);
  drawTrace(white.sampleTrace, qds.sampleTrace);

  const entry = {
    ts: new Date().toISOString(),
    k1, k2, amp, rho, thr, n, maxc, seed,
    posterMode: state.posterMode,
    noRegen: state.noRegen,
    white: {mean:white.mean, sigma:white.sigma, p10:white.p10, p50:white.p50, p90:white.p90},
    qds:   {mean:qds.mean,   sigma:qds.sigma,   p10:qds.p10,   p50:qds.p50,   p90:qds.p90},
    delta_pct: delta
  };

  state.lastRun = entry;
  pushHistory(entry);
  renderHistory();
}

function drawHist(w, q, maxc){
  const c = $("hist");
  const ctx = c.getContext("2d");
  const W = c.width = c.clientWidth * devicePixelRatio;
  const H = c.height = c.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  const bins = 24;
  const min = 0;
  const max = maxc;
  const bw = (max-min)/bins;

  const wb = new Array(bins).fill(0);
  const qb = new Array(bins).fill(0);

  for(const x of w){
    const i = Math.min(bins-1, Math.max(0, Math.floor((x-min)/bw)));
    wb[i]++;
  }
  for(const x of q){
    const i = Math.min(bins-1, Math.max(0, Math.floor((x-min)/bw)));
    qb[i]++;
  }

  const maxCount = Math.max(...wb, ...qb, 1);
  const pad = 18*devicePixelRatio;

  // axes
  ctx.globalAlpha = 1;
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.beginPath();
  ctx.moveTo(pad, H-pad);
  ctx.lineTo(W-pad, H-pad);
  ctx.lineTo(W-pad, pad);
  ctx.stroke();

  // bars (white outline vs neon fill)
  const barW = (W-2*pad)/bins;

  for(let i=0;i<bins;i++){
    const hW = (wb[i]/maxCount) * (H-2*pad);
    const hQ = (qb[i]/maxCount) * (H-2*pad);

    // White model bars (purple tint)
    ctx.fillStyle = "rgba(176,0,255,0.25)";
    ctx.fillRect(pad + i*barW + barW*0.05, H-pad-hW, barW*0.4, hW);

    // QDS model bars (green tint)
    ctx.fillStyle = "rgba(57,255,20,0.22)";
    ctx.fillRect(pad + i*barW + barW*0.55, H-pad-hQ, barW*0.4, hQ);
  }

  // labels
  ctx.fillStyle = "rgba(255,255,255,0.65)";
  ctx.font = `${11*devicePixelRatio}px system-ui`;
  ctx.fillText("White", pad, pad+10*devicePixelRatio);
  ctx.fillStyle = "rgba(57,255,20,0.75)";
  ctx.fillText("QDS", pad+50*devicePixelRatio, pad+10*devicePixelRatio);
}

function drawTrace(wt, qt){
  const c = $("trace");
  const ctx = c.getContext("2d");
  const W = c.width = c.clientWidth * devicePixelRatio;
  const H = c.height = c.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  if(!wt || !qt){ return; }

  const pad = 14*devicePixelRatio;
  const maxT = Math.max(wt[wt.length-1]?.t||1, qt[qt.length-1]?.t||1);

  function mapX(t){ return pad + (t/maxT)*(W-2*pad); }
  function mapY(cap){ return pad + (1-(cap/100))*(H-2*pad); }

  // grid
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.lineWidth = 1*devicePixelRatio;
  for(let g=0; g<=5; g++){
    const y = pad + g*(H-2*pad)/5;
    ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(W-pad,y); ctx.stroke();
  }

  // White trace (purple)
  ctx.strokeStyle = "rgba(176,0,255,0.8)";
  ctx.lineWidth = 2*devicePixelRatio;
  ctx.beginPath();
  wt.forEach((p,idx)=>{
    const x=mapX(p.t), y=mapY(p.cap);
    if(idx===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  // QDS trace (green)
  ctx.strokeStyle = "rgba(57,255,20,0.85)";
  ctx.lineWidth = 2*devicePixelRatio;
  ctx.beginPath();
  qt.forEach((p,idx)=>{
    const x=mapX(p.t), y=mapY(p.cap);
    if(idx===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  // legend
  ctx.fillStyle = "rgba(176,0,255,0.9)";
  ctx.font = `${11*devicePixelRatio}px system-ui`;
  ctx.fillText("White sample", pad, pad+10*devicePixelRatio);
  ctx.fillStyle = "rgba(57,255,20,0.9)";
  ctx.fillText("QDS sample", pad+100*devicePixelRatio, pad+10*devicePixelRatio);
}

// History
function loadHistory(){
  try{
    return JSON.parse(localStorage.getItem(state.historyKey) || "[]");
  }catch(e){ return []; }
}
function saveHistory(arr){
  localStorage.setItem(state.historyKey, JSON.stringify(arr.slice(-200)));
}
function pushHistory(entry){
  const arr = loadHistory();
  arr.push(entry);
  saveHistory(arr);
}
function renderHistory(){
  const host = $("history");
  const arr = loadHistory().slice(-6).reverse();
  host.innerHTML = "";

  if(arr.length===0){
    host.innerHTML = `<div class="tiny">No runs yet.</div>`;
    return;
  }

  arr.forEach(e=>{
    const d = new Date(e.ts);
    const stamp = d.toLocaleString();

    const isChaos = (e.rho >= 0.95) || (!e.posterMode) || (!e.noRegen);
    const tag = isChaos
      ? `<span class="tag chaos">CHAOS</span>`
      : `<span class="tag poster">POSTER-SAFE</span>`;

    const line =
      `<div class="history-item">
        <b>${stamp}</b>${tag}<br/>
        k1=${e.k1.toFixed(4)} ‚Ä¢ k2=${e.k2.toFixed(4)} ‚Ä¢ amp=${e.amp.toFixed(1)}% ‚Ä¢ œÅ=${e.rho.toFixed(2)} ‚Ä¢ thr=${e.thr}% ‚Ä¢ n=${e.n}<br/>
        white Œº=${e.white.mean.toFixed(1)} œÉ=${e.white.sigma.toFixed(1)} ‚Ä¢ QDS Œº=${e.qds.mean.toFixed(1)} œÉ=${e.qds.sigma.toFixed(1)}
        ‚Ä¢ Œî=${(e.delta_pct>=0?"+":"")}${e.delta_pct.toFixed(1)}%
      </div>`;
    host.insertAdjacentHTML("beforeend", line);
  });
}

// Bench viewer
$("benchParse").addEventListener("click", ()=>{
  const txt = $("benchPaste").value.trim();
  if(!txt){ $("benchOut").textContent = "Paste a JSON log first."; return; }
  try{
    const obj = JSON.parse(txt);
    // very loose schema handling
    const keys = Object.keys(obj);
    $("benchOut").innerHTML =
      `<div class="note">
        Parsed JSON ‚úÖ<br/>
        Top-level keys: ${keys.slice(0,20).join(", ")}${keys.length>20?"‚Ä¶":""}
      </div>`;
  }catch(e){
    $("benchOut").textContent = "Could not parse JSON.";
  }
});
$("benchClear").addEventListener("click", ()=>{
  $("benchPaste").value = "";
  $("benchOut").textContent = "";
});

// Utilities
$("copySum").addEventListener("click", ()=>{
  if(!state.lastRun){ return; }
  const e = state.lastRun;
  const txt =
`QDS Battery Hub v9.3 ‚Äî Science Neon
k1=${e.k1} k2=${e.k2} amp=${e.amp}% rho=${e.rho} thr=${e.thr}% n=${e.n} max=${e.maxc}
Poster=${e.posterMode} NoRegen=${e.noRegen} Seed=${e.seed}
White: mean=${e.white.mean.toFixed(2)} sigma=${e.white.sigma.toFixed(2)} P10/P50/P90=${e.white.p10}/${e.white.p50}/${e.white.p90}
QDS:   mean=${e.qds.mean.toFixed(2)} sigma=${e.qds.sigma.toFixed(2)} P10/P50/P90=${e.qds.p10}/${e.qds.p50}/${e.qds.p90}
Delta=${e.delta_pct.toFixed(2)}%`;
  navigator.clipboard?.writeText(txt);
});

function download(name, data){
  const blob = new Blob([data], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = name; a.click();
  URL.revokeObjectURL(url);
}

$("exportLast").addEventListener("click", ()=>{
  if(!state.lastRun){ return; }
  const stamp = new Date().toISOString().replace(/[:.]/g,"");
  download(`QDS_BatteryHub_v9.3_last_${stamp}.json`, JSON.stringify(state.lastRun,null,2));
});
$("exportAll").addEventListener("click", ()=>{
  const arr = loadHistory();
  const stamp = new Date().toISOString().replace(/[:.]/g,"");
  download(`QDS_BatteryHub_v9.3_history_${stamp}.json`, JSON.stringify(arr,null,2));
});
$("clearHist").addEventListener("click", ()=>{
  localStorage.removeItem(state.historyKey);
  renderHistory();
});

// Presets
function applyPreset(name){
  if(name==="phone"){
    $("k1").value = 0.0024;
    $("k2").value = 0.0006;
    $("amp").value = 1.8;
    $("rho").value = 0.25;
    $("thr").value = 80;
    $("n").value = 1200;
    $("maxc").value = 2000;
    state.posterMode = true; state.noRegen = true;
  }
  if(name==="contrast"){
    $("k1").value = 0.0018;
    $("k2").value = 0.0004;
    $("amp").value = 2.4;
    $("rho").value = 0.60;
    $("thr").value = 80;
    $("n").value = 1200;
    $("maxc").value = 2500;
    state.posterMode = true; state.noRegen = true;
  }
  if(name==="chaos"){
    $("k1").value = 0.0018;
    $("k2").value = 0.0004;
    $("amp").value = 3.0;
    $("rho").value = 0.99;
    $("thr").value = 80;
    $("n").value = 600;
    $("maxc").value = 4000;
    state.posterMode = false; state.noRegen = false;
  }
  syncLabels();
}

document.querySelectorAll("[data-preset]").forEach(b=>{
  b.addEventListener("click", ()=>applyPreset(b.dataset.preset));
});

// Reset
$("reset").addEventListener("click", ()=>applyPreset("phone"));

// Run
$("run").addEventListener("click", runSim);

// Init
syncLabels();
renderHistory();
applyPreset("phone");
runSim();


// --- qds_battery_hub_v9_4_science_neon_plus.html ---

/* =========================================================
   QDS Battery Hub v9.4 ‚Äî Science Neon+
   Single-file, offline, phone-safe
   Focus: qualitative behaviour of correlated stress
   ========================================================= */

const $ = (id)=>document.getElementById(id);
const TABS = [...document.querySelectorAll(".tab")];
const PANES = {
  lab: $("lab"),
  coach: $("coach"),
  bench: $("bench"),
};

function setTab(name){
  TABS.forEach(t=>t.classList.toggle("active", t.dataset.tab===name));
  Object.keys(PANES).forEach(k=>PANES[k].style.display = (k===name) ? "" : "none");
}
TABS.forEach(t=>t.addEventListener("click", ()=>setTab(t.dataset.tab)));

/* ---------- Persistent history ---------- */
const HIST_KEY = "QDS_BATTERY_HUB_V9_4_HISTORY";
let history = [];
try{ history = JSON.parse(localStorage.getItem(HIST_KEY)||"[]"); }catch(e){ history=[]; }
function saveHistory(){
  localStorage.setItem(HIST_KEY, JSON.stringify(history.slice(-120)));
  renderHistory();
}
function renderHistory(){
  const box = $("historyBox");
  if(!box) return;
  const last = history.slice(-6).reverse();
  box.innerHTML = last.length ? "" : `<div class="hist-item small">No runs yet.</div>`;
  last.forEach(h=>{
    const tag = h.tag ? `<span class="pill">${h.tag}</span>` : "";
    box.innerHTML += `
      <div class="hist-item">
        ${tag}<strong>${h.time}</strong><br/>
        <span class="mono">
          k1=${h.k1} ‚Ä¢ k2=${h.k2} ‚Ä¢ amp=${h.amp}% ‚Ä¢ œÅ=${h.rho} ‚Ä¢ T=${h.temp}¬∞C ‚Ä¢ DoD=${h.dodLabel} ‚Ä¢ thr=${h.thr}% ‚Ä¢ n=${h.n}
        </span><br/>
        <span class="mono">
          white Œº=${h.wMean} œÉ=${h.wSig} ‚Ä¢ QDS Œº=${h.qMean} œÉ=${h.qSig} ‚Ä¢ Œî=${h.delta}
        </span>
      </div>`;
  });
}
renderHistory();

/* ---------- UI value sync ---------- */
function fmt(x, d=4){ return (+x).toFixed(d); }
function fmt2(x){ return (+x).toFixed(2); }

const defaults = {
  k1:0.0018, k2:0.0004, amp:2.4, rho:0.60,
  temp:25, dod:"0.75",
  n:1200, maxc:2500, thr:80,
  seed:17345, seedlock:true, poster:true, noregen:true, fast:true
};

function updateLabels(){
  $("k1v").textContent = fmt($("k1").value);
  $("k2v").textContent = fmt($("k2").value);
  $("ampv").textContent = fmt2($("amp").value)+"%";
  $("rhov").textContent = fmt2($("rho").value);
  $("tempv").textContent = $("temp").value+"¬∞C";
  const dodSel = $("dod");
  $("dodv").textContent = dodSel.options[dodSel.selectedIndex].text.replace(/\s*\(.*\)/,"");
  $("nv").textContent = $("n").value;
  $("maxcv").textContent = $("maxc").value;
  $("thrv").textContent = $("thr").value+"%";
  $("seedv").textContent = $("seed").value;
}
["k1","k2","amp","rho","temp","dod","n","maxc","thr","seed"].forEach(id=>{
  $(id).addEventListener("input", updateLabels);
});
updateLabels();

/* ---------- PRNG ---------- */
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}
function randn(rng){
  // Box-Muller
  let u=0,v=0;
  while(u===0) u=rng();
  while(v===0) v=rng();
  return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
}

/* ---------- Toy physics knobs ---------- */
function tempMultiplier(T){
  // Gentle exponential-ish scaling around 25¬∞C.
  // This is intentionally mild to avoid poster explosions.
  const beta = 0.018; // tweakable
  return Math.exp(beta * (T - 25));
}
function dodLabelFromValue(v){
  if(v==="1.00") return "0‚Äì100";
  if(v==="0.88") return "10‚Äì90";
  if(v==="0.75") return "20‚Äì80";
  if(v==="0.62") return "30‚Äì70";
  return "custom";
}

/* ---------- Simulation core ---------- */
function simulateModel(params, correlated=false){
  const {
    k1, k2, amp, rho, temp, dodMult, n, maxc, thr,
    seed, poster, noregen, fast
  } = params;

  const rng = mulberry32(seed);
  const thrCap = thr;
  const cycles = new Array(n);

  // Per-cell variability (small)
  const k1J = 0.10; // ¬±10%
  const k2J = 0.12;

  // Noise amplitude as fraction
  const ampFrac = amp/100;

  const Tm = tempMultiplier(temp);
  const effectiveK1Base = k1 * dodMult * Tm;
  const effectiveK2Base = k2 * dodMult * Tm;

  // Poster clamps
  const minStress = poster ? 0.35 : -Infinity;
  const maxStress = poster ? 2.30 : Infinity;

  for(let i=0;i<n;i++){
    const k1i = effectiveK1Base * (1 + (rng()*2-1)*k1J);
    const k2i = effectiveK2Base * (1 + (rng()*2-1)*k2J);

    let cap = 100.0;
    let x = 0.0; // AR(1) state

    let t=1;
    for(; t<=maxc; t++){
      // base loss grows with sqrt(t) + linear
      const baseLoss = k1i*Math.sqrt(t) + k2i*t;

      let eps = randn(rng) * ampFrac; // gaussian stress %
      if(correlated){
        x = rho*x + eps;
      }else{
        x = eps;
      }

      // Convert stress to multiplicative factor on loss
      let stress = 1 + x;

      // NoRegen: don't allow "super-negative" stress to unrealistically heal the model
      if(noregen && stress < 0.70) stress = 0.70;

      if(poster){
        if(stress < minStress) stress = minStress;
        if(stress > maxStress) stress = maxStress;
      }

      cap -= baseLoss * stress * 100; // scale to % capacity units

      if(cap <= thrCap) break;

      // Fast mode avoids any extra per-cycle bookkeeping
      if(!fast){
        // placeholder for future richer traces
      }
    }
    cycles[i] = (t>maxc) ? maxc : t;
  }

  return cycles;
}

/* ---------- Stats ---------- */
function mean(arr){
  let s=0; for(let i=0;i<arr.length;i++) s+=arr[i];
  return s/arr.length;
}
function std(arr, m){
  let s=0; for(let i=0;i<arr.length;i++){ const d=arr[i]-m; s+=d*d; }
  return Math.sqrt(s/(arr.length-1 || 1));
}
function percentile(sorted, p){
  if(!sorted.length) return 0;
  const idx = (p/100)*(sorted.length-1);
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if(lo===hi) return sorted[lo];
  const w = idx-lo;
  return sorted[lo]*(1-w)+sorted[hi]*w;
}

/* ---------- Lightweight drawing ---------- */
function drawHistogram(canvas, white, qds){
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const all = white.concat(qds);
  const min = Math.min(...all), max = Math.max(...all);
  const bins = 28;
  const bw = Math.max(1, Math.floor((max-min)/bins));

  const countBins = (data)=>{
    const out = new Array(bins).fill(0);
    for(const v of data){
      const b = Math.min(bins-1, Math.max(0, Math.floor((v-min)/bw)));
      out[b] += 1;
    }
    return out;
  }
  const bwc = countBins(white);
  const bqc = countBins(qds);
  const peak = Math.max(...bwc, ...bqc, 1);

  // axes glow lines
  ctx.globalAlpha = 0.15;
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, h-2, w, 2);
  ctx.globalAlpha = 1;

  const pad = 10*devicePixelRatio;
  const chartW = w - pad*2;
  const chartH = h - pad*2;
  const barW = chartW / bins;

  for(let i=0;i<bins;i++){
    const x = pad + i*barW;
    const hw = (bwc[i]/peak) * chartH;
    const hq = (bqc[i]/peak) * chartH;

    // White bars (purple soft)
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "rgba(168,85,247,0.55)";
    ctx.fillRect(x, pad + (chartH-hw), barW*0.92, hw);

    // QDS overlay (neon green)
    ctx.globalAlpha = 0.65;
    ctx.fillStyle = "rgba(57,255,136,0.65)";
    ctx.fillRect(x+barW*0.12, pad + (chartH-hq), barW*0.60, hq);
  }
  ctx.globalAlpha = 1;
}

function drawTraces(canvas, params){
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const {
    k1, k2, amp, rho, temp, dodMult, maxc, thr, seed, poster, noregen
  } = params;

  const rngW = mulberry32(seed+101);
  const rngQ = mulberry32(seed+202);

  const ampFrac = amp/100;
  const Tm = tempMultiplier(temp);
  const effK1 = k1 * dodMult * Tm;
  const effK2 = k2 * dodMult * Tm;

  const minStress = poster ? 0.35 : -Infinity;
  const maxStress = poster ? 2.30 : Infinity;

  function buildTrace(correlated, rng){
    let cap = 100;
    let x = 0;
    const out = new Float32Array(maxc);
    for(let t=1;t<=maxc;t++){
      const baseLoss = (effK1*Math.sqrt(t) + effK2*t);
      let eps = randn(rng) * ampFrac;
      x = correlated ? (rho*x + eps) : eps;
      let stress = 1 + x;
      if(noregen && stress < 0.70) stress = 0.70;
      if(poster){
        if(stress < minStress) stress = minStress;
        if(stress > maxStress) stress = maxStress;
      }
      cap -= baseLoss * stress * 100;
      out[t-1] = cap;
      if(cap <= thr) {
        for(let k=t;k<=maxc;k++) out[k-1]=cap;
        break;
      }
    }
    return out;
  }

  const white = buildTrace(false, rngW);
  const qds = buildTrace(true, rngQ);

  const pad = 10*devicePixelRatio;
  const chartW = w - pad*2;
  const chartH = h - pad*2;

  // frame line
  ctx.globalAlpha = 0.12;
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, h-2, w, 2);
  ctx.globalAlpha = 1;

  function plot(arr, color){
    ctx.strokeStyle = color;
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.beginPath();
    for(let i=0;i<arr.length;i++){
      const x = pad + (i/(arr.length-1))*chartW;
      const yVal = Math.max(0, Math.min(100, arr[i]));
      const y = pad + (1 - yVal/100)*chartH;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  plot(white, "rgba(168,85,247,0.9)");
  plot(qds, "rgba(57,255,136,0.9)");

  // threshold line
  const yThr = pad + (1 - thr/100)*chartH;
  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = "rgba(255,255,255,0.5)";
  ctx.setLineDash([6*devicePixelRatio, 6*devicePixelRatio]);
  ctx.beginPath(); ctx.moveTo(pad, yThr); ctx.lineTo(pad+chartW, yThr); ctx.stroke();
  ctx.setLineDash([]); ctx.globalAlpha = 1;
}

/* ---------- Run orchestration ---------- */
function collectParams(){
  const dodMult = parseFloat($("dod").value);
  return {
    k1: parseFloat($("k1").value),
    k2: parseFloat($("k2").value),
    amp: parseFloat($("amp").value),
    rho: parseFloat($("rho").value),
    temp: parseInt($("temp").value,10),
    dodMult,
    dodLabel: dodLabelFromValue($("dod").value),
    n: parseInt($("n").value,10),
    maxc: parseInt($("maxc").value,10),
    thr: parseInt($("thr").value,10),
    seed: parseInt($("seed").value,10) || 1,
    seedlock: $("seedlock").checked,
    poster: $("poster").checked,
    noregen: $("noregen").checked,
    fast: $("fast").checked,
  };
}

let lastResult = null;

function runSimulation(tag=""){
  const p = collectParams();

  // If seed lock off, jitter seed a bit per run
  if(!p.seedlock){
    p.seed = (p.seed + Math.floor(Math.random()*9999)) % 999999 + 1;
    $("seed").value = p.seed;
    updateLabels();
  }

  const seedWhite = p.seed;
  const seedQDS = p.seed + 777; // deterministic separation

  const wCycles = simulateModel({...p, seed: seedWhite}, false);
  const qCycles = simulateModel({...p, seed: seedQDS}, true);

  // stats
  const wSorted = wCycles.slice().sort((a,b)=>a-b);
  const qSorted = qCycles.slice().sort((a,b)=>a-b);

  const wM = mean(wCycles), qM = mean(qCycles);
  const wS = std(wCycles, wM), qS = std(qCycles, qM);

  const wP10 = percentile(wSorted,10), wP50 = percentile(wSorted,50), wP90 = percentile(wSorted,90);
  const qP10 = percentile(qSorted,10), qP50 = percentile(qSorted,50), qP90 = percentile(qSorted,90);

  const delta = (qM - wM) / Math.max(1e-9, wM) * 100;

  // UI
  $("wMean").textContent = fmt2(wM);
  $("wSig").textContent = fmt2(wS);
  $("qMean").textContent = fmt2(qM);
  $("qSig").textContent = fmt2(qS);
  $("wP").textContent = `P10/P50/P90 ${fmt2(wP10)} / ${fmt2(wP50)} / ${fmt2(wP90)}`;
  $("qP").textContent = `P10/P50/P90 ${fmt2(qP10)} / ${fmt2(qP50)} / ${fmt2(qP90)}`;
  $("delta").textContent = `${delta>=0?"+":""}${fmt2(delta)}%`;

  $("meta").textContent =
    `Poster=${p.poster} ¬∑ NoRegen=${p.noregen} ¬∑ œÅ=${fmt2(p.rho)} ¬∑ T=${p.temp}¬∞C ¬∑ DoD=${p.dodLabel} ¬∑ n=${p.n}`;

  // Charts
  drawHistogram($("hist"), wCycles, qCycles);
  if(p.fast){
    // still draw a light trace with lower cost
    drawTraces($("trace"), {...p, seed:p.seed});
  }else{
    drawTraces($("trace"), {...p, seed:p.seed});
  }

  // record history
  const now = new Date();
  const time = now.toLocaleString();
  const entry = {
    tag,
    time,
    k1: fmt(p.k1),
    k2: fmt(p.k2),
    amp: fmt2(p.amp),
    rho: fmt2(p.rho),
    temp: p.temp,
    dodLabel: p.dodLabel,
    thr: p.thr,
    n: p.n,
    maxc: p.maxc,
    wMean: fmt2(wM),
    wSig: fmt2(wS),
    qMean: fmt2(qM),
    qSig: fmt2(qS),
    delta: `${delta>=0?"+":""}${fmt2(delta)}%`,
    wP10: fmt2(wP10), wP50: fmt2(wP50), wP90: fmt2(wP90),
    qP10: fmt2(qP10), qP50: fmt2(qP50), qP90: fmt2(qP90),
    poster: p.poster, noregen: p.noregen, seed: p.seed
  };
  history.push(entry);
  saveHistory();

  lastResult = { params:p, wCycles, qCycles, entry };
}

/* ---------- Buttons ---------- */
$("run").addEventListener("click", ()=>runSimulation("RUN"));
$("reset").addEventListener("click", ()=>{
  $("k1").value = defaults.k1;
  $("k2").value = defaults.k2;
  $("amp").value = defaults.amp;
  $("rho").value = defaults.rho;
  $("temp").value = defaults.temp;
  $("dod").value = defaults.dod;
  $("n").value = defaults.n;
  $("maxc").value = defaults.maxc;
  $("thr").value = defaults.thr;
  $("seed").value = defaults.seed;
  $("seedlock").checked = defaults.seedlock;
  $("poster").checked = defaults.poster;
  $("noregen").checked = defaults.noregen;
  $("fast").checked = defaults.fast;
  updateLabels();
});

$("presetPhone").addEventListener("click", ()=>{
  $("k1").value = 0.0017;
  $("k2").value = 0.00035;
  $("amp").value = 2.0;
  $("rho").value = 0.55;
  $("temp").value = 28;
  $("dod").value = "0.75";
  $("thr").value = 80;
  $("n").value = 1200;
  $("maxc").value = 2600;
  $("poster").checked = true;
  $("noregen").checked = true;
  $("fast").checked = true;
  updateLabels();
  runSimulation("REALISTIC");
});

$("presetQDS").addEventListener("click", ()=>{
  $("k1").value = 0.0018;
  $("k2").value = 0.0004;
  $("amp").value = 2.4;
  $("rho").value = 0.70;
  $("temp").value = 25;
  $("dod").value = "0.75";
  $("thr").value = 80;
  $("n").value = 1200;
  $("maxc").value = 2500;
  $("poster").checked = true;
  $("noregen").checked = true;
  $("fast").checked = true;
  updateLabels();
  runSimulation("QDS-CONTRAST");
});

$("presetChaos").addEventListener("click", ()=>{
  $("k1").value = 0.0022;
  $("k2").value = 0.0005;
  $("amp").value = 3.2;
  $("rho").value = 0.99;
  $("temp").value = 40;
  $("dod").value = "1.00";
  $("thr").value = 80;
  $("n").value = 600;
  $("maxc").value = 2500;
  $("poster").checked = true;   // still keep sane
  $("noregen").checked = true;
  $("fast").checked = true;
  updateLabels();
  runSimulation("CHAOS");
});

/* ---------- Export / Copy ---------- */
function download(name, text){
  const blob = new Blob([text], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
}

$("copy").addEventListener("click", async ()=>{
  if(!lastResult){ runSimulation("RUN"); }
  const e = lastResult.entry;
  const summary =
`QDS Battery Hub v9.4 ‚Äî Science Neon+
${e.time}
${e.tag ? "["+e.tag+"] " : ""}k1=${e.k1} ‚Ä¢ k2=${e.k2} ‚Ä¢ amp=${e.amp}% ‚Ä¢ œÅ=${e.rho} ‚Ä¢ T=${e.temp}¬∞C ‚Ä¢ DoD=${e.dodLabel} ‚Ä¢ thr=${e.thr}% ‚Ä¢ n=${e.n}
white Œº=${e.wMean} œÉ=${e.wSig} ‚Ä¢ QDS Œº=${e.qMean} œÉ=${e.qSig} ‚Ä¢ Œî=${e.delta}`;
  try{ await navigator.clipboard.writeText(summary); }catch(err){}
});

$("exportLast").addEventListener("click", ()=>{
  if(!lastResult){ runSimulation("RUN"); }
  const payload = {
    version:"9.4",
    type:"QDS_BATTERY_HUB_RUN",
    entry:lastResult.entry,
    params:lastResult.params,
  };
  const stamp = new Date().toISOString().replace(/[:.]/g,"-");
  download(`QDS_BatteryHub_v9.4_${stamp}.json`, JSON.stringify(payload,null,2));
});

$("exportAll").addEventListener("click", ()=>{
  const payload = {
    version:"9.4",
    type:"QDS_BATTERY_HUB_HISTORY",
    history
  };
  const stamp = new Date().toISOString().replace(/[:.]/g,"-");
  download(`QDS_BatteryHub_v9.4_HISTORY_${stamp}.json`, JSON.stringify(payload,null,2));
});

$("clearHist").addEventListener("click", ()=>{
  history = [];
  saveHistory();
});

/* ---------- Coach ---------- */
function buildCoachText(){
  const p = collectParams();
  const Tm = tempMultiplier(p.temp);
  const dodLabel = p.dodLabel;

  const riskRho =
    p.rho < 0.3 ? "low streak risk" :
    p.rho < 0.7 ? "moderate streak risk" :
    "high streak risk (tails widen)";

  const tempMsg =
    p.temp <= 10 ? "cold regime: performance may sag, but wear stress is lower (toy logic)." :
    p.temp <= 30 ? "comfort regime: most stable toy outcomes." :
    "hot regime: expect accelerated wear + fatter tails.";

  const dodMsg =
    dodLabel === "0‚Äì100" ? "Wide window: fastest toy wear." :
    dodLabel === "10‚Äì90" ? "Moderate window: improved toy longevity." :
    dodLabel === "20‚Äì80" ? "Sweet spot: life-friendly settings." :
    "Ultra narrow: maximum toy kindness.";

  const posterMsg = p.poster ? "Poster Mode ON: chaos tamed ‚úÖ" : "Poster Mode OFF: expect fireworks ‚ö†Ô∏è";
  const regenMsg = p.noregen ? "NoRegen ON: avoids unrealistic negative-stress wins." : "NoRegen OFF: toy can over-credit lucky cycles.";

  return (
`COACH READOUT (toy)
œÅ=${fmt2(p.rho)} ‚Üí ${riskRho}
T=${p.temp}¬∞C ‚Üí ${tempMsg}
DoD=${dodLabel} ‚Üí ${dodMsg}

Effective stress multiplier (temp) ‚âà ${fmt2(Tm)}
k1=${fmt(p.k1)}  k2=${fmt(p.k2)}  amp=${fmt2(p.amp)}%

Advice:
‚Ä¢ If you want ‚Äúscience poster‚Äù plots: keep œÅ ‚â§ 0.7, Poster ON.
‚Ä¢ For best-life demos: choose 20‚Äì80 or 30‚Äì70 window, lower amp, cooler temps.
‚Ä¢ Use Chaos preset only when showing tail-risk behaviour.

Flags:
‚Ä¢ ${posterMsg}
‚Ä¢ ${regenMsg}`
  );
}
function refreshCoach(){
  $("coachText").textContent = buildCoachText();
}
$("coachRefresh").addEventListener("click", refreshCoach);
refreshCoach();

/* ---------- AutoBench Viewer Import ---------- */
$("benchLoad").addEventListener("click", async ()=>{
  const files = $("benchFiles").files;
  const box = $("benchBox");
  if(!files || !files.length){
    box.innerHTML = `<div class="hist-item small">No files selected.</div>`;
    return;
  }
  box.innerHTML = "";
  for(const f of files){
    try{
      const text = await f.text();
      const j = JSON.parse(text);

      // We try to gracefully read either AutoBench v9.1-PRO logs
      // or Hub exports.
      let line = "";
      if(j && j.meta && j.results){
        // hypothetical structure
        line = `${f.name} ‚Äî ${JSON.stringify(j.meta).slice(0,120)}...`;
      } else if(j && j.entry){
        const e = j.entry;
        line = `${f.name}
k1=${e.k1} k2=${e.k2} amp=${e.amp}% œÅ=${e.rho} thr=${e.thr}% n=${e.n}
white Œº=${e.wMean} œÉ=${e.wSig} ‚Ä¢ QDS Œº=${e.qMean} œÉ=${e.qSig} ‚Ä¢ Œî=${e.delta}`;
      } else {
        // raw log fallback
        line = `${f.name} ‚Äî parsed JSON (structure unknown)`;
      }

      box.innerHTML += `<div class="hist-item mono">${line.replace(/\n/g,"<br/>")}</div>`;
    }catch(err){
      box.innerHTML += `<div class="hist-item mono">${f.name} ‚Äî failed to parse</div>`;
    }
  }
});

$("benchClear").addEventListener("click", ()=>{
  $("benchBox").innerHTML = `<div class="hist-item small">Viewer cleared.</div>`;
});

/* ---------- First run for a nice landing ---------- */
setTimeout(()=>{ if(!history.length) runSimulation("BOOT"); }, 80);


// --- qds_battery_hub_v9_5_science_neon.html ---

/* =========================
   QDS Battery Hub v9.5
   Offline, phone-safe
   ========================= */

/* ---------- tiny seeded RNG ---------- */
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}
function randn(rng){
  // Box-Muller
  let u=0, v=0;
  while(u===0) u=rng();
  while(v===0) v=rng();
  return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
}
function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }

/* ---------- model scalers (gentle, not pretend-precise) ---------- */
function tempFactor(T){
  // 25¬∞C baseline. Mild acceleration outside.
  // This is a toy: keep it smooth and conservative.
  const d = T - 25;
  const f = 1 + (d/25)*0.35;    // ~+35% at 50¬∞C, ~-14% at 15¬∞C
  return clamp(f, 0.75, 1.7);
}
function dodFactor(dodStr){
  // Smaller DoD window = less mechanical/chemical strain (toy)
  const map = {
    "40-80": 0.85,
    "20-80": 0.92,
    "10-90": 1.00,
    "0-100": 1.12,
    "60-100": 1.18
  };
  return map[dodStr] ?? 1.0;
}

/* ---------- stress generator ---------- */
function makeStressSeries({ampPct, rho, cycles, rng, poster, noRegen}){
  const amp = ampPct/100; // convert to fractional
  const series = new Float32Array(cycles);
  let x = 0;
  const epsScale = amp * Math.sqrt(Math.max(1e-6, 1 - rho*rho));
  for(let t=0; t<cycles; t++){
    const eps = randn(rng) * epsScale;
    x = rho*x + eps;

    // stress multiplier around 1
    let s = 1 + x;

    if(noRegen){
      // Prevent ultra-lucky negative streaks from "healing" the toy too much
      // (i.e., don't allow stress to go unrealistically below mild relief)
      s = Math.max(s, 0.85);
    }

    if(poster){
      // Tame extremes to keep demos honest
      s = clamp(s, 0.7, 1.6);
    } else {
      s = clamp(s, 0.4, 2.2);
    }

    series[t]=s;
  }
  return series;
}

/* ---------- capacity fade simulator ---------- */
function simulateModel(params, modelKind){
  const {
    k1, k2, ampPct, rho, T, DoD, thr,
    nCells, maxCycles, seedBase, poster, noRegen, seedLock
  } = params;

  const cyclesToFail = new Array(nCells);
  const trace = { cap: [], failAt: null };

  // baseline factors
  const fT = tempFactor(T);
  const fD = dodFactor(DoD);

  // per-cell variability (tiny)
  const cellJitter = 0.06; // 6% SD

  for(let i=0; i<nCells; i++){
    const seed = seedLock
      ? (seedBase + i*101 + (modelKind==="QDS"? 0 : 0))
      : (seedBase + i*101 + (modelKind==="QDS"? 7777 : 3333));

    const rng = mulberry32(seed|0);

    const k1i = k1 * (1 + randn(rng)*cellJitter);
    const k2i = k2 * (1 + randn(rng)*cellJitter);

    const useRho = (modelKind==="QDS") ? rho : 0.0;
    const stress = makeStressSeries({
      ampPct, rho: useRho, cycles: maxCycles,
      rng, poster, noRegen
    });

    let cap = 1.0; // 100%
    let failAt = maxCycles;

    for(let t=1; t<=maxCycles; t++){
      // composite fade per cycle (toy)
      // small positive drift with time
      const baseLoss = (k1i*Math.sqrt(t) + k2i*t);

      // stress + environment
      const loss = baseLoss * stress[t-1] * fT * fD;

      cap -= loss;

      if(cap*100 <= thr){
        failAt = t;
        break;
      }
    }

    cyclesToFail[i] = failAt;

    // store a representative trace (first cell)
    if(i===0){
      cap = 1.0;
      trace.cap.length = 0;
      trace.failAt = null;

      const rng2 = mulberry32(seed|0);
      const k1j = k1 * (1 + randn(rng2)*cellJitter);
      const k2j = k2 * (1 + randn(rng2)*cellJitter);
      const stress2 = makeStressSeries({
        ampPct, rho: useRho, cycles: maxCycles,
        rng: rng2, poster, noRegen
      });

      for(let t=1; t<=maxCycles; t++){
        const baseLoss = (k1j*Math.sqrt(t) + k2j*t);
        const loss = baseLoss * stress2[t-1] * fT * fD;
        cap -= loss;
        trace.cap.push(Math.max(0, cap*100));
        if(trace.failAt===null && cap*100 <= thr){
          trace.failAt = t;
        }
        if(t>1800 && trace.cap.length>1800) break; // mobile sanity
      }
    }
  }

  return { cyclesToFail, trace };
}

/* ---------- stats helpers ---------- */
function mean(arr){
  let s=0; for(const x of arr) s+=x; return s/arr.length;
}
function std(arr, mu){
  let s=0; for(const x of arr){ const d=x-mu; s+=d*d; }
  return Math.sqrt(s/(arr.length||1));
}
function quantile(sorted, q){
  const n = sorted.length;
  if(n===0) return 0;
  const pos = (n-1)*q;
  const lo = Math.floor(pos), hi = Math.ceil(pos);
  if(lo===hi) return sorted[lo];
  const t = pos-lo;
  return sorted[lo]*(1-t)+sorted[hi]*t;
}

/* ---------- history store with dedupe ---------- */
const HIST_KEY = "QDS_BATT_HISTORY_V9_5";

function sameRun(a,b){
  const keys=["k1","k2","ampPct","rho","T","DoD","thr","nCells","maxCycles","poster","noRegen"];
  return keys.every(k => String(a[k])===String(b[k]));
}
function loadHist(){
  try{ return JSON.parse(localStorage.getItem(HIST_KEY)||"[]"); }
  catch(e){ return []; }
}
function saveHist(hist){
  localStorage.setItem(HIST_KEY, JSON.stringify(hist.slice(0,200)));
}
function addRunToHist(run){
  const hist = loadHist();
  if(hist.length && sameRun(hist[0], run)){
    hist[0]=run;
  } else {
    hist.unshift(run);
  }
  saveHist(hist);
  renderHistory();
}

/* ---------- UI wiring ---------- */
const $ = id => document.getElementById(id);

const controls = {
  k1:$("k1"), k2:$("k2"), amp:$("amp"), rho:$("rho"),
  temp:$("temp"), thr:$("thr"), n:$("n"), maxCycles:$("maxCycles"),
  dod:$("dod"), seed:$("seed"),
  seedLock:$("seedLock"), poster:$("poster"), noRegen:$("noRegen")
};

function syncVals(){
  $("k1Val").textContent = Number(controls.k1.value).toFixed(4);
  $("k2Val").textContent = Number(controls.k2.value).toFixed(4);
  $("ampVal").textContent = Number(controls.amp.value).toFixed(2)+"%";
  $("rhoVal").textContent = Number(controls.rho.value).toFixed(2);
  $("tVal").textContent = Number(controls.temp.value)+"¬∞C";
  $("thrVal").textContent = Number(controls.thr.value)+"%";
  $("nVal").textContent = Number(controls.n.value);
  $("maxVal").textContent = Number(controls.maxCycles.value);
}
Object.values(controls).forEach(el=>{
  if(el && el.tagName==="INPUT" && el.type==="range"){
    el.addEventListener("input", syncVals);
  }
});
controls.dod.addEventListener("change", syncVals);
syncVals();

/* ---------- charts ---------- */
function drawHistogram(canvas, whiteArr, qdsArr){
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.clientWidth*devicePixelRatio;
  const h = canvas.height = canvas.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const all = whiteArr.concat(qdsArr);
  const max = Math.max(...all);
  const min = Math.min(...all);
  const bins = 28;

  const binW = (max-min)/bins || 1;
  const countW = new Array(bins).fill(0);
  const countQ = new Array(bins).fill(0);

  for(const x of whiteArr){
    const b = clamp(Math.floor((x-min)/binW), 0, bins-1);
    countW[b]++;
  }
  for(const x of qdsArr){
    const b = clamp(Math.floor((x-min)/binW), 0, bins-1);
    countQ[b]++;
  }
  const peak = Math.max(...countW, ...countQ) || 1;

  // axes baseline
  ctx.globalAlpha = 0.9;
  ctx.lineWidth = 1*devicePixelRatio;

  const padL = 28*devicePixelRatio, padR = 10*devicePixelRatio;
  const padT = 8*devicePixelRatio, padB = 24*devicePixelRatio;

  const plotW = w - padL - padR;
  const plotH = h - padT - padB;

  // subtle grid
  ctx.strokeStyle = "rgba(180,0,255,0.18)";
  for(let i=0; i<=4; i++){
    const y = padT + plotH*(i/4);
    ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(padL+plotW,y); ctx.stroke();
  }

  // bars
  const barGap = 1*devicePixelRatio;
  const barW = plotW/bins;

  for(let i=0; i<bins; i++){
    const x0 = padL + i*barW;
    const hw = (countW[i]/peak)*plotH;
    const hq = (countQ[i]/peak)*plotH;

    // White (purple tint)
    ctx.fillStyle = "rgba(180,0,255,0.35)";
    ctx.fillRect(x0+barGap, padT+plotH-hw, barW*0.48-barGap, hw);

    // QDS (green tint)
    ctx.fillStyle = "rgba(57,255,20,0.35)";
    ctx.fillRect(x0+barW*0.5, padT+plotH-hq, barW*0.48-barGap, hq);
  }

  // labels
  ctx.fillStyle = "rgba(233,230,255,0.75)";
  ctx.font = `${10*devicePixelRatio}px system-ui`;
  ctx.fillText("cycles", 4*devicePixelRatio, h-6*devicePixelRatio);
}

function drawTraces(canvas, whiteTrace, qdsTrace, thr){
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.clientWidth*devicePixelRatio;
  const h = canvas.height = canvas.clientHeight*devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const pad = 10*devicePixelRatio;
  const plotW = w-2*pad, plotH = h-2*pad;

  function line(trace, color){
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.8*devicePixelRatio;
    ctx.beginPath();
    const n = trace.length;
    for(let i=0; i<n; i++){
      const x = pad + (i/(n-1||1))*plotW;
      const y = pad + (1 - trace[i]/100)*plotH;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // threshold line
  const yThr = pad + (1 - thr/100)*plotH;
  ctx.strokeStyle = "rgba(255,77,154,0.45)";
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.setLineDash([4*devicePixelRatio, 4*devicePixelRatio]);
  ctx.beginPath(); ctx.moveTo(pad, yThr); ctx.lineTo(pad+plotW, yThr); ctx.stroke();
  ctx.setLineDash([]);

  line(whiteTrace, "rgba(180,0,255,0.85)");
  line(qdsTrace, "rgba(57,255,20,0.85)");
}

/* ---------- core run ---------- */
let lastRun = null;

function readParams(){
  return {
    k1: Number(controls.k1.value),
    k2: Number(controls.k2.value),
    ampPct: Number(controls.amp.value),
    rho: Number(controls.rho.value),
    T: Number(controls.temp.value),
    DoD: String(controls.dod.value),
    thr: Number(controls.thr.value),
    nCells: Number(controls.n.value),
    maxCycles: Number(controls.maxCycles.value),
    seedBase: Number(controls.seed.value)||12345,
    seedLock: !!controls.seedLock.checked,
    poster: !!controls.poster.checked,
    noRegen: !!controls.noRegen.checked
  };
}

function runOnce(tag="RUN"){
  const p = readParams();
  const ts = new Date();

  const white = simulateModel(p, "WHITE");
  const qds  = simulateModel(p, "QDS");

  const wArr = white.cyclesToFail;
  const qArr = qds.cyclesToFail;

  const wMu = mean(wArr);
  const qMu = mean(qArr);
  const wSd = std(wArr, wMu);
  const qSd = std(qArr, qMu);

  const wSorted = [...wArr].sort((a,b)=>a-b);
  const qSorted = [...qArr].sort((a,b)=>a-b);

  const wP10 = quantile(wSorted, 0.10);
  const wP50 = quantile(wSorted, 0.50);
  const wP90 = quantile(wSorted, 0.90);

  const qP10 = quantile(qSorted, 0.10);
  const qP50 = quantile(qSorted, 0.50);
  const qP90 = quantile(qSorted, 0.90);

  const deltaPct = ((qMu - wMu) / Math.max(1e-9, wMu))*100;

  lastRun = {
    tag,
    time: ts.toISOString(),
    timeLocal: ts.toLocaleString(),
    ...p,
    white: { mean:wMu, sd:wSd, p10:wP10, p50:wP50, p90:wP90 },
    qds:   { mean:qMu, sd:qSd, p10:qP10, p50:qP50, p90:qP90 },
    deltaPct,
    notes: "Semi-empirical toy: k1*sqrt(t) + k2*t with temp/DoD multipliers. White vs AR(1) stress."
  };

  // update UI
  $("wMean").textContent = wMu.toFixed(1);
  $("qMean").textContent = qMu.toFixed(1);
  $("wSd").textContent   = wSd.toFixed(1);
  $("qSd").textContent   = qSd.toFixed(1);

  $("wP").textContent = `P10/P50/P90 ${wP10.toFixed(0)} / ${wP50.toFixed(0)} / ${wP90.toFixed(0)}`;
  $("qP").textContent = `P10/P50/P90 ${qP10.toFixed(0)} / ${qP50.toFixed(0)} / ${qP90.toFixed(0)}`;

  const dTxt = (deltaPct>=0?"+":"") + deltaPct.toFixed(2) + "%";
  $("delta").textContent = dTxt;
  $("delta").className = "big " + (Math.abs(deltaPct) < 0.6 ? "" : (deltaPct>0 ? "good":"warn"));

  $("runsLine").textContent = `${p.nCells} per model`;
  $("modeLine").textContent =
    `œÅ=${p.rho.toFixed(2)} ¬∑ T=${p.T}¬∞C ¬∑ DoD=${p.DoD} ¬∑ Poster=${p.poster} ¬∑ NoRegen=${p.noRegen}`;

  drawHistogram($("histCanvas"), wArr, qArr);

  const wTrace = white.trace.cap.slice(0, 800);
  const qTrace = qds.trace.cap.slice(0, 800);
  drawTraces($("traceCanvas"), wTrace, qTrace, p.thr);

  const wFail = white.trace.failAt ?? "‚Äî";
  const qFail = qds.trace.failAt ?? "‚Äî";
  $("traceNote").textContent =
    `Sample cell traces. White fail‚âà${wFail} ¬∑ QDS fail‚âà${qFail} (if within displayed window).`;

  addRunToHist(lastRun);
  return lastRun;
}

/* ---------- QuickSweep √ó10 ---------- */
function quickSweep(){
  const baseSeed = Number(controls.seed.value)||12345;
  const deltas = [];
  const oldLock = controls.seedLock.checked;
  controls.seedLock.checked = true; // enforce fairness

  for(let i=0; i<10; i++){
    controls.seed.value = String(baseSeed + i*999);
    const r = runOnce("SWEEP");
    deltas.push(r.deltaPct);
  }
  controls.seed.value = String(baseSeed);
  controls.seedLock.checked = oldLock;
  syncVals();

  const mu = mean(deltas);
  alert(`QuickSweep √ó10 complete.\nMean Œî = ${(mu>=0?"+":"")}${mu.toFixed(2)}%\n(Seed-locked A/B)`);
}

/* ---------- presets ---------- */
function presetPhone(){
  controls.k1.value = 0.0018;
  controls.k2.value = 0.0004;
  controls.amp.value = 2.4;
  controls.rho.value = 0.60;
  controls.temp.value = 25;
  controls.dod.value = "20-80";
  controls.thr.value = 80;
  controls.n.value = 1200;
  controls.maxCycles.value = 2500;
  controls.poster.checked = true;
  controls.noRegen.checked = true;
  controls.seedLock.checked = true;
  syncVals();
}
function presetContrast(){
  presetPhone();
  controls.rho.value = 0.70;
  controls.amp.value = 2.4;
  syncVals();
}
function presetChaos(){
  controls.k1.value = 0.0022;
  controls.k2.value = 0.0005;
  controls.amp.value = 3.2;
  controls.rho.value = 0.99;
  controls.temp.value = 40;
  controls.dod.value = "0-100";
  controls.thr.value = 80;
  controls.n.value = 600;
  controls.maxCycles.value = 1800;
  controls.poster.checked = false;
  controls.noRegen.checked = true;
  controls.seedLock.checked = true;
  syncVals();
}

/* ---------- history render ---------- */
function renderHistory(){
  const box = $("historyBox");
  const hist = loadHist();
  box.innerHTML = "";
  if(hist.length===0){
    const d = document.createElement("div");
    d.className="hitem hint";
    d.textContent="No runs yet. Smash Run simulation.";
    box.appendChild(d);
    return;
  }
  const show = hist.slice(0,6);
  for(const h of show){
    const div = document.createElement("div");
    div.className = "hitem";
    const d = h.deltaPct ?? 0;
    const dTxt = (d>=0?"+":"") + Number(d).toFixed(2) + "%";
    const cls = Math.abs(d)<0.6 ? "" : (d>0 ? "good":"warn");
    div.innerHTML = `
      <span class="tag">${h.tag||"RUN"}</span>
      <b class="mono">${h.timeLocal||""}</b><br/>
      <span class="mono">
      k1=${Number(h.k1).toFixed(4)} ‚Ä¢ k2=${Number(h.k2).toFixed(4)} ‚Ä¢
      amp=${Number(h.ampPct).toFixed(2)}% ‚Ä¢ œÅ=${Number(h.rho).toFixed(2)} ‚Ä¢
      T=${h.T}¬∞C ‚Ä¢ DoD=${h.DoD} ‚Ä¢ thr=${h.thr}% ‚Ä¢ n=${h.nCells}
      </span><br/>
      <span class="mono">
        white Œº=${Number(h.white?.mean||0).toFixed(2)} œÉ=${Number(h.white?.sd||0).toFixed(2)} ‚Ä¢
        QDS Œº=${Number(h.qds?.mean||0).toFixed(2)} œÉ=${Number(h.qds?.sd||0).toFixed(2)} ‚Ä¢
        <b class="${cls}">Œî=${dTxt}</b>
      </span>
    `;
    box.appendChild(div);
  }
}
renderHistory();

/* ---------- export helpers ---------- */
function downloadJSON(obj, name){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
function copySummary(){
  if(!lastRun){ alert("Run a simulation first."); return; }
  const r = lastRun;
  const text =
`${r.tag||"RUN"} ${r.timeLocal}
k1=${r.k1.toFixed(4)} ‚Ä¢ k2=${r.k2.toFixed(4)} ‚Ä¢ amp=${r.ampPct.toFixed(2)}% ‚Ä¢ œÅ=${r.rho.toFixed(2)}
T=${r.T}¬∞C ‚Ä¢ DoD=${r.DoD} ‚Ä¢ thr=${r.thr}% ‚Ä¢ n=${r.nCells}
white Œº=${r.white.mean.toFixed(2)} œÉ=${r.white.sd.toFixed(2)}
QDS   Œº=${r.qds.mean.toFixed(2)} œÉ=${r.qds.sd.toFixed(2)}
Œî=${(r.deltaPct>=0?"+":"")}${r.deltaPct.toFixed(2)}%
Poster=${r.poster} ‚Ä¢ NoRegen=${r.noRegen} ‚Ä¢ SeedLock=${r.seedLock}`;
  navigator.clipboard?.writeText(text).then(()=> {
    alert("Summary copied.");
  }).catch(()=> alert(text));
}

/* ---------- buttons ---------- */
$("runBtn").addEventListener("click", ()=>runOnce("RUN"));
$("resetBtn").addEventListener("click", ()=>{ presetPhone(); });
$("sweepBtn").addEventListener("click", quickSweep);

$("presetPhone").addEventListener("click", presetPhone);
$("presetContrast").addEventListener("click", presetContrast);
$("presetChaos").addEventListener("click", presetChaos);

$("copyBtn").addEventListener("click", copySummary);
$("exportLastBtn").addEventListener("click", ()=>{
  if(!lastRun){ alert("No last run yet."); return; }
  downloadJSON(lastRun, `QDS_BatteryHub_v9.5_last_${Date.now()}.json`);
});
$("exportHistBtn").addEventListener("click", ()=>{
  const hist = loadHist();
  downloadJSON(hist, `QDS_BatteryHub_v9.5_history_${Date.now()}.json`);
});
$("clearHistBtn").addEventListener("click", ()=>{
  if(confirm("Clear local history?")){
    localStorage.removeItem(HIST_KEY);
    renderHistory();
  }
});

/* ---------- tabs ---------- */
document.querySelectorAll(".tab-btn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    document.querySelectorAll(".tab-btn").forEach(b=>b.classList.remove("active"));
    document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
    btn.classList.add("active");
    $(btn.dataset.tab).classList.add("active");
  });
});

/* =========================
   Battery Coach
   ========================= */
const cTemp = $("cTemp"), cDoD=$("cDoD"), cFast=$("cFast"), cFull=$("cFull");
function syncCoachVals(){
  $("cTVal").textContent = Number(cTemp.value)+"¬∞C";
  $("cFastVal").textContent = Number(cFast.value);
  $("cFullVal").textContent = Number(cFull.value);
}
[cTemp,cFast,cFull].forEach(el=>el.addEventListener("input", syncCoachVals));
cDoD.addEventListener("change", syncCoachVals);
syncCoachVals();

function coachRules(){
  const T = Number(cTemp.value);
  const DoD = cDoD.value;
  const fast = Number(cFast.value);
  const full = Number(cFull.value);

  const rules = [];
  if(T>=40) rules.push("Heat alert: avoid gaming/fast-charge while hot.");
  else if(T<=10) rules.push("Cold zone: charging slowly is kinder.");
  else rules.push("Temp zone looks friendly.");

  if(DoD==="20-80" || DoD==="40-80") rules.push("Mid-band DoD is a solid daily default.");
  if(DoD==="0-100") rules.push("Full-depth cycling increases wear rate (toy + real-world trend).");
  if(DoD==="60-100") rules.push("High SoC window + heat is a common wear combo.");

  if(fast>=8) rules.push("Fast-charge heavy: use when needed, not as a lifestyle.");
  else if(fast<=3) rules.push("Fast-charge modest: good long-term posture.");

  if(full>=7) rules.push("Sitting at 100% often: consider 80‚Äì90% cap if your phone supports it.");
  else if(full<=3) rules.push("Low 100%-habit: strong care pattern.");

  return rules;
}

function computeCareScore(){
  const T = Number(cTemp.value);
  const DoD = cDoD.value;
  const fast = Number(cFast.value);
  const full = Number(cFull.value);

  // score out of 100
  let score = 100;

  // temperature penalties
  if(T>25) score -= (T-25)*1.2;  // gentle
  if(T>40) score -= (T-40)*1.8;  // extra heat penalty
  if(T<10) score -= (10-T)*0.6;  // cold inconvenience (minor)

  // DoD window
  const dF = dodFactor(DoD);
  score -= (dF-0.85)*80; // map to penalty

  // fast/full habits
  score -= fast*2.2;
  score -= full*2.6;

  score = clamp(score, 0, 100);

  $("careScore").textContent = Math.round(score);
  $("careExplain").textContent =
    score>=85 ? "Green zone: gentle thermal + DoD habits." :
    score>=65 ? "Good zone: a few easy wins remain." :
    score>=45 ? "Yellow zone: heat/DoD habits likely dominate wear." :
                "Red zone: this looks like deliberate battery torture üòÖ";

  const rb = $("coachRules");
  rb.innerHTML = "";
  for(const r of coachRules()){
    const div = document.createElement("div");
    div.className="hitem hint";
    div.textContent = "‚Ä¢ " + r;
    rb.appendChild(div);
  }
}

$("coachScoreBtn").addEventListener("click", computeCareScore);
$("coachSync").addEventListener("click", ()=>{
  cTemp.value = controls.temp.value;
  cDoD.value = controls.dod.value;
  cFast.value = 4;
  cFull.value = 3;
  syncCoachVals();
  computeCareScore();
});
$("coachDemoGood").addEventListener("click", ()=>{
  cTemp.value = 22; cDoD.value="40-80"; cFast.value=2; cFull.value=2;
  syncCoachVals(); computeCareScore();
});
$("coachDemoBad").addEventListener("click", ()=>{
  cTemp.value = 52; cDoD.value="0-100"; cFast.value=9; cFull.value=9;
  syncCoachVals(); computeCareScore();
});
computeCareScore();

/* =========================
   AutoBench Viewer
   ========================= */
$("benchLoadSample").addEventListener("click", ()=>{
  const sample = {
    tool:"QDS_AutoBench",
    version:"9.1-PRO",
    created:new Date().toISOString(),
    scenarios:[
      {tag:"Ladder D", base:1.2, amp:1.8, p:0.25, thr:30, n:1200,
       white:{mean:56.7, sd:5.9}, qds:{mean:58.8, sd:6.4}, deltaPct:3.4},
      {tag:"Stability", seed:222, base:1.2, amp:1.8, p:0.25, thr:50, n:1200,
       white:{mean:35.6, sd:5.0}, qds:{mean:36.4, sd:5.3}, deltaPct:2.31}
    ]
  };
  $("benchText").value = JSON.stringify(sample, null, 2);
});

$("benchClearBtn").addEventListener("click", ()=>{
  $("benchText").value="";
  $("bCount").textContent="‚Äî";
  $("bMeanDelta").textContent="‚Äî";
  $("benchList").innerHTML="";
});

$("benchFile").addEventListener("change", (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = () => $("benchText").value = String(reader.result||"");
  reader.readAsText(file);
});

$("benchParseBtn").addEventListener("click", ()=>{
  let obj=null;
  try{
    obj = JSON.parse($("benchText").value||"{}");
  }catch(e){
    alert("JSON parse error.");
    return;
  }
  const scenarios = obj.scenarios || obj.results || [];
  $("bCount").textContent = scenarios.length;

  const deltas = [];
  const list = $("benchList");
  list.innerHTML = "";

  for(const s of scenarios){
    const d = Number(s.deltaPct ?? s.delta ?? 0);
    deltas.push(d);

    const div = document.createElement("div");
    div.className="hitem";
    const dTxt = (d>=0?"+":"") + d.toFixed(2) + "%";
    div.innerHTML = `
      <span class="tag">${s.tag||"Scenario"}</span>
      <span class="mono">
        white Œº=${Number(s.white?.mean ?? s.white_mu ?? 0).toFixed(2)} œÉ=${Number(s.white?.sd ?? s.white_sigma ?? 0).toFixed(2)} ‚Ä¢
        QDS Œº=${Number(s.qds?.mean ?? s.qds_mu ?? 0).toFixed(2)} œÉ=${Number(s.qds?.sd ?? s.qds_sigma ?? 0).toFixed(2)} ‚Ä¢
        <b>${dTxt}</b>
      </span>
    `;
    list.appendChild(div);
  }

  const mu = deltas.length ? mean(deltas) : 0;
  $("bMeanDelta").textContent = (mu>=0?"+":"") + mu.toFixed(2) + "%";
});

/* ---------- boot default preset ---------- */
presetPhone();
runOnce("POSTER-SAFE");


// --- qds_battery_hub_v9_6_science_neon.html ---

/* ==========================================================
   QDS Battery Hub v9.6 ‚Äî single-file, no deps, phone-safe
   ========================================================== */

const LS_KEY = "QDS_BATT_HUB_HISTORY_V96";
const LS_PIN = "QDS_BATT_HUB_PIN_V96";
const MAX_SHOW = 8;

const defaults = {
  k1: 0.0018,
  k2: 0.0004,
  amp: 2.4,
  rho: 0.60,
  temp: 25,
  thr: 80,
  dod: "20-80",
  n: 1200,
  maxc: 2500,
  seedlock: "on",
  poster: "on",
  noregen: "on",
};

const dodMap = {
  "40-80": { factor: 0.85, label:"40‚Äì80 (gentle)" },
  "20-80": { factor: 1.00, label:"20‚Äì80 (phone-friendly)" },
  "10-90": { factor: 1.12, label:"10‚Äì90" },
  "60-100":{ factor: 1.25, label:"60‚Äì100 (stressful)" },
  "0-100": { factor: 1.40, label:"0‚Äì100 (full depth)" },
};

// toy temperature multiplier
function tempFactor(T){
  // mild exponential so it doesn't explode
  const beta = 0.028; // tuned for stability in toy space
  return Math.exp(beta * (T - 25));
}

// small PRNG for repeatability
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}

// Box-Muller normal from uniform PRNG
function randn(rng){
  let u = 0, v = 0;
  while(u === 0) u = rng();
  while(v === 0) v = rng();
  return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}

// percentile helper
function percentile(arr, p){
  if(!arr.length) return NaN;
  const a = [...arr].sort((x,y)=>x-y);
  const idx = (p/100) * (a.length - 1);
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if(lo === hi) return a[lo];
  const w = idx - lo;
  return a[lo]*(1-w) + a[hi]*w;
}

function mean(arr){
  let s=0; for(const x of arr) s+=x;
  return s/arr.length;
}
function std(arr){
  const m = mean(arr);
  let s=0; for(const x of arr){ const d=x-m; s+=d*d; }
  return Math.sqrt(s/(arr.length-1 || 1));
}

function getControls(){
  return {
    k1: parseFloat(el("k1").value),
    k2: parseFloat(el("k2").value),
    amp: parseFloat(el("amp").value),
    rho: parseFloat(el("rho").value),
    temp: parseFloat(el("temp").value),
    thr: parseFloat(el("thr").value),
    dod: el("dod").value,
    n: parseInt(el("n").value),
    maxc: parseInt(el("maxc").value),
    seedlock: el("seedlock").value,
    poster: el("poster").value,
    noregen: el("noregen").value,
  };
}

function applyControls(s){
  el("k1").value = s.k1;
  el("k2").value = s.k2;
  el("amp").value = s.amp;
  el("rho").value = s.rho;
  el("temp").value = s.temp;
  el("thr").value = s.thr;
  el("dod").value = s.dod;
  el("n").value = s.n;
  el("maxc").value = s.maxc;
  el("seedlock").value = s.seedlock;
  el("poster").value = s.poster;
  el("noregen").value = s.noregen;
  syncLabels();
  updateCoachNow();
}

function syncLabels(){
  el("k1v").textContent = Number(el("k1").value).toFixed(4);
  el("k2v").textContent = Number(el("k2").value).toFixed(4);
  el("ampv").textContent = Number(el("amp").value).toFixed(1) + "%";
  el("rhov").textContent = Number(el("rho").value).toFixed(2);
  el("tempv").textContent = Number(el("temp").value) + "¬∞C";
  el("thrv").textContent = Number(el("thr").value) + "%";
  el("nv").textContent = el("n").value;
  el("maxcv").textContent = el("maxc").value;
}

function el(id){ return document.getElementById(id); }

// ----------------------------------------------------------
// Core simulation
// ----------------------------------------------------------
function simulateOneModel(mode, settings, rng){
  const {
    k1, k2, amp, rho, temp, thr, dod, n, maxc, poster, noregen
  } = settings;

  const dodF = (dodMap[dod] || dodMap["20-80"]).factor;
  const tF = tempFactor(temp);

  // small cell-to-cell variation in k1/k2
  const k1_sd = k1 * 0.06;
  const k2_sd = k2 * 0.08;

  const lifetimes = new Array(n);
  let sampleTrace = [];
  let sampleFail = null;

  for(let i=0; i<n; i++){
    const k1_i = Math.max(0, k1 + randn(rng)*k1_sd);
    const k2_i = Math.max(0, k2 + randn(rng)*k2_sd);

    let cap = 100.0;
    let x = 0.0; // AR(1) state for QDS stress
    let trace = (i===0) ? [] : null;

    for(let t=1; t<=maxc; t++){
      // base composite fade per cycle index
      const baseLoss = (k1_i * Math.sqrt(t) + k2_i * t);

      // stress factor
      let stressZ;
      if(mode === "white"){
        stressZ = randn(rng);
      }else{
        // AR(1) with stationary variance ~1
        const eps = randn(rng);
        const scale = Math.sqrt(Math.max(0, 1 - rho*rho));
        x = rho * x + scale * eps;
        stressZ = x;
      }

      let S = 1 + (amp/100) * stressZ;

      if(poster === "on"){
        // keep reasonable for demos
        if(S < 0.2) S = 0.2;
        if(S > 3.0) S = 3.0;
      }

      let loss = baseLoss * S * tF * dodF * 100; 
      // multiply by 100 to move toy params into "capacity % per cycle" scale

      if(noregen === "on"){
        if(loss < 0) loss = 0;
      }

      cap -= loss;

      if(trace){
        trace.push(Math.max(cap, 0));
      }

      if(cap <= thr){
        lifetimes[i] = t;
        if(i===0){
          sampleTrace = trace;
          sampleFail = t;
        }
        break;
      }

      if(t === maxc){
        lifetimes[i] = maxc;
        if(i===0){
          sampleTrace = trace;
          sampleFail = maxc;
        }
      }
    }
  }

  return {
    lifetimes,
    sampleTrace,
    sampleFail
  };
}

function runSimulation(tagOverride=null){
  const settings = getControls();

  // seed logic
  const baseSeed = 0xC0FFEE;
  const salt = Math.floor(Math.random()*1e9);
  const seed = (settings.seedlock === "on") ? baseSeed : salt;

  const rngA = mulberry32(seed ^ 0xA5A5A5A5);
  const rngB = mulberry32(seed ^ 0x5A5A5A5A);

  const t0 = performance.now();

  const white = simulateOneModel("white", settings, rngA);
  const qds   = simulateOneModel("qds", settings, rngB);

  const wArr = white.lifetimes;
  const qArr = qds.lifetimes;

  const wMean = mean(wArr), qMean = mean(qArr);
  const wStd = std(wArr),  qStd = std(qArr);

  const wP10 = percentile(wArr,10), wP50 = percentile(wArr,50), wP90 = percentile(wArr,90);
  const qP10 = percentile(qArr,10), qP50 = percentile(qArr,50), qP90 = percentile(qArr,90);

  const delta = ((qMean - wMean) / (wMean || 1)) * 100;

  const t1 = performance.now();

  const runTag = tagOverride || inferRunTag(settings);

  const entry = {
    id: "run_" + Date.now() + "_" + Math.floor(Math.random()*9999),
    ts: new Date().toISOString(),
    tag: runTag,
    settings,
    results: {
      wMean, qMean, wStd, qStd,
      wP10, wP50, wP90,
      qP10, qP50, qP90,
      delta,
      n: settings.n,
      maxc: settings.maxc,
      sampleWhiteFail: white.sampleFail,
      sampleQDSFail: qds.sampleFail,
      ms: Math.round(t1 - t0)
    },
    traces: {
      white: white.sampleTrace.slice(0, 600), // keep light
      qds: qds.sampleTrace.slice(0, 600)
    }
  };

  saveHistory(entry);
  renderFromEntry(entry);

  refreshHistoryUI();
  updateAutoCompare();
  updateSparkline();
  updateCoachNow();
}

function inferRunTag(s){
  if(s.rho >= 0.95 || s.amp >= 5 || s.temp >= 45 || s.dod === "0-100") return "CHAOS";
  if(s.dod === "20-80" && s.temp <= 30 && s.amp <= 2.6 && s.rho <= 0.70) return "REALISTIC";
  if(s.rho >= 0.70 && s.amp >= 2.0) return "QDS-CONTRAST";
  return "RUN";
}

// ----------------------------------------------------------
// History with dedupe + pin + filters
// ----------------------------------------------------------
function loadHistory(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    return raw ? JSON.parse(raw) : [];
  }catch(e){
    return [];
  }
}

function saveHistory(entry){
  const hist = loadHistory();

  // dedupe by settings signature
  const sig = settingsSignature(entry.settings);
  const idx = hist.findIndex(h => settingsSignature(h.settings) === sig);

  if(idx >= 0){
    // replace the existing matching settings with the new run
    hist[idx] = entry;
  }else{
    hist.unshift(entry);
  }

  // trim long history to keep storage sane
  const trimmed = hist.slice(0, 120);
  localStorage.setItem(LS_KEY, JSON.stringify(trimmed));
}

function settingsSignature(s){
  return [
    s.k1.toFixed(4), s.k2.toFixed(4),
    s.amp.toFixed(1), s.rho.toFixed(2),
    s.temp, s.thr, s.dod,
    s.n, s.maxc,
    s.seedlock, s.poster, s.noregen
  ].join("|");
}

function clearHistory(){
  localStorage.removeItem(LS_KEY);
  localStorage.removeItem(LS_PIN);
  refreshHistoryUI();
  updateSparkline();
  el("autoCompare").textContent = "Run twice to populate.";
  el("pinnedBox").textContent = "No pinned run yet. Pin one in history below.";
  wipeResults();
}

// pin logic
function getPinnedId(){
  return localStorage.getItem(LS_PIN) || "";
}
function setPinnedId(id){
  if(id) localStorage.setItem(LS_PIN, id);
  else localStorage.removeItem(LS_PIN);
}

let historyFilter = "ALL";

function refreshHistoryUI(){
  const hist = loadHistory();
  const pinnedId = getPinnedId();

  const filtered = hist.filter(h=>{
    if(historyFilter === "ALL") return true;
    if(historyFilter === "SWEEP") return (h.tag || "").includes("SWEEP");
    if(historyFilter === "CHAOS") return h.tag === "CHAOS";
    if(historyFilter === "REALISTIC") return h.tag === "REALISTIC";
    return true;
  });

  const show = filtered.slice(0, MAX_SHOW);

  const box = el("history");
  box.innerHTML = "";

  if(show.length === 0){
    const empty = document.createElement("div");
    empty.className = "tiny";
    empty.textContent = "No runs yet. Hit Run simulation.";
    box.appendChild(empty);
    return;
  }

  for(const h of show){
    const item = document.createElement("div");
    item.className = "hist-item";

    const head = document.createElement("div");
    head.className = "hist-head";

    const left = document.createElement("div");
    left.innerHTML = `<span class="hist-tag">${escapeHtml(h.tag || "RUN")}</span>`;

    const right = document.createElement("div");
    right.className = "hist-time";
    right.textContent = prettyTime(h.ts);

    head.appendChild(left);
    head.appendChild(right);

    const body = document.createElement("div");
    body.className = "hist-body";
    const s = h.settings, r = h.results;

    const verdict = coachOneLine(s, r);

    body.innerHTML =
      `<div class="tiny mono">
        k1=${fmt(s.k1,4)} ‚Ä¢ k2=${fmt(s.k2,4)} ‚Ä¢ amp=${fmt(s.amp,2)}% ‚Ä¢ œÅ=${fmt(s.rho,2)} ‚Ä¢ T=${s.temp}¬∞C ‚Ä¢ DoD=${escapeHtml(s.dod)} ‚Ä¢ thr=${s.thr}% ‚Ä¢ n=${s.n}
      </div>
      <div>
        white Œº=${fmt(r.wMean,2)} œÉ=${fmt(r.wStd,2)} ‚Ä¢ QDS Œº=${fmt(r.qMean,2)} œÉ=${fmt(r.qStd,2)} ‚Ä¢ <b>Œî=${fmt(r.delta,2)}%</b>
      </div>
      <div class="tiny">Coach: <b>${escapeHtml(verdict)}</b></div>`;

    const actions = document.createElement("div");
    actions.style.marginTop = "6px";
    actions.className = "btn-row";

    const loadBtn = document.createElement("button");
    loadBtn.className = "secondary";
    loadBtn.textContent = "Load";
    loadBtn.onclick = ()=> {
      applyControls(h.settings);
      renderFromEntry(h);
      updateAutoCompare();
      updateSparkline();
      updatePinnedBox();
    };

    const pinBtn = document.createElement("button");
    const isPinned = (h.id === pinnedId);
    pinBtn.className = isPinned ? "pin" : "pin off";
    pinBtn.textContent = isPinned ? "Pinned ‚òÖ" : "Pin ‚òÜ";
    pinBtn.onclick = ()=>{
      const nowPinned = (getPinnedId() === h.id) ? "" : h.id;
      setPinnedId(nowPinned);
      refreshHistoryUI();
      updatePinnedBox();
    };

    const copyBtn = document.createElement("button");
    copyBtn.className = "secondary";
    copyBtn.textContent = "Copy";
    copyBtn.onclick = ()=> copyText(formatEntryText(h));

    actions.appendChild(loadBtn);
    actions.appendChild(pinBtn);
    actions.appendChild(copyBtn);

    item.appendChild(head);
    item.appendChild(body);
    item.appendChild(actions);

    box.appendChild(item);
  }

  updatePinnedBox();
}

// ----------------------------------------------------------
// Rendering charts + results
// ----------------------------------------------------------
function wipeResults(){
  el("wMean").textContent = "‚Äî";
  el("qMean").textContent = "‚Äî";
  el("wStd").textContent = "‚Äî";
  el("qStd").textContent = "‚Äî";
  el("delta").textContent = "‚Äî";
  el("wP").textContent = "P10/P50/P90 ‚Äî";
  el("qP").textContent = "P10/P50/P90 ‚Äî";
  el("condLine").textContent = "‚Äî";
  drawEmpty(el("histCanvas"));
  drawEmpty(el("traceCanvas"));
}

function renderFromEntry(h){
  const s = h.settings, r = h.results;

  el("wMean").textContent = fmt(r.wMean,2);
  el("qMean").textContent = fmt(r.qMean,2);
  el("wStd").textContent = fmt(r.wStd,2);
  el("qStd").textContent = fmt(r.qStd,2);
  el("delta").textContent = (r.delta>=0?"+":"") + fmt(r.delta,2) + "%";

  el("wP").textContent = `P10/P50/P90 ${fmt(r.wP10,1)} / ${fmt(r.wP50,1)} / ${fmt(r.wP90,1)}`;
  el("qP").textContent = `P10/P50/P90 ${fmt(r.qP10,1)} / ${fmt(r.qP50,1)} / ${fmt(r.qP90,1)}`;

  el("condLine").textContent =
    `œÅ=${fmt(s.rho,2)} ¬∑ T=${s.temp}¬∞C ¬∑ DoD=${s.dod} ¬∑ Poster=${s.poster==="on"} ¬∑ NoRegen=${s.noregen==="on"} ¬∑ ${r.n} runs/model`;

  drawHistogram(el("histCanvas"), h);
  drawTraces(el("traceCanvas"), h);

  // update "current setup verdict" for coach tab
  updateCoachNow();
}

function drawEmpty(canvas){
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.globalAlpha = 0.9;
  ctx.font = "12px system-ui";
  ctx.fillStyle = "#b8b1d9";
  ctx.fillText("Run simulation to draw.", 12, 22);
}

function drawHistogram(canvas, h){
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // We don't store full lifetime arrays in history for size,
  // so rebuild a small proxy histogram from summary + settings
  // by re-running a lighter quick sim if needed.
  // But to keep v9.6 lean, we approximate bins around P10-P90.
  const r = h.results;
  const min = Math.max(1, Math.floor(Math.min(r.wP10, r.qP10) - 5));
  const max = Math.ceil(Math.max(r.wP90, r.qP90) + 5);

  const bins = 18;
  const binW = (max-min)/bins;

  function bell(x, mu, sig){
    sig = Math.max(sig, 0.2);
    const z = (x-mu)/sig;
    return Math.exp(-0.5*z*z);
  }

  const wHeights = [];
  const qHeights = [];
  let wMax=0, qMax=0;

  for(let i=0;i<bins;i++){
    const x = min + (i+0.5)*binW;
    const wh = bell(x, r.wP50, r.wStd);
    const qh = bell(x, r.qP50, r.qStd);
    wHeights.push(wh); qHeights.push(qh);
    wMax = Math.max(wMax, wh);
    qMax = Math.max(qMax, qh);
  }
  const maxH = Math.max(wMax, qMax) || 1;

  const W = canvas.width, H = canvas.height;
  const pad = 24;

  // axes line
  ctx.strokeStyle = "rgba(255,255,255,.08)";
  ctx.beginPath();
  ctx.moveTo(pad, H-pad);
  ctx.lineTo(W-pad, H-pad);
  ctx.stroke();

  // bars
  for(let i=0;i<bins;i++){
    const x0 = pad + i * ((W-2*pad)/bins);
    const barW = ((W-2*pad)/bins) * 0.42;

    const wh = wHeights[i]/maxH;
    const qh = qHeights[i]/maxH;

    const wBarH = wh * (H-2*pad);
    const qBarH = qh * (H-2*pad);

    // White (purple)
    ctx.fillStyle = "rgba(155,92,255,.45)";
    ctx.fillRect(x0, (H-pad)-wBarH, barW, wBarH);

    // QDS (green), offset
    ctx.fillStyle = "rgba(57,255,138,.45)";
    ctx.fillRect(x0 + barW + 2, (H-pad)-qBarH, barW, qBarH);
  }

  ctx.fillStyle = "rgba(255,255,255,.75)";
  ctx.font = "11px system-ui";
  ctx.fillText("Approx histogram (mobile-fast)", pad, 14);
  ctx.fillStyle = "rgba(155,92,255,.9)";
  ctx.fillText("White", pad, 28);
  ctx.fillStyle = "rgba(57,255,138,.9)";
  ctx.fillText("QDS", pad+48, 28);
}

function drawTraces(canvas, h){
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const W = canvas.width, H = canvas.height;
  const pad = 22;

  const wTrace = (h.traces && h.traces.white) ? h.traces.white : [];
  const qTrace = (h.traces && h.traces.qds) ? h.traces.qds : [];

  const maxLen = Math.max(wTrace.length, qTrace.length, 10);
  const xScale = (W-2*pad) / (maxLen-1);

  // y scale 0..100
  function yMap(v){
    const vv = Math.max(0, Math.min(100, v));
    return pad + (1 - vv/100) * (H-2*pad);
  }

  // grid line
  ctx.strokeStyle = "rgba(255,255,255,.06)";
  ctx.beginPath();
  ctx.moveTo(pad, yMap(80));
  ctx.lineTo(W-pad, yMap(80));
  ctx.stroke();

  // white line
  if(wTrace.length){
    ctx.strokeStyle = "rgba(155,92,255,.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<wTrace.length;i++){
      const x = pad + i*xScale;
      const y = yMap(wTrace[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // qds line
  if(qTrace.length){
    ctx.strokeStyle = "rgba(57,255,138,.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<qTrace.length;i++){
      const x = pad + i*xScale;
      const y = yMap(qTrace[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  ctx.fillStyle = "rgba(255,255,255,.75)";
  ctx.font = "11px system-ui";
  ctx.fillText("Sample traces (1 each)", pad, 14);
}

// ----------------------------------------------------------
// Auto-compare last 2 runs
// ----------------------------------------------------------
function updateAutoCompare(){
  const hist = loadHistory();
  if(hist.length < 2){
    el("autoCompare").textContent = "Run twice to populate.";
    return;
  }
  const a = hist[0], b = hist[1];

  const da = a.results.delta, db = b.results.delta;

  const line =
    `Latest vs previous:
     Œî ${fmt(da,2)}% vs ${fmt(db,2)}% ‚Ä¢
     QDS Œº ${fmt(a.results.qMean,2)} vs ${fmt(b.results.qMean,2)} ‚Ä¢
     White Œº ${fmt(a.results.wMean,2)} vs ${fmt(b.results.wMean,2)}.
     T ${a.settings.temp}¬∞C‚Üí${b.settings.temp}¬∞C ‚Ä¢ DoD ${a.settings.dod}‚Üí${b.settings.dod} ‚Ä¢ œÅ ${fmt(a.settings.rho,2)}‚Üí${fmt(b.settings.rho,2)}.`;

  el("autoCompare").textContent = line.replace(/\s+/g," ").trim();
}

// ----------------------------------------------------------
// Coach logic
// ----------------------------------------------------------
function coachOneLine(s, r=null){
  const dodLabel = (dodMap[s.dod]||{}).label || s.dod;

  const heat = s.temp >= 40 ? "Hot" : (s.temp <= 15 ? "Cool" : "Moderate");
  const depth = (s.dod === "40-80" || s.dod === "20-80") ? "mid-window" :
                (s.dod === "0-100" ? "full-depth" : "wide-window");

  const streak = (s.rho >= 0.85 && s.amp >= 3) ? "streaky tails" :
                 (s.rho >= 0.70 ? "mild persistence" : "mostly i.i.d.");

  let effect = "";
  if(r){
    const d = r.delta;
    if(Math.abs(d) < 0.5) effect = "QDS effect subtle";
    else if(d > 0) effect = "QDS lifts mean slightly";
    else effect = "QDS trims mean slightly";
  }else{
    effect = (s.rho >= 0.8) ? "expect wider spread" : "expect subtle spread shift";
  }

  return `${heat}, ${depth} (${dodLabel}), ${streak}; ${effect}.`;
}

function updateCoachNow(){
  const s = getControls();
  el("coachNow").textContent = coachOneLine(s);
  el("coachWhy").textContent =
    `T=${s.temp}¬∞C ¬∑ DoD=${s.dod} ¬∑ amp=${fmt(s.amp,1)}% ¬∑ œÅ=${fmt(s.rho,2)} ¬∑ Poster=${s.poster==="on"}.`;
}

// pinned box
function updatePinnedBox(){
  const hist = loadHistory();
  const pid = getPinnedId();
  const h = hist.find(x=>x.id===pid);

  if(!h){
    el("pinnedBox").textContent = "No pinned run yet. Pin one in history below.";
    return;
  }

  el("pinnedBox").innerHTML =
    `<div class="tiny"><span class="pin">Pinned ‚òÖ</span></div>
     <div class="tiny mono">${prettyTime(h.ts)} ‚Ä¢ ${escapeHtml(h.tag||"RUN")}</div>
     <div class="tiny mono">
       k1=${fmt(h.settings.k1,4)} ‚Ä¢ k2=${fmt(h.settings.k2,4)} ‚Ä¢ amp=${fmt(h.settings.amp,2)}% ‚Ä¢
       œÅ=${fmt(h.settings.rho,2)} ‚Ä¢ T=${h.settings.temp}¬∞C ‚Ä¢ DoD=${escapeHtml(h.settings.dod)} ‚Ä¢ thr=${h.settings.thr}%
     </div>
     <div>
       white Œº=${fmt(h.results.wMean,2)} œÉ=${fmt(h.results.wStd,2)} ‚Ä¢
       QDS Œº=${fmt(h.results.qMean,2)} œÉ=${fmt(h.results.qStd,2)} ‚Ä¢
       <b>Œî=${fmt(h.results.delta,2)}%</b>
     </div>
     <div class="tiny">Coach: <b>${escapeHtml(coachOneLine(h.settings, h.results))}</b></div>`;
}

// ----------------------------------------------------------
// Sparkline
// ----------------------------------------------------------
function updateSparkline(){
  const hist = loadHistory();
  drawSpark(el("sparkCanvas"), hist.slice(0, 40).reverse());
}

function drawSpark(canvas, arr){
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const W = canvas.width, H = canvas.height;
  const padX = 10, padY = 10;

  if(!arr.length){
    ctx.fillStyle = "rgba(255,255,255,.7)";
    ctx.font = "11px system-ui";
    ctx.fillText("No history yet.", padX, 18);
    return;
  }

  const vals = arr.map(h => Number(h.results && h.results.delta || 0));
  const vMin = Math.min(...vals, -5);
  const vMax = Math.max(...vals, 5);
  const range = (vMax - vMin) || 1;

  function xMap(i){
    return padX + i * ((W-2*padX)/(vals.length-1 || 1));
  }
  function yMap(v){
    const norm = (v - vMin)/range;
    return padY + (1-norm) * (H-2*padY);
  }

  // zero line
  const y0 = yMap(0);
  ctx.strokeStyle = "rgba(255,255,255,.08)";
  ctx.beginPath();
  ctx.moveTo(padX, y0);
  ctx.lineTo(W-padX, y0);
  ctx.stroke();

  // line
  ctx.strokeStyle = "rgba(57,255,138,.9)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  vals.forEach((v,i)=>{
    const x = xMap(i), y = yMap(v);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  // points
  ctx.fillStyle = "rgba(155,92,255,.9)";
  vals.forEach((v,i)=>{
    const x = xMap(i), y = yMap(v);
    ctx.fillRect(x-1.5, y-1.5, 3, 3);
  });

  ctx.fillStyle = "rgba(255,255,255,.75)";
  ctx.font = "10px system-ui";
  ctx.fillText("Œî% trend", padX, 12);
}

// ----------------------------------------------------------
// Export / copy
// ----------------------------------------------------------
function formatEntryText(h){
  const s=h.settings, r=h.results;
  return `${(h.tag||"RUN")} ${prettyTime(h.ts)}
k1=${fmt(s.k1,4)} ‚Ä¢ k2=${fmt(s.k2,4)} ‚Ä¢ amp=${fmt(s.amp,2)}% ‚Ä¢ œÅ=${fmt(s.rho,2)} ‚Ä¢ T=${s.temp}¬∞C ‚Ä¢ DoD=${s.dod} ‚Ä¢ thr=${s.thr}% ‚Ä¢ n=${s.n}
white Œº=${fmt(r.wMean,2)} œÉ=${fmt(r.wStd,2)} ‚Ä¢ QDS Œº=${fmt(r.qMean,2)} œÉ=${fmt(r.qStd,2)} ‚Ä¢ Œî=${fmt(r.delta,2)}%`;
}

function exportJSON(obj, filename){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 500);
}

function copyText(txt){
  if(navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(txt).catch(()=>{});
  }else{
    const ta = document.createElement("textarea");
    ta.value = txt;
    document.body.appendChild(ta);
    ta.select();
    try{ document.execCommand("copy"); }catch(e){}
    ta.remove();
  }
}

// ----------------------------------------------------------
// Utilities
// ----------------------------------------------------------
function fmt(x, d=2){
  if(!isFinite(x)) return "‚Äî";
  return Number(x).toFixed(d);
}
function prettyTime(iso){
  try{
    const d = new Date(iso);
    return d.toLocaleString();
  }catch(e){
    return iso;
  }
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}

// ----------------------------------------------------------
// Tabs
// ----------------------------------------------------------
document.querySelectorAll(".tab-btn").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    document.querySelectorAll(".tab-btn").forEach(b=>b.classList.remove("active"));
    btn.classList.add("active");
    const tab = btn.dataset.tab;

    el("tab-lab").classList.toggle("hidden", tab!=="lab");
    el("tab-coach").classList.toggle("hidden", tab!=="coach");
    el("tab-bench").classList.toggle("hidden", tab!=="bench");

    // refresh visuals when switching
    if(tab==="bench") updateSparkline();
    if(tab==="coach") updatePinnedBox();
  });
});

// ----------------------------------------------------------
// Presets
// ----------------------------------------------------------
function presetPhone(){
  applyControls({
    ...defaults,
    amp: 2.0, rho: 0.55, temp: 25, dod:"20-80", n:1200, maxc:2500,
    poster:"on", noregen:"on"
  });
}
function presetQDS(){
  applyControls({
    ...defaults,
    amp: 2.4, rho: 0.70, temp: 25, dod:"20-80", n:1200,
    poster:"on", noregen:"on"
  });
}
function presetChaos(){
  applyControls({
    ...defaults,
    k1:0.0022, k2:0.0005, amp: 3.2, rho: 0.99, temp: 40,
    dod:"0-100", thr: 80, n: 600, maxc: 2500,
    poster:"off", noregen:"on"
  });
}

// ----------------------------------------------------------
// QuickSweep √ó10
// ----------------------------------------------------------
function quickSweep(){
  const base = getControls();
  for(let i=0;i<10;i++){
    // tiny jitter to avoid dedupe eating everything during sweeps
    el("rho").value = Math.min(0.99, Math.max(0, base.rho + (i-5)*0.002));
    syncLabels();
    runSimulation("SWEEP");
  }
  // restore base
  applyControls(base);
}

// ----------------------------------------------------------
// Wire UI events
// ----------------------------------------------------------
["k1","k2","amp","rho","temp","thr","n","maxc"].forEach(id=>{
  el(id).addEventListener("input", ()=>{ syncLabels(); updateCoachNow(); });
});
["dod","seedlock","poster","noregen"].forEach(id=>{
  el(id).addEventListener("change", ()=>{ updateCoachNow(); });
});

el("runBtn").onclick = ()=> runSimulation();
el("resetBtn").onclick = ()=> applyControls(defaults);
el("sweepBtn").onclick = ()=> quickSweep();

el("presetPhone").onclick = presetPhone;
el("presetQDS").onclick = presetQDS;
el("presetChaos").onclick = presetChaos;

el("copyBtn").onclick = ()=>{
  const hist = loadHistory();
  if(hist[0]) copyText(formatEntryText(hist[0]));
};
el("exportLastBtn").onclick = ()=>{
  const hist = loadHistory();
  if(hist[0]) exportJSON(hist[0], "qds_battery_last_run_v9_6.json");
};
el("exportAllBtn").onclick = ()=>{
  const hist = loadHistory();
  exportJSON(hist, "qds_battery_history_v9_6.json");
};
el("clearBtn").onclick = clearHistory;

// filters (bench tab buttons)
el("filterAll").onclick = ()=>{ historyFilter="ALL"; refreshHistoryUI(); };
el("filterSweeps").onclick = ()=>{ historyFilter="SWEEP"; refreshHistoryUI(); };
el("filterChaos").onclick = ()=>{ historyFilter="CHAOS"; refreshHistoryUI(); };
el("filterPhone").onclick = ()=>{ historyFilter="REALISTIC"; refreshHistoryUI(); };

// ----------------------------------------------------------
// Init
// ----------------------------------------------------------
(function init(){
  applyControls(defaults);
  refreshHistoryUI();
  updateAutoCompare();
  updateSparkline();
  updatePinnedBox();

  // if existing history, render most recent
  const hist = loadHistory();
  if(hist[0]){
    renderFromEntry(hist[0]);
  }else{
    wipeResults();
  }
})();


// --- qds_battery_index_v1_neon_os.html ---

(function(){
  const primary = [
    {
      file:"qds_battery_hub_v9_6_science_neon.html",
      title:"Battery Hub v9.6",
      tag:"LATEST SCIENCE NEON",
      desc:"AR(1) stress + T + DoD + Poster/NoRegen + QuickSweep.",
      chips:["k1/k2","Temp","DoD","AR(1)","Poster-safe"],
      accent:"green"
    },
    {
      file:"qds_battery_hub_v9_5_science_neon.html",
      title:"Battery Hub v9.5",
      tag:"STABLE BASELINE",
      desc:"Clean semi-empirical toy. Great for demos.",
      chips:["Seed lock","Dedupe history","Fast hist"],
      accent:""
    },
    {
      file:"qds_battery_hub_v9_4_science_neon_plus.html",
      title:"Battery Hub v9.4+",
      tag:"PLUS FEATURES",
      desc:"Earlier expanded science shell.",
      chips:["Neon UI","Spread focus"],
      accent:""
    },
    {
      file:"qds_battery_hub_v9_3_science_neon.html",
      title:"Battery Hub v9.3",
      tag:"FOUNDATION",
      desc:"First solid science neon cut.",
      chips:["Toy realism"],
      accent:""
    },
    {
      file:"qds_battery_hub_v9_2_purple_neon.html",
      title:"Battery Hub v9.2",
      tag:"PURPLE NEON",
      desc:"High-style contrast build.",
      chips:["Aesthetic"],
      accent:""
    },
    {
      file:"qds_battery_hub_v9_1_purple_neon.html",
      title:"Battery Hub v9.1",
      tag:"ORIGIN",
      desc:"Early purple-neon hub.",
      chips:["Classic"],
      accent:""
    }
  ];

  const suites = [
    ["qds_battery_suite_v8_nextlevel.html","Suite v8 NextLevel"],
    ["qds_battery_suite_v8_3_neon_shell.html","Suite v8.3 Neon Shell"],
    ["qds_battery_suite_v8_2_poster_tamed.html","Suite v8.2 Poster Tamed"],
    ["qds_battery_suite_v8_1_fairpath.html","Suite v8.1 Fair Path"],
    ["qds_battery_suite_v6_realworld.html","Suite v6 RealWorld"],
    ["qds_battery_suite_v5_boss_polish.html","Suite v5 Boss Polish"],
    ["qds_battery_suite_v4_showcase.html","Suite v4 Showcase"],
    ["qds_battery_lab_showcase_stress_bias_v2.html","Stress Bias v2"],
    ["qds_battery_lab_showcase_stress_bias_v1.html","Stress Bias v1"],
    ["qds_battery_lab_showcase_v1.html","Lab Showcase v1"]
  ];

  const misc = [
    ["qds_battery_lab.html","Noise & Lifetime Lab"],
    ["qds_battery_noise_toy_v1.html","Noise Toy v1"],
    ["qds_battery_whisperer_v2.html","Battery Whisperer"],
    ["qds_battery_coach_v3.html","Battery Coach v3"],
    ["solar_system_v8_offline.html","Solar System V8 (bonus)"],
    ["omega_qds_lab.html","Œ© Unified Lab"],
    ["indus_atlas_v1_qds_language_lab.html","Indus Atlas (bonus)"]
  ];

  function cardHTML(item){
    const chips = (item.chips||[]).map(c=>{
      const cls = (item.accent==="green" && (c==="AR(1)" || c==="Temp" || c==="DoD")) ? "chip green":"chip";
      return `<span class="${cls}">${c}</span>`;
    }).join("");
    return `
      <a class="card-btn" href="${item.file}">
        <span class="scan"></span>
        <span class="tag">üîã ${item.tag}</span>
        <h4>${item.title}</h4>
        <p>${item.desc}</p>
        <div class="chipline">${chips}</div>
      </a>
    `;
  }

  function miniHTML(file, label){
    return `<a class="mini-btn" href="${file}">‚ö° ${label}</a>`;
  }

  const rail = document.getElementById("primaryRail");
  rail.innerHTML = primary.map(cardHTML).join("");

  const suiteGrid = document.getElementById("suiteGrid");
  suiteGrid.innerHTML = suites.map(s=>miniHTML(s[0], s[1])).join("");

  const miscGrid = document.getElementById("miscGrid");
  miscGrid.innerHTML = misc.map(m=>miniHTML(m[0], m[1])).join("");

  // Server status hint
  const pill = document.getElementById("srvPill");
  const isLocal = location.hostname === "127.0.0.1" || location.hostname === "localhost";
  if(isLocal){
    pill.innerHTML = "Status: <b>LOCAL SERVER OK</b> ‚Ä¢ You‚Äôre in the Shed grid ‚öôÔ∏è";
  }else if(location.protocol === "file:"){
    pill.textContent = "Status: FILE MODE ‚Ä¢ Most pages still work, but best via http.server";
  }else{
    pill.textContent = "Status: Remote/unknown host ‚Ä¢ If something breaks, serve locally";
  }
})();


// --- qds_battery_os_index_v1.html ---

const PAGES = [
  // --- Recommended / flagship ---
  {id:"hub97", name:"Battery Hub v9.7 ‚Äî Lab-Shaped Neon", file:"qds_battery_hub_v9_7_science_neon_lab.html",
   group:"recommended", tag:"Most accurate (toy)", tagClass:"green",
   meta:"Cycle + Calendar ‚Ä¢ Capacity + Resistance ‚Ä¢ AR(1) stress"},
  {id:"hub96", name:"Battery Hub v9.6 ‚Äî Science Neon", file:"qds_battery_hub_v9_6_science_neon.html",
   group:"recommended", tag:"Stable", tagClass:"green",
   meta:"Fast phone-safe semi-empirical model"},
  {id:"coach3", name:"Battery Coach v3", file:"qds_battery_coach_v3.html",
   group:"recommended", tag:"Practical", tagClass:"green",
   meta:"Friendly advice layer"},

  // --- Hubs ---
  {name:"Hub v9.6 ‚Äî Science Neon", file:"qds_battery_hub_v9_6_science_neon.html", group:"hubs",
   tag:"Latest prior", meta:"AR(1) stress + T + DoD + Poster/NoRegen"},
  {name:"Hub v9.5.1 ‚Äî Science Neon", file:"qds_battery_hub_v9_5_1_science_neon.html", group:"hubs",
   tag:"Patch", meta:"Bugfix / tweaks"},
  {name:"Hub v9.5 ‚Äî Science Neon", file:"qds_battery_hub_v9_5_science_neon.html", group:"hubs",
   tag:"Milestone", meta:"QuickSweep + dedupe"},
  {name:"Hub v9.4 ‚Äî Science Neon Plus", file:"qds_battery_hub_v9_4_science_neon_plus.html", group:"hubs",
   tag:"Expansion", meta:"Enhanced UI + logic"},
  {name:"Hub v9.3 ‚Äî Science Neon", file:"qds_battery_hub_v9_3_science_neon.html", group:"hubs",
   tag:"Core", meta:"Semi-empirical fade toy"},
  {name:"Hub v9.2 ‚Äî Purple / Neon Green", file:"qds_battery_hub_v9_2_purple_neon.html", group:"hubs",
   tag:"Classic neon", meta:"Earlier style build"},
  {name:"Hub v9.1 ‚Äî Purple Neon", file:"qds_battery_hub_v9_1_purple_neon.html", group:"hubs",
   tag:"Prototype", meta:"First neon hub"},

  // --- Suites & toys ---
  {name:"Suite v8 NextLevel", file:"qds_battery_suite_v8_nextlevel.html", group:"suites",
   tag:"Showcase", meta:"UI + behaviours pack"},
  {name:"Suite v8.3 Neon Shell", file:"qds_battery_suite_v8_3_neon_shell.html", group:"suites",
   tag:"Neon", meta:"Styled showcase"},
  {name:"Suite v8.2 Poster Tamed", file:"qds_battery_suite_v8_2_poster_tamed.html", group:"suites",
   tag:"Poster-safe", meta:"Tamed extremes"},
  {name:"Suite v8.1 FairPath", file:"qds_battery_suite_v8_1_fairpath.html", group:"suites",
   tag:"Balanced", meta:"Fair comparison focus"},
  {name:"Suite v6 RealWorld", file:"qds_battery_suite_v6_realworld.html", group:"suites",
   tag:"Realism push", meta:"More grounded assumptions"},
  {name:"Suite v5 Boss Polish", file:"qds_battery_suite_v5_boss_polish.html", group:"suites",
   tag:"Polish", meta:"UI refinement"},
  {name:"Suite v4 Showcase", file:"qds_battery_suite_v4_showcase.html", group:"suites",
   tag:"Vintage", meta:"Earlier demo set"},
  {name:"Noise Toy v1", file:"qds_battery_noise_toy_v1.html", group:"suites",
   tag:"Fast intuition", meta:"Noise-only behaviour demo"},
  {name:"Lab Showcase v1", file:"qds_battery_lab_showcase_v1.html", group:"suites",
   tag:"Demo", meta:"Guided visuals"},
  {name:"Stress Bias v1", file:"qds_battery_lab_showcase_stress_bias_v1.html", group:"suites",
   tag:"Experiment", meta:"Bias illustration"},
  {name:"Stress Bias v2", file:"qds_battery_lab_showcase_stress_bias_v2.html", group:"suites",
   tag:"Experiment", meta:"Bias variant"},

  // --- Coach & logs ---
  {name:"Battery Lab Classic", file:"qds_battery_lab.html", group:"coach",
   tag:"Workbench", meta:"Older stable lab page"},
  {name:"Whisperer v2", file:"qds_battery_whisperer_v2.html", group:"coach",
   tag:"Fun utility", meta:"Lightweight helper"}
];

function card(p){
  const a = document.createElement("a");
  a.className = "btn";
  a.href = p.file;
  a.innerHTML = `
    <span class="tag ${p.tagClass||""}">${p.tag||"Module"}</span>
    <span class="name">${p.name}</span>
    <span class="meta">${p.meta||p.file}</span>
  `;
  return a;
}

function mount(group, elId){
  const root = document.getElementById(elId);
  PAGES.filter(p=>p.group===group).forEach(p=>root.appendChild(card(p)));
}

mount("recommended","recommended");
mount("hubs","hubs");
mount("suites","suites");
mount("coach","coach");


// --- qds_battery_hub_v9_7_science_neon_lab.html ---

/* ============================================================
   QDS Battery Hub v9.7 ‚Äî phone-safe semi-empirical simulator
   No deps. Canvas charts. localStorage history + dedupe.
   ============================================================ */

const LS_KEY = "QDS_BATTERY_HUB_HISTORY_V9_7";
const MAX_SHOW = 8;

const $ = id => document.getElementById(id);

const defaults = {
  k1: 0.0018, k2: 0.0004, amp: 2.4, rho: 0.60,
  temp: 25, thrC: 80, dod: "20-80",
  n: 1200, maxCycles: 2500,
  seedLock: true, poster: true, noregen: true,
  useCalendar: true, useResistance: true, thrR: 1.35
};

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function mean(arr){ return arr.reduce((s,v)=>s+v,0)/arr.length; }
function sd(arr){
  const m = mean(arr);
  const v = mean(arr.map(x=>(x-m)*(x-m)));
  return Math.sqrt(v);
}
function quantile(arr, q){
  const a=[...arr].sort((x,y)=>x-y);
  const idx = (a.length-1)*q;
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if(lo===hi) return a[lo];
  const t = idx-lo;
  return a[lo]*(1-t)+a[hi]*t;
}

function tempFactor(T){
  // Toy Arrhenius-ish multiplier kept gentle for mobile stability.
  // Roughly ~ +2% per ¬∞C above 25, -1.5% per ¬∞C below 25, capped.
  const d = T - 25;
  let f = 1 + (d>=0 ? 0.02*d : 0.015*d);
  return clamp(f, 0.55, 2.8);
}

function dodFactor(dod){
  // Simple stress mapping: deeper windows = harsher.
  const map = {
    "40-80": 0.85,
    "20-80": 1.00,
    "10-90": 1.12,
    "60-100": 1.28,
    "0-100": 1.40
  };
  return map[dod] ?? 1.0;
}

function makeRNG(seed){
  // tiny LCG for reproducibility
  let s = seed>>>0;
  return function(){
    s = (1664525*s + 1013904223) >>> 0;
    return (s / 4294967296);
  };
}
function randn(rng){
  // Box-Muller
  let u=0,v=0;
  while(u===0) u=rng();
  while(v===0) v=rng();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

function ar1Series(len, rho, amp, rng, poster){
  // returns multiplicative stress factor S_t around 1.0
  let x = 0;
  const out = new Array(len);
  const sigma = amp/100; // convert % to fraction
  for(let t=0;t<len;t++){
    const eps = randn(rng) * sigma;
    x = rho*x + eps;
    let s = 1 + x;
    if(poster){
      s = clamp(s, 1-2.5*sigma, 1+2.5*sigma);
    }
    out[t]=s;
  }
  return out;
}

function iidSeries(len, amp, rng, poster){
  const sigma = amp/100;
  const out = new Array(len);
  for(let t=0;t<len;t++){
    let s = 1 + randn(rng)*sigma;
    if(poster){
      s = clamp(s, 1-2.5*sigma, 1+2.5*sigma);
    }
    out[t]=s;
  }
  return out;
}

function simulateOneCell(params, rng, correlated){
  const {
    k1,k2,amp,rho,temp,thrC,dod,maxCycles,
    poster,noregen,useCalendar,useResistance,thrR
  } = params;

  // small per-cell variability (manufacturing spread)
  const k1i = k1 * (0.92 + 0.16*rng());
  const k2i = k2 * (0.92 + 0.16*rng());

  const FT = tempFactor(temp);
  const FD = dodFactor(dod);

  // stress series
  const S = correlated
    ? ar1Series(maxCycles, rho, amp, rng, poster)
    : iidSeries(maxCycles, amp, rng, poster);

  let cap = 100.0;
  let R = 1.0; // resistance multiple of R0

  // calendar ageing per cycle: tiny baseline that scales with temp
  const calBase = useCalendar ? (0.00006 * FT) : 0;

  // resistance growth baseline factor
  const rBase = useResistance ? (0.00005 * FT * FD) : 0;

  for(let t=1; t<=maxCycles; t++){
    const cycLoss = (k1i*Math.sqrt(t) + k2i*t) * FT * FD * S[t-1] * 100; 
    // scale into % points
    let dC = cycLoss * 0.00001; 
    // The 1e-5 factor keeps values in a sane phone-toy regime.

    // calendar term (time-driven)
    dC += calBase * 100;

    if(noregen) dC = Math.max(0, dC);

    cap -= dC;

    // resistance drift (toy)
    if(useResistance){
      // correlated stress also nudges resistance a bit
      let dR = rBase * (0.6 + 0.8*S[t-1]);
      if(poster) dR = clamp(dR, 0, rBase*2.2);
      R += dR;
    }

    const capFail = cap <= thrC;
    const rFail = useResistance ? (R >= thrR) : false;

    if(capFail || rFail){
      return {cycles:t, capEnd:cap, REnd:R};
    }
  }
  return {cycles:maxCycles, capEnd:cap, REnd:R};
}

function runModel(params, correlated, seed){
  const rng = makeRNG(seed);
  const cycles = new Array(params.n);
  const sampleTrace = [];
  const sampleTraceR = [];
  // pick first cell as sample
  for(let i=0;i<params.n;i++){
    const res = simulateOneCell(params, rng, correlated);
    cycles[i]=res.cycles;
    if(i===0){
      // re-run a trace with same RNG seed style but higher resolution
      // We'll do a simplified quick trace using a fresh rng derived from seed+i+offset
      const trng = makeRNG(seed + (correlated?777:333));
      const trace = buildTrace(params, trng, correlated);
      sampleTrace.push(...trace.cap);
      sampleTraceR.push(...trace.R);
    }
  }
  return {cycles, sample:{cap:sampleTrace, R:sampleTraceR}};
}

function buildTrace(params, rng, correlated){
  const {
    k1,k2,amp,rho,temp,thrC,dod,maxCycles,
    poster,noregen,useCalendar,useResistance,thrR
  } = params;

  const k1i = k1;
  const k2i = k2;

  const FT = tempFactor(temp);
  const FD = dodFactor(dod);

  const S = correlated
    ? ar1Series(maxCycles, rho, amp, rng, poster)
    : iidSeries(maxCycles, amp, rng, poster);

  let cap=100, R=1.0;
  const calBase = useCalendar ? (0.00006 * FT) : 0;
  const rBase = useResistance ? (0.00005 * FT * FD) : 0;

  const capArr = new Array(maxCycles);
  const rArr = new Array(maxCycles);

  for(let t=1; t<=maxCycles; t++){
    const cycLoss = (k1i*Math.sqrt(t) + k2i*t) * FT * FD * S[t-1] * 100;
    let dC = cycLoss * 0.00001;
    dC += calBase * 100;
    if(noregen) dC = Math.max(0, dC);
    cap -= dC;

    if(useResistance){
      let dR = rBase * (0.6 + 0.8*S[t-1]);
      if(poster) dR = clamp(dR, 0, rBase*2.2);
      R += dR;
    }

    capArr[t-1]=cap;
    rArr[t-1]=R;

    if(cap <= thrC || (useResistance && R>=thrR)){
      // keep filling flat tail for nicer chart
      for(let k=t;k<=maxCycles;k++){
        capArr[k-1]=capArr[t-1];
        rArr[k-1]=rArr[t-1];
      }
      break;
    }
  }
  return {cap:capArr, R:rArr};
}

function getParams(){
  return {
    k1: parseFloat($("k1").value),
    k2: parseFloat($("k2").value),
    amp: parseFloat($("amp").value),
    rho: clamp(parseFloat($("rho").value), 0, 0.99),
    temp: parseFloat($("temp").value),
    thrC: parseFloat($("thrC").value),
    dod: $("dod").value,
    n: Math.max(50, parseInt($("n").value,10)||defaults.n),
    maxCycles: Math.max(50, parseInt($("maxCycles").value,10)||defaults.maxCycles),
    seedLock: $("seedLock").checked,
    poster: $("poster").checked,
    noregen: $("noregen").checked,
    useCalendar: $("useCalendar").checked,
    useResistance: $("useResistance").checked,
    thrR: parseFloat($("thrR").value)
  };
}

function setParams(p){
  $("k1").value = p.k1;
  $("k2").value = p.k2;
  $("amp").value = p.amp;
  $("rho").value = p.rho;
  $("temp").value = p.temp;
  $("thrC").value = p.thrC;
  $("dod").value = p.dod;
  $("n").value = p.n;
  $("maxCycles").value = p.maxCycles;
  $("seedLock").checked = p.seedLock;
  $("poster").checked = p.poster;
  $("noregen").checked = p.noregen;
  $("useCalendar").checked = p.useCalendar;
  $("useResistance").checked = p.useResistance;
  $("thrR").value = p.thrR ?? defaults.thrR;
  updateCoach();
}

function presetRealistic(){
  setParams({
    ...defaults,
    k1:0.0018, k2:0.0004, amp:2.0, rho:0.55,
    temp:25, thrC:80, dod:"20-80",
    n:1200, maxCycles:2500,
    poster:true, noregen:true,
    useCalendar:true, useResistance:true, thrR:1.35
  });
}
function presetQDS(){
  setParams({
    ...defaults,
    k1:0.0018, k2:0.0004, amp:2.4, rho:0.70,
    temp:25, thrC:80, dod:"20-80",
    n:1200, maxCycles:2500,
    poster:true, noregen:true,
    useCalendar:true, useResistance:true, thrR:1.35
  });
}
function presetChaos(){
  setParams({
    ...defaults,
    k1:0.0022, k2:0.0006, amp:4.2, rho:0.99,
    temp:40, thrC:80, dod:"0-100",
    n:600, maxCycles:2500,
    poster:false, noregen:true,
    useCalendar:true, useResistance:true, thrR:1.45
  });
}

function makeRunSummary(params, whiteStats, qdsStats){
  const d = ((qdsStats.mean - whiteStats.mean)/whiteStats.mean)*100;
  const line =
    `k1=${params.k1.toFixed(4)} ‚Ä¢ k2=${params.k2.toFixed(4)} ‚Ä¢ `+
    `amp=${params.amp.toFixed(2)}% ‚Ä¢ œÅ=${params.rho.toFixed(2)} ‚Ä¢ `+
    `T=${params.temp}¬∞C ‚Ä¢ DoD=${params.dod.replace("-","‚Äì")} ‚Ä¢ `+
    `thrC=${params.thrC}% ‚Ä¢ `+
    (params.useResistance ? `thrR=${params.thrR.toFixed(2)}√óR0 ‚Ä¢ ` : ``)+
    `n=${params.n}`;

  return {delta:d, line};
}

function computeStats(cycles){
  const m = mean(cycles);
  return {
    mean: m,
    sd: sd(cycles),
    p10: quantile(cycles, .10),
    p50: quantile(cycles, .50),
    p90: quantile(cycles, .90),
  };
}

function drawHistogram(canvas, white, qds){
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const all = white.concat(qds);
  const min = Math.min(...all), max = Math.max(...all);
  const bins = 24;
  const binSize = Math.max(1, Math.ceil((max-min+1)/bins));

  function binCount(arr){
    const counts = new Array(bins).fill(0);
    for(const x of arr){
      const idx = clamp(Math.floor((x-min)/binSize), 0, bins-1);
      counts[idx]++;
    }
    return counts;
  }
  const cw = binCount(white);
  const cq = binCount(qds);
  const maxC = Math.max(...cw, ...cq, 1);

  const pad = 18*devicePixelRatio;
  const chartW = w - pad*2;
  const chartH = h - pad*2;
  const barW = chartW / bins;

  // axes faint
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.strokeRect(pad, pad, chartW, chartH);

  for(let i=0;i<bins;i++){
    const x = pad + i*barW;
    const hw = (cw[i]/maxC)*chartH;
    const hq = (cq[i]/maxC)*chartH;

    // white bars (lavender)
    ctx.fillStyle = "rgba(155,92,255,0.35)";
    ctx.fillRect(x+barW*0.08, pad + (chartH-hw), barW*0.38, hw);

    // qds bars (neon)
    ctx.fillStyle = "rgba(0,255,136,0.35)";
    ctx.fillRect(x+barW*0.54, pad + (chartH-hq), barW*0.38, hq);
  }

  // legend
  ctx.fillStyle = "rgba(155,92,255,0.9)";
  ctx.fillRect(pad, 6*devicePixelRatio, 12*devicePixelRatio, 6*devicePixelRatio);
  ctx.fillStyle = "rgba(0,255,136,0.9)";
  ctx.fillRect(pad+70*devicePixelRatio, 6*devicePixelRatio, 12*devicePixelRatio, 6*devicePixelRatio);

  ctx.fillStyle = "rgba(245,237,255,0.85)";
  ctx.font = `${10*devicePixelRatio}px system-ui`;
  ctx.fillText("White", pad+16*devicePixelRatio, 12*devicePixelRatio);
  ctx.fillText("QDS", pad+86*devicePixelRatio, 12*devicePixelRatio);
}

function drawTrace(canvas, whiteTrace, qdsTrace, params){
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const pad = 18*devicePixelRatio;
  const chartW = w - pad*2;
  const chartH = h - pad*2;

  // axes
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.strokeRect(pad, pad, chartW, chartH);

  const len = Math.min(whiteTrace.cap.length, qdsTrace.cap.length);
  const xScale = chartW/(len-1);

  // y range around capacity
  const minCap = Math.min(
    ...whiteTrace.cap.slice(0,len),
    ...qdsTrace.cap.slice(0,len),
    params.thrC-2
  );
  const maxCap = 102;
  const yScale = chartH/(maxCap - minCap);

  function y(c){ return pad + (maxCap - c)*yScale; }
  function x(i){ return pad + i*xScale; }

  // threshold line
  ctx.strokeStyle = "rgba(255,75,216,0.35)";
  ctx.setLineDash([4*devicePixelRatio, 4*devicePixelRatio]);
  ctx.beginPath();
  ctx.moveTo(pad, y(params.thrC));
  ctx.lineTo(pad+chartW, y(params.thrC));
  ctx.stroke();
  ctx.setLineDash([]);

  // white trace
  ctx.strokeStyle = "rgba(155,92,255,0.85)";
  ctx.lineWidth = 2*devicePixelRatio;
  ctx.beginPath();
  for(let i=0;i<len;i++){
    const yc = y(whiteTrace.cap[i]);
    if(i===0) ctx.moveTo(x(i), yc);
    else ctx.lineTo(x(i), yc);
  }
  ctx.stroke();

  // qds trace
  ctx.strokeStyle = "rgba(0,255,136,0.85)";
  ctx.lineWidth = 2*devicePixelRatio;
  ctx.beginPath();
  for(let i=0;i<len;i++){
    const yc = y(qdsTrace.cap[i]);
    if(i===0) ctx.moveTo(x(i), yc);
    else ctx.lineTo(x(i), yc);
  }
  ctx.stroke();

  // faint resistance overlay (if enabled)
  if(params.useResistance){
    const minR = 1.0;
    const maxR = Math.max(params.thrR, 1.5);
    const rScale = chartH/(maxR-minR);
    function yR(r){ return pad + (maxR - r)*rScale; }

    ctx.strokeStyle = "rgba(155,92,255,0.25)";
    ctx.lineWidth = 1*devicePixelRatio;
    ctx.beginPath();
    for(let i=0;i<len;i++){
      const yr = yR(whiteTrace.R[i]);
      if(i===0) ctx.moveTo(x(i), yr);
      else ctx.lineTo(x(i), yr);
    }
    ctx.stroke();

    ctx.strokeStyle = "rgba(0,255,136,0.25)";
    ctx.beginPath();
    for(let i=0;i<len;i++){
      const yr = yR(qdsTrace.R[i]);
      if(i===0) ctx.moveTo(x(i), yr);
      else ctx.lineTo(x(i), yr);
    }
    ctx.stroke();
  }

  // legend text
  ctx.fillStyle = "rgba(245,237,255,0.9)";
  ctx.font = `${10*devicePixelRatio}px system-ui`;
  ctx.fillText("Capacity traces", pad, h - 6*devicePixelRatio);
}

function loadHistory(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  }catch{ return []; }
}
function saveHistory(arr){
  localStorage.setItem(LS_KEY, JSON.stringify(arr));
}

function paramsKey(p){
  // stable signature for dedupe
  return [
    p.k1,p.k2,p.amp,p.rho,p.temp,p.thrC,p.dod,p.n,p.maxCycles,
    p.seedLock,p.poster,p.noregen,p.useCalendar,p.useResistance,p.thrR
  ].join("|");
}

function renderHistory(){
  const root = $("history");
  root.innerHTML = "";
  const hist = loadHistory().slice(0, MAX_SHOW);
  if(hist.length===0){
    root.innerHTML = `<div class="small">No runs yet. Smash ‚ÄúRun simulation‚Äù.</div>`;
    return;
  }
  for(const h of hist){
    const div = document.createElement("div");
    div.className = "history-item";
    div.innerHTML = `
      <div class="small"><span class="badge">${h.mode||"RUN"}</span> <b>${h.time}</b></div>
      <div class="small">${h.line}</div>
      <div class="small">
        white Œº=${h.white.mean.toFixed(2)} œÉ=${h.white.sd.toFixed(2)} ‚Ä¢
        QDS Œº=${h.qds.mean.toFixed(2)} œÉ=${h.qds.sd.toFixed(2)} ‚Ä¢
        <b>Œî=${h.delta.toFixed(2)}%</b>
      </div>
    `;
    root.appendChild(div);
  }
}

function updateCoach(){
  const p = getParams();
  const FT = tempFactor(p.temp);
  const FD = dodFactor(p.dod);

  let heatLabel = p.temp >= 40 ? "Hot" : (p.temp <= 15 ? "Cool" : "Moderate");
  let dodLabel = p.dod === "40-80" ? "gentle mid-window"
              : p.dod === "20-80" ? "phone-friendly mid-window"
              : p.dod === "10-90" ? "broad window"
              : p.dod === "60-100" ? "high-stress top range"
              : "full depth";

  let rhoLabel = p.rho >= 0.9 ? "streaky tails likely"
              : p.rho >= 0.6 ? "mild persistence"
              : "mostly i.i.d.";

  const coachTxt = `
    <div class="section-title"><span>Coach readout</span><span class="pill">toy wisdom</span></div>
    <div class="small">
      <b>${heatLabel}</b> regime ‚Ä¢ <b>${dodLabel}</b> ‚Ä¢ <b>${rhoLabel}</b>.<br>
      Stress multipliers: F(T)‚âà${FT.toFixed(2)} ‚Ä¢ F(DoD)‚âà${FD.toFixed(2)}.<br>
      ${p.poster ? "Poster ON: demo-safe clipping active." : "Poster OFF: tails are allowed to roar."}<br>
      ${p.useResistance ? `Resistance EoL active at ${p.thrR.toFixed(2)}√óR‚ÇÄ.` : "Resistance channel disabled."}
    </div>
  `;
  $("coachOut").innerHTML = coachTxt;
  $("viewerOut").innerHTML = renderViewerText();
}

function renderViewerText(){
  const hist = loadHistory();
  if(hist.length===0) return `<div class="small">No history yet.</div>`;
  const last = hist[0];
  return `
    <div class="history-item">
      <div class="small"><b>Latest run</b></div>
      <div class="small">${last.time}</div>
      <div class="small">${last.line}</div>
      <div class="small">White Œº ${last.white.mean.toFixed(2)} ‚Ä¢ QDS Œº ${last.qds.mean.toFixed(2)} ‚Ä¢ Œî ${last.delta.toFixed(2)}%</div>
    </div>
  `;
}

function runOnce(modeTag="RUN"){
  $("status").textContent = "Running‚Ä¶";

  const p = getParams();
  const seedBase = p.seedLock ? 123456 : Math.floor(Math.random()*1e9);

  const whiteRes = runModel(p, false, seedBase + 11);
  const qdsRes   = runModel(p, true,  seedBase + 22);

  const whiteStats = computeStats(whiteRes.cycles);
  const qdsStats   = computeStats(qdsRes.cycles);

  const summary = makeRunSummary(p, whiteStats, qdsStats);

  // UI
  $("wMean").textContent = whiteStats.mean.toFixed(2);
  $("qMean").textContent = qdsStats.mean.toFixed(2);
  $("wSd").textContent = whiteStats.sd.toFixed(2);
  $("qSd").textContent = qdsStats.sd.toFixed(2);
  $("wP").textContent = `P10/P50/P90 ${whiteStats.p10.toFixed(1)} / ${whiteStats.p50.toFixed(1)} / ${whiteStats.p90.toFixed(1)}`;
  $("qP").textContent = `P10/P50/P90 ${qdsStats.p10.toFixed(1)} / ${qdsStats.p50.toFixed(1)} / ${qdsStats.p90.toFixed(1)}`;

  const dStr = (summary.delta>=0?"+":"") + summary.delta.toFixed(2) + "%";
  $("delta").innerHTML = `<span class="${summary.delta>=0? "ok":"warn"}">${dStr}</span>`;
  $("metaLine").textContent =
    `œÅ=${p.rho.toFixed(2)} ¬∑ T=${p.temp}¬∞C ¬∑ DoD=${p.dod} ¬∑ `+
    `Poster=${p.poster} ¬∑ NoRegen=${p.noregen} ¬∑ `+
    `${p.n} runs/model`;

  drawHistogram($("hist"), whiteRes.cycles, qdsRes.cycles);

  drawTrace(
    $("trace"),
    {cap:whiteRes.sample.cap, R:whiteRes.sample.R},
    {cap:qdsRes.sample.cap, R:qdsRes.sample.R},
    p
  );

  // history with dedupe
  const now = new Date();
  const timeStr = now.toLocaleString();

  const entry = {
    version:"9.7",
    mode: modeTag,
    time: timeStr,
    line: summary.line,
    delta: summary.delta,
    params: p,
    white: whiteStats,
    qds: qdsStats,
    key: paramsKey(p)
  };

  let hist = loadHistory();
  const idx = hist.findIndex(h=>h.key===entry.key);
  if(idx===0){
    hist[0]=entry; // refresh timestamp
  }else if(idx>0){
    hist.splice(idx,1);
    hist.unshift(entry);
  }else{
    hist.unshift(entry);
  }
  hist = hist.slice(0, 80);
  saveHistory(hist);
  renderHistory();
  updateCoach();

  $("status").textContent = `Done. Œî=${summary.delta.toFixed(2)}% ‚Ä¢ history updated.`;
  return entry;
}

function resetDefaults(){
  setParams({...defaults});
  $("status").textContent = "Defaults restored.";
}

function quickSweep(){
  const baseParams = getParams();
  const runs = 10;
  let lastEntry=null;
  for(let i=0;i<runs;i++){
    // Slightly jitter rho for sweep flavour
    $("rho").value = clamp(baseParams.rho + (i-5)*0.01, 0, 0.99).toFixed(2);
    lastEntry = runOnce("SWEEP");
  }
  $("rho").value = baseParams.rho;
  $("status").textContent = `Sweep complete √ó${runs}.`;
  return lastEntry;
}

function copySummary(){
  const hist = loadHistory();
  if(hist.length===0){ $("status").textContent="Nothing to copy yet."; return; }
  const h = hist[0];
  const txt =
    `${h.mode} ${h.time}\n`+
    `${h.line}\n`+
    `white Œº=${h.white.mean.toFixed(2)} œÉ=${h.white.sd.toFixed(2)}\n`+
    `QDS Œº=${h.qds.mean.toFixed(2)} œÉ=${h.qds.sd.toFixed(2)}\n`+
    `Œî=${h.delta.toFixed(2)}%`;
  navigator.clipboard?.writeText(txt).then(()=>{
    $("status").textContent="Summary copied.";
  }).catch(()=>{
    $("status").textContent="Copy failed (browser limits).";
  });
}

function exportJSON(obj, filename){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download=filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function exportLast(){
  const hist = loadHistory();
  if(hist.length===0){ $("status").textContent="No history yet."; return; }
  exportJSON(hist[0], `qds_battery_hub_v9_7_last.json`);
}
function exportAll(){
  const hist = loadHistory();
  exportJSON(hist, `qds_battery_hub_v9_7_history.json`);
}
function clearHistory(){
  localStorage.removeItem(LS_KEY);
  renderHistory();
  updateCoach();
  $("status").textContent="History cleared.";
}

// Tabs
document.querySelectorAll(".tab").forEach(t=>{
  t.addEventListener("click", ()=>{
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    const tab = t.dataset.tab;
    $("tab-lab").style.display = tab==="lab" ? "" : "none";
    $("tab-coach").style.display = tab==="coach" ? "" : "none";
    $("tab-viewer").style.display = tab==="viewer" ? "" : "none";
  });
});

// Wire buttons
$("runBtn").onclick = ()=>runOnce("RUN");
$("resetBtn").onclick = resetDefaults;
$("sweepBtn").onclick = quickSweep;

$("presetReal").onclick = presetRealistic;
$("presetQds").onclick = presetQDS;
$("presetChaos").onclick = presetChaos;

$("copySummary").onclick = copySummary;
$("exportLast").onclick = exportLast;
$("exportAll").onclick = exportAll;
$("clearHist").onclick = clearHistory;

// Update coach on input changes
["k1","k2","amp","rho","temp","thrC","dod","n","maxCycles","seedLock","poster","noregen","useCalendar","useResistance","thrR"]
  .forEach(id=>{
    const el = $(id);
    el.addEventListener("change", updateCoach);
    el.addEventListener("input", ()=>{ if(id==="rho"||id==="amp") updateCoach(); });
  });

// Init
resetDefaults();
renderHistory();
updateCoach();


// --- cannon_wall_breaker_v1.html ---

(() => {
  // ------------------------------------------------------------
  // Minimal 3D-ish engine (no deps). Canvas + simple projection.
  // ------------------------------------------------------------
  const canvas = document.getElementById("c");
  const box = document.getElementById("canvasBox");
  const ctx = canvas.getContext("2d");

  // UI
  const elPower = document.getElementById("power");
  const elElev  = document.getElementById("elev");
  const elYaw   = document.getElementById("yaw");
  const elRadius= document.getElementById("radius");
  const elWW    = document.getElementById("wW");
  const elWH    = document.getElementById("wH");
  const elBS    = document.getElementById("bS");
  const elFrag  = document.getElementById("frag");

  const vPower = document.getElementById("powerVal");
  const vElev  = document.getElementById("elevVal");
  const vYaw   = document.getElementById("yawVal");
  const vRadius= document.getElementById("radiusVal");
  const vWW    = document.getElementById("wWVal");
  const vWH    = document.getElementById("wHVal");
  const vBS    = document.getElementById("bSVal");
  const vFrag  = document.getElementById("fragVal");

  const statBlocks = document.getElementById("statBlocks");
  const statHits = document.getElementById("statHits");
  const statShots = document.getElementById("statShots");

  const btnFire = document.getElementById("btnFire");
  const btnReset= document.getElementById("btnReset");
  const btnSlow = document.getElementById("btnSlow");
  const btnCam  = document.getElementById("btnCam");

  function syncVals(){
    vPower.textContent = elPower.value;
    vElev.textContent  = elElev.value + "¬∞";
    vYaw.textContent   = elYaw.value + "¬∞";
    vRadius.textContent= elRadius.value;
    vWW.textContent    = elWW.value;
    vWH.textContent    = elWH.value;
    vBS.textContent    = elBS.value;
    vFrag.textContent  = elFrag.value;
  }
  [elPower,elElev,elYaw,elRadius,elWW,elWH,elBS,elFrag].forEach(e=>e.addEventListener("input", () => {
    syncVals();
  }));
  syncVals();

  // Resize
  function resize(){
    const r = box.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(r.width * dpr);
    canvas.height= Math.floor((r.height) * dpr);
    canvas.style.width = r.width+"px";
    canvas.style.height= r.height+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  new ResizeObserver(resize).observe(box);
  resize();

  // Math helpers
  const TAU = Math.PI * 2;
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // Camera / view
  let camMode = "orbit"; // orbit | chase
  let camYaw = -0.35, camPitch = 0.22;
  let camDist = 22;
  let dragging = false;
  let lastX=0,lastY=0;
  let pinchDist = 0;

  // World scale units
  // We'll keep everything small and stable for phone.
  const G = 9.8; // gravity "units"

  // Entities
  let blocks = [];
  let balls = [];
  let sparks = [];
  let debris = [];

  let hits = 0;
  let shots = 0;
  let slowMo = false;

  // Cannon position & base direction
  const cannon = {
    pos: {x:0, y:1.2, z:-14},
    barrelLen: 2.4
  };

  // Wall plane around z = 0
  function buildWall(){
    blocks = [];
    const wW = parseInt(elWW.value,10);
    const wH = parseInt(elWH.value,10);
    const bS = parseFloat(elBS.value);
    const gap = bS * 0.06;
    const startX = -((wW-1) * (bS+gap))/2;
    const startY = 0.6;
    const z = 0;

    for(let j=0;j<wH;j++){
      for(let i=0;i<wW;i++){
        const x = startX + i*(bS+gap);
        const y = startY + j*(bS+gap);
        blocks.push({
          x,y,z,
          s:bS,
          alive:true,
          wobble: Math.random()*TAU,
          hp: 1
        });
      }
    }
    statBlocks.textContent = "blocks: " + blocks.length;
  }

  buildWall();

  function resetSim(keepStats=false){
    balls = [];
    sparks = [];
    debris = [];
    if(!keepStats){
      hits = 0; shots = 0;
    }
    statHits.textContent = "hits: " + hits;
    statShots.textContent = "shots: " + shots;
  }

  btnReset.addEventListener("click", () => {
    buildWall();
    resetSim(false);
  });

  btnSlow.addEventListener("click", () => {
    slowMo = !slowMo;
    btnSlow.textContent = slowMo ? "Slow-Mo: ON" : "Slow-Mo";
  });

  btnCam.addEventListener("click", () => {
    camMode = (camMode === "orbit") ? "chase" : "orbit";
    btnCam.textContent = "Cam: " + (camMode === "orbit" ? "Orbit" : "Chase");
  });

  function fire(){
    const power = parseFloat(elPower.value);
    const elevDeg = parseFloat(elElev.value);
    const yawDeg = parseFloat(elYaw.value);
    const r = parseFloat(elRadius.value);

    const elev = elevDeg * Math.PI/180;
    const yaw = yawDeg * Math.PI/180;

    // Direction vector from angles
    const dx = Math.sin(yaw) * Math.cos(elev);
    const dy = Math.sin(elev);
    const dz = Math.cos(yaw) * Math.cos(elev);

    // Spawn at barrel tip
    const bx = cannon.pos.x + dx * cannon.barrelLen;
    const by = cannon.pos.y + dy * cannon.barrelLen;
    const bz = cannon.pos.z + dz * cannon.barrelLen;

    // Velocity
    const v = power * 0.12; // tuned for scene scale
    balls.push({
      x:bx,y:by,z:bz,
      vx:dx*v, vy:dy*v, vz:dz*v,
      r,
      alive:true,
      age:0
    });

    shots++;
    statShots.textContent = "shots: " + shots;

    // Muzzle spark
    for(let i=0;i<14;i++){
      sparks.push({
        x:bx,y:by,z:bz,
        vx:(Math.random()-0.5)*0.8 + dx*0.8,
        vy:(Math.random()-0.5)*0.8 + dy*0.8,
        vz:(Math.random()-0.5)*0.8 + dz*0.8,
        life: 0.6 + Math.random()*0.4
      });
    }
  }

  btnFire.addEventListener("click", fire);

  // Touch + mouse controls
  function pointerDown(e){
    dragging = true;
    const p = getPoint(e);
    lastX = p.x; lastY = p.y;
  }
  function pointerMove(e){
    if(!dragging) return;
    const p = getPoint(e);
    const dx = p.x - lastX;
    const dy = p.y - lastY;
    lastX = p.x; lastY = p.y;

    camYaw   += dx * 0.005;
    camPitch += dy * 0.005;
    camPitch = clamp(camPitch, -0.35, 0.65);
  }
  function pointerUp(){
    dragging = false;
  }
  function getPoint(e){
    if(e.touches && e.touches.length){
      return {x:e.touches[0].clientX, y:e.touches[0].clientY};
    }
    return {x:e.clientX, y:e.clientY};
  }

  canvas.addEventListener("mousedown", pointerDown);
  window.addEventListener("mousemove", pointerMove);
  window.addEventListener("mouseup", pointerUp);

  canvas.addEventListener("touchstart", (e)=>{
    if(e.touches.length===2){
      pinchDist = distTouches(e.touches[0], e.touches[1]);
    }else{
      pointerDown(e);
    }
  }, {passive:true});

  canvas.addEventListener("touchmove", (e)=>{
    if(e.touches.length===2){
      const d = distTouches(e.touches[0], e.touches[1]);
      const dd = d - pinchDist;
      pinchDist = d;
      camDist = clamp(camDist - dd*0.02, 10, 40);
    }else{
      pointerMove(e);
    }
  }, {passive:true});

  canvas.addEventListener("touchend", pointerUp, {passive:true});

  function distTouches(a,b){
    const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY;
    return Math.sqrt(dx*dx+dy*dy);
  }

  // Double tap to fire
  let lastTap = 0;
  canvas.addEventListener("touchend", ()=>{
    const now = performance.now();
    if(now - lastTap < 260){
      fire();
      lastTap = 0;
    }else{
      lastTap = now;
    }
  }, {passive:true});

  // ------------------------------------------------------------
  // Projection & rendering
  // ------------------------------------------------------------
  function project(x,y,z, cam){
    // World -> camera space
    const cx = x - cam.x, cy = y - cam.y, cz = z - cam.z;

    // Rotate around yaw then pitch (camera orientation)
    const sy = Math.sin(-cam.yaw), cyaw = Math.cos(-cam.yaw);
    let x1 = cx * cyaw - cz * sy;
    let z1 = cx * sy + cz * cyaw;

    const sp = Math.sin(-cam.pitch), cp = Math.cos(-cam.pitch);
    let y2 = cy * cp - z1 * sp;
    let z2 = cy * sp + z1 * cp;

    // Perspective
    const f = cam.fov;
    const s = f / (f + z2);
    const px = x1 * s;
    const py = y2 * s;

    return {x:px, y:py, z:z2, s};
  }

  function getCamera(){
    if(camMode === "chase" && balls.length){
      const b = balls[balls.length-1];
      // behind ball
      const tx = b.x - b.vx*3;
      const ty = b.y + 2.5;
      const tz = b.z - b.vz*3 - 6;

      const yaw = Math.atan2((b.x - tx), (b.z - tz));
      return {x:tx, y:ty, z:tz, yaw:yaw, pitch:0.12, fov:18};
    }

    // orbit around wall center
    const target = {x:0, y:3.2, z:0};
    const x = target.x + Math.sin(camYaw) * camDist;
    const z = target.z - Math.cos(camYaw) * camDist;
    const y = target.y + camPitch * camDist * 0.6;

    return {x,y,z, yaw:camYaw, pitch:camPitch, fov:18};
  }

  function draw(){
    const w = canvas.width / (Math.min(2, window.devicePixelRatio||1));
    const h = canvas.height/ (Math.min(2, window.devicePixelRatio||1));

    ctx.clearRect(0,0,w,h);

    // Soft star-ish dust
    ctx.fillStyle = "rgba(140,180,255,0.04)";
    for(let i=0;i<18;i++){
      const rx = (i*97)%w;
      const ry = (i*173)%h;
      ctx.fillRect(rx,ry,1.5,1.5);
    }

    const cam = getCamera();

    // Center transform
    ctx.save();
    ctx.translate(w/2, h*0.56);

    // Ground grid (fake)
    drawGrid(cam);

    // Collect renderables with depth for painter's sort
    const items = [];

    // Blocks as cubes
    for(const bl of blocks){
      if(!bl.alive) continue;
      items.push({type:"block", ref:bl});
    }

    // Balls
    for(const b of balls){
      if(!b.alive) continue;
      items.push({type:"ball", ref:b});
    }

    // Debris
    for(const d of debris){
      items.push({type:"debris", ref:d});
    }

    // Sparks
    for(const s of sparks){
      items.push({type:"spark", ref:s});
    }

    // Sort by projected z (far to near)
    items.sort((A,B)=>{
      const az = getDepth(A, cam);
      const bz = getDepth(B, cam);
      return az - bz;
    });

    for(const it of items){
      if(it.type==="block") drawBlock(it.ref, cam);
      else if(it.type==="ball") drawBall(it.ref, cam);
      else if(it.type==="debris") drawDebris(it.ref, cam);
      else drawSpark(it.ref, cam);
    }

    // Cannon overlay
    drawCannon(cam);

    ctx.restore();

    // Title whisper
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(200,230,255,0.08)";
    ctx.fillRect(10, h-34, 140, 22);
    ctx.fillStyle = "rgba(200,240,255,0.7)";
    ctx.font = "11px system-ui";
    ctx.fillText("Drag to orbit ‚Ä¢ Double tap FIRE", 16, h-19);
    ctx.restore();
  }

  function getDepth(item, cam){
    const r = item.ref;
    const p = project(r.x||0, r.y||0, r.z||0, cam);
    return p.z;
  }

  function drawGrid(cam){
    const size = 18;
    const step = 1.5;
    ctx.lineWidth = 1;

    for(let i=-size;i<=size;i++){
      const a1 = project(i*step, 0, -size*step, cam);
      const a2 = project(i*step, 0,  size*step, cam);
      const b1 = project(-size*step, 0, i*step, cam);
      const b2 = project( size*step, 0, i*step, cam);

      ctx.strokeStyle = "rgba(124,243,255,0.05)";
      ctx.beginPath(); ctx.moveTo(a1.x*22, a1.y*22); ctx.lineTo(a2.x*22, a2.y*22); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(b1.x*22, b1.y*22); ctx.lineTo(b2.x*22, b2.y*22); ctx.stroke();
    }
  }

  function drawBlock(bl, cam){
    const s = bl.s;
    const wob = Math.sin(bl.wobble)*0.02;
    // cube corners (simple 3D box)
    const half = s/2;

    // We'll draw 3 faces using projected quads
    const x=bl.x, y=bl.y, z=bl.z + wob;

    const P = (dx,dy,dz)=>project(x+dx, y+dy, z+dz, cam);

    const p000 = P(-half, -half, -half);
    const p100 = P( half, -half, -half);
    const p010 = P(-half,  half, -half);
    const p110 = P( half,  half, -half);
    const p001 = P(-half, -half,  half);
    const p101 = P( half, -half,  half);
    const p011 = P(-half,  half,  half);
    const p111 = P( half,  half,  half);

    // scale to screen-ish
    const S = 22;

    // Face colors (neon stone)
    const baseA = "rgba(120,160,255,0.10)";
    const baseB = "rgba(140,255,220,0.10)";
    const outline = "rgba(160,210,255,0.10)";

    // Determine simple face visibility by z ordering (approx)
    // We'll draw "front" (+z), "top" (+y), "right" (+x)
    // This is not perfect, but looks good.
    // Front face: p001 p101 p111 p011
    ctx.fillStyle = baseA;
    quad(p001,p101,p111,p011,S,true);

    // Top face: p011 p111 p110 p010
    ctx.fillStyle = baseB;
    quad(p011,p111,p110,p010,S,true);

    // Right face: p101 p100 p110 p111
    ctx.fillStyle = "rgba(124,243,255,0.08)";
    quad(p101,p100,p110,p111,S,true);

    // Outline
    ctx.strokeStyle = outline;
    ctx.lineWidth = 1;
    wire(p000,p100,p110,p010,p001,p101,p111,p011,S);
  }

  function quad(a,b,c,d,S, fill){
    ctx.beginPath();
    ctx.moveTo(a.x*S, a.y*S);
    ctx.lineTo(b.x*S, b.y*S);
    ctx.lineTo(c.x*S, c.y*S);
    ctx.lineTo(d.x*S, d.y*S);
    ctx.closePath();
    if(fill) ctx.fill();
  }

  function wire(p000,p100,p110,p010,p001,p101,p111,p011,S){
    const line = (u,v)=>{
      ctx.beginPath(); ctx.moveTo(u.x*S,u.y*S); ctx.lineTo(v.x*S,v.y*S); ctx.stroke();
    };
    line(p000,p100); line(p100,p110); line(p110,p010); line(p010,p000);
    line(p001,p101); line(p101,p111); line(p111,p011); line(p011,p001);
    line(p000,p001); line(p100,p101); line(p110,p111); line(p010,p011);
  }

  function drawBall(b, cam){
    const p = project(b.x,b.y,b.z, cam);
    const S = 22;

    const r = b.r * p.s * S * 1.15;

    // glow
    const g = ctx.createRadialGradient(p.x*S, p.y*S, 0, p.x*S, p.y*S, r*2.2);
    g.addColorStop(0, "rgba(156,255,220,0.22)");
    g.addColorStop(1, "rgba(156,255,220,0)");
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(p.x*S, p.y*S, r*2.2, 0, TAU); ctx.fill();

    // core
    ctx.fillStyle = "rgba(220,255,250,0.85)";
    ctx.beginPath(); ctx.arc(p.x*S, p.y*S, r, 0, TAU); ctx.fill();

    ctx.strokeStyle = "rgba(124,243,255,0.35)";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(p.x*S, p.y*S, r, 0, TAU); ctx.stroke();
  }

  function drawDebris(d, cam){
    const p = project(d.x,d.y,d.z, cam);
    const S = 22;
    const r = d.size * p.s * S;

    ctx.fillStyle = "rgba(160,200,255,0.25)";
    ctx.fillRect(p.x*S - r/2, p.y*S - r/2, r, r);
  }

  function drawSpark(s, cam){
    const p = project(s.x,s.y,s.z, cam);
    const S = 22;
    const r = 0.08 * p.s * S;

    ctx.fillStyle = "rgba(255,180,220,0.55)";
    ctx.beginPath(); ctx.arc(p.x*S, p.y*S, r, 0, TAU); ctx.fill();
  }

  function drawCannon(cam){
    // Simple cannon barrel line in 3D
    const power = parseFloat(elPower.value);
    const elev = parseFloat(elElev.value) * Math.PI/180;
    const yaw  = parseFloat(elYaw.value) * Math.PI/180;

    const dx = Math.sin(yaw) * Math.cos(elev);
    const dy = Math.sin(elev);
    const dz = Math.cos(yaw) * Math.cos(elev);

    const x0 = cannon.pos.x, y0 = cannon.pos.y, z0 = cannon.pos.z;
    const x1 = x0 + dx * cannon.barrelLen;
    const y1 = y0 + dy * cannon.barrelLen;
    const z1 = z0 + dz * cannon.barrelLen;

    const p0 = project(x0,y0,z0, cam);
    const p1 = project(x1,y1,z1, cam);
    const S = 22;

    // Base glow
    ctx.strokeStyle = "rgba(124,243,255,0.18)";
    ctx.lineWidth = 7;
    ctx.beginPath(); ctx.moveTo(p0.x*S, p0.y*S); ctx.lineTo(p1.x*S, p1.y*S); ctx.stroke();

    // Barrel core
    ctx.strokeStyle = "rgba(210,240,255,0.75)";
    ctx.lineWidth = 2.2;
    ctx.beginPath(); ctx.moveTo(p0.x*S, p0.y*S); ctx.lineTo(p1.x*S, p1.y*S); ctx.stroke();

    // Cannon base marker
    ctx.fillStyle = "rgba(124,243,255,0.10)";
    ctx.beginPath(); ctx.arc(p0.x*S, p0.y*S, 6, 0, TAU); ctx.fill();

    // Little power hint text
    ctx.fillStyle = "rgba(200,240,255,0.55)";
    ctx.font = "10px system-ui";
    ctx.fillText("P"+Math.round(power), p0.x*S+8, p0.y*S-6);
  }

  // ------------------------------------------------------------
  // Physics + collisions
  // ------------------------------------------------------------
  function step(dt){
    const timeScale = slowMo ? 0.35 : 1.0;
    dt *= timeScale;

    // Animate block wobble
    for(const bl of blocks){
      bl.wobble += dt * 1.2;
    }

    // Balls
    for(const b of balls){
      if(!b.alive) continue;
      b.age += dt;

      // Integrate
      b.vy -= G * dt * 0.12; // tuned gravity
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.z += b.vz * dt;

      // Floor
      if(b.y < 0.1){
        b.y = 0.1;
        b.vy *= -0.35;
        b.vx *= 0.92;
        b.vz *= 0.92;
        if(Math.abs(b.vy) < 0.08) b.vy = 0;
      }

      // Cull old balls
      if(b.age > 12 || Math.abs(b.x) > 40 || b.z > 30 || b.z < -40){
        b.alive = false;
      }

      // Collide with blocks
      for(const bl of blocks){
        if(!bl.alive) continue;

        // AABB-ish sphere hit
        const half = bl.s/2;
        const dx = b.x - bl.x;
        const dy = b.y - bl.y;
        const dz = b.z - bl.z;

        const nx = clamp(dx, -half, half);
        const ny = clamp(dy, -half, half);
        const nz = clamp(dz, -half, half);

        const cx = bl.x + nx;
        const cy = bl.y + ny;
        const cz = bl.z + nz;

        const sx = b.x - cx, sy = b.y - cy, sz = b.z - cz;
        const dist2 = sx*sx + sy*sy + sz*sz;

        if(dist2 <= b.r*b.r){
          // Impact energy estimate
          const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy + b.vz*b.vz);
          const frag = parseFloat(elFrag.value);

          // Damage threshold
          const dmg = speed * b.r * 0.7 / frag;

          bl.hp -= dmg;

          // Bounce a little
          b.vx *= 0.75;
          b.vy *= 0.75;
          b.vz *= -0.55;

          // Hit spark
          for(let i=0;i<10;i++){
            sparks.push({
              x:b.x,y:b.y,z:b.z,
              vx:(Math.random()-0.5)*1.2,
              vy:(Math.random())*1.3,
              vz:(Math.random()-0.5)*1.2,
              life: 0.35 + Math.random()*0.25
            });
          }

          if(bl.hp <= 0){
            bl.alive = false;
            hits++;
            statHits.textContent = "hits: " + hits;

            // Debris burst
            const chunks = 10 + Math.floor(Math.random()*8);
            for(let i=0;i<chunks;i++){
              debris.push({
                x:bl.x + (Math.random()-0.5)*0.25,
                y:bl.y + (Math.random()-0.5)*0.25,
                z:bl.z + (Math.random()-0.5)*0.25,
                vx:(Math.random()-0.5)*2.2,
                vy:Math.random()*2.3,
                vz:(Math.random()-0.5)*2.2,
                life: 1.8 + Math.random()*1.2,
                size: bl.s * (0.12 + Math.random()*0.12)
              });
            }
          }
        }
      }
    }

    // Sparks
    for(const s of sparks){
      s.life -= dt;
      s.x += s.vx * dt;
      s.y += s.vy * dt;
      s.z += s.vz * dt;
      s.vy -= G * dt * 0.06;
    }
    sparks = sparks.filter(s=>s.life > 0);

    // Debris
    for(const d of debris){
      d.life -= dt;
      d.x += d.vx * dt;
      d.y += d.vy * dt;
      d.z += d.vz * dt;
      d.vy -= G * dt * 0.10;

      if(d.y < 0.05){
        d.y = 0.05;
        d.vy *= -0.25;
        d.vx *= 0.85;
        d.vz *= 0.85;
      }
    }
    debris = debris.filter(d=>d.life > 0);

    // Update blocks count display (live)
    const aliveCount = blocks.reduce((a,b)=>a+(b.alive?1:0),0);
    statBlocks.textContent = "blocks: " + aliveCount;
  }

  // ------------------------------------------------------------
  // Loop
  // ------------------------------------------------------------
  let lastT = performance.now();
  function loop(t){
    const dt = Math.min(0.033, (t-lastT)/1000);
    lastT = t;

    step(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();


// --- cannon_wall_breaker_v1_1.html ---

(() => {
  // ==========================================================
  // Œ© Cannon Wall Breaker v1.1+
  // - 3 camera modes: orbit | chase | cannon
  // - touch drag look-around + pinch zoom
  // - simple 3D blocks + projectile gravity
  // - offline-first, no libs
  // ==========================================================

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // ---------------- small vec helpers ----------------
  const v3 = (x=0,y=0,z=0)=>({x,y,z});
  const add = (a,b)=>v3(a.x+b.x,a.y+b.y,a.z+b.z);
  const sub = (a,b)=>v3(a.x-b.x,a.y-b.y,a.z-b.z);
  const mul = (a,s)=>v3(a.x*s,a.y*s,a.z*s);
  const dot = (a,b)=>a.x*b.x+a.y*b.y+a.z*b.z;
  const len = a=>Math.hypot(a.x,a.y,a.z);
  const norm = a=>{const l=len(a)||1; return v3(a.x/l,a.y/l,a.z/l);};
  const cross = (a,b)=>v3(
    a.y*b.z-a.z*b.y,
    a.z*b.x-a.x*b.z,
    a.x*b.y-a.y*b.x
  );
  const lerp = (a,b,t)=>v3(
    a.x+(b.x-a.x)*t,
    a.y+(b.y-a.y)*t,
    a.z+(b.z-a.z)*t
  );
  const clamp = (n,min,max)=>Math.max(min, Math.min(max,n));
  const rad = d=>d*Math.PI/180;

  // ---------------- world objects ----------------
  const cannon = {
    pos: v3(0, 1.2, 0),
    yaw: 0,
    pitch: 0
  };

  let shells = [];
  let debris = [];
  let blocks = [];
  let lastShell = null;

  // wall presets
  const WALL_PRESETS = {
    soft: { rows: 6, cols: 10, size: 1.6, spacing: 1.75, hp: 1 },
    med:  { rows: 8, cols: 12, size: 1.5, spacing: 1.7,  hp: 2 },
    hard: { rows: 10, cols: 14, size: 1.4, spacing: 1.65, hp: 3 },
  };

  let wallMode = "med";

  function buildWall(mode="med"){
    wallMode = mode;
    blocks.length = 0;
    const P = WALL_PRESETS[mode];
    const z0 = 38;
    const width = (P.cols-1)*P.spacing;
    const height = (P.rows-1)*P.spacing;

    for(let r=0;r<P.rows;r++){
      for(let c=0;c<P.cols;c++){
        const x = c*P.spacing - width/2;
        const y = 2 + r*P.spacing;
        blocks.push({
          pos: v3(x,y,z0),
          size: P.size,
          hp: P.hp,
          alive: true,
        });
      }
    }
  }

  // ---------------- camera ----------------
  let camMode = "orbit"; // orbit | chase | cannon

  const camera = {
    pos: v3(0,6,18),
    look: v3(0,3,10),
    smooth: 0.14,
  };

  let orbitBaseDist = 18;
  let chaseBaseDist = 14;
  let cannonBaseDist = 3.2;
  let cannonBaseUp = 1.1;
  let cannonLookAhead = 18;

  // touch offsets
  let dragYaw = 0;
  let dragPitch = 0;
  let pinchDelta = 0;

  const PITCH_MIN = -0.85;
  const PITCH_MAX =  0.60;

  function cannonForward(){
    const y = cannon.yaw || 0;
    const p = cannon.pitch || 0;
    const cy = Math.cos(y), sy = Math.sin(y);
    const cp = Math.cos(p), sp = Math.sin(p);
    return norm(v3(
      sy * cp,
      sp,
      cy * cp
    ));
  }

  function getChaseTarget(){
    if (lastShell && lastShell.alive) return lastShell.pos;
    return cannon.pos;
  }

  function getCamera(){
    const focus = cannon.pos;
    const offYaw = dragYaw || 0;
    const offPitchRaw = dragPitch || 0;
    const offPitch = clamp(offPitchRaw, PITCH_MIN, PITCH_MAX);

    const baseYaw = (cannon.yaw || 0) + offYaw;
    const basePitch = clamp((cannon.pitch || 0) + offPitch, PITCH_MIN, PITCH_MAX);

    const cy = Math.cos(baseYaw), sy = Math.sin(baseYaw);
    const cp = Math.cos(basePitch), sp = Math.sin(basePitch);

    const aimDir = norm(v3(
      sy * cp,
      sp,
      cy * cp
    ));

    const pinch = pinchDelta || 0;

    let targetPos, targetLook;

    if (camMode === "orbit") {
      const dist = clamp(orbitBaseDist + pinch, 8, 40);
      targetLook = add(focus, mul(aimDir, 6));
      targetPos = add(add(focus, mul(v3(0,1,0), 3.0)), mul(aimDir, -dist));
    }
    else if (camMode === "chase") {
      const chaseTarget = getChaseTarget();
      const dist = clamp(chaseBaseDist + pinch, 6, 35);
      targetLook = chaseTarget;
      targetPos = add(add(chaseTarget, v3(0, 2.2, 0)), mul(aimDir, -dist));
    }
    else { // cannon
      const dist = clamp(cannonBaseDist + pinch*0.25, 2.2, 8.0);
      const anchor = add(focus, v3(0, cannonBaseUp, 0));
      targetPos = add(anchor, mul(aimDir, -dist));
      targetLook = add(anchor, mul(aimDir, cannonLookAhead));
    }

    camera.pos = lerp(camera.pos, targetPos, camera.smooth);
    camera.look = lerp(camera.look, targetLook, camera.smooth);
    return camera;
  }

  // ---------------- projection ----------------
  function project(pt){
    const cam = camera;
    const forward = norm(sub(cam.look, cam.pos));
    const worldUp = v3(0,1,0);
    let right = cross(forward, worldUp);
    if (len(right) < 0.0001) right = v3(1,0,0);
    right = norm(right);
    const up = norm(cross(right, forward));

    const rel = sub(pt, cam.pos);
    const x = dot(rel, right);
    const y = dot(rel, up);
    const z = dot(rel, forward);

    if (z <= 0.05) return null;

    const fov = 1.05; // tuned for phone comfort
    const sx = (x / z) * (innerWidth * fov) + innerWidth/2;
    const sy = (-y / z) * (innerWidth * fov) + innerHeight/2;

    return { x:sx, y:sy, z };
  }

  function drawCube(c, size){
    // Simple wire-ish cube using 8 points projected
    const s = size/2;
    const pts = [
      v3(c.x-s,c.y-s,c.z-s), v3(c.x+s,c.y-s,c.z-s),
      v3(c.x+s,c.y+s,c.z-s), v3(c.x-s,c.y+s,c.z-s),
      v3(c.x-s,c.y-s,c.z+s), v3(c.x+s,c.y-s,c.z+s),
      v3(c.x+s,c.y+s,c.z+s), v3(c.x-s,c.y+s,c.z+s),
    ];
    const pr = pts.map(project);
    if (pr.some(p=>!p)) return;

    const e = [
      [0,1],[1,2],[2,3],[3,0],
      [4,5],[5,6],[6,7],[7,4],
      [0,4],[1,5],[2,6],[3,7]
    ];

    ctx.beginPath();
    for (const [a,b] of e){
      ctx.moveTo(pr[a].x, pr[a].y);
      ctx.lineTo(pr[b].x, pr[b].y);
    }
    ctx.stroke();
  }

  // ---------------- physics ----------------
  const GRAV = -9.2; // toy gravity
  const SHELL_SPEED = 26;

  function fire(){
    const dir = cannonForward();
    const p = add(cannon.pos, mul(dir, 1.7));
    const v = add(mul(dir, SHELL_SPEED), v3(0, 1.0, 0));

    const shell = {
      pos: p,
      vel: v,
      r: 0.35,
      alive: true,
      t: 0
    };
    shells.push(shell);
    lastShell = shell;
  }

  function spawnDebris(hitPos, count=10){
    for(let i=0;i<count;i++){
      const rv = v3(
        (Math.random()-0.5)*6,
        Math.random()*6,
        (Math.random()-0.5)*6
      );
      debris.push({
        pos: v3(hitPos.x, hitPos.y, hitPos.z),
        vel: rv,
        life: 0.9 + Math.random()*0.6
      });
    }
  }

  function step(dt){
    // shells
    for (const s of shells){
      if (!s.alive) continue;
      s.t += dt;
      s.vel.y += GRAV * dt;
      s.pos = add(s.pos, mul(s.vel, dt));

      // simple lifetime + ground check
      if (s.pos.y < 0.2 || s.t > 6){
        s.alive = false;
      }

      // block collisions
      for (const b of blocks){
        if (!b.alive || !s.alive) continue;
        const d = sub(s.pos, b.pos);
        const dist = len(d);
        const hitRange = s.r + b.size*0.75;
        if (dist < hitRange){
          b.hp -= 1;
          s.vel = mul(s.vel, 0.6); // lose energy
          spawnDebris(b.pos, 8);

          if (b.hp <= 0){
            b.alive = false;
            spawnDebris(b.pos, 14);
          }
          // tiny bounce nudge
          const n = norm(d);
          s.vel = add(s.vel, mul(n, 3.2));
        }
      }
    }

    // debris
    for (const d of debris){
      d.life -= dt;
      d.vel.y += GRAV * 0.6 * dt;
      d.pos = add(d.pos, mul(d.vel, dt));
    }
    debris = debris.filter(d => d.life > 0);

    // clean shells list occasionally
    if (shells.length > 24){
      shells = shells.filter(s => s.alive);
    }
  }

  // ---------------- render ----------------
  function drawGround(){
    // faint horizon + grid lines
    ctx.save();
    ctx.strokeStyle = "rgba(140,180,255,0.08)";
    ctx.lineWidth = 1;

    for(let i=-10;i<=10;i++){
      const a = project(v3(i*2, 0, 6));
      const b = project(v3(i*2, 0, 60));
      if (a && b){
        ctx.beginPath();
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
      }
    }
    for(let k=6;k<=60;k+=6){
      const a = project(v3(-22, 0, k));
      const b = project(v3( 22, 0, k));
      if (a && b){
        ctx.beginPath();
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function drawCannon(){
    ctx.save();
    ctx.strokeStyle = "rgba(200,230,255,0.35)";
    ctx.lineWidth = 1.4;

    // body cube-ish
    drawCube(v3(cannon.pos.x, cannon.pos.y, cannon.pos.z), 1.2);

    // barrel line
    const dir = cannonForward();
    const p0 = add(cannon.pos, v3(0, 0.4, 0));
    const p1 = add(p0, mul(dir, 2.8));
    const a = project(p0), b = project(p1);

    if (a && b){
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawBlocks(){
    ctx.save();
    ctx.lineWidth = 1;

    // sort by depth for nicer feel
    const alive = blocks.filter(b=>b.alive);
    alive.sort((A,B)=> (B.pos.z - A.pos.z));

    for (const b of alive){
      const hp = b.hp;
      ctx.strokeStyle =
        (hp >= 3) ? "rgba(255,140,140,0.45)" :
        (hp === 2) ? "rgba(255,210,140,0.45)" :
                    "rgba(140,210,255,0.45)";
      drawCube(b.pos, b.size);
    }

    ctx.restore();
  }

  function drawShells(){
    ctx.save();
    for (const s of shells){
      if (!s.alive) continue;
      const p = project(s.pos);
      if (!p) continue;
      const r = clamp(120 / (p.z+0.001), 2, 12) * s.r;

      ctx.fillStyle = "rgba(160,220,255,0.9)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawDebris(){
    ctx.save();
    ctx.fillStyle = "rgba(200,220,255,0.25)";
    for (const d of debris){
      const p = project(d.pos);
      if (!p) continue;
      const r = clamp(60 / (p.z+0.001), 1, 4);
      ctx.globalAlpha = clamp(d.life, 0, 1) * 0.7;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function render(){
    // background
    ctx.fillStyle = "#05070c";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    drawGround();
    drawBlocks();
    drawCannon();
    drawShells();
    drawDebris();
  }

  // ---------------- touch controls ----------------
  const pointers = new Map();
  let lastPinchDist = 0;
  let lastDragX = 0, lastDragY = 0;

  function getDist(a,b){
    const dx = a.x-b.x, dy = a.y-b.y;
    return Math.hypot(dx,dy);
  }

  canvas.addEventListener("pointerdown", (e)=>{
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });
    if (pointers.size === 1){
      lastDragX = e.clientX; lastDragY = e.clientY;
    }
    if (pointers.size === 2){
      const [p1,p2] = [...pointers.values()];
      lastPinchDist = getDist(p1,p2);
    }
  });

  canvas.addEventListener("pointermove", (e)=>{
    if (!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

    if (pointers.size === 1){
      const dx = e.clientX - lastDragX;
      const dy = e.clientY - lastDragY;
      lastDragX = e.clientX; lastDragY = e.clientY;

      // tuned for phones
      dragYaw   += dx * 0.0055;
      dragPitch += dy * 0.0045;

      dragPitch = clamp(dragPitch, PITCH_MIN, PITCH_MAX);
    }
    else if (pointers.size === 2){
      const [p1,p2] = [...pointers.values()];
      const dist = getDist(p1,p2);
      const delta = dist - lastPinchDist;
      lastPinchDist = dist;

      // pinch affects distance
      pinchDelta += delta * 0.02;
      pinchDelta = clamp(pinchDelta, -10, 18);
    }
  });

  function endPointer(e){
    pointers.delete(e.pointerId);
    if (pointers.size < 2) lastPinchDist = 0;
  }
  canvas.addEventListener("pointerup", endPointer);
  canvas.addEventListener("pointercancel", endPointer);
  canvas.addEventListener("pointerout", endPointer);
  canvas.addEventListener("pointerleave", endPointer);

  // ---------------- UI ----------------
  const btnFire = document.getElementById("btnFire");
  const btnReset = document.getElementById("btnReset");
  const btnCam = document.getElementById("btnCam");
  const yawRange = document.getElementById("yawRange");
  const pitchRange = document.getElementById("pitchRange");
  const btnSoft = document.getElementById("btnSoft");
  const btnMed = document.getElementById("btnMed");
  const btnHard = document.getElementById("btnHard");
  const stats = document.getElementById("stats");

  btnFire.addEventListener("click", fire);

  btnReset.addEventListener("click", ()=>{
    shells.length = 0;
    debris.length = 0;
    lastShell = null;
    dragYaw = 0; dragPitch = 0; pinchDelta = 0;
    cannon.yaw = 0; cannon.pitch = 0;
    yawRange.value = "0";
    pitchRange.value = "0";
    buildWall(wallMode);
  });

  btnCam.addEventListener("click", () => {
    camMode = (camMode === "orbit") ? "chase" :
              (camMode === "chase") ? "cannon" : "orbit";

    const label = (camMode === "orbit") ? "Orbit" :
                  (camMode === "chase") ? "Chase" : "Cannon";

    btnCam.textContent = "Cam: " + label;

    // comfort reset
    pinchDelta = 0;
  });

  yawRange.addEventListener("input", ()=>{
    cannon.yaw = rad(parseFloat(yawRange.value));
  });

  pitchRange.addEventListener("input", ()=>{
    cannon.pitch = rad(parseFloat(pitchRange.value));
  });

  btnSoft.addEventListener("click", ()=> buildWall("soft"));
  btnMed.addEventListener("click", ()=> buildWall("med"));
  btnHard.addEventListener("click", ()=> buildWall("hard"));

  // ---------------- main loop ----------------
  let lastT = performance.now();

  function tick(t){
    const dt = clamp((t - lastT) / 1000, 0, 0.033);
    lastT = t;

    getCamera();
    step(dt);
    render();

    // stats
    const aliveBlocks = blocks.reduce((n,b)=>n+(b.alive?1:0),0);
    const aliveShells = shells.reduce((n,s)=>n+(s.alive?1:0),0);
    stats.textContent = `Blocks: ${aliveBlocks} | Shells: ${aliveShells}`;

    requestAnimationFrame(tick);
  }

  // init
  buildWall("med");
  requestAnimationFrame(tick);

})();


// --- cannon_side_2d_v1.html ---

(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  function resize(){
    const dpr = Math.min(2, devicePixelRatio||1);
    canvas.width = innerWidth*dpr;
    canvas.height = innerHeight*dpr;
    canvas.style.width = innerWidth+"px";
    canvas.style.height = innerHeight+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  const PPM = 22;
  const G = 9.5;

  function groundY(){ return innerHeight * 0.82; }
  function cannonPos(){
    return { x: innerWidth * 0.12, y: groundY() - 24 };
  }

  let shells = [];
  let blocks = [];
  let debris = [];

  const PRE = {
    soft: { rows: 5, cols: 8,  w: 26, h: 18, gap: 4, hp: 1 },
    med:  { rows: 7, cols: 10, w: 24, h: 18, gap: 4, hp: 2 },
    hard: { rows: 9, cols: 12, w: 22, h: 16, gap: 3, hp: 3 },
  };
  let wallMode = "med";

  function buildWall(mode="med"){
    wallMode = mode;
    blocks.length = 0;

    const P = PRE[mode];
    const startX = innerWidth * 0.62;
    const baseY = groundY();

    for(let r=0;r<P.rows;r++){
      for(let c=0;c<P.cols;c++){
        const x = startX + c*(P.w+P.gap);
        const y = baseY - (r+1)*(P.h+P.gap);
        blocks.push({ x, y, w:P.w, h:P.h, hp:P.hp, alive:true });
      }
    }
  }

  function spawnDebris(x,y,n=10){
    for(let i=0;i<n;i++){
      debris.push({
        x, y,
        vx:(Math.random()-0.5)*180,
        vy:-Math.random()*220,
        life: 0.6 + Math.random()*0.5
      });
    }
  }

  let aiming = false;
  let aimVec = { x:0, y:0 };
  const MAX_PULL = 140;
  const SPEED_GAIN = 0.22;

  function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
  function len2(x,y){ return Math.hypot(x,y); }

  function fireFromAim(){
    const C = cannonPos();
    const dx = aimVec.x;
    const dy = aimVec.y;

    const pull = clamp(len2(dx,dy), 0, MAX_PULL);
    if (pull < 6) return;

    const nx = dx / (pull||1);
    const ny = dy / (pull||1);

    const dirx = -nx;
    const diry = -ny;

    const speed = pull * SPEED_GAIN;
    const vx = dirx * speed * 60 / PPM;
    const vy = diry * speed * 60 / PPM;

    shells.push({
      x: C.x, y: C.y,
      vx, vy,
      r: 10,
      alive:true,
      t:0
    });
  }

  function circleRectHit(cx,cy,cr, rx,ry,rw,rh){
    const x = clamp(cx, rx, rx+rw);
    const y = clamp(cy, ry, ry+rh);
    const dx = cx-x, dy = cy-y;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  function step(dt){
    const gy = G;

    for(const s of shells){
      if(!s.alive) continue;
      s.t += dt;

      s.vy += gy * dt;
      s.x += (s.vx * PPM) * dt;
      s.y += (s.vy * PPM) * dt;

      if (s.y + s.r > groundY()){
        s.y = groundY()-s.r;
        s.vy *= -0.35;
        s.vx *= 0.7;
        if (Math.abs(s.vy) < 1.2) s.alive = false;
      }

      if (s.x < -200 || s.x > innerWidth+200 || s.t > 10){
        s.alive = false;
      }

      for(const b of blocks){
        if(!b.alive || !s.alive) continue;
        if (circleRectHit(s.x,s.y,s.r, b.x,b.y,b.w,b.h)){
          b.hp -= 1;
          spawnDebris(s.x,s.y, 8);

          s.vx *= 0.6;
          s.vy *= -0.25;

          if (b.hp <= 0){
            b.alive = false;
            spawnDebris(b.x+b.w/2, b.y+b.h/2, 14);
          }
        }
      }
    }

    for(const d of debris){
      d.life -= dt;
      d.vy += gy * 0.6 * dt * PPM;
      d.x += d.vx * dt;
      d.y += d.vy * dt;
    }
    debris = debris.filter(d => d.life > 0);

    if (shells.length > 30){
      shells = shells.filter(s => s.alive);
    }
  }

  function draw(){
    ctx.fillStyle = "#060912";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    ctx.strokeStyle = "rgba(140,180,255,0.14)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, groundY());
    ctx.lineTo(innerWidth, groundY());
    ctx.stroke();

    const C = cannonPos();
    ctx.save();
    ctx.strokeStyle = "rgba(200,230,255,0.5)";
    ctx.lineWidth = 2;

    ctx.strokeRect(C.x-16, C.y-10, 30, 20);

    let bx = 36, by = -6;
    if (aiming){
      const pull = clamp(len2(aimVec.x,aimVec.y), 0, MAX_PULL);
      const nx = aimVec.x/(pull||1), ny = aimVec.y/(pull||1);
      const dirx = -nx, diry = -ny;
      bx = dirx * 44;
      by = diry * 44;
    }
    ctx.beginPath();
    ctx.moveTo(C.x, C.y);
    ctx.lineTo(C.x + bx, C.y + by);
    ctx.stroke();
    ctx.restore();

    if (aiming){
      ctx.strokeStyle = "rgba(125,211,252,0.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(C.x, C.y);
      ctx.lineTo(C.x + aimVec.x, C.y + aimVec.y);
      ctx.stroke();

      const p = clamp(len2(aimVec.x,aimVec.y), 0, MAX_PULL);
      ctx.fillStyle = "rgba(125,211,252,0.18)";
      ctx.beginPath();
      ctx.arc(C.x, C.y, p, 0, Math.PI*2);
      ctx.fill();
    }

    const alive = blocks.filter(b=>b.alive);
    for(const b of alive){
      ctx.strokeStyle =
        (b.hp >= 3) ? "rgba(255,140,140,0.55)" :
        (b.hp === 2) ? "rgba(255,210,140,0.55)" :
                       "rgba(140,210,255,0.55)";
      ctx.lineWidth = 1.5;
      ctx.strokeRect(b.x,b.y,b.w,b.h);
    }

    for(const s of shells){
      if(!s.alive) continue;
      ctx.fillStyle = "rgba(160,220,255,0.92)";
      ctx.beginPath();
      ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
      ctx.fill();
    }

    for(const d of debris){
      ctx.globalAlpha = Math.max(0, Math.min(1, d.life)) * 0.7;
      ctx.fillStyle = "rgba(200,220,255,0.35)";
      ctx.beginPath();
      ctx.arc(d.x,d.y,2.2,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function pointerToAim(e){
    const C = cannonPos();
    const dx = e.clientX - C.x;
    const dy = e.clientY - C.y;
    const L = len2(dx,dy);
    const cl = Math.min(L, MAX_PULL);
    aimVec.x = dx * (cl/(L||1));
    aimVec.y = dy * (cl/(L||1));
  }

  canvas.addEventListener("pointerdown", (e)=>{
    canvas.setPointerCapture(e.pointerId);
    aiming = true;
    pointerToAim(e);
  });

  canvas.addEventListener("pointermove", (e)=>{
    if(!aiming) return;
    pointerToAim(e);
  });

  function release(){
    if(!aiming) return;
    aiming = false;
    fireFromAim();
    aimVec.x = 0; aimVec.y = 0;
  }
  canvas.addEventListener("pointerup", release);
  canvas.addEventListener("pointercancel", release);

  const stats = document.getElementById("stats");
  document.getElementById("btnReset").addEventListener("click", ()=>{
    shells.length = 0; debris.length = 0;
    buildWall(wallMode);
  });
  document.getElementById("btnSoft").addEventListener("click", ()=>buildWall("soft"));
  document.getElementById("btnMed").addEventListener("click", ()=>buildWall("med"));
  document.getElementById("btnHard").addEventListener("click", ()=>buildWall("hard"));

  let lastT = performance.now();
  function tick(t){
    const dt = Math.min(0.033, (t-lastT)/1000);
    lastT = t;

    step(dt);
    draw();

    const aliveBlocks = blocks.reduce((n,b)=>n+(b.alive?1:0),0);
    const aliveShells = shells.reduce((n,s)=>n+(s.alive?1:0),0);
    stats.textContent = `Blocks: ${aliveBlocks} | Shells: ${aliveShells}`;

    requestAnimationFrame(tick);
  }

  buildWall("med");
  requestAnimationFrame(tick);

})();


// --- qds_test_task_pack_v1.html ---

(() => {
  // ============================
  // QDS Test Task Pack v1
  // Offline localStorage runner
  // ============================

  const KEY = "QDS_TEST_PACK_V1";

  const TASKS = [
    "Confirm dataset source + version and record reference IDs.",
    "Define the exact hypothesis statement for this session.",
    "Write falsification thresholds (what would count as a fail).",
    "Run H‚ÇÄ-variance micro-fit with raw pasted data.",
    "Capture screenshot of fit + plot for record.",
    "If using galaxy data, confirm units + distance conventions.",
    "Record device + browser + performance notes.",
    "Export JSON log for archive."
  ];

  // ---- elements ----
  const checklistEl = document.getElementById("checklist");
  const progressTxt = document.getElementById("progressTxt");

  const sessionName = document.getElementById("sessionName");
  const dateStamp = document.getElementById("dateStamp");
  const device = document.getElementById("device");
  const datasetRef = document.getElementById("datasetRef");
  const metaStatus = document.getElementById("metaStatus");

  const csvBox = document.getElementById("csvBox");
  const fitOut = document.getElementById("fitOut");
  const fitHint = document.getElementById("fitHint");
  const plot = document.getElementById("plot");
  const pctx = plot.getContext("2d");

  const notes = document.getElementById("notes");
  const saveStatus = document.getElementById("saveStatus");

  // ---- state ----
  let state = loadState();

  // ---- init date guess ----
  if (!state.meta.dateStamp) {
    const d = new Date();
    const pad = n => String(n).padStart(2,"0");
    state.meta.dateStamp = `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    saveState();
  }

  // ---- build checklist UI ----
  function renderChecklist(){
    checklistEl.innerHTML = "";
    TASKS.forEach((t, i) => {
      const id = "task_" + i;
      const row = document.createElement("label");
      row.innerHTML = `
        <input type="checkbox" id="${id}">
        <span>${t}</span>
      `;
      checklistEl.appendChild(row);
      const cb = row.querySelector("input");
      cb.checked = !!state.tasks[i];
      cb.addEventListener("change", () => {
        state.tasks[i] = cb.checked;
        saveState();
        updateProgress();
      });
    });
    updateProgress();
  }

  function updateProgress(){
    const done = state.tasks.filter(Boolean).length;
    const pct = Math.round((done / TASKS.length) * 100);
    progressTxt.textContent = `${pct}% (${done}/${TASKS.length})`;
  }

  // ---- meta ----
  function renderMeta(){
    sessionName.value = state.meta.sessionName || "";
    dateStamp.value = state.meta.dateStamp || "";
    device.value = state.meta.device || "";
    datasetRef.value = state.meta.datasetRef || "";
  }

  document.getElementById("btnSaveMeta").addEventListener("click", () => {
    state.meta.sessionName = sessionName.value.trim();
    state.meta.dateStamp = dateStamp.value.trim();
    state.meta.device = device.value.trim();
    state.meta.datasetRef = datasetRef.value.trim();
    saveState();
    metaStatus.textContent = "Meta saved ‚úì";
    setTimeout(()=>metaStatus.textContent="", 900);
  });

  // ---- notes ----
  function renderNotes(){
    notes.value = state.notes || "";
  }
  document.getElementById("btnSaveNotes").addEventListener("click", () => {
    state.notes = notes.value;
    saveState();
    saveStatus.textContent = "Saved ‚úì";
    setTimeout(()=>saveStatus.textContent="", 900);
  });

  // ---- checklist buttons ----
  document.getElementById("btnAll").addEventListener("click", () => {
    state.tasks = TASKS.map(()=>true);
    saveState();
    renderChecklist();
  });
  document.getElementById("btnNone").addEventListener("click", () => {
    state.tasks = TASKS.map(()=>false);
    saveState();
    renderChecklist();
  });

  // ---- export ----
  document.getElementById("btnExport").addEventListener("click", () => {
    // ensure latest text inputs captured
    state.meta.sessionName = sessionName.value.trim();
    state.meta.dateStamp = dateStamp.value.trim();
    state.meta.device = device.value.trim();
    state.meta.datasetRef = datasetRef.value.trim();
    state.notes = notes.value;
    state.h0 = state.h0 || {};

    const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    const stamp = (state.meta.dateStamp || "date").replace(/[^0-9\-]/g,"");
    const name = (state.meta.sessionName || "QDS_TestPack").replace(/[^\w\-]+/g,"_");
    a.href = URL.createObjectURL(blob);
    a.download = `${name}_${stamp}_testpack.json`;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  });

  // ---- wipe ----
  document.getElementById("btnWipeAll").addEventListener("click", () => {
    localStorage.removeItem(KEY);
    state = defaultState();
    renderChecklist(); renderMeta(); renderNotes();
    fitOut.textContent = ""; fitHint.textContent = "";
    drawPlot([], null);
  });

  // ============================
  // H0 variance micro-fit
  // ============================

  const SAMPLE = `R,sigmaH_over_H
50,0.030
80,0.025
120,0.021
200,0.017
300,0.0145
450,0.0125
700,0.0108`;

  document.getElementById("btnLoadSample").addEventListener("click", () => {
    csvBox.value = SAMPLE;
  });

  document.getElementById("btnClearData").addEventListener("click", () => {
    csvBox.value = "";
    fitOut.textContent = "";
    fitHint.textContent = "";
    drawPlot([], null);
  });

  document.getElementById("btnFit").addEventListener("click", () => {
    const rows = parseCSV(csvBox.value);
    if (!rows.length){
      fitOut.textContent = "No valid data found.";
      fitHint.textContent = "";
      drawPlot([], null);
      return;
    }

    const R = rows.map(r => r.R).filter(n => n>0);
    const Y = rows.map(r => r.Y).filter(n => n>0);

    if (R.length < 2 || Y.length < 2){
      fitOut.textContent = "Need at least 2 positive data points.";
      fitHint.textContent = "";
      drawPlot(rows, null);
      return;
    }

    // Fit log(y) = log(A) - p log(R)
    const x = rows.map(r => Math.log(r.R));
    const y = rows.map(r => Math.log(r.Y));

    const fit = linReg(x, y);
    const slope = fit.m;             // slope = -p
    const intercept = fit.b;         // intercept = log(A)

    const p = -slope;
    const A = Math.exp(intercept);

    // simple R^2
    const r2 = fit.r2;

    state.h0 = {
      model: "sigmaH_over_H = A * R^-p",
      A, p, r2,
      n: rows.length,
      data: rows
    };
    saveState();

    fitOut.innerHTML =
      `<span class="good">Fit OK</span><br>` +
      `A ‚âà <b>${A.toFixed(5)}</b><br>` +
      `p ‚âà <b>${p.toFixed(4)}</b><br>` +
      `R¬≤ ‚âà <b>${r2.toFixed(3)}</b><br>` +
      `N = ${rows.length}`;

    fitHint.textContent =
      `Interpretation: lower p means a slower drop with scale R. ` +
      `Use this as a compact check before deeper, external analysis.`;

    drawPlot(rows, {A, p});
  });

  function parseCSV(txt){
    const out = [];
    const lines = (txt||"").split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    for (const line of lines){
      if (/^[A-Za-z]/.test(line)) continue; // skip header-ish
      const parts = line.split(/[,\t; ]+/).filter(Boolean);
      if (parts.length < 2) continue;
      const R = parseFloat(parts[0]);
      const Y = parseFloat(parts[1]);
      if (!isFinite(R) || !isFinite(Y)) continue;
      out.push({R, Y});
    }
    return out;
  }

  function linReg(x, y){
    const n = Math.min(x.length, y.length);
    let sx=0, sy=0, sxx=0, sxy=0;
    for (let i=0;i<n;i++){
      sx += x[i]; sy += y[i];
      sxx += x[i]*x[i];
      sxy += x[i]*y[i];
    }
    const denom = (n*sxx - sx*sx) || 1e-12;
    const m = (n*sxy - sx*sy) / denom;
    const b = (sy - m*sx) / n;

    // r^2
    let ssTot=0, ssRes=0;
    const yMean = sy/n;
    for (let i=0;i<n;i++){
      const yi = y[i];
      const yhat = m*x[i] + b;
      ssTot += (yi - yMean)**2;
      ssRes += (yi - yhat)**2;
    }
    const r2 = ssTot > 0 ? (1 - ssRes/ssTot) : 0;

    return {m,b,r2};
  }

  function drawPlot(rows, fit){
    // retina-safe resize
    const dpr = Math.min(2, window.devicePixelRatio||1);
    plot.width = Math.floor(plot.clientWidth * dpr);
    plot.height = Math.floor(plot.clientHeight * dpr);
    pctx.setTransform(dpr,0,0,dpr,0,0);

    const W = plot.clientWidth;
    const H = plot.clientHeight;
    pctx.clearRect(0,0,W,H);

    // background
    pctx.fillStyle = "rgba(255,255,255,0.02)";
    pctx.fillRect(0,0,W,H);

    // axes padding
    const padL=38, padR=10, padT=10, padB=28;
    const x0=padL, y0=H-padB, x1=W-padR, y1=padT;

    // grid
    pctx.strokeStyle = "rgba(140,180,255,0.08)";
    pctx.lineWidth = 1;
    for(let i=0;i<=4;i++){
      const gx = x0 + (x1-x0)*(i/4);
      pctx.beginPath(); pctx.moveTo(gx,y0); pctx.lineTo(gx,y1); pctx.stroke();
      const gy = y0 - (y0-y1)*(i/4);
      pctx.beginPath(); pctx.moveTo(x0,gy); pctx.lineTo(x1,gy); pctx.stroke();
    }

    if (!rows || !rows.length){
      // axes labels
      pctx.fillStyle = "rgba(200,220,255,0.5)";
      pctx.font = "11px system-ui";
      pctx.fillText("log R", x1-36, H-8);
      pctx.fillText("log œÉ(H)/H", 6, 14);
      return;
    }

    // log space bounds
    const xs = rows.map(r => Math.log(r.R));
    const ys = rows.map(r => Math.log(r.Y));
    let xmin=Math.min(...xs), xmax=Math.max(...xs);
    let ymin=Math.min(...ys), ymax=Math.max(...ys);
    if (xmax-xmin < 1e-6){ xmax=xmin+1; }
    if (ymax-ymin < 1e-6){ ymax=ymin+1; }

    const sx = v => x0 + (v-xmin)/(xmax-xmin) * (x1-x0);
    const sy = v => y0 - (v-ymin)/(ymax-ymin) * (y0-y1);

    // points
    pctx.fillStyle = "rgba(125,211,252,0.9)";
    for(let i=0;i<rows.length;i++){
      const px = sx(xs[i]);
      const py = sy(ys[i]);
      pctx.beginPath();
      pctx.arc(px,py,3.2,0,Math.PI*2);
      pctx.fill();
    }

    // fit line
    if (fit && isFinite(fit.A) && isFinite(fit.p)){
      // y = A R^-p -> log y = log A - p log R
      const a = Math.log(fit.A);
      const p = fit.p;

      const xA = xmin, xB = xmax;
      const yA = a - p*xA;
      const yB = a - p*xB;

      pctx.strokeStyle = "rgba(200,240,255,0.7)";
      pctx.lineWidth = 2;
      pctx.beginPath();
      pctx.moveTo(sx(xA), sy(yA));
      pctx.lineTo(sx(xB), sy(yB));
      pctx.stroke();
    }

    // labels
    pctx.fillStyle = "rgba(200,220,255,0.6)";
    pctx.font = "11px system-ui";
    pctx.fillText("log R", x1-36, H-8);
    pctx.fillText("log œÉ(H)/H", 6, 14);
  }

  // ---- storage ----
  function defaultState(){
    return {
      tasks: TASKS.map(()=>false),
      meta: {
        sessionName:"",
        dateStamp:"",
        device:"",
        datasetRef:""
      },
      notes:"",
      h0:null
    };
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(KEY);
      if (!raw) return defaultState();
      const obj = JSON.parse(raw);

      // soft-migrate
      if (!obj.tasks || obj.tasks.length !== TASKS.length){
        obj.tasks = TASKS.map((_,i)=>!!(obj.tasks && obj.tasks[i]));
      }
      obj.meta = obj.meta || {};
      obj.notes = obj.notes || "";
      return obj;
    }catch(e){
      return defaultState();
    }
  }

  function saveState(){
    localStorage.setItem(KEY, JSON.stringify(state));
  }

  // ---- initial render ----
  renderChecklist();
  renderMeta();
  renderNotes();

  // attempt to redraw plot if saved data exists
  if (state.h0 && state.h0.data){
    drawPlot(state.h0.data, {A:state.h0.A, p:state.h0.p});
    fitOut.innerHTML =
      `<span class="mut">Loaded saved fit</span><br>` +
      `A ‚âà <b>${(state.h0.A||0).toFixed(5)}</b><br>` +
      `p ‚âà <b>${(state.h0.p||0).toFixed(4)}</b><br>` +
      `R¬≤ ‚âà <b>${(state.h0.r2||0).toFixed(3)}</b><br>` +
      `N = ${state.h0.n||0}`;
  } else {
    drawPlot([], null);
  }

})();


// --- qds_test_task_pack_v1_1_pro.html ---

(() => {
  // ============================
  // QDS Test Task Pack v1.1 PRO
  // ============================

  const KEY = "QDS_TEST_PACK_V1_1_PRO";

  const TASKS = [
    "Confirm dataset source + version and record reference IDs.",
    "Define the exact hypothesis statement for this session.",
    "Write falsification thresholds (what would count as a fail).",
    "Run H‚ÇÄ-variance micro-fit with raw pasted data.",
    "Capture screenshot of fit + plot for record.",
    "If using galaxy data, confirm units + distance conventions.",
    "Record device + browser + performance notes.",
    "Export JSON log for archive."
  ];

  // ---- elements ----
  const checklistEl = document.getElementById("checklist");
  const progressTxt = document.getElementById("progressTxt");

  const sessionName = document.getElementById("sessionName");
  const dateStamp = document.getElementById("dateStamp");
  const device = document.getElementById("device");
  const browser = document.getElementById("browser");
  const datasetRef = document.getElementById("datasetRef");
  const metaStatus = document.getElementById("metaStatus");

  const csvBox = document.getElementById("csvBox");
  const fitOut = document.getElementById("fitOut");
  const fitHint = document.getElementById("fitHint");
  const plotH0 = document.getElementById("plotH0");
  const pctxH0 = plotH0.getContext("2d");
  const insH0 = document.getElementById("insH0");
  const insCountH0 = document.getElementById("insCountH0");

  const galBox = document.getElementById("galBox");
  const galOut = document.getElementById("galOut");
  const galHint = document.getElementById("galHint");
  const plotGal = document.getElementById("plotGal");
  const pctxGal = plotGal.getContext("2d");
  const insGal = document.getElementById("insGal");
  const insCountGal = document.getElementById("insCountGal");

  const notes = document.getElementById("notes");
  const saveStatus = document.getElementById("saveStatus");

  // ---- state ----
  let state = loadState();

  // ============================
  // Tabs
  // ============================
  document.querySelectorAll(".tabBtn").forEach(btn => {
    btn.addEventListener("click", () => {
      document.querySelectorAll(".tabBtn").forEach(b => b.classList.remove("active"));
      document.querySelectorAll(".tabPanel").forEach(p => p.classList.remove("active"));
      btn.classList.add("active");
      document.getElementById(btn.dataset.tab).classList.add("active");
    });
  });

  // ============================
  // Init date + auto detect
  // ============================
  const pad = n => String(n).padStart(2,"0");
  if (!state.meta.dateStamp){
    const d = new Date();
    state.meta.dateStamp = `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  }
  if (!state.meta.device){
    state.meta.device = navigator.platform || "Android";
  }
  if (!state.meta.browser){
    state.meta.browser = navigator.userAgent || "Browser";
  }
  saveState();

  // ============================
  // Checklist
  // ============================
  function renderChecklist(){
    checklistEl.innerHTML = "";
    TASKS.forEach((t, i) => {
      const row = document.createElement("label");
      row.innerHTML = `<input type="checkbox"><span>${t}</span>`;
      checklistEl.appendChild(row);
      const cb = row.querySelector("input");
      cb.checked = !!state.tasks[i];
      cb.addEventListener("change", () => {
        state.tasks[i] = cb.checked;
        saveState();
        updateProgress();
      });
    });
    updateProgress();
  }

  function updateProgress(){
    const done = state.tasks.filter(Boolean).length;
    const pct = Math.round((done / TASKS.length) * 100);
    progressTxt.textContent = `${pct}% (${done}/${TASKS.length})`;
  }

  document.getElementById("btnAll").addEventListener("click", () => {
    state.tasks = TASKS.map(()=>true);
    saveState(); renderChecklist();
  });
  document.getElementById("btnNone").addEventListener("click", () => {
    state.tasks = TASKS.map(()=>false);
    saveState(); renderChecklist();
  });

  // ============================
  // Meta
  // ============================
  function renderMeta(){
    sessionName.value = state.meta.sessionName || "";
    dateStamp.value = state.meta.dateStamp || "";
    device.value = state.meta.device || "";
    browser.value = state.meta.browser || "";
    datasetRef.value = state.meta.datasetRef || "";
  }

  document.getElementById("btnSaveMeta").addEventListener("click", () => {
    state.meta.sessionName = sessionName.value.trim();
    state.meta.dateStamp = dateStamp.value.trim();
    state.meta.device = device.value.trim();
    state.meta.browser = browser.value.trim();
    state.meta.datasetRef = datasetRef.value.trim();
    saveState();
    metaStatus.textContent = "Meta saved ‚úì";
    setTimeout(()=>metaStatus.textContent="", 900);
  });

  // ============================
  // Notes
  // ============================
  function renderNotes(){
    notes.value = state.notes || "";
  }
  document.getElementById("btnSaveNotes").addEventListener("click", () => {
    state.notes = notes.value;
    saveState();
    saveStatus.textContent = "Saved ‚úì";
    setTimeout(()=>saveStatus.textContent="", 900);
  });

  // ============================
  // Clipboard helpers
  // ============================
  async function pasteClipboardInto(textarea){
    try{
      if (!navigator.clipboard || !navigator.clipboard.readText){
        return false;
      }
      const t = await navigator.clipboard.readText();
      if (t && t.trim()){
        textarea.value = t.trim();
        return true;
      }
      return false;
    }catch(e){
      return false;
    }
  }

  document.getElementById("btnPasteClipH0").addEventListener("click", async () => {
    const ok = await pasteClipboardInto(csvBox);
    if (!ok) flashHint(fitOut, "Clipboard blocked/empty. Paste manually.");
    renderInspectorH0();
  });

  document.getElementById("btnPasteClipGal").addEventListener("click", async () => {
    const ok = await pasteClipboardInto(galBox);
    if (!ok) flashHint(galOut, "Clipboard blocked/empty. Paste manually.");
    renderInspectorGal();
  });

  function flashHint(el, msg){
    el.innerHTML = `<span class="warn">${escapeHtml(msg)}</span>`;
    setTimeout(()=>{ if(el.innerText.includes(msg)) el.innerHTML=""; }, 1200);
  }

  // ============================
  // Export
  // ============================
  document.getElementById("btnExport").addEventListener("click", () => {
    // capture latest inputs
    state.meta.sessionName = sessionName.value.trim();
    state.meta.dateStamp = dateStamp.value.trim();
    state.meta.device = device.value.trim();
    state.meta.browser = browser.value.trim();
    state.meta.datasetRef = datasetRef.value.trim();
    state.notes = notes.value;

    const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    const stamp = (state.meta.dateStamp || "date").replace(/[^0-9\-]/g,"");
    const name = (state.meta.sessionName || "QDS_TestPack_PRO").replace(/[^\w\-]+/g,"_");
    a.href = URL.createObjectURL(blob);
    a.download = `${name}_${stamp}_testpack.json`;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  });

  // ============================
  // Wipe
  // ============================
  document.getElementById("btnWipeAll").addEventListener("click", () => {
    localStorage.removeItem(KEY);
    state = defaultState();
    renderChecklist(); renderMeta(); renderNotes();
    fitOut.textContent=""; fitHint.textContent="";
    galOut.textContent=""; galHint.textContent="";
    drawPlotH0([], null);
    drawPlotGal([], null);
    renderInspectorH0();
    renderInspectorGal();
  });

  // ============================
  // H0 Micro-Fit
  // ============================
  const SAMPLE_H0 = `R,sigmaH_over_H
50,0.030
80,0.025
120,0.021
200,0.017
300,0.0145
450,0.0125
700,0.0108`;

  document.getElementById("btnLoadSample").addEventListener("click", () => {
    csvBox.value = SAMPLE_H0;
    renderInspectorH0();
  });

  document.getElementById("btnClearData").addEventListener("click", () => {
    csvBox.value = "";
    fitOut.textContent = "";
    fitHint.textContent = "";
    state.h0 = null;
    saveState();
    drawPlotH0([], null);
    renderInspectorH0();
  });

  csvBox.addEventListener("input", () => renderInspectorH0());

  document.getElementById("btnFit").addEventListener("click", () => {
    const parsed = parseFlexibleTable(csvBox.value);
    const rows = pickH0Rows(parsed);

    renderInspectorH0(parsed);

    if (rows.length < 2){
      fitOut.innerHTML = `<span class="bad">No valid data found.</span>`;
      fitHint.textContent = "";
      drawPlotH0(rows, null);
      state.h0 = null; saveState();
      return;
    }

    const x = rows.map(r => Math.log(r.R));
    const y = rows.map(r => Math.log(r.Y));

    const fit = linReg(x, y);
    const p = -fit.m;
    const A = Math.exp(fit.b);
    const r2 = fit.r2;

    state.h0 = { model:"sigmaH_over_H = A * R^-p", A, p, r2, n: rows.length, data: rows };
    saveState();

    fitOut.innerHTML =
      `<span class="good">Fit OK</span><br>` +
      `A ‚âà <b>${A.toFixed(5)}</b><br>` +
      `p ‚âà <b>${p.toFixed(4)}</b><br>` +
      `R¬≤ ‚âà <b>${r2.toFixed(3)}</b><br>` +
      `N = ${rows.length}`;

    fitHint.textContent =
      `Lower p means slower drop with scale R. Use this as a compact check before deeper external analysis.`;

    drawPlotH0(rows, {A, p});
  });

  function pickH0Rows(parsed){
    // Accept two-column numeric tables, header or no header.
    const rows = [];
    for (const r of parsed.rows){
      const nums = r.nums;
      if (nums.length >= 2){
        const R = nums[0], Y = nums[1];
        if (isFinite(R) && isFinite(Y) && R>0 && Y>0) rows.push({R, Y});
      }
    }
    return rows;
  }

  // ============================
  // Galaxy Micro-Check
  // ============================
  const SAMPLE_GAL = `r,v_obs,v_newt,v_qds
1,110,90,108
2,140,115,138
3,160,130,158
4,175,140,172
5,185,147,183
6,192,150,191`;

  document.getElementById("btnLoadGalSample").addEventListener("click", () => {
    galBox.value = SAMPLE_GAL;
    renderInspectorGal();
  });

  document.getElementById("btnGalClear").addEventListener("click", () => {
    galBox.value = "";
    galOut.textContent = "";
    galHint.textContent = "";
    state.gal = null;
    saveState();
    drawPlotGal([], null);
    renderInspectorGal();
  });

  galBox.addEventListener("input", () => renderInspectorGal());

  document.getElementById("btnGalAnalyse").addEventListener("click", () => {
    const parsed = parseFlexibleTable(galBox.value);
    renderInspectorGal(parsed);

    const rows = pickGalaxyRows(parsed);

    if (rows.length < 2){
      galOut.innerHTML = `<span class="bad">No valid galaxy rows.</span>`;
      galHint.textContent = `Try headers: r,v_obs,v_newt,v_qds or just numeric columns in that order.`;
      drawPlotGal(rows, null);
      state.gal = null; saveState();
      return;
    }

    const haveObs = rows.some(r => isFinite(r.v_obs));
    const haveNewt = rows.some(r => isFinite(r.v_newt));
    const haveQds  = rows.some(r => isFinite(r.v_qds));

    let rmsNewt = null, rmsQds = null;

    if (haveObs && haveNewt){
      rmsNewt = rmsPair(rows, "v_obs", "v_newt");
    }
    if (haveObs && haveQds){
      rmsQds = rmsPair(rows, "v_obs", "v_qds");
    }

    state.gal = {
      n: rows.length,
      haveObs, haveNewt, haveQds,
      rmsNewt, rmsQds,
      data: rows
    };
    saveState();

    let out = `<span class="good">Parsed OK</span><br>N = ${rows.length}<br>`;
    if (rmsNewt != null) out += `RMS(obs vs newt) ‚âà <b>${rmsNewt.toFixed(3)}</b><br>`;
    if (rmsQds  != null) out += `RMS(obs vs qds)  ‚âà <b>${rmsQds.toFixed(3)}</b><br>`;
    if (rmsNewt == null && rmsQds == null){
      out += `<span class="warn">Add v_newt and/or v_qds for RMS comparison.</span>`;
    }

    galOut.innerHTML = out;

    if (rmsNewt != null && rmsQds != null){
      const delta = rmsNewt - rmsQds;
      galHint.textContent =
        `If RMS(obs vs qds) is lower than Newtonian here, that supports the direction of your model on this quick check. ŒîRMS ‚âà ${delta.toFixed(3)}.`;
    } else {
      galHint.textContent =
        `This utility stays model-agnostic: you can paste any v_model columns you want and compare against v_obs.`;
    }

    drawPlotGal(rows, {haveObs, haveNewt, haveQds});
  });

  function pickGalaxyRows(parsed){
    const rows = [];

    // Attempt header mapping if present
    const header = (parsed.header || []).map(h => h.toLowerCase());
    const idx = (name) => header.indexOf(name);

    const i_r = idx("r");
    const i_vo = idx("v_obs");
    const i_vn = idx("v_newt");
    const i_vq = idx("v_qds");

    for (const r of parsed.rows){
      if (r.rawTokens.length === 0) continue;

      let rr=null, vo=null, vn=null, vq=null;

      if (header.length){
        const get = (i) => (i>=0 && i<r.rawTokens.length) ? parseFloatSafe(r.rawTokens[i]) : null;
        rr = get(i_r);
        vo = get(i_vo);
        vn = get(i_vn);
        vq = get(i_vq);
      }

      // Fallback to numeric order if no header or missing
      if (!isFinite(rr)){
        const nums = r.nums;
        if (nums.length >= 2){
          rr = nums[0];
          vo = nums[1];
          vn = nums.length >= 3 ? nums[2] : null;
          vq = nums.length >= 4 ? nums[3] : null;
        }
      }

      if (isFinite(rr) && rr>0){
        rows.push({
          r: rr,
          v_obs: isFinite(vo) ? vo : null,
          v_newt: isFinite(vn) ? vn : null,
          v_qds: isFinite(vq) ? vq : null
        });
      }
    }

    // sort by r
    rows.sort((a,b)=>a.r-b.r);
    return rows;
  }

  function rmsPair(rows, a, b){
    let s=0, n=0;
    for (const r of rows){
      const x = r[a], y = r[b];
      if (isFinite(x) && isFinite(y)){
        const d = x-y;
        s += d*d; n++;
      }
    }
    return n ? Math.sqrt(s/n) : null;
  }

  // ============================
  // Inspectors
  // ============================
  function renderInspectorH0(parsedOpt){
    const parsed = parsedOpt || parseFlexibleTable(csvBox.value);
    const max = 60;
    const lines = parsed.lines.slice(0, max);

    insH0.innerHTML = "";
    let okCount=0;

    lines.forEach((L) => {
      const nums = L.nums;
      const ok = (nums.length >= 2 && isFinite(nums[0]) && isFinite(nums[1]) && nums[0]>0 && nums[1]>0);
      if (ok) okCount++;

      const div = document.createElement("div");
      div.className = "line " + (ok ? "ok" : "bad");

      div.innerHTML =
        `<span class="pill ${ok ? "ok":"bad"}">${ok ? "OK":"ERR"}</span>` +
        `<span class="mono small">${escapeHtml(L.text)}</span>`;

      insH0.appendChild(div);
    });

    insCountH0.textContent = `OK ${okCount}/${lines.length}`;
  }

  function renderInspectorGal(parsedOpt){
    const parsed = parsedOpt || parseFlexibleTable(galBox.value);
    const max = 60;
    const lines = parsed.lines.slice(0, max);

    insGal.innerHTML = "";
    let okCount=0;

    lines.forEach((L) => {
      const nums = L.nums;
      const ok = (nums.length >= 2 && isFinite(nums[0]) && nums[0]>0);
      if (ok) okCount++;

      const div = document.createElement("div");
      div.className = "line " + (ok ? "ok" : "bad");
      div.innerHTML =
        `<span class="pill ${ok ? "ok":"bad"}">${ok ? "OK":"ERR"}</span>` +
        `<span class="mono small">${escapeHtml(L.text)}</span>`;
      insGal.appendChild(div);
    });

    insCountGal.textContent = `OK ${okCount}/${lines.length}`;
  }

  // ============================
  // Plots (simple, log/linear)
  // ============================
  function prepCanvas(canvas, ctx){
    const dpr = Math.min(2, devicePixelRatio||1);
    canvas.width = Math.floor(canvas.clientWidth*dpr);
    canvas.height = Math.floor(canvas.clientHeight*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function drawPlotH0(rows, fit){
    prepCanvas(plotH0, pctxH0);
    const W = plotH0.clientWidth, H = plotH0.clientHeight;
    pctxH0.clearRect(0,0,W,H);

    // bg
    pctxH0.fillStyle = "rgba(255,255,255,0.02)";
    pctxH0.fillRect(0,0,W,H);

    const padL=38, padR=10, padT=10, padB=28;
    const x0=padL, y0=H-padB, x1=W-padR, y1=padT;

    // grid
    pctxH0.strokeStyle = "rgba(140,180,255,0.08)";
    pctxH0.lineWidth = 1;
    for(let i=0;i<=4;i++){
      const gx = x0 + (x1-x0)*(i/4);
      pctxH0.beginPath(); pctxH0.moveTo(gx,y0); pctxH0.lineTo(gx,y1); pctxH0.stroke();
      const gy = y0 - (y0-y1)*(i/4);
      pctxH0.beginPath(); pctxH0.moveTo(x0,gy); pctxH0.lineTo(x1,gy); pctxH0.stroke();
    }

    if (!rows || rows.length === 0){
      pctxH0.fillStyle = "rgba(200,220,255,0.5)";
      pctxH0.font = "11px system-ui";
      pctxH0.fillText("log R", x1-36, H-8);
      pctxH0.fillText("log œÉ(H)/H", 6, 14);
      return;
    }

    const xs = rows.map(r => Math.log(r.R));
    const ys = rows.map(r => Math.log(r.Y));
    let xmin=Math.min(...xs), xmax=Math.max(...xs);
    let ymin=Math.min(...ys), ymax=Math.max(...ys);
    if (xmax-xmin < 1e-6){ xmax=xmin+1; }
    if (ymax-ymin < 1e-6){ ymax=ymin+1; }

    const sx = v => x0 + (v-xmin)/(xmax-xmin) * (x1-x0);
    const sy = v => y0 - (v-ymin)/(ymax-ymin) * (y0-y1);

    // points
    pctxH0.fillStyle = "rgba(125,211,252,0.9)";
    rows.forEach((r,i) => {
      const px = sx(xs[i]), py = sy(ys[i]);
      pctxH0.beginPath();
      pctxH0.arc(px,py,3.2,0,Math.PI*2);
      pctxH0.fill();
    });

    // fit line
    if (fit && isFinite(fit.A) && isFinite(fit.p)){
      const a = Math.log(fit.A), p = fit.p;
      const xA=xmin, xB=xmax;
      const yA=a - p*xA, yB=a - p*xB;

      pctxH0.strokeStyle = "rgba(200,240,255,0.7)";
      pctxH0.lineWidth = 2;
      pctxH0.beginPath();
      pctxH0.moveTo(sx(xA), sy(yA));
      pctxH0.lineTo(sx(xB), sy(yB));
      pctxH0.stroke();
    }

    pctxH0.fillStyle = "rgba(200,220,255,0.6)";
    pctxH0.font = "11px system-ui";
    pctxH0.fillText("log R", x1-36, H-8);
    pctxH0.fillText("log œÉ(H)/H", 6, 14);
  }

  function drawPlotGal(rows, flags){
    prepCanvas(plotGal, pctxGal);
    const W = plotGal.clientWidth, H = plotGal.clientHeight;
    pctxGal.clearRect(0,0,W,H);

    pctxGal.fillStyle = "rgba(255,255,255,0.02)";
    pctxGal.fillRect(0,0,W,H);

    const padL=38, padR=10, padT=10, padB=28;
    const x0=padL, y0=H-padB, x1=W-padR, y1=padT;

    // grid
    pctxGal.strokeStyle = "rgba(140,180,255,0.08)";
    pctxGal.lineWidth = 1;
    for(let i=0;i<=4;i++){
      const gx = x0 + (x1-x0)*(i/4);
      pctxGal.beginPath(); pctxGal.moveTo(gx,y0); pctxGal.lineTo(gx,y1); pctxGal.stroke();
      const gy = y0 - (y0-y1)*(i/4);
      pctxGal.beginPath(); pctxGal.moveTo(x0,gy); pctxGal.lineTo(x1,gy); pctxGal.stroke();
    }

    if (!rows || rows.length === 0){
      pctxGal.fillStyle = "rgba(200,220,255,0.5)";
      pctxGal.font = "11px system-ui";
      pctxGal.fillText("r", x1-10, H-8);
      pctxGal.fillText("v", 8, 14);
      return;
    }

    const rs = rows.map(r => r.r);
    const vsAll = [];
    rows.forEach(r => {
      if (isFinite(r.v_obs)) vsAll.push(r.v_obs);
      if (isFinite(r.v_newt)) vsAll.push(r.v_newt);
      if (isFinite(r.v_qds)) vsAll.push(r.v_qds);
    });

    let rmin=Math.min(...rs), rmax=Math.max(...rs);
    let vmin=Math.min(...vsAll), vmax=Math.max(...vsAll);
    if (rmax-rmin < 1e-6){ rmax=rmin+1; }
    if (vmax-vmin < 1e-6){ vmax=vmin+1; }

    const sx = v => x0 + (v-rmin)/(rmax-rmin) * (x1-x0);
    const sy = v => y0 - (v-vmin)/(vmax-vmin) * (y0-y1);

    function drawSeries(key, stroke, fill){
      const pts = rows.filter(r => isFinite(r[key]));
      if (pts.length < 2) return;

      pctxGal.strokeStyle = stroke;
      pctxGal.lineWidth = 2;
      pctxGal.beginPath();
      pts.forEach((r,i) => {
        const px = sx(r.r), py = sy(r[key]);
        if (i===0) pctxGal.moveTo(px,py); else pctxGal.lineTo(px,py);
      });
      pctxGal.stroke();

      pctxGal.fillStyle = fill;
      pts.forEach(r => {
        const px = sx(r.r), py = sy(r[key]);
        pctxGal.beginPath();
        pctxGal.arc(px,py,2.8,0,Math.PI*2);
        pctxGal.fill();
      });
    }

    // keep colours subtle and readable
    drawSeries("v_obs",  "rgba(200,240,255,0.7)", "rgba(200,240,255,0.9)");
    drawSeries("v_newt", "rgba(255,210,140,0.6)", "rgba(255,210,140,0.85)");
    drawSeries("v_qds",  "rgba(155,255,177,0.6)", "rgba(155,255,177,0.9)");

    pctxGal.fillStyle = "rgba(200,220,255,0.6)";
    pctxGal.font = "11px system-ui";
    pctxGal.fillText("r", x1-10, H-8);
    pctxGal.fillText("v", 8, 14);
  }

  // ============================
  // Flexible parser
  // ============================
  function parseFlexibleTable(txt){
    const linesRaw = (txt||"").split(/\r?\n/);
    const lines = [];
    const rows = [];

    let header = null;

    for (const raw of linesRaw){
      const text = raw.trim();
      if (!text) continue;

      // Tokenize by commas, tabs, semicolons, or multiple spaces
      const toks = text.split(/[\t,;]+|\s{2,}/).map(t => t.trim()).filter(Boolean);

      // If still single token with spaces, split by single spaces
      const tokens = (toks.length<=1) ? text.split(/\s+/).filter(Boolean) : toks;

      const nums = tokens.map(parseFloatSafe).filter(n => isFinite(n));

      lines.push({ text, rawTokens: tokens, nums });

      // header heuristic: first non-numeric-ish line with letters
      if (!header){
        const hasLetter = /[A-Za-z_]/.test(text);
        const hasNum = /\d/.test(text);
        if (hasLetter && !(!hasLetter && hasNum)){
          // keep as header candidates
          const headerTokens = text.split(/[\t,; ]+/).map(t=>t.trim()).filter(Boolean);
          // Avoid treating pure numeric lines as header
          const headerNums = headerTokens.map(parseFloatSafe).filter(n=>isFinite(n));
          if (headerNums.length < Math.max(1, headerTokens.length/2)){
            header = headerTokens;
            continue;
          }
        }
      }

      rows.push({ rawTokens: tokens, nums });
    }

    return { header, lines, rows };
  }

  function parseFloatSafe(s){
    if (s == null) return NaN;
    // Strip non-numeric trailing junk (lightly)
    const t = String(s).replace(/[^0-9eE\.\+\-]/g,"");
    const n = parseFloat(t);
    return n;
  }

  // ============================
  // Regression
  // ============================
  function linReg(x, y){
    const n = Math.min(x.length, y.length);
    let sx=0, sy=0, sxx=0, sxy=0;
    for (let i=0;i<n;i++){
      sx += x[i]; sy += y[i];
      sxx += x[i]*x[i];
      sxy += x[i]*y[i];
    }
    const denom = (n*sxx - sx*sx) || 1e-12;
    const m = (n*sxy - sx*sy) / denom;
    const b = (sy - m*sx) / n;

    let ssTot=0, ssRes=0;
    const yMean = sy/n;
    for (let i=0;i<n;i++){
      const yi = y[i];
      const yhat = m*x[i] + b;
      ssTot += (yi - yMean)**2;
      ssRes += (yi - yhat)**2;
    }
    const r2 = ssTot > 0 ? (1 - ssRes/ssTot) : 0;

    return {m,b,r2};
  }

  // ============================
  // Utilities
  // ============================
  function escapeHtml(s){
    return String(s).replace(/[&<>"]/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"
    }[c]));
  }

  // ============================
  // Storage
  // ============================
  function defaultState(){
    return {
      tasks: TASKS.map(()=>false),
      meta: { sessionName:"", dateStamp:"", device:"", browser:"", datasetRef:"" },
      notes:"",
      h0:null,
      gal:null
    };
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(KEY);
      if (!raw) return defaultState();
      const obj = JSON.parse(raw);

      if (!obj.tasks || obj.tasks.length !== TASKS.length){
        obj.tasks = TASKS.map((_,i)=>!!(obj.tasks && obj.tasks[i]));
      }
      obj.meta = obj.meta || {};
      obj.notes = obj.notes || "";
      obj.h0 = obj.h0 || null;
      obj.gal = obj.gal || null;
      return obj;
    }catch(e){
      return defaultState();
    }
  }

  function saveState(){
    localStorage.setItem(KEY, JSON.stringify(state));
  }

  // ============================
  // Initial render
  // ============================
  renderChecklist();
  renderMeta();
  renderNotes();

  // restore plots/inspectors
  renderInspectorH0();
  renderInspectorGal();

  if (state.h0 && state.h0.data){
    fitOut.innerHTML =
      `<span class="mut">Loaded saved fit</span><br>` +
      `A ‚âà <b>${(state.h0.A||0).toFixed(5)}</b><br>` +
      `p ‚âà <b>${(state.h0.p||0).toFixed(4)}</b><br>` +
      `R¬≤ ‚âà <b>${(state.h0.r2||0).toFixed(3)}</b><br>` +
      `N = ${state.h0.n||0}`;
    drawPlotH0(state.h0.data, {A:state.h0.A, p:state.h0.p});
  } else {
    drawPlotH0([], null);
  }

  if (state.gal && state.gal.data){
    galOut.innerHTML = `<span class="mut">Loaded saved galaxy check</span><br>N = ${state.gal.n||0}`;
    drawPlotGal(state.gal.data, {haveObs:state.gal.haveObs, haveNewt:state.gal.haveNewt, haveQds:state.gal.haveQds});
  } else {
    drawPlotGal([], null);
  }

})();


// --- qds_5_pillars_hub.html ---

  const pillarLinks = Array.from(document.querySelectorAll('.pillar'))
    .map(a => a.getAttribute('href'))
    .filter(h => h && h !== '#');

  document.getElementById('openAll').addEventListener('click', (e) => {
    e.preventDefault();
    // Mobile pop-up rules vary. This attempts to open all in new tabs from a single user gesture.
    pillarLinks.forEach((href, i) => {
      setTimeout(() => window.open(href, '_blank'), i * 120);
    });
  });


// --- qds_chips_noise_v1.html ---

const rho=document.getElementById("rho"),rhoV=document.getElementById("rhoV"),out=document.getElementById("out");
rho.oninput=()=>rhoV.textContent=Number(rho.value).toFixed(2);
document.getElementById("run").onclick=()=>{
  const r=Number(rho.value);
  const stability=(100*(1-0.55*r)).toFixed(1);
  out.innerHTML="Toy result: correlated jitter model suggests ~<b>"+stability+
    "%</b> relative stability margin (illustrative only).";
};


// --- qds_compression_lab_v1.html ---

function gen(n){
  let x=0, arr=[];
  for(let i=0;i<n;i++){ x=0.7*x+(Math.random()-0.5); arr.push(x); }
  return arr;
}
function sizeEstimate(arr){ return arr.length; }
document.getElementById("run").onclick=()=>{
  const raw=gen(2000);
  const naive=raw.filter((_,i)=>i%2==0);
  const kernel=raw.filter((v,i)=>Math.abs(v)<0.35 || i%3==0);
  const r=sizeEstimate(raw), n=sizeEstimate(naive), k=sizeEstimate(kernel);
  document.getElementById("out").innerHTML=
    "Raw points: <b>"+r+"</b><br>"+
    "Naive thin: <b>"+n+"</b> (~"+(100*n/r).toFixed(1)+"%)<br>"+
    "Kernel-ish thin: <b>"+k+"</b> (~"+(100*k/r).toFixed(1)+"%)<br>"+
    "<small>Illustrative only - shows the idea of coherence-aware pruning.</small>";
};


// --- qds_sensors_metrology_v1.html ---

const rho=document.getElementById("rho"),rhoV=document.getElementById("rhoV"),out=document.getElementById("out");
rho.oninput=()=>rhoV.textContent=Number(rho.value).toFixed(2);
document.getElementById("run").onclick=()=>{
  const r=Number(rho.value);
  const gain=(1/(1+3*r)).toFixed(2);
  out.innerHTML="Toy averaging gain factor ~ <b>"+gain+
    "x</b> under correlated noise (illustrative).<br><small>LifeFirst: modelling only.</small>";
};


// --- qds_5_pillars_hub_v1.html ---

  const PILLARS = [
    "qds_battery_os_index_v1.html",
    "qds_chips_noise_v1.html",
    "qds_compression_lab_v1.html",
    "qds_sensors_metrology_v1.html",
    "qds_test_task_pack_v1.html"
  ];

  document.getElementById("openAll").addEventListener("click", () => {
    // Slight stagger reduces mobile popup-block rage.
    PILLARS.forEach((p, i) => setTimeout(() => window.open(p, "_blank"), i * 120));
  });


// --- pyramid_pinball_v1.html ---

(function () {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const W = canvas.width;
  const H = canvas.height;

  // Playfield bounds (inner walls)
  const marginX = 55;    // side wall x-offset
  const topY = 80;       // top wall
  const bottomY = 540;   // drain line (above UI)
  const pyramidY = 420;

  const ball = {
    x: W - marginX - 12,
    y: bottomY - 18,
    vx: 0,
    vy: 0,
    r: 9,
    active: false,
  };

  let score = 0;
  let ballIndex = 1;
  let lives = 3;

  const flippers = {
    left:  { x1: marginX + 45, y1: bottomY - 15, width: 70, height: 10, active: false },
    right: { x1: W - marginX - 45 - 70, y1: bottomY - 15, width: 70, height: 10, active: false },
  };

  const bumpers = [
    { x: W * 0.5, y: topY + 80, r: 14, score: 150 },
    { x: W * 0.35, y: topY + 130, r: 12, score: 100 },
    { x: W * 0.65, y: topY + 130, r: 12, score: 100 },
    { x: W * 0.25, y: topY + 190, r: 10, score: 75 },
    { x: W * 0.75, y: topY + 190, r: 10, score: 75 },
  ];

  // Controls state
  let leftHeld = false;
  let rightHeld = false;
  let plunging = false;
  let plungeStartTime = 0;

  // Physics
  const gravity = 900;      // px/s^2
  const bounceWall = 0.88;
  const bounceBumper = 0.95;
  const maxSpeed = 1400;

  let lastTime = performance.now();
  let fpsAccum = 0;
  let fpsFrames = 0;
  let fps = 0;

  const scoreEl = document.getElementById("scoreEl");
  const ballEl = document.getElementById("ballEl");
  const lifeEl = document.getElementById("lifeEl");
  const fpsEl = document.getElementById("fpsEl");

  function resetBall(hardReset=false) {
    ball.x = W - marginX - 12;
    ball.y = bottomY - 18;
    ball.vx = 0;
    ball.vy = 0;
    ball.active = false;

    if (hardReset) {
      lives--;
      if (lives <= 0) {
        lives = 0;
        updateHUD();
        setTimeout(() => {
          alert("Game over, old chap.\nTap New Game to try again.");
        }, 50);
        return;
      } else {
        ballIndex++;
      }
    }
    updateHUD();
  }

  function updateHUD() {
    scoreEl.textContent = score;
    ballEl.textContent = ballIndex;
    lifeEl.textContent = lives;
  }

  function clamp(v, min, max) {
    return v < min ? min : v > max ? max : v;
  }

  function handleWallCollisions(dt) {
    const r = ball.r;
    // Side walls
    if (ball.x - r < marginX) {
      ball.x = marginX + r;
      ball.vx = Math.abs(ball.vx) * bounceWall;
    } else if (ball.x + r > W - marginX) {
      ball.x = W - marginX - r;
      ball.vx = -Math.abs(ball.vx) * bounceWall;
    }
    // Top wall
    if (ball.y - r < topY) {
      ball.y = topY + r;
      ball.vy = Math.abs(ball.vy) * bounceWall;
    }
    // Drain zone (no bounce, lose ball)
    if (ball.y - r > bottomY + 30) {
      resetBall(true);
    }

    // Absolute escape guard (just in case numerical nonsense)
    if (
      ball.x < -100 || ball.x > W + 100 ||
      ball.y < -150 || ball.y > H + 200
    ) {
      resetBall(true);
    }
  }

  function rectHit(fl, r) {
    // Simple AABB collision
    const closestX = clamp(ball.x, fl.x1, fl.x1 + fl.width);
    const closestY = clamp(ball.y, fl.y1, fl.y1 + fl.height);
    const dx = ball.x - closestX;
    const dy = ball.y - closestY;
    return (dx * dx + dy * dy) < r * r;
  }

  function handleFlippers(dt) {
    const r = ball.r;

    // Left flipper gives leftwards & upwards impulse
    if (flippers.left.active && rectHit(flippers.left, r)) {
      ball.vy = -Math.abs(ball.vy) - 550;
      ball.vx = -260;
    }

    // Right flipper gives rightwards & upwards impulse
    if (flippers.right.active && rectHit(flippers.right, r)) {
      ball.vy = -Math.abs(ball.vy) - 550;
      ball.vx = 260;
    }
  }

  function handleBumpers() {
    for (const b of bumpers) {
      const dx = ball.x - b.x;
      const dy = ball.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = ball.r + b.r;
      if (dist < minDist && dist > 0.0001) {
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;
        ball.x += nx * overlap;
        ball.y += ny * overlap;

        const vDotN = ball.vx * nx + ball.vy * ny;
        ball.vx -= 2 * vDotN * nx;
        ball.vy -= 2 * vDotN * ny;
        ball.vx *= bounceBumper;
        ball.vy *= bounceBumper;

        score += b.score;
        updateHUD();
      }
    }
  }

  function physicsStep(dt) {
    if (!ball.active) return;

    ball.vy += gravity * dt;

    // Integrate
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // Clamp speeds
    const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
    if (speed > maxSpeed) {
      const s = maxSpeed / (speed || 1);
      ball.vx *= s;
      ball.vy *= s;
    }

    handleWallCollisions(dt);
    handleFlippers(dt);
    handleBumpers();
  }

  function drawField() {
    ctx.clearRect(0, 0, W, H);

    // Outer glow
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, "rgba(255,216,107,0.08)");
    grad.addColorStop(0.5, "rgba(255,216,107,0.02)");
    grad.addColorStop(1, "rgba(255,216,107,0.08)");
    ctx.fillStyle = grad;
    ctx.fillRect(marginX - 10, topY - 10, W - 2 * (marginX - 10), bottomY - topY + 40);

    // Playfield outline (simple coffin / pyramid-ish shape)
    ctx.strokeStyle = "rgba(255,216,107,0.78)";
    ctx.lineWidth = 3;

    ctx.beginPath();
    ctx.moveTo(marginX, bottomY);
    ctx.lineTo(marginX, topY + 80);
    ctx.lineTo(W / 2, topY);
    ctx.lineTo(W - marginX, topY + 80);
    ctx.lineTo(W - marginX, bottomY);
    ctx.stroke();

    // Drain line
    ctx.beginPath();
    ctx.moveTo(marginX, bottomY);
    ctx.lineTo(W - marginX, bottomY);
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = "rgba(255,216,107,0.35)";
    ctx.stroke();
    ctx.globalAlpha = 1.0;

    // Pyramid at center
    ctx.beginPath();
    ctx.moveTo(W / 2, pyramidY - 32);
    ctx.lineTo(W / 2 - 40, pyramidY + 26);
    ctx.lineTo(W / 2 + 40, pyramidY + 26);
    ctx.closePath();
    ctx.strokeStyle = "rgba(255,216,107,0.5)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawBumpers() {
    for (const b of bumpers) {
      const rOuter = b.r + 4;
      const rInner = b.r - 3;

      const g = ctx.createRadialGradient(b.x, b.y, rInner * 0.4, b.x, b.y, rOuter);
      g.addColorStop(0, "rgba(255, 248, 210, 1)");
      g.addColorStop(1, "rgba(255, 216, 107, 0.05)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(b.x, b.y, rOuter, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "rgba(255,216,107,0.8)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(b.x, b.y, rInner, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  function drawFlippers() {
    ctx.fillStyle = "rgba(255,216,107," + (flippers.left.active ? "0.95" : "0.7") + ")";
    const lf = flippers.left;
    ctx.beginPath();
    ctx.roundRect(lf.x1, lf.y1, lf.width, lf.height, 6);
    ctx.fill();

    ctx.fillStyle = "rgba(255,216,107," + (flippers.right.active ? "0.95" : "0.7") + ")";
    const rf = flippers.right;
    ctx.beginPath();
    ctx.roundRect(rf.x1, rf.y1, rf.width, rf.height, 6);
    ctx.fill();
  }

  function drawBall() {
    const g = ctx.createRadialGradient(ball.x - 3, ball.y - 4, 1, ball.x, ball.y, ball.r + 2);
    g.addColorStop(0, "#fff6d4");
    g.addColorStop(1, "rgba(255,216,107,0.15)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fill();
  }

  function draw(dt) {
    drawField();
    drawBumpers();
    drawFlippers();
    drawBall();
  }

  function gameLoop(now) {
    const dt = Math.min((now - lastTime) / 1000, 0.03); // clamp big jumps
    lastTime = now;

    physicsStep(dt);
    draw(dt);

    // FPS calc
    fpsAccum += dt;
    fpsFrames++;
    if (fpsAccum >= 0.5) {
      fps = Math.round(fpsFrames / fpsAccum);
      fpsEl.textContent = fps;
      fpsAccum = 0;
      fpsFrames = 0;
    }

    requestAnimationFrame(gameLoop);
  }

  // ========= Controls =========

  function setBtnActive(el, active) {
    if (!el) return;
    if (active) el.classList.add("active");
    else el.classList.remove("active");
  }

  function handlePress(id, onDown, onUp) {
    const el = document.getElementById(id);
    const down = (e) => {
      e.preventDefault();
      onDown();
      setBtnActive(el, true);
    };
    const up = (e) => {
      e && e.preventDefault();
      onUp();
      setBtnActive(el, false);
    };
    el.addEventListener("pointerdown", down);
    el.addEventListener("pointerup", up);
    el.addEventListener("pointercancel", up);
    el.addEventListener("pointerleave", (e) => {
      if (e.pressure === 0) setBtnActive(el, false);
    });
  }

  handlePress("leftBtn",
    () => { leftHeld = true; flippers.left.active = true; },
    () => { leftHeld = false; flippers.left.active = false; }
  );

  handlePress("rightBtn",
    () => { rightHeld = true; flippers.right.active = true; },
    () => { rightHeld = false; flippers.right.active = false; }
  );

  handlePress("plungeBtn",
    () => {
      if (!ball.active) {
        plunging = true;
        plungeStartTime = performance.now();
      }
    },
    () => {
      if (plunging && !ball.active) {
        plunging = false;
        const holdMs = performance.now() - plungeStartTime;
        const power = clamp(holdMs / 900, 0.25, 1.0);
        ball.active = true;
        ball.vy = - (420 + 580 * power);
        ball.vx = -40 + 80 * Math.random(); // small random offset
      }
    }
  );

  document.getElementById("newGameBtn").addEventListener("click", () => {
    score = 0;
    lives = 3;
    ballIndex = 1;
    resetBall(false);
  });

  document.getElementById("helpBtn").addEventListener("click", () => {
    alert(
`Pyramid Pinball ‚Äî Shed Edition üé©

‚Ä¢ Hold the middle button to charge the plunge, release to shoot.
‚Ä¢ Tap / hold left & right buttons to flip.
‚Ä¢ Hit the glowing bumpers to earn points.
‚Ä¢ If the ball leaves the lower drain, you lose a life.
‚Ä¢ If it ever somehow escapes the pyramid, the escape-guard
  will safely reset it instead of letting it fly off-screen.

Pure toy, no real physics claims ‚Äî just vibes and gold.`
    );
  });

  // Start
  updateHUD();
  resetBall(false);
  requestAnimationFrame(gameLoop);
})();


// --- qds_showcase_index_v1.html ---

    (function(){
      const searchEl = document.getElementById("search");
      const categoryEl = document.getElementById("category");
      const toggleBtn = document.getElementById("collapseToggle");

      const sections = Array.from(document.querySelectorAll(".section"));
      const cards = Array.from(document.querySelectorAll(".card"));

      let collapsed = false;

      function normalize(s){
        return (s || "").toLowerCase().trim();
      }

      function applyFilters(){
        const q = normalize(searchEl.value);
        const cat = categoryEl.value;

        // Filter cards
        cards.forEach(card => {
          const c = card.getAttribute("data-category") || "";
          const tags = card.getAttribute("data-tags") || "";
          const text = (card.innerText || "") + " " + tags;

          const matchesCat = (cat === "all") || (c === cat);
          const matchesQ = !q || normalize(text).includes(q);

          card.classList.toggle("hidden", !(matchesCat && matchesQ));
        });

        // Hide sections that have no visible cards
        sections.forEach(sec => {
          const secCat = sec.getAttribute("data-section");
          const visibleInSec = cards.some(card =>
            !card.classList.contains("hidden") &&
            (card.getAttribute("data-category") === secCat)
          );

          // Special case: "space" section includes an Indus card that is also core.
          // We still treat it normally‚Äîif filtered away, section may hide.
          sec.classList.toggle("hidden", !visibleInSec && cat !== "all");
          if(cat === "all"){
            // When showing all, only hide a section if ALL its cards are hidden by search.
            const anyVisible = Array.from(sec.querySelectorAll(".card"))
              .some(c => !c.classList.contains("hidden"));
            sec.classList.toggle("hidden", !anyVisible);
          }
        });
      }

      function setCollapsed(state){
        collapsed = state;
        sections.forEach(sec => {
          const grid = sec.querySelector(".grid");
          if(!grid) return;
          grid.style.display = collapsed ? "none" : "grid";
        });
        toggleBtn.textContent = collapsed ? "Expand all" : "Collapse all";
      }

      searchEl.addEventListener("input", applyFilters);
      categoryEl.addEventListener("change", applyFilters);

      toggleBtn.addEventListener("click", () => {
        setCollapsed(!collapsed);
      });

      // Initial
      applyFilters();
      setCollapsed(false);
    })();
  

// --- qds_shed_index_v1.html ---

(function(){
  const searchEl = document.getElementById("search");
  const bucketEl = document.getElementById("bucket");
  const toggleBtn = document.getElementById("collapseToggle");

  const sections = Array.from(document.querySelectorAll(".section"));
  const cards = () => Array.from(document.querySelectorAll(".card"));

  let collapsed = false;

  function normalize(s){ return (s||"").toLowerCase().trim(); }

  function applyFilters(){
    const q = normalize(searchEl.value);
    const b = bucketEl.value;

    cards().forEach(card => {
      const bucket = card.getAttribute("data-bucket") || card.closest(".section")?.getAttribute("data-section") || "";
      const tags = card.getAttribute("data-tags") || "";
      const text = (card.innerText || "") + " " + tags;

      const matchesBucket = (b === "all") || (bucket === b);
      const matchesQ = !q || normalize(text).includes(q);

      card.classList.toggle("hidden", !(matchesBucket && matchesQ));
    });

    sections.forEach(sec => {
      const anyVisible = Array.from(sec.querySelectorAll(".card"))
        .some(c => !c.classList.contains("hidden"));
      sec.classList.toggle("hidden", !anyVisible);
    });
  }

  function setCollapsed(state){
    collapsed = state;
    sections.forEach(sec => {
      const grid = sec.querySelector(".grid");
      if(!grid) return;
      grid.style.display = collapsed ? "none" : "grid";
    });
    toggleBtn.textContent = collapsed ? "Expand all" : "Collapse all";
  }

  searchEl.addEventListener("input", applyFilters);
  bucketEl.addEventListener("change", applyFilters);
  toggleBtn.addEventListener("click", () => setCollapsed(!collapsed));

  applyFilters();
  setCollapsed(false);
})();


// --- qds_showcase_index_v1_1.html ---

    (function(){
      const searchEl = document.getElementById("search");
      const categoryEl = document.getElementById("category");
      const toggleBtn = document.getElementById("collapseToggle");

      const sections = Array.from(document.querySelectorAll(".section"));
      const cards = Array.from(document.querySelectorAll(".card"));

      let collapsed = false;

      function normalize(s){
        return (s || "").toLowerCase().trim();
      }

      function applyFilters(){
        const q = normalize(searchEl.value);
        const cat = categoryEl.value;

        cards.forEach(card => {
          const c = card.getAttribute("data-category") || "";
          const tags = card.getAttribute("data-tags") || "";
          const text = (card.innerText || "") + " " + tags;

          const matchesCat = (cat === "all") || (c === cat);
          const matchesQ = !q || normalize(text).includes(q);

          card.classList.toggle("hidden", !(matchesCat && matchesQ));
        });

        sections.forEach(sec => {
          const secCat = sec.getAttribute("data-section");
          const visibleInSec = cards.some(card =>
            !card.classList.contains("hidden") &&
            (card.getAttribute("data-category") === secCat)
          );

          sec.classList.toggle("hidden", !visibleInSec && cat !== "all");
          if(cat === "all"){
            const anyVisible = Array.from(sec.querySelectorAll(".card"))
              .some(c => !c.classList.contains("hidden"));
            sec.classList.toggle("hidden", !anyVisible);
          }
        });
      }

      function setCollapsed(state){
        collapsed = state;
        sections.forEach(sec => {
          const grid = sec.querySelector(".grid");
          if(!grid) return;
          grid.style.display = collapsed ? "none" : "grid";
        });
        toggleBtn.textContent = collapsed ? "Expand all" : "Collapse all";
      }

      searchEl.addEventListener("input", applyFilters);
      categoryEl.addEventListener("change", applyFilters);

      toggleBtn.addEventListener("click", () => {
        setCollapsed(!collapsed);
      });

      applyFilters();
      setCollapsed(false);
    })();
  

// --- ddmelts_microsite_v1_1.html ---

    // Smooth scroll helper
    function scrollToId(id){
      const el = document.getElementById(id);
      if(!el) return;
      el.scrollIntoView({behavior:"smooth", block:"start"});
    }

    // Order message builder
    function buildMessage(){
      const name = (document.getElementById("custName").value || "").trim();
      const delivery = document.getElementById("delivery").value;
      const product = document.getElementById("product").value;
      const qty = document.getElementById("qty").value || "1";
      const scent = (document.getElementById("scent").value || "").trim();
      const budget = (document.getElementById("budget").value || "").trim();
      const notes = (document.getElementById("notes").value || "").trim();

      const lines = [];
      lines.push("Hi Denny‚Äôs Delights üíó");
      lines.push("");
      lines.push("I‚Äôd love to place an order / enquire:");
      lines.push(`‚Ä¢ Name: ${name || "‚Äî"}`);
      lines.push(`‚Ä¢ Product: ${product}`);
      lines.push(`‚Ä¢ Quantity: ${qty}`);
      lines.push(`‚Ä¢ Delivery: ${delivery}`);
      if(scent)  lines.push(`‚Ä¢ Scent / vibe: ${scent}`);
      if(budget) lines.push(`‚Ä¢ Budget: ${budget}`);
      if(notes)  lines.push(`‚Ä¢ Notes: ${notes}`);
      lines.push("");
      lines.push("Thanks! ‚ú®");

      return lines.join("\n");
    }

    function generateMessage(){
      const msg = buildMessage();
      const box = document.getElementById("msgBox");
      box.textContent = msg;
    }

    async function copyMessage(){
      const box = document.getElementById("msgBox");
      const msg = (box.textContent || "").trim();
      if(!msg || msg.includes("will appear here")){
        generateMessage();
      }
      const finalMsg = (document.getElementById("msgBox").textContent || "").trim();
      try{
        await navigator.clipboard.writeText(finalMsg);
        document.getElementById("msgBox").textContent = finalMsg + "\n\n‚úÖ Copied to clipboard.";
      }catch(e){
        // Fallback: select text hint
        document.getElementById("msgBox").textContent = finalMsg + "\n\n‚ö†Ô∏è Clipboard blocked by browser. Long-press to select/copy.";
      }
    }

    function emailDraft(){
      // Placeholder email ‚Äî edit when you know the real one
      const BUSINESS_EMAIL = "your-email-here@example.com";
      const subject = encodeURIComponent("DDmelts order / enquiry");
      const body = encodeURIComponent(buildMessage());
      const href = `mailto:${BUSINESS_EMAIL}?subject=${subject}&body=${body}`;
      window.location.href = href;
    }
  

// --- ddmelts_microsite_v1_2_live_links.html ---

  // -------------------------------------------------------
  // DDmelts Microsite v1.2 config (easy edits)
  // -------------------------------------------------------
  const BRAND = {
    name: "DDmelts ‚Ä¢ Denny‚Äôs Delights",
    instagram: "https://instagram.com/dennysdelightswaxmelts",
    shop: "https://ddmelts.sumupstore.com",
    address: "16 Forge Road, Dursley, GL11 4GB"
  };

  // -------------------------------------------------------
  // Hearts generator (light + random)
  // -------------------------------------------------------
  (function makeHearts(){
    const wrap = document.getElementById("hearts");
    const count = 18; // subtle
    for(let i=0;i<count;i++){
      const h = document.createElement("div");
      h.className = "heart";
      const left = Math.random()*100;
      const delay = Math.random()*8;
      const dur = 10 + Math.random()*14;
      const size = 10 + Math.random()*10;

      h.style.left = left + "vw";
      h.style.animationDelay = delay + "s";
      h.style.animationDuration = dur + "s";
      h.style.width = size + "px";
      h.style.height = size + "px";

      wrap.appendChild(h);
    }
  })();

  // -------------------------------------------------------
  // Order message builder
  // -------------------------------------------------------
  const $ = (id)=>document.getElementById(id);

  function buildMessage(){
    const name = $("custName").value.trim() || "Hi!";
    const delivery = $("delivery").value;
    const product = $("product").value;
    const qty = $("qty").value || "1";
    const vibe = $("vibe").value.trim() || "open to recommendations";
    const budget = $("budget").value.trim();
    const notes = $("notes").value.trim();

    let msg =
`Hi ${BRAND.name} üíó

Name: ${name}
Delivery: ${delivery}
Product: ${product}
Quantity: ${qty}
Scent / vibe: ${vibe}`;

    if(budget) msg += `\nBudget: ${budget}`;
    if(notes) msg += `\nNotes: ${notes}`;

    msg += `

Thanks! ‚ú®`;

    return msg;
  }

  $("genBtn").addEventListener("click", ()=>{
    $("outBox").textContent = buildMessage();
  });

  $("copyBtn").addEventListener("click", async ()=>{
    const msg = buildMessage();
    $("outBox").textContent = msg;
    try{
      await navigator.clipboard.writeText(msg);
      $("copyBtn").textContent = "‚úÖ Copied";
      setTimeout(()=> $("copyBtn").textContent = "üìã Copy message", 900);
    }catch(e){
      $("copyBtn").textContent = "Copy failed";
      setTimeout(()=> $("copyBtn").textContent = "üìã Copy message", 900);
    }
  });

  // keep IG button synced
  $("igBtn").setAttribute("href", BRAND.instagram);


// --- ddmelts_microsite_v1_2_pink_hearts.html ---

    // --- Message builder (simple + reliable) ---
    const $ = (id) => document.getElementById(id);

    function buildMessage(){
      const name = $("custName").value.trim() || "Hi";
      const delivery = $("delivery").value;
      const type = $("productType").value;
      const qty = Math.max(1, parseInt($("qty").value || "1", 10));
      const vibe = $("vibe").value.trim();
      const budget = $("budget").value.trim();
      const occasion = $("occasion").value.trim();
      const notes = $("notes").value.trim();

      const lines = [];
      lines.push(`Hi DDmelts üíó`);
      lines.push(`Name: ${name}`);
      lines.push(`Order type: ${type}`);
      lines.push(`Quantity: ${qty}`);
      lines.push(`Delivery: ${delivery}`);

      if(vibe) lines.push(`Scent / vibe: ${vibe}`);
      if(occasion) lines.push(`Occasion: ${occasion}`);
      if(budget) lines.push(`Budget: ${budget}`);
      if(notes) lines.push(`Notes: ${notes}`);

      lines.push(``);
      lines.push(`Thanks! ‚ú®`);

      return lines.join("\n");
    }

    $("genBtn").addEventListener("click", () => {
      $("outMsg").textContent = buildMessage();
    });

    $("copyBtn").addEventListener("click", async () => {
      const msg = $("outMsg").textContent.trim() || buildMessage();
      try{
        await navigator.clipboard.writeText(msg);
        $("outMsg").textContent = msg + "\n\n(‚úÖ Copied to clipboard)";
      }catch(e){
        $("outMsg").textContent = msg + "\n\n(‚ö†Ô∏è Copy blocked by browser ‚Äî long-press to select)";
      }
    });
  

// --- solar_system_v9_2_mobile_3d_showcase.html ---


// --- qds_solar_v6_textures.html ---



// Get canvas + engine
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

// Create scene
const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

    // Camera
    const camera = new BABYLON.ArcRotateCamera(
        "camera",
        Math.PI / 2,
        Math.PI / 2.5,
        80,
        new BABYLON.Vector3(0, 0, 0),
        scene
    );
    camera.attachControl(canvas, true);

    // Lighting
    const light = new BABYLON.HemisphericLight(
        "light",
        new BABYLON.Vector3(0, 1, 0),
        scene
    );
    light.intensity = 0.6;

    // REAL SUN LIGHT for shading planets
    const sunLight = new BABYLON.PointLight(
        "sunLight",
        new BABYLON.Vector3(0, 0, 0),
        scene
    );
    sunLight.intensity = 2.5;

    // Asset manager for loading textures
    const assets = new BABYLON.AssetsManager(scene);

    // Texture URLs
    const urls = {
        sun: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/sun.jpg",
        mercury: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/mercurymap.jpg",
        venus: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/venusmap.jpg",
        earth: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/earthmap1k.jpg",
        moon: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/moonmap1k.jpg",
        mars: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/marsmap1k.jpg",
        jupiter: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/jupiter.jpg",
        saturn: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/saturn.jpg",
        saturnRing: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/saturnringcolor.jpg",
        uranus: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/uranus.jpg",
        neptune: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/neptune.jpg",
        pluto: "https://raw.githubusercontent.com/erichlof/Planet-Textures/master/plutomap1k.jpg"
    };

    let textures = {};

    // Load all textures
    for (let key in urls) {
        const task = assets.addTextureTask(key, urls[key]);
        task.onSuccess = t => { textures[key] = t.texture; };
    }

    // After textures load, continue in PART 2
    assets.onFinish = function() {
        console.log("Textures loaded.");
        window.startSolarSystem(scene, textures);
    };

    assets.load();

    return scene;
};

const scene = createScene();
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());



// --- qds_universe_v9_2_neon_clear_planets.html ---


  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

  const PLANET_TEXT = {
    mercury: "Mercury ‚Äì fast, hot, and a bit crispy.",
    venus:   "Venus ‚Äì runaway greenhouse. Do not open windows.",
    earth:   "Earth ‚Äì liquid water, plate tectonics, questionable Wi‚ÄëFi.",
    mars:    "Mars ‚Äì dusty, cold, working on the whole 'habitable' thing.",
    jupiter: "Jupiter ‚Äì big lad. Moon hoarder. Storm enthusiast.",
    saturn:  "Saturn ‚Äì brings its own hula hoop collection.",
    uranus:  "Uranus ‚Äì tilted like it had a rough day.",
    neptune: "Neptune ‚Äì deep blue and very, very windy.",
    pluto:   "Pluto ‚Äì tiny, icy, emotionally still a planet."
  };

  const state = {
    qdsLambda: 1.4,
    qdsTau: 2.0,
    chaosOn: false,
    meltdown: false,
    rideTarget: "earth",
    rideOn: false,
    cmewaves: [],
    t: 0
  };

  function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

    const camera = new BABYLON.ArcRotateCamera("cam",
      -Math.PI / 2.2,
      Math.PI / 2.6,
      120,
      new BABYLON.Vector3(0, 8, 0),
      scene
    );
    camera.attachControl(canvas, true);
    camera.lowerRadiusLimit = 40;
    camera.upperRadiusLimit = 220;

    const light = new BABYLON.HemisphericLight("hemi",
      new BABYLON.Vector3(0, 1, 0),
      scene
    );
    light.intensity = 0.6;

    const sunLight = new BABYLON.PointLight("sunLight",
      new BABYLON.Vector3(0, 6, 0),
      scene
    );
    sunLight.intensity = 1.3;

    const glow = new BABYLON.GlowLayer("glow", scene);
    glow.intensity = 0.7;

    // QDS grid
    const grid = BABYLON.MeshBuilder.CreateGround("qdsGrid", {
      width: 420,
      height: 420,
      subdivisions: 140
    }, scene);
    grid.position.y = -6;

    const gridMat = new BABYLON.StandardMaterial("gridMat", scene);
    gridMat.wireframe = true;
    gridMat.diffuseColor = new BABYLON.Color3(0.05, 0.7, 0.9);
    gridMat.emissiveColor = new BABYLON.Color3(0.0, 0.4, 0.6);
    grid.material = gridMat;

    // Warp the grid
    const positions = grid.getVerticesData(BABYLON.VertexBuffer.PositionKind);

    scene.registerBeforeRender(() => {
      const t = state.t;
      const lambda = state.qdsLambda;
      const tau = state.qdsTau;
      const ampBase = state.meltdown ? 2.4 : 1.4;
      const amp = ampBase + (state.chaosOn ? 0.6 : 0.0);
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const z = positions[i + 2];
        const r = Math.sqrt(x*x + z*z);
        const wobble = Math.sin(r * 0.08 * lambda - t * 0.9 * tau);
        positions[i + 1] = wobble * amp;
      }
      grid.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
      grid.refreshBoundingInfo();

      state.cmewaves = state.cmewaves.filter(w => {
        w.radius += w.speed;
        w.mesh.scaling.setAll(w.radius);
        const fade = Math.max(0, 1.0 - w.radius / 260);
        w.material.emissiveColor = new BABYLON.Color3(1.0, 0.8 * fade, 0.2 * fade);
        if (w.radius > 260) {
          w.mesh.dispose();
          return false;
        }
        return true;
      });

      if (state.rideOn && planets[state.rideTarget]) {
        const target = planets[state.rideTarget].mesh;
        const pos = target.position;
        camera.target.copyFrom(pos);
        camera.alpha += 0.0015;
      }

      state.t += engine.getDeltaTime() * 0.001;
    });

    // Sun
    const sun = BABYLON.MeshBuilder.CreateSphere("sun", { diameter: 18, segments: 32 }, scene);
    sun.position.y = 6;

    const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
    sunMat.diffuseColor = new BABYLON.Color3(1.0, 0.95, 0.7);
    sunMat.emissiveColor = new BABYLON.Color3(1.4, 1.1, 0.4);
    sun.material = sunMat;

    const corona = BABYLON.MeshBuilder.CreateSphere("corona",
      { diameter: 30, segments: 32 },
      scene
    );
    const coronaMat = new BABYLON.StandardMaterial("coronaMat", scene);
    coronaMat.emissiveColor = new BABYLON.Color3(0.9, 0.95, 1.3);
    coronaMat.alpha = 0.25;
    corona.material = coronaMat;
    corona.position = sun.position.clone();

    // Planets: brighter + slightly larger
    function makePlanet(name, radius, distance, color, emissive, speed) {
      const planet = BABYLON.MeshBuilder.CreateSphere(name, {
        diameter: radius * 2.2,
        segments: 24
      }, scene);
      const mat = new BABYLON.StandardMaterial(name + "Mat", scene);
      mat.diffuseColor = color;
      mat.specularColor = new BABYLON.Color3(0.2,0.2,0.2);
      mat.emissiveColor = emissive;
      planet.material = mat;

      const halo = BABYLON.MeshBuilder.CreateSphere(name + "Halo", {
        diameter: radius * 3.3,
        segments: 24
      }, scene);
      const haloMat = new BABYLON.StandardMaterial(name + "HaloMat", scene);
      haloMat.emissiveColor = emissive.scale(1.4);
      haloMat.alpha = 0.16;
      halo.material = haloMat;

      planet.position.x = distance;
      planet.position.y = 4;
      halo.parent = planet;

      return { mesh: planet, speed, distance, angle: Math.random() * Math.PI * 2 };
    }

    window.planets = {
      mercury: makePlanet("mercury", 1.2, 26,
        new BABYLON.Color3(0.8, 0.7, 0.6),
        new BABYLON.Color3(0.9, 0.8, 0.7),
        0.024),
      venus: makePlanet("venus", 1.7, 34,
        new BABYLON.Color3(0.9, 0.8, 0.5),
        new BABYLON.Color3(1.0, 0.9, 0.6),
        0.018),
      earth: makePlanet("earth", 1.8, 42,
        new BABYLON.Color3(0.2, 0.4, 0.9),
        new BABYLON.Color3(0.3, 0.6, 1.2),
        0.015),
      mars: makePlanet("mars", 1.4, 50,
        new BABYLON.Color3(0.9, 0.3, 0.1),
        new BABYLON.Color3(1.0, 0.4, 0.2),
        0.013),
      jupiter: makePlanet("jupiter", 3.5, 64,
        new BABYLON.Color3(0.9, 0.8, 0.6),
        new BABYLON.Color3(1.1, 0.9, 0.7),
        0.010),
      saturn: makePlanet("saturn", 3.0, 80,
        new BABYLON.Color3(0.9, 0.8, 0.6),
        new BABYLON.Color3(1.0, 0.9, 0.7),
        0.008),
      uranus: makePlanet("uranus", 2.4, 96,
        new BABYLON.Color3(0.6, 0.9, 0.9),
        new BABYLON.Color3(0.6, 1.0, 1.2),
        0.006),
      neptune: makePlanet("neptune", 2.4, 112,
        new BABYLON.Color3(0.2, 0.3, 0.9),
        new BABYLON.Color3(0.3, 0.5, 1.2),
        0.005),
      pluto: makePlanet("pluto", 1.1, 130,
        new BABYLON.Color3(0.8, 0.8, 0.9),
        new BABYLON.Color3(0.9, 0.9, 1.2),
        0.004)
    };

    // Saturn ring
    const ring = BABYLON.MeshBuilder.CreateTorus("saturnRing", {
      diameter: 16,
      thickness: 0.4,
      tessellation: 80
    }, scene);
    const ringMat = new BABYLON.StandardMaterial("ringMat", scene);
    ringMat.emissiveColor = new BABYLON.Color3(1.0, 0.9, 0.7);
    ringMat.diffuseColor = new BABYLON.Color3(0.9, 0.8, 0.5);
    ring.material = ringMat;
    ring.rotation.x = Math.PI / 2;
    ring.parent = planets.saturn.mesh;

    // Orbit lines
    Object.values(planets).forEach(p => {
      const circle = BABYLON.MeshBuilder.CreateTorus("orbit_"+p.mesh.name, {
        diameter: p.distance * 2,
        thickness: 0.08,
        tessellation: 140
      }, scene);
      const om = new BABYLON.StandardMaterial("orbitMat_"+p.mesh.name, scene);
      om.emissiveColor = new BABYLON.Color3(0.3, 0.6, 1.0);
      om.alpha = 0.5;
      circle.material = om;
      circle.rotation.x = Math.PI / 2;
      circle.position.y = 4;
    });

    scene.onBeforeRenderObservable.add(() => {
      const dt = engine.getDeltaTime() * 0.001;
      Object.values(planets).forEach(p => {
        p.angle += p.speed * (state.chaosOn ? 1.5 : 1.0);
        const x = Math.cos(p.angle) * p.distance;
        const z = Math.sin(p.angle) * p.distance;
        p.mesh.position.x = x;
        p.mesh.position.z = z;
      });
    });

    // CME firing
    function fireCME(strength = 1.0) {
      const torus = BABYLON.MeshBuilder.CreateTorus("cmeRing", {
        diameter: 22,
        thickness: 0.8,
        tessellation: 90
      }, scene);
      const mat = new BABYLON.StandardMaterial("cmeMat", scene);
      mat.emissiveColor = new BABYLON.Color3(1.0, 0.9, 0.4);
      torus.material = mat;
      torus.position.y = 6;
      torus.rotation.x = Math.PI / 2;
      state.cmewaves.push({
        mesh: torus,
        material: mat,
        radius: 1,
        speed: 0.7 + strength * 0.4
      });
    }
    window.fireCME = fireCME;

    window.applyMode = function(mode) {
      if (mode === "normal") {
        state.chaosOn = false;
        state.meltdown = false;
        glow.intensity = 0.7;
        gridMat.emissiveColor = new BABYLON.Color3(0.0, 0.4, 0.6);
        sunMat.emissiveColor = new BABYLON.Color3(1.4, 1.1, 0.4);
      } else if (mode === "chaos") {
        state.chaosOn = !state.chaosOn;
      } else if (mode === "meltdown") {
        state.meltdown = !state.meltdown;
        glow.intensity = state.meltdown ? 1.0 : 0.7;
      }
    };

    window.setLambda = v => { state.qdsLambda = v; };
    window.setTau = v => { state.qdsTau = v; };
    window.getCamera = () => camera;

    return scene;
  }

  const scene = createScene();

  engine.runRenderLoop(() => {
    scene.render();
  });

  window.addEventListener("resize", () => {
    engine.resize();
  });

  // HUD wiring
  const lambdaSlider = document.getElementById("lambdaSlider");
  const tauSlider = document.getElementById("tauSlider");
  const lambdaVal = document.getElementById("lambdaVal");
  const tauVal = document.getElementById("tauVal");
  const planetSelect = document.getElementById("planetSelect");
  const planetInfo = document.getElementById("planetInfo");
  const statusBar = document.getElementById("statusBar");

  lambdaSlider.oninput = e => {
    const v = parseFloat(e.target.value);
    lambdaVal.textContent = v.toFixed(1);
    window.setLambda(v);
  };
  tauSlider.oninput = e => {
    const v = parseFloat(e.target.value);
    tauVal.textContent = v.toFixed(1);
    window.setTau(v);
  };

  document.getElementById("btnCME").onclick = () => {
    window.fireCME(1.0);
    statusBar.textContent = "Status: CME fired ‚Äì shock ring through QDS grid.";
  };
  document.getElementById("btnChaos").onclick = () => {
    window.applyMode("chaos");
    statusBar.textContent = "Status: MAX Chaos toggled ‚Äì jittery orbits and noisy grid.";
  };
  document.getElementById("btnNormal").onclick = () => {
    window.applyMode("normal");
    statusBar.textContent = "Status: Back to calmer QDS field.";
  };
  document.getElementById("btnMeltdown").onclick = () => {
    window.applyMode("meltdown");
    statusBar.textContent = "Status: QDS MELTDOWN ‚Äì grid amplitude cranked. Hold onto your hat.";
  };
  document.getElementById("btnRide").onclick = () => {
    const cam = window.getCamera();
    state.rideOn = !state.rideOn;
    if (!state.rideOn) {
      statusBar.textContent = "Status: Ride Along disengaged. Camera free.";
      return;
    }
    const targetKey = planetSelect.value === "none" ? "earth" : planetSelect.value;
    state.rideTarget = targetKey;
    statusBar.textContent = "Status: Riding along with " + targetKey.toUpperCase() + ".";
    if (planets[targetKey]) {
      cam.radius = 22;
      cam.beta = Math.PI / 2.4;
    }
  };

  planetSelect.onchange = e => {
    const key = e.target.value;
    if (key === "none") {
      planetInfo.textContent = "Planet info will appear here.";
      return;
    }
    planetInfo.textContent = PLANET_TEXT[key] || "";
    state.rideTarget = key;
  };

  document.getElementById("hudToggle").onclick = () => {
    const hud = document.getElementById("hud");
    if (hud.style.display === "none") {
      hud.style.display = "block";
    } else {
      hud.style.display = "none";
    }
  };


// --- qds_universe_v12b_mobile.html ---

(function(){
  const canvas = document.getElementById('qdsCanvas');
  const ctx = canvas.getContext('2d');

  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  });

  // Controls
  const lambdaSlider = document.getElementById('lambdaSlider');
  const tauSlider = document.getElementById('tauSlider');
  const lambdaVal = document.getElementById('lambdaVal');
  const tauVal = document.getElementById('tauVal');
  const planetSelect = document.getElementById('planetSelect');
  const planetInfo = document.getElementById('planetInfo');
  const statusEl = document.getElementById('status');
  const hudToggle = document.getElementById('hudToggle');
  const panel = document.getElementById('panel');

  let lambdaC = parseFloat(lambdaSlider.value);
  let tauC = parseFloat(tauSlider.value);
  let chaosLevel = 0;
  let rideAlong = false;
  let meltdown = false;
  let cmePulse = 0;

  lambdaSlider.addEventListener('input', () => {
    lambdaC = parseFloat(lambdaSlider.value);
    lambdaVal.textContent = lambdaC.toFixed(1);
    statusEl.textContent = 'Status: Grid bend tuned ‚Äì Œªc now ' + lambdaC.toFixed(1) + '.';
  });
  tauSlider.addEventListener('input', () => {
    tauC = parseFloat(tauSlider.value);
    tauVal.textContent = tauC.toFixed(1);
    statusEl.textContent = 'Status: Temporal hum adjusted ‚Äì œÑc now ' + tauC.toFixed(1) + '.';
  });

  document.getElementById('btnCME').addEventListener('click', () => {
    cmePulse = 1.0;
    statusEl.textContent = 'Status: CME fired ‚Äì expanding shock rings through the QDS grid.';
  });

  document.getElementById('btnChaos').addEventListener('click', () => {
    chaosLevel = chaosLevel > 0 ? 0 : 1;
    statusEl.textContent = chaosLevel > 0
      ? 'Status: MAX Chaos engaged ‚Äì jittery orbits and noisy grid.'
      : 'Status: Chaos damped ‚Äì grid settling back to a gentle hum.';
  });

  document.getElementById('btnNormal').addEventListener('click', () => {
    chaosLevel = 0;
    meltdown = false;
    rideAlong = false;
    statusEl.textContent = 'Status: Normal mode ‚Äì QDS grid humming softly.';
  });

  document.getElementById('btnRide').addEventListener('click', () => {
    rideAlong = !rideAlong;
    statusEl.textContent = rideAlong
      ? 'Status: Ride Along ‚Äì camera locked to ' + planetSelect.value + '.'
      : 'Status: Ride Along disengaged ‚Äì camera drifting freely.';
  });

  document.getElementById('btnMelt').addEventListener('click', () => {
    meltdown = !meltdown;
    chaosLevel = meltdown ? 1 : chaosLevel;
    statusEl.textContent = meltdown
      ? 'Status: QDS MELTDOWN ‚Äì stacked CMEs, max coherence, neon storm.'
      : 'Status: Meltdown cooling ‚Äì vacuum settling, still spicy.';
  });

  hudToggle.addEventListener('click', () => {
    panel.classList.toggle('hidden');
  });

  const planetMeta = {
    'Mercury': 'Small, fast, baked. Orbital racetrack specialist.',
    'Venus': 'Runaway greenhouse, atmospheric chaos expert.',
    'Earth': 'Home. Liquid water, plate tectonics, questionable Wi‚ÄëFi.',
    'Mars': 'Rusty, dusty, future QDS field lab.',
    'Jupiter': 'Gas giant, gravity bully, CME amplifier.',
    'Saturn': 'Rings, vibes, and subtle warp-field harmonics.',
    'Uranus': 'Sideways spinner, axial chaos demonstrator.',
    'Neptune': 'Deep blue, supersonic winds, distant hum.',
    'Pluto (respect!)': 'Tiny, icy, emotionally still a planet.'
  };

  function updatePlanetInfo() {
    const name = planetSelect.value;
    planetInfo.textContent = name + ' ‚Äì ' + (planetMeta[name] || '');
  }
  planetSelect.addEventListener('change', updatePlanetInfo);
  updatePlanetInfo();

  // World + camera
  const planets = [];
  function initPlanets() {
    const baseR = Math.min(width, height) * 0.035;
    const centerY = height * 0.63;
    planets.length = 0;
    planets.push({ name: 'Sun', r: baseR * 1.4, orbitR: 0, speed: 0, color: '#ffd86b' });
    planets.push({ name: 'Mercury', r: baseR * 0.35, orbitR: baseR * 2.0, speed: 0.018, color: '#ffddaa' });
    planets.push({ name: 'Venus', r: baseR * 0.5, orbitR: baseR * 3.0, speed: 0.013, color: '#ffcf8a' });
    planets.push({ name: 'Earth', r: baseR * 0.5, orbitR: baseR * 4.2, speed: 0.011, color: '#68c9ff' });
    planets.push({ name: 'Mars', r: baseR * 0.42, orbitR: baseR * 5.2, speed: 0.009, color: '#ff865e' });
    planets.push({ name: 'Jupiter', r: baseR * 0.9, orbitR: baseR * 7.8, speed: 0.006, color: '#f7d7b8' });
    planets.push({ name: 'Saturn', r: baseR * 0.8, orbitR: baseR * 9.4, speed: 0.0045, color: '#f5e3b5', ring: true });
    planets.push({ name: 'Uranus', r: baseR * 0.6, orbitR: baseR * 11.0, speed: 0.0035, color: '#a4f1ff' });
    planets.push({ name: 'Neptune', r: baseR * 0.6, orbitR: baseR * 12.6, speed: 0.003, color: '#5fb6ff' });
    planets.push({ name: 'Pluto (respect!)', r: baseR * 0.25, orbitR: baseR * 14.0, speed: 0.002, color: '#e0f0ff' });
  }
  initPlanets();

  let t = 0;
  let camera = {
    x: 0,
    y: height * 0.1,
    zoom: 1
  };

  const chaosOrbs = [];
  canvas.addEventListener('pointerdown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    chaosOrbs.push({
      x, y,
      vx: (Math.random() - 0.5) * 0.8,
      vy: -Math.random() * 1.2,
      life: 1.0,
      size: 6 + Math.random() * 10
    });
  });

  function worldToScreen(wx, wy) {
    const sx = (wx - camera.x) * camera.zoom + width / 2;
    const sy = (wy - camera.y) * camera.zoom + height * 0.55;
    return { x: sx, y: sy };
  }

  function drawGrid(time) {
    const rows = 22;
    const cols = 26;
    const gridWidth = Math.min(width * 1.6, 1600);
    const gridHeight = Math.min(height * 0.9, 900);
    const yBase = height * 0.6;

    const dx = gridWidth / cols;
    const dy = gridHeight / rows;
    const startX = -gridWidth / 2;
    const startY = yBase - gridHeight * 0.2;

    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(130, 230, 255, 0.7)';

    const warpAmp = 18 * lambdaC;
    const warpFreq = 0.7 + lambdaC * 0.3;
    const chaosJitter = chaosLevel > 0 ? 6 : 0;

    // Horizontal
    for (let j = 0; j <= rows; j++) {
      ctx.beginPath();
      for (let i = 0; i <= cols; i++) {
        const wx = startX + i * dx;
        let wy = startY + j * dy;
        const u = i / cols;
        const v = j / rows;
        wy += Math.sin(time * 0.7 + u * 4 * warpFreq) * warpAmp * (1 - v);
        wy += Math.cos(time * 0.5 + v * 6) * warpAmp * 0.25;
        if (chaosLevel > 0) {
          wy += (Math.random() - 0.5) * chaosJitter;
        }
        const { x, y } = worldToScreen(wx, wy);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    // Vertical
    for (let i = 0; i <= cols; i++) {
      ctx.beginPath();
      for (let j = 0; j <= rows; j++) {
        const wx = startX + i * dx;
        let wy = startY + j * dy;
        const u = i / cols;
        const v = j / rows;
        wy += Math.sin(time * 0.7 + u * 4 * warpFreq) * warpAmp * (1 - v);
        wy += Math.cos(time * 0.5 + v * 6) * warpAmp * 0.25;
        if (chaosLevel > 0) {
          wy += (Math.random() - 0.5) * chaosJitter;
        }
        const { x, y } = worldToScreen(wx, wy);
        if (j === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
  }

  function drawOrbits(time) {
    const centerY = height * 0.6;
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(200,220,255,0.22)';
    planets.forEach((p, idx) => {
      if (idx === 0) return; // skip sun
      const orbitR = p.orbitR;
      const steps = 80;
      ctx.beginPath();
      for (let i = 0; i <= steps; i++) {
        const ang = (i / steps) * Math.PI * 2;
        let wx = Math.cos(ang) * orbitR;
        let wy = centerY + Math.sin(ang) * orbitR * 0.22;
        const wobble = Math.sin(time * 0.3 + idx + i * 0.22) * 4 * tauC;
        wy += wobble;
        const { x, y } = worldToScreen(wx, wy);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();
    });
    ctx.restore();
  }

  function updatePlanets(dt) {
    const centerY = height * 0.6;
    planets.forEach((p, idx) => {
      if (idx === 0) {
        p.wx = 0;
        p.wy = centerY;
        return;
      }
      const chaosSpin = chaosLevel > 0 ? (Math.sin(t * 0.8 + idx) * 0.015) : 0;
      p.angle = (p.angle || 0) + (p.speed + chaosSpin) * dt * tauC;
      const ang = p.angle;
      let wx = Math.cos(ang) * p.orbitR;
      let wy = centerY + Math.sin(ang) * p.orbitR * 0.22;
      const wobble = Math.sin(t * 0.4 + idx * 0.7) * 12 * (tauC - 0.8);
      wy += wobble;
      p.wx = wx;
      p.wy = wy;
    });
  }

  function drawPlanets() {
    planets.forEach((p, idx) => {
      const screen = worldToScreen(p.wx, p.wy);
      const r = p.r * camera.zoom;
      if (idx === 0) {
        // sun glow
        const grad = ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, r * 2.0);
        const glow = 0.55 + 0.45 * Math.sin(t * 0.9);
        grad.addColorStop(0, 'rgba(255,244,200,1)');
        grad.addColorStop(0.5, 'rgba(255,210,120,' + glow + ')');
        grad.addColorStop(1, 'rgba(255,210,120,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, r * 2.1, 0, Math.PI * 2);
        ctx.fill();
      }

      // planet
      const gradP = ctx.createRadialGradient(screen.x - r * 0.5, screen.y - r * 0.5, r * 0.2,
                                             screen.x, screen.y, r);
      gradP.addColorStop(0, '#ffffff');
      gradP.addColorStop(0.4, p.color);
      gradP.addColorStop(1, '#000000');
      ctx.fillStyle = gradP;
      ctx.beginPath();
      ctx.arc(screen.x, screen.y, r, 0, Math.PI * 2);
      ctx.fill();

      if (p.ring) {
        ctx.strokeStyle = 'rgba(255,255,255,0.75)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.ellipse(screen.x, screen.y, r * 1.7, r * 0.9, 0.4, 0, Math.PI * 2);
        ctx.stroke();
      }

      // highlight selected planet ring
      if (planetSelect.value === p.name) {
        ctx.strokeStyle = 'rgba(255,230,150,0.9)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, r * 1.5, 0, Math.PI * 2);
        ctx.stroke();
      }
    });
  }

  function drawChaosOrbs(dt) {
    for (let i = chaosOrbs.length - 1; i >= 0; i--) {
      const o = chaosOrbs[i];
      o.x += o.vx * dt;
      o.y += o.vy * dt;
      o.vy += 0.002 * dt;
      o.life -= 0.0015 * dt;
      if (o.life <= 0) {
        chaosOrbs.splice(i, 1);
        continue;
      }
      const alpha = Math.max(0, o.life);
      const radius = o.size * (0.5 + 0.5 * (1 - o.life));
      const grad = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, radius);
      grad.addColorStop(0, 'rgba(255,255,255,' + alpha + ')');
      grad.addColorStop(0.4, 'rgba(120,230,255,' + alpha + ')');
      grad.addColorStop(1, 'rgba(120,230,255,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(o.x, o.y, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function updateCamera(dt) {
    const wobbleAmp = 18 * (lambdaC - 0.8);
    const wobbleX = Math.sin(t * 0.15) * wobbleAmp;
    const wobbleY = Math.cos(t * 0.18) * wobbleAmp;

    let targetX = wobbleX;
    let targetY = wobbleY;

    if (rideAlong) {
      const name = planetSelect.value;
      const targetPlanet = planets.find(p => p.name === name) || planets[2];
      targetX = targetPlanet.wx;
      targetY = targetPlanet.wy - height * 0.12;
    }

    const lerp = (a,b,s)=>a+(b-a)*s;
    const followSpeed = rideAlong ? 0.08 : 0.03;
    camera.x = lerp(camera.x, targetX, followSpeed * dt * 0.06);
    camera.y = lerp(camera.y, targetY, followSpeed * dt * 0.06);

    const targetZoom = meltdown ? 1.2 : rideAlong ? 1.05 : 1.0;
    camera.zoom = lerp(camera.zoom, targetZoom, 0.04 * dt * 0.06);
  }

  function drawCME(time) {
    if (cmePulse <= 0.001) return;
    const sun = planets[0];
    const center = worldToScreen(sun.wx, sun.wy);
    const maxR = Math.max(width, height) * 1.2;
    const r = (1 - cmePulse) * maxR;
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,230,160,' + cmePulse + ')';
    ctx.beginPath();
    ctx.arc(center.x, center.y, r, 0, Math.PI * 2);
    ctx.stroke();
    cmePulse *= 0.96;
  }

  let last = performance.now();
  function loop(now){
    const dt = now - last;
    last = now;
    t += dt * 0.0015 * tauC;

    ctx.clearRect(0,0,width,height);

    updateCamera(dt);
    updatePlanets(dt);
    drawGrid(t);
    drawOrbits(t);
    drawPlanets();
    drawChaosOrbs(dt);
    drawCME(t);

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();


// --- qds_universe_v9_6_turbo_pan.html ---

    (function() {
      const canvas = document.getElementById("universe-canvas");
      const ctx = canvas.getContext("2d");

      let width = 0, height = 0, baseScale = 1;
      function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        baseScale = Math.min(width, height) / 900;
      }
      window.addEventListener("resize", resize);
      resize();

      // Controls
      const speedSlider = document.getElementById("speedSlider");
      const turboSlider = document.getElementById("turboSlider");
      const turboAutoToggle = document.getElementById("turboAutoToggle");
      const spinSlider = document.getElementById("spinSlider");
      const spinToggle = document.getElementById("spinToggle");
      const lambdaSlider = document.getElementById("lambdaSlider");
      const tauSlider = document.getElementById("tauSlider");
      const alphaSlider = document.getElementById("alphaSlider");
      const trailToggle = document.getElementById("trailToggle");
      const noiseToggle = document.getElementById("noiseToggle");
      const rideToggle = document.getElementById("rideToggle");
      const rideCmeToggle = document.getElementById("rideCmeToggle");
      const resetBtn = document.getElementById("resetBtn");
      const randomBtn = document.getElementById("randomBtn");
      const ludicrousBtn = document.getElementById("ludicrousBtn");
      const calmBtn = document.getElementById("calmBtn");
      const hudToggle = document.getElementById("hudToggle");

      const speedLabel = document.getElementById("speedLabel");
      const turboLabel = document.getElementById("turboLabel");
      const spinLabel = document.getElementById("spinLabel");
      const lambdaLabel = document.getElementById("lambdaLabel");
      const tauLabel = document.getElementById("tauLabel");
      const alphaLabel = document.getElementById("alphaLabel");
      const simTimeLabel = document.getElementById("simTimeLabel");
      const warpLabel = document.getElementById("warpLabel");
      const cameraLabel = document.getElementById("cameraLabel");
      const rideLabel = document.getElementById("rideLabel");
      const rideSelectLabel = document.getElementById("rideSelectLabel");
      const ludicrousStatus = document.getElementById("ludicrousStatus");
      const fpsLabel = document.getElementById("fpsLabel");

      const params = {
        G: 1.0,
        baseSpeed: parseFloat(speedSlider.value),
        turbo: parseFloat(turboSlider.value),
        lambdaC: parseFloat(lambdaSlider.value),
        tauC: parseFloat(tauSlider.value),
        alpha: parseFloat(alphaSlider.value),
        spinBase: parseFloat(spinSlider.value),
        spinEnabled: spinToggle.checked,
        trails: trailToggle.checked,
        noise: noiseToggle.checked,
        rideAlong: rideToggle.checked,
        rideCME: rideCmeToggle.checked,
        softening: 25,
        qdsOscAmp: 0.4,
        ludicrous: false,
        ludicrousBoost: 5.5,
      };

      function updateLabels() {
        speedLabel.textContent = params.baseSpeed.toFixed(2) + "√ó";
        turboLabel.textContent = params.turbo.toFixed(1) + "√ó";
        spinLabel.textContent = params.spinBase.toFixed(2) + "√ó";
        lambdaLabel.textContent = params.lambdaC.toFixed(0);
        tauLabel.textContent = params.tauC.toFixed(1);
        alphaLabel.textContent = params.alpha.toFixed(2);
        warpLabel.textContent = "Œªc=" + params.lambdaC.toFixed(0) + " ¬∑ œÑc=" + params.tauC.toFixed(1) + " ¬∑ Œ±=" + params.alpha.toFixed(2);
        cameraLabel.textContent = params.rideAlong
          ? "Ride-Along ¬∑ drag still pans view"
          : "Drag in space to slide camera";
        rideLabel.textContent = params.rideAlong ? "On ¬∑ Chaos Orb" : "Off";
      }
      updateLabels();

      speedSlider.addEventListener("input", () => { params.baseSpeed = parseFloat(speedSlider.value); updateLabels(); });
      turboSlider.addEventListener("input", () => { params.turbo = parseFloat(turboSlider.value); updateLabels(); });
      spinSlider.addEventListener("input", () => { params.spinBase = parseFloat(spinSlider.value); updateLabels(); });
      spinToggle.addEventListener("change", () => { params.spinEnabled = spinToggle.checked; updateLabels(); });
      lambdaSlider.addEventListener("input", () => { params.lambdaC = parseFloat(lambdaSlider.value); updateLabels(); });
      tauSlider.addEventListener("input", () => { params.tauC = parseFloat(tauSlider.value); updateLabels(); });
      alphaSlider.addEventListener("input", () => { params.alpha = parseFloat(alphaSlider.value); updateLabels(); });
      trailToggle.addEventListener("change", () => { params.trails = trailToggle.checked; });
      noiseToggle.addEventListener("change", () => { params.noise = noiseToggle.checked; });
      rideToggle.addEventListener("change", () => { params.rideAlong = rideToggle.checked; updateLabels(); });
      rideCmeToggle.addEventListener("change", () => { params.rideCME = rideCmeToggle.checked; });
      hudToggle.addEventListener("click", () => { document.body.classList.toggle("hud-minimal"); });

      // Drag-to-pan state
      let panX = 0, panY = 0;
      let isDragging = false;
      let lastX = 0, lastY = 0;

      function startDrag(x, y) {
        isDragging = true;
        lastX = x;
        lastY = y;
      }
      function dragTo(x, y) {
        if (!isDragging) return;
        const dx = x - lastX;
        const dy = y - lastY;
        lastX = x;
        lastY = y;
        const zoom = baseScale * camZoom;
        if (zoom > 0) {
          panX += dx / zoom;
          panY += dy / zoom;
        }
      }
      function endDrag() { isDragging = false; }

      canvas.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;
        e.preventDefault();
        startDrag(e.clientX, e.clientY);
      });
      window.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        e.preventDefault();
        dragTo(e.clientX, e.clientY);
      });
      window.addEventListener("mouseup", endDrag);

      canvas.addEventListener("touchstart", (e) => {
        if (e.touches.length > 0) {
          const t = e.touches[0];
          startDrag(t.clientX, t.clientY);
        }
      }, { passive: false });
      canvas.addEventListener("touchmove", (e) => {
        if (!isDragging) return;
        if (e.touches.length > 0) {
          const t = e.touches[0];
          dragTo(t.clientX, t.clientY);
          e.preventDefault();
        }
      }, { passive: false });
      canvas.addEventListener("touchend", endDrag, { passive: true });
      canvas.addEventListener("touchcancel", endDrag, { passive: true });

      // Simulation state
      let bodies = [];
      let simTime = 0;
      let lastTs = null;
      let rotationAngle = 0;

      // camera follow
      let camTargetX = 0, camTargetY = 0, camTargetZoom = 1;
      let camX = 0, camY = 0, camZoom = 1;

      function makeSystem(randomise) {
        bodies = [];
        bodies.push({ name:"Star", mass:5000, x:0, y:0, vx:0, vy:0, radius:23, hue:48, isStar:true });
        const planetCount = 7;
        for (let i = 0; i < planetCount; i++) {
          const baseR = 90 + i * 60;
          const r = baseR * (randomise ? (0.7 + Math.random() * 0.7) : 1);
          const angle = Math.random() * Math.PI * 2;
          const mass = 4 + i * 1.4;
          const orbitDir = Math.random() < 0.9 ? 1 : -1;
          const x = r * Math.cos(angle);
          const y = r * Math.sin(angle);
          const vCirc = Math.sqrt((params.G * 5000) / r);
          const jitter = randomise ? (0.9 + Math.random() * 0.3) : 1;
          const vx = -orbitDir * vCirc * Math.sin(angle) * jitter;
          const vy = orbitDir * vCirc * Math.cos(angle) * jitter;
          bodies.push({ name:"P"+(i+1), mass, x, y, vx, vy, radius:7 + i*0.9, hue:200 + i*20, isStar:false });
        }
        if (bodies[4]) rideSelectLabel.textContent = "Auto: " + bodies[4].name + " Chaos Orb";
        simTime = 0;
        camTargetX = camX = 0;
        camTargetY = camY = 0;
        camTargetZoom = camZoom = 1;
        panX = panY = 0;
      }

      resetBtn.addEventListener("click", () => makeSystem(false));
      randomBtn.addEventListener("click", () => makeSystem(true));

      // Ludicrous controls
      ludicrousBtn.addEventListener("click", () => {
        params.ludicrous = !params.ludicrous;
        if (params.ludicrous) {
          ludicrousStatus.textContent = "LUDICROUS engaged";
          ludicrousBtn.classList.add("ludicrous-active");
        } else {
          ludicrousStatus.textContent = "Idle";
          ludicrousBtn.classList.remove("ludicrous-active");
          if (turboAutoToggle.checked && params.turbo > 1) {
            params.turbo = 1;
            turboSlider.value = "1";
            updateLabels();
          }
        }
      });
      calmBtn.addEventListener("click", () => {
        params.ludicrous = false;
        ludicrousStatus.textContent = "Idle";
        ludicrousBtn.classList.remove("ludicrous-active");
        params.turbo = 1;
        turboSlider.value = "1";
        updateLabels();
      });

      makeSystem(false);

      // FPS
      let fpsLast = performance.now();
      let fpsFrames = 0;
      function updateFPS(now) {
        fpsFrames++;
        const diff = now - fpsLast;
        if (diff >= 500) {
          const fps = (fpsFrames * 1000) / diff;
          fpsFrames = 0;
          fpsLast = now;
          fpsLabel.textContent = "FPS: " + fps.toFixed(0);
        }
      }

      function step(timestamp) {
        if (lastTs == null) lastTs = timestamp;
        let realDt = (timestamp - lastTs) / 1000;
        lastTs = timestamp;
        if (realDt > 0.1) realDt = 0.1;

        const dt = realDt * params.baseSpeed * params.turbo * (params.ludicrous ? params.ludicrousBoost : 1);
        simTime += dt;
        simTimeLabel.textContent = simTime.toFixed(1) + " s";

        const omega = (2 * Math.PI) / params.tauC;
        const f_t = 1 + params.qdsOscAmp * Math.sin(omega * simTime);

        const ax = new Array(bodies.length).fill(0);
        const ay = new Array(bodies.length).fill(0);

        for (let i=0;i<bodies.length;i++) {
          const bi = bodies[i];
          for (let j=0;j<bodies.length;j++) {
            if (i===j) continue;
            const bj = bodies[j];
            const dx = bj.x - bi.x;
            const dy = bj.y - bi.y;
            const r2 = dx*dx + dy*dy + params.softening;
            const r = Math.sqrt(r2);
            const inv_r3 = 1.0 / (r2 * r);
            let factor = params.G * bj.mass * inv_r3;
            const warp_r = Math.exp(-r / params.lambdaC);
            factor *= (1 + params.alpha * warp_r * f_t);
            ax[i] += factor * dx;
            ay[i] += factor * dy;
          }
        }

        if (params.noise) {
          const noiseLevel = 0.03;
          for (let i=1;i<bodies.length;i++) {
            ax[i] += (Math.random()-0.5)*noiseLevel;
            ay[i] += (Math.random()-0.5)*noiseLevel;
          }
        }

        for (let i=0;i<bodies.length;i++) {
          const b = bodies[i];
          if (b.isStar) {
            b.vx += ax[i]*dt*0.2;
            b.vy += ay[i]*dt*0.2;
          } else {
            b.vx += ax[i]*dt;
            b.vy += ay[i]*dt;
          }
          b.x += b.vx*dt;
          b.y += b.vy*dt;
        }

        // camera follow Chaos Orb
        const chaosIndex = 4;
        let targetX = 0, targetY = 0, targetZoom = 1;
        if (params.rideAlong && bodies[chaosIndex]) {
          targetX = bodies[chaosIndex].x;
          targetY = bodies[chaosIndex].y;
          targetZoom = 1.3;
        }
        const ease = 1 - Math.exp(-6 * realDt);
        camTargetX = targetX;
        camTargetY = targetY;
        camTargetZoom = targetZoom;
        camX += (camTargetX - camX)*ease;
        camY += (camTargetY - camY)*ease;
        camZoom += (camTargetZoom - camZoom)*ease;

        if (params.spinEnabled && !params.rideAlong) {
          rotationAngle += params.spinBase * 0.25 * dt;
        }

        draw();
        updateFPS(timestamp);
        requestAnimationFrame(step);
      }

      function drawCMEGlow(ctx, radiusPx, t) {
        const pulses = 3;
        for (let i=0;i<pulses;i++) {
          const phase = t*0.6 + i*0.8;
          const angle = phase*0.9;
          const spread = 0.9 + 0.3*Math.sin(phase);
          const innerR = radiusPx*(1.0+0.4*spread);
          const outerR = radiusPx*(1.5+0.6*spread);
          const grad = ctx.createRadialGradient(0,0,innerR*0.95,0,0,outerR);
          grad.addColorStop(0,"rgba(251,191,36,0.0)");
          grad.addColorStop(0.2,"rgba(251,146,60,0.28)");
          grad.addColorStop(0.8,"rgba(59,130,246,0.0)");
          ctx.save();
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.fillStyle = grad;
          ctx.ellipse(0,0,outerR,outerR*0.45,0,-0.6,0.6);
          ctx.fill();
          ctx.restore();
        }
      }

      function draw() {
        if (!params.trails) ctx.clearRect(0,0,width,height);
        else {
          ctx.fillStyle = "rgba(3,6,16,0.16)";
          ctx.fillRect(0,0,width,height);
        }

        ctx.save();
        ctx.translate(width/2, height/2);
        const zoom = baseScale * camZoom;
        ctx.scale(zoom, zoom);
        ctx.translate(panX, panY);        // <- user pan
        if (!params.rideAlong) ctx.rotate(rotationAngle);
        ctx.translate(-camX, -camY);

        const star = bodies[0];
        const starX = star.x, starY = star.y;

        ctx.save();
        ctx.translate(starX, starY);
        const starRadiusPx = star.radius * baseScale * 1.2;
        const starGrad = ctx.createRadialGradient(-starRadiusPx*0.25,-starRadiusPx*0.25,starRadiusPx*0.2,0,0,starRadiusPx*1.5);
        starGrad.addColorStop(0,"rgba(255,255,255,1)");
        starGrad.addColorStop(0.35,"rgba(252,211,77,0.98)");
        starGrad.addColorStop(0.7,"rgba(251,146,60,0.25)");
        starGrad.addColorStop(1,"rgba(15,23,42,0.02)");
        ctx.beginPath();
        ctx.fillStyle = starGrad;
        ctx.arc(0,0,starRadiusPx,0,Math.PI*2);
        ctx.fill();
        drawCMEGlow(ctx, starRadiusPx, simTime);
        ctx.beginPath();
        ctx.lineWidth = 1.3 / camZoom;
        ctx.strokeStyle = "rgba(15,23,42,0.9)";
        ctx.arc(0,0,starRadiusPx,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();

        for (let i=1;i<bodies.length;i++) {
          const b = bodies[i];
          const rOrbit = Math.hypot(b.x - starX, b.y - starY);
          const orbitRadiusPx = rOrbit * baseScale;
          ctx.beginPath();
          ctx.lineWidth = 0.8 / camZoom;
          ctx.strokeStyle = "rgba(30,64,175,0.22)";
          ctx.setLineDash([3/camZoom,3/camZoom]);
          ctx.ellipse(starX, starY, orbitRadiusPx, orbitRadiusPx, 0, 0, Math.PI*2);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        for (let i=1;i<bodies.length;i++) {
          const b = bodies[i];
          const px = b.x, py = b.y;
          const rPx = b.radius * baseScale;
          const grad = ctx.createRadialGradient(px-rPx*0.3,py-rPx*0.3,rPx*0.15,px,py,rPx*1.6);
          const hue = b.hue;
          grad.addColorStop(0,"hsla("+hue+",100%,85%,1)");
          grad.addColorStop(0.35,"hsla("+hue+",95%,62%,0.98)");
          grad.addColorStop(0.7,"hsla("+hue+",90%,60%,0.35)");
          grad.addColorStop(1,"hsla("+hue+",90%,60%,0)");
          ctx.beginPath();
          ctx.fillStyle = grad;
          ctx.arc(px,py,rPx,0,Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.lineWidth = 1 / camZoom;
          ctx.strokeStyle = "rgba(15,23,42,0.9)";
          ctx.arc(px,py,rPx,0,Math.PI*2);
          ctx.stroke();

          if (params.rideAlong && params.rideCME && i === 4) {
            ctx.save();
            ctx.translate(px,py);
            const flareR = rPx*2.2;
            const flareGrad = ctx.createRadialGradient(0,0,flareR*0.25,0,0,flareR*1.4);
            flareGrad.addColorStop(0,"rgba(56,189,248,0.0)");
            flareGrad.addColorStop(0.4,"rgba(129,140,248,0.5)");
            flareGrad.addColorStop(1,"rgba(15,23,42,0.0)");
            ctx.beginPath();
            ctx.fillStyle = flareGrad;
            ctx.arc(0,0,flareR,0,Math.PI*2);
            ctx.fill();
            ctx.restore();
          }
        }

        ctx.restore();
      }

      requestAnimationFrame(step);
    })();
  

// --- qds_revenue_predictor_v1.html ---

  const ids = ["Lm","q","cs","kp","kr","S","P","R"];
  ids.forEach(id => document.getElementById(id).addEventListener("input", calc));

  function num(id){ return parseFloat(document.getElementById(id).value || "0"); }
  function fmt(n){ return (Math.round(n)).toLocaleString("en-GB"); }

  function calc(){
    const Lm=num("Lm"), q=num("q"), cs=num("cs"), kp=num("kp"), kr=num("kr");
    const S=num("S"), P=num("P"), R=num("R");

    const Ns = Lm*q*cs;
    const Np = Ns*kp;
    const Nr = Np*kr;

    const rev_m = Ns*S + Np*P + Nr*R;
    const rev_y = 12*rev_m;

    document.getElementById("Ns").textContent = Ns.toFixed(2);
    document.getElementById("Np").textContent = Np.toFixed(2);
    document.getElementById("Nr").textContent = Nr.toFixed(2);
    document.getElementById("rev_m").textContent = fmt(rev_m);
    document.getElementById("rev_y").textContent = fmt(rev_y);
  }

  function preset(mode){
    if(mode==="con"){
      setVals({Lm:6,q:0.30,cs:0.20,kp:0.40,kr:0.30,S:750,P:5000,R:1200});
    }else if(mode==="base"){
      setVals({Lm:8,q:0.50,cs:0.40,kp:0.50,kr:0.40,S:1000,P:8000,R:1500});
    }else if(mode==="opt"){
      setVals({Lm:10,q:0.55,cs:0.45,kp:0.55,kr:0.45,S:1200,P:10000,R:2000});
    }
    calc();
  }

  function setVals(obj){
    for(const k in obj){
      const el=document.getElementById(k);
      if(el) el.value=obj[k];
    }
  }

  function copySummary(){
    const Lm=num("Lm"), q=num("q"), cs=num("cs"), kp=num("kp"), kr=num("kr");
    const S=num("S"), P=num("P"), R=num("R");
    const Ns=(Lm*q*cs), Np=(Ns*kp), Nr=(Np*kr);
    const rev_m=Ns*S+Np*P+Nr*R, rev_y=12*rev_m;

    const text =
`QDS Revenue Predictor (Honest Mode)
Leads/mo: ${Lm}
q: ${q}, c_s: ${cs}, k_p: ${kp}, k_r: ${kr}
Prices: S ¬£${S}, P ¬£${P}, R ¬£${R}/mo
Expected: Ns ${Ns.toFixed(2)}, Np ${Np.toFixed(2)}, Nr ${Nr.toFixed(2)}
Revenue: ~¬£${fmt(rev_m)}/mo, ~¬£${fmt(rev_y)}/yr`;

    navigator.clipboard?.writeText(text);
    alert("Summary copied.");
  }

  preset("base");


// --- qds_revenue_onepager.html ---

  // ---------- Utilities ----------
  const $ = (id) => document.getElementById(id);

  function clamp(n, min, max){
    if (Number.isNaN(n)) return min;
    return Math.min(Math.max(n, min), max);
  }

  function num(v){ return Number(v ?? 0) || 0; }

  function fmtMoney(value, currencyLabel="¬£"){
    const v = Math.round(value);
    // Simple grouping without Intl to stay ultra-portable
    const s = v.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    return `${currencyLabel}${s}`;
  }

  function fmtNum(value, digits=2){
    return Number(value).toFixed(digits);
  }

  // ---------- Presets ----------
  const PRESETS = {
    conservative: {
      qRate: 0.4, sClose: 0.3, pFromS: 0.3, rFromP: 0.25,
      churn: 4
    },
    base: {
      qRate: 0.5, sClose: 0.4, pFromS: 0.35, rFromP: 0.3,
      churn: 3
    },
    optimistic: {
      qRate: 0.6, sClose: 0.5, pFromS: 0.45, rFromP: 0.4,
      churn: 2
    }
  };

  // ---------- Core model ----------
  function computeModel(overrides={}){
    const currencyLabel = $("currencyLabel").value || "¬£";
    const months = clamp(num($("months").value), 3, 36);

    const L   = num(overrides.leads ?? $("leads").value);
    const q   = clamp(num(overrides.qRate ?? $("qRate").value), 0, 1);
    const s   = clamp(num(overrides.sClose ?? $("sClose").value), 0, 1);
    const p   = clamp(num(overrides.pFromS ?? $("pFromS").value), 0, 1);
    const r   = clamp(num(overrides.rFromP ?? $("rFromP").value), 0, 1);

    const S¬£  = num(overrides.priceSprint ?? $("priceSprint").value);
    const P¬£  = num(overrides.pricePilot ?? $("pricePilot").value);
    const R¬£  = num(overrides.priceRetainer ?? $("priceRetainer").value);

    const Smax = num(overrides.capSprints ?? $("capSprints").value);
    const Pmax = num(overrides.capPilots ?? $("capPilots").value);

    const M0  = num(overrides.startMRR ?? $("startMRR").value);
    const cPct = clamp(num(overrides.churn ?? $("churn").value), 0, 50);
    const c = cPct / 100;

    const costBase = num($("costBase").value);

    // Funnel
    const Q = L * q;
    const Es_raw = Q * s;
    const Es = (Smax >= 0) ? Math.min(Es_raw, Smax) : Es_raw;

    const Ep_raw = Es * p;
    const Ep = (Pmax >= 0) ? Math.min(Ep_raw, Pmax) : Ep_raw;

    const Nr = Ep * r;

    // Revenue
    const Rev_s = Es * S¬£;
    const Rev_p = Ep * P¬£;
    const NewMRR = Nr * R¬£;

    const Rev_mo = Rev_s + Rev_p + NewMRR;
    const Rev_yr = Rev_mo * 12;

    // MRR accumulation
    const MRR = [M0];
    for(let i=1; i<=months; i++){
      const prev = MRR[i-1];
      MRR[i] = (prev * (1 - c)) + NewMRR;
    }

    // Bottleneck + status
    let bottleneck = "None";
    let status = "Green";
    const capS = (Smax >= 0 && Es_raw > Smax);
    const capP = (Pmax >= 0 && Ep_raw > Pmax);

    if(capS) bottleneck = "Sprints";
    else if(capP) bottleneck = "Pilots";

    if(capS || capP) status = "Amber";
    if((capS && Smax === 0) || (capP && Pmax === 0)) status = "Red";

    const breakEven = (costBase > 0) ? (Rev_mo - costBase) : null;

    return {
      currencyLabel, months,
      L,q,s,p,r,S¬£,P¬£,R¬£,Smax,Pmax,M0,cPct,c,costBase,
      Q, Es_raw, Es, Ep_raw, Ep, Nr,
      Rev_s, Rev_p, NewMRR, Rev_mo, Rev_yr,
      MRR, status, bottleneck, capS, capP, breakEven
    };
  }

  // ---------- Sensitivity ----------
  function computeSensitivity(base){
    const plusLead = computeModel({ leads: base.L + 1 });
    const deltaLeadYr = plusLead.Rev_yr - base.Rev_yr;

    const plusClose = computeModel({ sClose: clamp(base.s + 0.10, 0, 1) });
    const deltaCloseYr = plusClose.Rev_yr - base.Rev_yr;

    const plusCap = computeModel({ capSprints: base.Smax + 1 });
    const deltaCapYr = plusCap.Rev_yr - base.Rev_yr;

    return { deltaLeadYr, deltaCloseYr, deltaCapYr };
  }

  // ---------- Board summary ----------
  function buildBoardSummary(m){
    const ccy = m.currencyLabel;
    const capLine = (m.capS || m.capP)
      ? `Capacity cap active (${m.bottleneck}).`
      : `No capacity cap triggered.`;

    const churnLine = `Churn assumed at ${fmtNum(m.cPct,1)}%/mo.`;

    const summary =
`This model is deliberately conservative.
${capLine}
Expected per month: ${fmtNum(m.Es,2)} sprints, ${fmtNum(m.Ep,2)} pilots, ${fmtNum(m.Nr,2)} new retainers.
Revenue / mo: ${fmtMoney(m.Rev_mo, ccy)} | Run-rate / year: ${fmtMoney(m.Rev_yr, ccy)}.
New MRR / mo: ${fmtMoney(m.NewMRR, ccy)}. ${churnLine}
Upside comes from lead volume, conversion quality, and delivery capacity ‚Äî not optimistic assumptions.`;

    return summary;
  }

  // ---------- One-pager content ----------
  function renderOnePager(m, sens){
    const ccy = m.currencyLabel;

    $("opPurpose").textContent =
      `Conservative forecast built on real funnel conversions + delivery limits. Mode: ${$("preset").value}.`;

    $("opStatus").className =
      `status-pill ${m.status === "Green" ? "status-green" : m.status === "Amber" ? "status-amber" : "status-red"}`;
    $("opStatus").textContent = m.status;

    $("opDemand").innerHTML =
      `<b>Demand</b><br/>
       Leads: <span class="mono">${fmtNum(m.L,0)}</span><br/>
       Qualified rate q: <span class="mono">${fmtNum(m.q,2)}</span><br/>
       Sprint close s: <span class="mono">${fmtNum(m.s,2)}</span><br/>
       Pilot-from-sprint p: <span class="mono">${fmtNum(m.p,2)}</span><br/>
       Retainer-from-pilot r: <span class="mono">${fmtNum(m.r,2)}</span>`;

    $("opPricing").innerHTML =
      `<b>Pricing</b><br/>
       Sprint: <span class="mono">${fmtMoney(m.S¬£, ccy)}</span><br/>
       Pilot: <span class="mono">${fmtMoney(m.P¬£, ccy)}</span><br/>
       Retainer / mo: <span class="mono">${fmtMoney(m.R¬£, ccy)}</span>`;

    $("opCapacity").innerHTML =
      `<b>Capacity</b><br/>
       Max sprints/mo: <span class="mono">${fmtNum(m.Smax,0)}</span><br/>
       Max pilots/mo: <span class="mono">${fmtNum(m.Pmax,0)}</span><br/>
       Bottleneck: <span class="mono">${m.bottleneck}</span>`;

    const qConf = $("qConf").value, sConf = $("sConf").value, cConf = $("cConf").value;
    const qNote = $("qNote").value || "‚Äî";
    const sNote = $("sNote").value || "‚Äî";
    const cNote = $("cNote").value || "‚Äî";

    $("opAudit").innerHTML =
      `<b>Qualified rate (q)</b>: <span class="mono">${fmtNum(m.q,2)}</span> (${qConf}) ‚Äî ${qNote}<br/>
       <b>Sprint close (s)</b>: <span class="mono">${fmtNum(m.s,2)}</span> (${sConf}) ‚Äî ${sNote}<br/>
       <b>Churn (c)</b>: <span class="mono">${fmtNum(m.cPct,1)}%</span> (${cConf}) ‚Äî ${cNote}`;

    $("opVolumes").innerHTML =
      `<b>Expected volumes / month</b><br/>
       Qualified: <span class="mono">${fmtNum(m.Q,2)}</span><br/>
       Sprints: <span class="mono">${fmtNum(m.Es,2)}</span>${m.capS ? " <b>(capped)</b>" : ""}<br/>
       Pilots: <span class="mono">${fmtNum(m.Ep,2)}</span>${m.capP ? " <b>(capped)</b>" : ""}<br/>
       New retainers: <span class="mono">${fmtNum(m.Nr,2)}</span>`;

    $("opBottleneck").innerHTML =
      `<b>Status</b>: <span class="mono">${m.status}</span><br/>
       <b>Bottleneck</b>: <span class="mono">${m.bottleneck}</span><br/>
       <span class="muted">Capacity constraints prevent unrealistic forecasts and define a true revenue ceiling.</span>`;

    $("opOutputs1").innerHTML =
      `<b>Revenue / month</b><br/>
       <span class="mono">${fmtMoney(m.Rev_mo, ccy)}</span>`;
    $("opOutputs2").innerHTML =
      `<b>Revenue / year</b><br/>
       <span class="mono">${fmtMoney(m.Rev_yr, ccy)}</span>`;
    $("opOutputs3").innerHTML =
      `<b>New MRR / month</b><br/>
       <span class="mono">${fmtMoney(m.NewMRR, ccy)}</span>`;

    const m3 = m.MRR[Math.min(3, m.months)];
    const m6 = m.MRR[Math.min(6, m.months)];
    const m12 = m.MRR[Math.min(12, m.months)];

    $("opMRR").innerHTML =
      `<b>MRR accumulation</b><br/>
       Starting MRR: <span class="mono">${fmtMoney(m.M0, ccy)}</span><br/>
       MRR @ 3 mo: <span class="mono">${fmtMoney(m3, ccy)}</span><br/>
       MRR @ 6 mo: <span class="mono">${fmtMoney(m6, ccy)}</span><br/>
       MRR @ 12 mo: <span class="mono">${fmtMoney(m12, ccy)}</span><br/>
       <span class="muted">Formula: MRR‚Çú‚Çä‚ÇÅ = MRR‚Çú √ó (1 ‚àí c) + NewMRR</span>`;

    $("opSensitivity").innerHTML =
      `+1 lead/mo ‚Üí <span class="mono">${fmtMoney(sens.deltaLeadYr, ccy)}</span> / year<br/>
       +0.10 sprint close ‚Üí <span class="mono">${fmtMoney(sens.deltaCloseYr, ccy)}</span> / year<br/>
       +1 sprint capacity ‚Üí <span class="mono">${fmtMoney(sens.deltaCapYr, ccy)}</span> / year`;

    $("opSummary").textContent = buildBoardSummary(m);
  }

  // ---------- Render dashboard ----------
  function render(){
    const m = computeModel();
    const sens = computeSensitivity(m);
    const ccy = m.currencyLabel;

    // Audit values
    $("qAuditVal").textContent = fmtNum(m.q,2);
    $("sAuditVal").textContent = fmtNum(m.s,2);
    $("cAuditVal").textContent = fmtNum(m.cPct,1) + "%";

    // Status pill
    $("statusPill").className =
      `status-pill ${m.status === "Green" ? "status-green" : m.status === "Amber" ? "status-amber" : "status-red"}`;
    $("statusPill").textContent = `${m.status} ‚Ä¢ Bottleneck: ${m.bottleneck}`;

    // KPIs
    $("kpiRevMo").textContent = fmtMoney(m.Rev_mo, ccy);
    $("kpiRevYr").textContent = fmtMoney(m.Rev_yr, ccy);
    $("kpiNewMRR").textContent = fmtMoney(m.NewMRR, ccy);

    // Volumes
    $("outQualified").textContent = fmtNum(m.Q,2);
    $("outSprints").textContent = fmtNum(m.Es,2);
    $("outPilots").textContent = fmtNum(m.Ep,2);
    $("outRetainers").textContent = fmtNum(m.Nr,2);

    $("capSFlag").textContent = m.capS ? " (capped)" : "";
    $("capPFlag").textContent = m.capP ? " (capped)" : "";

    // MRR outputs
    $("outStartMRR").textContent = fmtMoney(m.M0, ccy);
    const m3 = m.MRR[Math.min(3, m.months)];
    const m6 = m.MRR[Math.min(6, m.months)];
    const m12 = m.MRR[Math.min(12, m.months)];

    $("outMRR3").textContent = fmtMoney(m3, ccy);
    $("outMRR6").textContent = fmtMoney(m6, ccy);
    $("outMRR12").textContent = fmtMoney(m12, ccy);

    // Sensitivity
    $("sensLead").textContent = fmtMoney(sens.deltaLeadYr, ccy);
    $("sensClose").textContent = fmtMoney(sens.deltaCloseYr, ccy);
    $("sensCap").textContent = fmtMoney(sens.deltaCapYr, ccy);

    // Board summary
    const summary = buildBoardSummary(m);
    $("boardSummaryBox").textContent = summary;

    // One-pager fields
    renderOnePager(m, sens);

    // Store for copy
    $("copySummaryBtn").dataset.summary = summary;
  }

  // ---------- Preset handler ----------
  function applyPreset(){
    const key = $("preset").value;
    const p = PRESETS[key] || PRESETS.base;
    $("qRate").value = p.qRate;
    $("sClose").value = p.sClose;
    $("pFromS").value = p.pFromS;
    $("rFromP").value = p.rFromP;
    $("churn").value = p.churn;
  }

  // ---------- View toggle ----------
  function toggleView(){
    $("dashboardView").classList.toggle("hidden");
    $("onePagerView").classList.toggle("hidden");
  }

  // ---------- Copy summary ----------
  async function copySummary(){
    const text = $("copySummaryBtn").dataset.summary || "";
    if(!text) return;

    try{
      if(navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(text);
        $("copySummaryBtn").textContent = "Copied ‚úì";
        setTimeout(()=> $("copySummaryBtn").textContent = "Copy Board Summary", 900);
      } else {
        // Fallback
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        $("copySummaryBtn").textContent = "Copied ‚úì";
        setTimeout(()=> $("copySummaryBtn").textContent = "Copy Board Summary", 900);
      }
    }catch(e){
      $("copySummaryBtn").textContent = "Copy failed";
      setTimeout(()=> $("copySummaryBtn").textContent = "Copy Board Summary", 900);
    }
  }

  // ---------- Print ----------
  function printOnePager(){
    // Ensure pager view is visible for print
    if($("onePagerView").classList.contains("hidden")){
      toggleView();
    }
    window.print();
  }

  // ---------- Wire up ----------
  const inputs = [
    "preset","currencyLabel","months",
    "leads","qRate","sClose","pFromS","rFromP",
    "priceSprint","pricePilot","priceRetainer",
    "capSprints","capPilots","capNotes",
    "startMRR","churn","costBase",
    "qConf","sConf","cConf",
    "qNote","sNote","cNote"
  ];

  inputs.forEach(id=>{
    const el = $(id);
    if(!el) return;
    el.addEventListener("input", ()=>{
      if(id === "preset"){
        applyPreset();
      }
      render();
    });
    el.addEventListener("change", ()=>{
      if(id === "preset"){
        applyPreset();
      }
      render();
    });
  });

  $("toggleViewBtn").addEventListener("click", toggleView);
  $("copySummaryBtn").addEventListener("click", copySummary);
  $("printBtn").addEventListener("click", printOnePager);

  // Init
  applyPreset();
  render();


// --- qds_revenue_floor_v2.html ---

(function(){
  const $ = (id)=>document.getElementById(id);
  const KEY = "QDS_GrowthHub_RevenueFloor_v5_1";

  // IMPORTANT FIX: presets store churn as FRACTION (0.03 = 3%), not percent (3.0).
  const presets = {
    conservative: {
      L:4, q:0.35, s:0.20, p:0.25, r:0.15,
      sprintPrice:2200, pilotPrice:3200, retainerMonth:650,
      Smax:1, Pmax:1, months:12, m0:0, c:0.035, cost:0
    },
    base: {
      L:6, q:0.40, s:0.25, p:0.30, r:0.20,
      sprintPrice:2500, pilotPrice:3500, retainerMonth:800,
      Smax:2, Pmax:1, months:12, m0:0, c:0.03, cost:0
    },
    optimistic: {
      L:10, q:0.50, s:0.30, p:0.35, r:0.25,
      sprintPrice:3000, pilotPrice:4200, retainerMonth:1000,
      Smax:3, Pmax:2, months:12, m0:0, c:0.025, cost:0
    }
  };

  function clamp01(x){ x = Number(x); if(!isFinite(x)) return 0; return Math.max(0, Math.min(1, x)); }
  function num(x, def=0){ x = Number(x); return isFinite(x) ? x : def; }

  function sym(){
    const s = String($("sym").value || "¬£").trim();
    return s.length ? s : "¬£";
  }

  function fmtMoney(x){
    const s = sym();
    if(!isFinite(x)) return "‚Äî";
    const v = Math.round(x);
    return s + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  function fmtMoneySigned(x){
    const s = sym();
    if(!isFinite(x)) return "‚Äî";
    const sign = x > 0 ? "+" : (x < 0 ? "‚àí" : "¬±");
    const v = Math.round(Math.abs(x));
    return sign + s + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  function readInputs(){
    // c entered as % in UI -> fraction internally; clamp to avoid nonsense >99%
    const cFrac = Math.min(0.99, Math.max(0, num($("c").value)/100));
    return {
      L: num($("L").value),
      q: clamp01($("q").value),
      s: clamp01($("s").value),
      p: clamp01($("p").value),
      r: clamp01($("r").value),
      sprintPrice: num($("sprintPrice").value),
      pilotPrice: num($("pilotPrice").value),
      retainerMonth: num($("retainerMonth").value),
      Smax: num($("Smax").value),
      Pmax: num($("Pmax").value),
      months: Math.max(1, Math.floor(num($("months").value, 12))),
      m0: Math.max(0, num($("m0").value)),
      c: cFrac,
      cost: Math.max(0, num($("cost").value)),
      notes: String($("notes").value||"")
    };
  }

  // Core model: demand -> conversion -> caps -> revenue; MRR accum with churn
  function model(inp){
    const qualified = inp.L * inp.q;

    const sprintsRaw = qualified * inp.s;
    const sprints = (isFinite(inp.Smax) && inp.Smax >= 0) ? Math.min(sprintsRaw, inp.Smax) : sprintsRaw;

    const pilotsRaw = sprints * inp.p;
    const pilots = (isFinite(inp.Pmax) && inp.Pmax >= 0) ? Math.min(pilotsRaw, inp.Pmax) : pilotsRaw;

    const newRetainers = pilots * inp.r;

    const revMonth =
      sprints * inp.sprintPrice +
      pilots  * inp.pilotPrice +
      newRetainers * inp.retainerMonth;

    const runRateYear = revMonth * 12;

    const mrrTrack = [];
    let mrr = inp.m0;
    for(let t=1; t<=inp.months; t++){
      mrr = mrr * (1 - inp.c) + newRetainers * inp.retainerMonth;
      mrrTrack.push(mrr);
    }

    function mAt(month){
      if(month <= 0) return inp.m0;
      if(month > mrrTrack.length) return mrrTrack[mrrTrack.length-1] ?? inp.m0;
      return mrrTrack[month-1];
    }

    return {
      qualified,
      sprintsRaw, sprints,
      pilotsRaw, pilots,
      newRetainers,
      revMonth, runRateYear,
      mrrTrack,
      mrr3: mAt(3),
      mrr6: mAt(6),
      mrr12: mAt(12),
      mrrH: mAt(inp.months),
    };
  }

  function confChip(level){
    let cls="chip cMed", dot="var(--teal)";
    if(level==="Low"){ cls="chip cLow"; dot="var(--warn)"; }
    if(level==="High"){ cls="chip cHigh"; dot="var(--lime)"; }
    return `<span class="${cls}"><span class="cDot" style="background:${dot}"></span>${level}</span>`;
  }

  function setAudit(inp){
    const tbody = $("auditBody");
    tbody.innerHTML = "";

    const rows = [
      {k:"Qualified rate (q)", v: inp.q.toFixed(2), conf:"Med", note:"How many leads are actually in-scope."},
      {k:"Sprint close (s)", v: inp.s.toFixed(2), conf:"Med", note:"Conversion from qualified to paid sprint."},
      {k:"Pilot-from-sprint (p)", v: inp.p.toFixed(2), conf:"Med", note:"Who extends from sprint into pilot."},
      {k:"Retainer-from-pilot (r)", v: inp.r.toFixed(2), conf:"Med", note:"Pilot ‚Üí ongoing retainer conversion."},
      {k:"Churn (c)", v: (inp.c*100).toFixed(1) + "%", conf:"Low", note:"Until you have 6‚Äì12 months data."},
      {k:"Capacity caps", v: `Smax=${inp.Smax}, Pmax=${inp.Pmax}`, conf:"High", note:"Your time/ops reality (non-negotiable)."},
    ];

    for(const r of rows){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${r.k}</td>
        <td>${r.v}</td>
        <td>${confChip(r.conf)}</td>
      `;
      tbody.appendChild(tr);

      const tr2 = document.createElement("tr");
      tr2.innerHTML = `<td colspan="3"><div class="noteBox"><b>Evidence note:</b> ${r.note}</div></td>`;
      tbody.appendChild(tr2);
    }
  }

  function setSensitivity(inp, base){
    const scenarios = [
      { idy:"s_y1", idm:"s_m1", mod: x => ({...x, L: x.L + 1}) },
      { idy:"s_y2", idm:"s_m2", mod: x => ({...x, s: clamp01(x.s + 0.10)}) },
      { idy:"s_y3", idm:"s_m3", mod: x => ({...x, Smax: (isFinite(x.Smax) ? x.Smax + 1 : x.Smax)}) },
      { idy:"s_y4", idm:"s_m4", mod: x => ({...x, p: clamp01(x.p + 0.05)}) },
      { idy:"s_y5", idm:"s_m5", mod: x => ({...x, r: clamp01(x.r + 0.05)}) },
    ];

    for(const sc of scenarios){
      const m = model(sc.mod(inp));
      const dy = m.runRateYear - base.runRateYear;
      const dm = m.revMonth - base.revMonth;

      const yEl = $(sc.idy);
      const mEl = $(sc.idm);

      yEl.textContent = fmtMoneySigned(dy);
      mEl.textContent = fmtMoneySigned(dm);

      const cls = (dy > 1e-9) ? "good" : (dy < -1e-9) ? "bad" : "neutral";
      yEl.className = cls;
      mEl.className = cls;
    }
  }

  function render(){
    const inp = readInputs();

    // currency hints
    const s = sym();
    $("labSprint").textContent = `${s} / sprint`;
    $("labPilot").textContent  = `${s} / pilot`;
    $("labRet").textContent    = `${s} / mo`;

    const m = model(inp);

    $("revMonthOut").textContent = fmtMoney(m.revMonth);
    $("runRateOut").textContent  = fmtMoney(m.runRateYear);
    $("newMRROut").textContent   = fmtMoney(m.newRetainers * inp.retainerMonth);
    $("mrrHOut").textContent     = fmtMoney(m.mrrH);
    $("mrrHSub").textContent     = `MRR after churn @ ${inp.months} month${inp.months===1?"":"s"}`;

    $("volLine").innerHTML =
      `<b>Expected volumes / month</b><br/>
      Qualified: <b>${m.qualified.toFixed(2)}</b> ‚Ä¢
      Sprints: <b>${m.sprints.toFixed(2)}</b> <span style="opacity:.8">(raw ${m.sprintsRaw.toFixed(2)})</span> ‚Ä¢
      Pilots: <b>${m.pilots.toFixed(2)}</b> <span style="opacity:.8">(raw ${m.pilotsRaw.toFixed(2)})</span> ‚Ä¢
      New retainers: <b>${m.newRetainers.toFixed(2)}</b>`;

    const m3  = (inp.months >= 3)  ? fmtMoney(m.mrr3)  : "‚Äî";
    const m6  = (inp.months >= 6)  ? fmtMoney(m.mrr6)  : "‚Äî";
    const m12 = (inp.months >= 12) ? fmtMoney(m.mrr12) : "‚Äî";

    $("mrrLine").innerHTML =
      `<b>MRR accumulation</b><br/>
      Starting: <b>${fmtMoney(inp.m0)}</b> ‚Ä¢
      MRR @ 3 mo: <b>${m3}</b> ‚Ä¢
      MRR @ 6 mo: <b>${m6}</b> ‚Ä¢
      MRR @ 12 mo: <b>${m12}</b> ‚Ä¢
      MRR @ horizon: <b>${fmtMoney(m.mrrH)}</b>`;

    const board = `Base plan: ${fmtMoney(m.revMonth)}/mo revenue ‚Üí ${fmtMoney(m.runRateYear)}/yr run-rate. Adds ${fmtMoney(m.newRetainers * inp.retainerMonth)}/mo new MRR; projected MRR @ ${inp.months} months: ${fmtMoney(m.mrrH)}.`;
    $("boardSummaryText").textContent = board;

    setAudit(inp);
    setSensitivity(inp, m);
  }

  function applyPreset(name){
    const p = presets[name] || presets.base;
    $("L").value = p.L;
    $("q").value = p.q;
    $("s").value = p.s;
    $("p").value = p.p;
    $("r").value = p.r;
    $("sprintPrice").value = p.sprintPrice;
    $("pilotPrice").value = p.pilotPrice;
    $("retainerMonth").value = p.retainerMonth;
    $("Smax").value = p.Smax;
    $("Pmax").value = p.Pmax;
    $("months").value = p.months;
    $("m0").value = p.m0;
    $("c").value = (p.c*100).toFixed(1); // fraction -> %
    $("cost").value = p.cost;
    render();
  }

  function saveLS(){
    const inp = readInputs();
    localStorage.setItem(KEY, JSON.stringify({
      sym: $("sym").value,
      months: inp.months,
      m0: inp.m0,
      L: inp.L, q: inp.q, s: inp.s, p: inp.p, r: inp.r,
      sprintPrice: inp.sprintPrice,
      pilotPrice: inp.pilotPrice,
      retainerMonth: inp.retainerMonth,
      Smax: inp.Smax, Pmax: inp.Pmax,
      c: (inp.c*100), // store as %
      cost: inp.cost,
      notes: inp.notes
    }));
  }

  function loadLS(){
    const raw = localStorage.getItem(KEY);
    if(!raw) return;
    try{
      const x = JSON.parse(raw);
      if(x.sym!==undefined) $("sym").value = x.sym;
      if(x.months!==undefined) $("months").value = x.months;
      if(x.m0!==undefined) $("m0").value = x.m0;
      if(x.L!==undefined) $("L").value = x.L;
      if(x.q!==undefined) $("q").value = x.q;
      if(x.s!==undefined) $("s").value = x.s;
      if(x.p!==undefined) $("p").value = x.p;
      if(x.r!==undefined) $("r").value = x.r;
      if(x.sprintPrice!==undefined) $("sprintPrice").value = x.sprintPrice;
      if(x.pilotPrice!==undefined) $("pilotPrice").value = x.pilotPrice;
      if(x.retainerMonth!==undefined) $("retainerMonth").value = x.retainerMonth;
      if(x.Smax!==undefined) $("Smax").value = x.Smax;
      if(x.Pmax!==undefined) $("Pmax").value = x.Pmax;
      if(x.c!==undefined) $("c").value = x.c;
      if(x.cost!==undefined) $("cost").value = x.cost;
      if(x.notes!==undefined) $("notes").value = x.notes;
      render();
    }catch(e){}
  }

  // Events
  document.addEventListener("input", (e)=>{
    if(e.target && (e.target.tagName==="INPUT"||e.target.tagName==="SELECT"||e.target.tagName==="TEXTAREA")) render();
  }, true);
  document.addEventListener("change", (e)=>{
    if(e.target && (e.target.tagName==="INPUT"||e.target.tagName==="SELECT"||e.target.tagName==="TEXTAREA")) render();
  }, true);

  $("mode").addEventListener("change", ()=>applyPreset($("mode").value));

  $("btnToggleOnePager").addEventListener("click", ()=>{ document.body.classList.toggle("onepager"); });
  $("btnPrint").addEventListener("click", ()=>window.print());

  $("btnCopyBoard").addEventListener("click", async ()=>{
    const text = $("boardSummaryText").textContent || "";
    try{
      await navigator.clipboard.writeText(text);
      $("btnCopyBoard").textContent = "Copied ‚úì";
      setTimeout(()=> $("btnCopyBoard").textContent="Copy Board Summary", 900);
    }catch(e){
      const ta = document.createElement("textarea");
      ta.value = text; document.body.appendChild(ta);
      ta.select(); document.execCommand("copy");
      ta.remove();
    }
  });

  $("btnReset").addEventListener("click", ()=>{
    $("mode").value = "base";
    $("sym").value = "¬£";
    $("notes").value = "";
    applyPreset("base");
  });

  $("btnSaveLS").addEventListener("click", ()=>saveLS());
  $("btnLoadLS").addEventListener("click", ()=>loadLS());
  $("btnDefaults").addEventListener("click", ()=>{
    $("mode").value="base"; $("sym").value="¬£"; $("notes").value="";
    applyPreset("base");
  });

  // Boot
  applyPreset("base");
})();


// --- portfolio_ultimate_allinone_v1.html ---

function copyDOI(t){
  navigator.clipboard?.writeText(t).catch(()=>{});
  const el=document.getElementById("doi_qdsx");
  if(el){ el.textContent=t+"  ‚úì copied"; setTimeout(()=>el.textContent=t,1200); }
}
const f=document.getElementById("filter");
if(f){
  f.addEventListener("input",()=>{
    const q=f.value.toLowerCase().trim();
    document.querySelectorAll(".section,.card").forEach(c=>{
      const text=c.innerText.toLowerCase();
      c.style.outline = q && text.includes(q) ? "1px solid rgba(34,211,238,.45)" : "none";
    });
  });
}


// --- all_pages_index.html ---

// ---- data injected below ----
const PAGES = [
  { title: "battery skin v2", href: "battery_skin_v2.html" }
,
  { title: "battery skin v2 max", href: "battery_skin_v2_max.html" }
,
  { title: "cannon side 2d v1", href: "cannon_side_2d_v1.html" }
,
  { title: "cannon wall breaker v1", href: "cannon_wall_breaker_v1.html" }
,
  { title: "cannon wall breaker v1 1", href: "cannon_wall_breaker_v1_1.html" }
,
  { title: "catapult balloon pop v1", href: "catapult_balloon_pop_v1.html" }
,
  { title: "ddmelts microsite v1", href: "ddmelts_microsite_v1.html" }
,
  { title: "ddmelts microsite v1 1", href: "ddmelts_microsite_v1_1.html" }
,
  { title: "ddmelts microsite v1 2 live links", href: "ddmelts_microsite_v1_2_live_links.html" }
,
  { title: "ddmelts microsite v1 2 pink hearts", href: "ddmelts_microsite_v1_2_pink_hearts.html" }
,
  { title: "dev door space", href: "dev_door_space.html" }
,
  { title: "dev hub", href: "dev_hub.html" }
,
  { title: "frontdoor", href: "frontdoor.html" }
,
  { title: "frontdoor show", href: "frontdoor_show.html" }
,
  { title: "frontdoor show fix revenue 20251210 223127", href: "frontdoor_show_fix_revenue_20251210_223127.html" }
,
  { title: "growthhub", href: "growthhub.html" }
,
  { title: "growthhub allinone v1", href: "growthhub_allinone_v1.html" }
,
  { title: "growthhub allinone v1 1", href: "growthhub_allinone_v1_1.html" }
,
  { title: "growthhub demo front 20251207 170108", href: "growthhub_demo_front_20251207_170108.html" }
,
  { title: "growthhub demo front 20251207 172220", href: "growthhub_demo_front_20251207_172220.html" }
,
  { title: "growthhub jargon v1", href: "growthhub_jargon_v1.html" }
,
  { title: "growthhub linked 20251207 162635", href: "growthhub_linked_20251207_162635.html" }
,
  { title: "growthhub linked 20251207 162917", href: "growthhub_linked_20251207_162917.html" }
,
  { title: "growthhub linked 20251207 163105", href: "growthhub_linked_20251207_163105.html" }
,
  { title: "growthhub linked 20251207 163119", href: "growthhub_linked_20251207_163119.html" }
,
  { title: "growthhub linked 20251207 163619", href: "growthhub_linked_20251207_163619.html" }
,
  { title: "growthhub linked 20251207 163635", href: "growthhub_linked_20251207_163635.html" }
,
  { title: "growthhub linked 20251207 165546", href: "growthhub_linked_20251207_165546.html" }
,
  { title: "growthhub linked 20251207 165600", href: "growthhub_linked_20251207_165600.html" }
,
  { title: "growthhub linked 20251207 165721", href: "growthhub_linked_20251207_165721.html" }
,
  { title: "growthhub meeting script v1", href: "growthhub_meeting_script_v1.html" }
,
  { title: "growthhub multi area stack v1", href: "growthhub_multi_area_stack_v1.html" }
,
  { title: "growthhub official top5", href: "growthhub_official_top5.html" }
,
  { title: "growthhub official top5 demo front 20251207 170108", href: "growthhub_official_top5_demo_front_20251207_170108.html" }
,
  { title: "growthhub official top5 demo front 20251207 172220", href: "growthhub_official_top5_demo_front_20251207_172220.html" }
,
  { title: "growthhub official top5 with offer 20251207 165318", href: "growthhub_official_top5_with_offer_20251207_165318.html" }
,
  { title: "growthhub official top5 with offer 20251207 165325", href: "growthhub_official_top5_with_offer_20251207_165325.html" }
,
  { title: "growthhub official top5 with offer 20251207 165411", href: "growthhub_official_top5_with_offer_20251207_165411.html" }
,
  { title: "growthhub official top5 with offer 20251207 165424", href: "growthhub_official_top5_with_offer_20251207_165424.html" }
,
  { title: "growthhub official top5 with offer 20251207 165431", href: "growthhub_official_top5_with_offer_20251207_165431.html" }
,
  { title: "growthhub official top5 with offer 20251207 165545", href: "growthhub_official_top5_with_offer_20251207_165545.html" }
,
  { title: "growthhub official top5 with offer 20251207 165559", href: "growthhub_official_top5_with_offer_20251207_165559.html" }
,
  { title: "growthhub official top5 with offer 20251207 165720", href: "growthhub_official_top5_with_offer_20251207_165720.html" }
,
  { title: "growthhub stroud demo", href: "growthhub_stroud_demo.html" }
,
  { title: "growthhub with offer 20251207 165318", href: "growthhub_with_offer_20251207_165318.html" }
,
  { title: "growthhub with offer 20251207 165325", href: "growthhub_with_offer_20251207_165325.html" }
,
  { title: "growthhub with offer 20251207 165411", href: "growthhub_with_offer_20251207_165411.html" }
,
  { title: "growthhub with offer 20251207 165424", href: "growthhub_with_offer_20251207_165424.html" }
,
  { title: "growthhub with offer 20251207 165431", href: "growthhub_with_offer_20251207_165431.html" }
,
  { title: "growthhub with offer 20251207 165545", href: "growthhub_with_offer_20251207_165545.html" }
,
  { title: "growthhub with offer 20251207 165559", href: "growthhub_with_offer_20251207_165559.html" }
,
  { title: "growthhub with offer 20251207 165720", href: "growthhub_with_offer_20251207_165720.html" }
,
  { title: "h code warning nodes demo", href: "h_code_warning_nodes_demo.html" }
,
  { title: "index", href: "index.html" }
,
  { title: "index demo front 20251207 170108", href: "index_demo_front_20251207_170108.html" }
,
  { title: "index demo front 20251207 172220", href: "index_demo_front_20251207_172220.html" }
,
  { title: "index with offer 20251207 165318", href: "index_with_offer_20251207_165318.html" }
,
  { title: "index with offer 20251207 165325", href: "index_with_offer_20251207_165325.html" }
,
  { title: "index with offer 20251207 165411", href: "index_with_offer_20251207_165411.html" }
,
  { title: "index with offer 20251207 165424", href: "index_with_offer_20251207_165424.html" }
,
  { title: "index with offer 20251207 165431", href: "index_with_offer_20251207_165431.html" }
,
  { title: "index with offer 20251207 165545", href: "index_with_offer_20251207_165545.html" }
,
  { title: "index with offer 20251207 165559", href: "index_with_offer_20251207_165559.html" }
,
  { title: "index with offer 20251207 165720", href: "index_with_offer_20251207_165720.html" }
,
  { title: "indus atlas v1 qds language lab", href: "indus_atlas_v1_qds_language_lab.html" }
,
  { title: "last5days index", href: "last5days_index.html" }
,
  { title: "legacy hub v1", href: "legacy_hub_v1.html" }
,
  { title: "offer demo suite v1", href: "offer_demo_suite_v1.html" }
,
  { title: "offer index v1", href: "offer_index_v1.html" }
,
  { title: "offer microsite v1", href: "offer_microsite_v1.html" }
,
  { title: "offer showcase hub v1", href: "offer_showcase_hub_v1.html" }
,
  { title: "omega os index v1", href: "omega_os_index_v1.html" }
,
  { title: "omega os index v2", href: "omega_os_index_v2.html" }
,
  { title: "omega qds lab", href: "omega_qds_lab.html" }
,
  { title: "phone chatgpt case study", href: "phone_chatgpt_case_study.html" }
,
  { title: "portfolio", href: "portfolio.html" }
,
  { title: "portfolio market allinone v1", href: "portfolio_market_allinone_v1.html" }
,
  { title: "portfolio offer v2", href: "portfolio_offer_v2.html" }
,
  { title: "portfolio offer v2 20251206 134821", href: "portfolio_offer_v2_20251206_134821.html" }
,
  { title: "portfolio ultimate allinone v1", href: "portfolio_ultimate_allinone_v1.html" }
,
  { title: "portfolio v1", href: "portfolio_v1.html" }
,
  { title: "proof of ship v1", href: "proof_of_ship_v1.html" }
,
  { title: "pyramid pinball v1", href: "pyramid_pinball_v1.html" }
,
  { title: "q", href: "q.html" }
,
  { title: "qds 5 pillars hub", href: "qds_5_pillars_hub.html" }
,
  { title: "qds 5 pillars hub v1", href: "qds_5_pillars_hub_v1.html" }
,
  { title: "qds avian lab v2", href: "qds_avian_lab_v2.html" }
,
  { title: "qds avian lab v3 pro", href: "qds_avian_lab_v3_pro.html" }
,
  { title: "qds avian lab v4 pro", href: "qds_avian_lab_v4_pro.html" }
,
  { title: "qds avian navigation lab", href: "qds_avian_navigation_lab.html" }
,
  { title: "qds battery coach v3", href: "qds_battery_coach_v3.html" }
,
  { title: "qds battery design v1", href: "qds_battery_design_v1.html" }
,
  { title: "qds battery habitat demo", href: "qds_battery_habitat_demo.html" }
,
  { title: "qds battery habitat v1 1 build 001", href: "qds_battery_habitat_v1_1_build_001.html" }
,
  { title: "qds battery habitat v1 2 build002", href: "qds_battery_habitat_v1_2_build002.html" }
,
  { title: "qds battery hub v9 1 purple neon", href: "qds_battery_hub_v9_1_purple_neon.html" }
,
  { title: "qds battery hub v9 2 purple neon", href: "qds_battery_hub_v9_2_purple_neon.html" }
,
  { title: "qds battery hub v9 3 science neon", href: "qds_battery_hub_v9_3_science_neon.html" }
,
  { title: "qds battery hub v9 4 science neon plus", href: "qds_battery_hub_v9_4_science_neon_plus.html" }
,
  { title: "qds battery hub v9 5 1 science neon", href: "qds_battery_hub_v9_5_1_science_neon.html" }
,
  { title: "qds battery hub v9 5 science neon", href: "qds_battery_hub_v9_5_science_neon.html" }
,
  { title: "qds battery hub v9 6 science neon", href: "qds_battery_hub_v9_6_science_neon.html" }
,
  { title: "qds battery hub v9 7 science neon lab", href: "qds_battery_hub_v9_7_science_neon_lab.html" }
,
  { title: "qds battery index v1 neon os", href: "qds_battery_index_v1_neon_os.html" }
,
  { title: "qds battery lab", href: "qds_battery_lab.html" }
,
  { title: "qds battery lab showcase stress bias v1", href: "qds_battery_lab_showcase_stress_bias_v1.html" }
,
  { title: "qds battery lab showcase stress bias v2", href: "qds_battery_lab_showcase_stress_bias_v2.html" }
,
  { title: "qds battery lab showcase v1", href: "qds_battery_lab_showcase_v1.html" }
,
  { title: "qds battery noise toy v1", href: "qds_battery_noise_toy_v1.html" }
,
  { title: "qds battery os index v1", href: "qds_battery_os_index_v1.html" }
,
  { title: "qds battery suite v4 showcase", href: "qds_battery_suite_v4_showcase.html" }
,
  { title: "qds battery suite v5 boss polish", href: "qds_battery_suite_v5_boss_polish.html" }
,
  { title: "qds battery suite v6 realworld", href: "qds_battery_suite_v6_realworld.html" }
,
  { title: "qds battery suite v8 1 fairpath", href: "qds_battery_suite_v8_1_fairpath.html" }
,
  { title: "qds battery suite v8 2 poster tamed", href: "qds_battery_suite_v8_2_poster_tamed.html" }
,
  { title: "qds battery suite v8 3 neon shell", href: "qds_battery_suite_v8_3_neon_shell.html" }
,
  { title: "qds battery suite v8 nextlevel", href: "qds_battery_suite_v8_nextlevel.html" }
,
  { title: "qds battery whisperer v2", href: "qds_battery_whisperer_v2.html" }
,
  { title: "qds binary pulsar lab", href: "qds_binary_pulsar_lab.html" }
,
  { title: "qds binary pulsar notes", href: "qds_binary_pulsar_notes.html" }
,
  { title: "qds business projection posh v1", href: "qds_business_projection_posh_v1.html" }
,
  { title: "qds chips noise v1", href: "qds_chips_noise_v1.html" }
,
  { title: "qds compression lab v1", href: "qds_compression_lab_v1.html" }
,
  { title: "qds domain map", href: "qds_domain_map.html" }
,
  { title: "qds domain map animated v1", href: "qds_domain_map_animated_v1.html" }
,
  { title: "qds micro lab", href: "qds_micro_lab.html" }
,
  { title: "qds offer bundle v1 20251207 165042", href: "qds_offer_bundle_v1_20251207_165042.html" }
,
  { title: "qds offer bundle v1 20251207 165051", href: "qds_offer_bundle_v1_20251207_165051.html" }
,
  { title: "qds production dashboard v1", href: "qds_production_dashboard_v1.html" }
,
  { title: "qds revenue floor BASE", href: "qds_revenue_floor_BASE.html" }
,
  { title: "qds revenue floor STRETCH", href: "qds_revenue_floor_STRETCH.html" }
,
  { title: "qds revenue floor v2", href: "qds_revenue_floor_v2.html" }
,
  { title: "qds revenue onepager", href: "qds_revenue_onepager.html" }
,
  { title: "qds revenue predictor v1", href: "qds_revenue_predictor_v1.html" }
,
  { title: "qds rotation lab", href: "qds_rotation_lab.html" }
,
  { title: "qds sensors metrology v1", href: "qds_sensors_metrology_v1.html" }
,
  { title: "qds shed index v1", href: "qds_shed_index_v1.html" }
,
  { title: "qds showcase index v1", href: "qds_showcase_index_v1.html" }
,
  { title: "qds showcase index v1 1", href: "qds_showcase_index_v1_1.html" }
,
  { title: "qds solar v6 textures", href: "qds_solar_v6_textures.html" }
,
  { title: "qds test platform", href: "qds_test_platform.html" }
,
  { title: "qds test platformV3", href: "qds_test_platformV3.html" }
,
  { title: "qds test task pack v1", href: "qds_test_task_pack_v1.html" }
,
  { title: "qds test task pack v1 1 pro", href: "qds_test_task_pack_v1_1_pro.html" }
,
  { title: "qds tool atlas v1", href: "qds_tool_atlas_v1.html" }
,
  { title: "qds universe v12b mobile", href: "qds_universe_v12b_mobile.html" }
,
  { title: "qds universe v9 10 neon planet colours", href: "qds_universe_v9_10_neon_planet_colours.html" }
,
  { title: "qds universe v9 2 neon clear planets", href: "qds_universe_v9_2_neon_clear_planets.html" }
,
  { title: "qds universe v9 6 turbo pan", href: "qds_universe_v9_6_turbo_pan.html" }
,
  { title: "qds variance lab", href: "qds_variance_lab.html" }
,
  { title: "solar system v8 offline", href: "solar_system_v8_offline.html" }
,
  { title: "solar system v9 2 mobile 3d showcase", href: "solar_system_v9_2_mobile_3d_showcase.html" }
,
  { title: "start here 90s v1", href: "start_here_90s_v1.html" }
,
  { title: "stinchcombe map", href: "stinchcombe_map.html" }
];

const categorize = (name) => {
  const n = name.toLowerCase();
  if (n.includes("battery")) return "Battery";
  if (n.includes("universe")) return "Universe";
  if (n.includes("solar")) return "Solar";
  if (n.includes("growthhub") || n.includes("offer")) return "Growth / Revenue";
  if (n.includes("omega") || n.includes("os")) return "Œ© / OS";
  if (n.includes("index")) return "Indexes / Hubs";
  if (n.includes("indus") || n.includes("language")) return "Language / Indus";
  if (n.includes("her") || n.includes("stinchcombe")) return "Maps / HER";
  if (n.includes("h code") || n.includes("h_code")) return "H-Code / Nervous System";
  if (n.includes("test") || n.includes("lab")) return "Tests / Labs";
  return "Misc";
};

const elList  = document.getElementById("list");
const elQ     = document.getElementById("q");
const elGroup = document.getElementById("group");
const elReset = document.getElementById("reset");
const elStats = document.getElementById("stats");

const FULL = PAGES.map(p => ({
  ...p,
  path: p.href,
  category: categorize(p.title + " " + p.href),
}));

const renderFlat = (items) => {
  elList.innerHTML = "";
  for (const p of items) {
    const a = document.createElement("a");
    a.className = "card";
    a.href = p.href;
    a.innerHTML = `
      <div class="name">${p.title}</div>
      <div class="path">${p.path}</div>
      <span class="tag">${p.category}</span>
    `;
    elList.appendChild(a);
  }
};

const renderGrouped = (items) => {
  elList.innerHTML = "";
  const groups = {};
  for (const p of items) {
    (groups[p.category] ||= []).push(p);
  }
  const cats = Object.keys(groups).sort();
  for (const c of cats) {
    const header = document.createElement("div");
    header.style.gridColumn = "1 / -1";
    header.style.padding = "8px 6px 2px";
    header.style.color = "#a7b0c5";
    header.style.fontSize = "12px";
    header.style.letterSpacing = ".06em";
    header.textContent = c;
    elList.appendChild(header);

    for (const p of groups[c]) {
      const a = document.createElement("a");
      a.className = "card";
      a.href = p.href;
      a.innerHTML = `
        <div class="name">${p.title}</div>
        <div class="path">${p.path}</div>
        <span class="tag">${p.category}</span>
      `;
      elList.appendChild(a);
    }
  }
};

const apply = () => {
  const q = (elQ.value || "").toLowerCase().trim();
  let items = FULL.filter(p =>
    !q ||
    p.title.toLowerCase().includes(q) ||
    p.path.toLowerCase().includes(q) ||
    p.category.toLowerCase().includes(q)
  );

  // update stats
  elStats.textContent = `${items.length} pages shown ¬∑ ${FULL.length} total`;

  if (elGroup.value === "category") renderGrouped(items);
  else renderFlat(items);
};

elQ.addEventListener("input", apply);
elGroup.addEventListener("change", apply);
elReset.addEventListener("click", () => {
  elQ.value = "";
  elGroup.value = "none";
  apply();
});

// init
apply();


// --- qds_battery_habitat_demo.html ---

/* ---------------------------
   QDS Battery Habitat v1 Demo
   Offline, dependency-free
---------------------------- */

const $ = (id) => document.getElementById(id);

// Toggles
const togAI = $("togAI");
const togThermalCase = $("togThermalCase");
const togAir = $("togAir");
const togHoney = $("togHoney");
const togDamp = $("togDamp");
const togSolar = $("togSolar");

// Context inputs
const useCase = $("useCase");
const discipline = $("discipline");
const ambient = $("ambient");
const vibe = $("vibe");

// Audit inputs
const baseLife = $("baseLife");
const baseCost = $("baseCost");

// Diagram inputs (light usage only)
const L_pack = $("L_pack");
const W_pack = $("W_pack");
const H_pack = $("H_pack");
const P_hex = $("P_hex");

// Outputs
const lifeUplift = $("lifeUplift");
const confidenceTag = $("confidenceTag");
const drivers = $("drivers");

const projLife = $("projLife");
const savingsTag = $("savingsTag");
const annualValue = $("annualValue");

// Bars
const barAI = $("barAI"), barAITxt = $("barAITxt");
const barCase = $("barCase"), barCaseTxt = $("barCaseTxt");
const barAir = $("barAir"), barAirTxt = $("barAirTxt");
const barHoney = $("barHoney"), barHoneyTxt = $("barHoneyTxt");
const barDamp = $("barDamp"), barDampTxt = $("barDampTxt");
const barSolar = $("barSolar"), barSolarTxt = $("barSolarTxt");

function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

function getContextMultipliers(){
  // Use case baseline opportunity
  let uc = useCase.value;
  let ucMult = 1.0;
  if(uc === "ev_fleet") ucMult = 1.15;      // high duty = more upside
  if(uc === "ev_light") ucMult = 1.0;
  if(uc === "stationary") ucMult = 0.9;    // calmer cycles
  if(uc === "remote") ucMult = 1.05;

  // Discipline effect
  let d = discipline.value;
  let dMult = (d === "low") ? 0.75 : (d === "med") ? 1.0 : 1.18;

  // Ambient temperature stress factor (rough)
  let T = parseFloat(ambient.value || "18");
  let heatPenalty = 1.0;
  if(T >= 30) heatPenalty = 0.92;
  if(T >= 38) heatPenalty = 0.86;
  if(T <= 0)  heatPenalty = 0.92;

  // Vibration harshness upside for damping/honeycomb
  let v = vibe.value;
  let vibeMult = (v === "low") ? 0.9 : (v === "med") ? 1.0 : 1.12;

  return { ucMult, dMult, heatPenalty, vibeMult };
}

function estimateUplift(){
  // Base component ranges (percent points)
  // These are deliberately modest + overlapping-aware.
  const components = {
    ai:     togAI.checked ?  [5, 10]  : [0,0],
    tcase:  togThermalCase.checked ? [3, 7]  : [0,0],
    air:    togAir.checked ? [2, 5]  : [0,0],
    honey:  togHoney.checked ? [2, 6] : [0,0],
    damp:   togDamp.checked ? [1, 4]  : [0,0],
    solar:  togSolar.checked ? [0.5, 2] : [0,0],
  };

  // Raw sum of mins/maxes
  let minSum = 0, maxSum = 0;
  for(const k in components){
    minSum += components[k][0];
    maxSum += components[k][1];
  }

  // Overlap penalty: more features => diminishing returns
  const featureCount =
    (togAI.checked?1:0) +
    (togThermalCase.checked?1:0) +
    (togAir.checked?1:0) +
    (togHoney.checked?1:0) +
    (togDamp.checked?1:0) +
    (togSolar.checked?1:0);

  // Penalty factor tuned to keep sane ranges
  let overlapFactor = 1.0;
  if(featureCount >= 3) overlapFactor -= 0.08;
  if(featureCount >= 4) overlapFactor -= 0.08;
  if(featureCount >= 5) overlapFactor -= 0.07;
  if(featureCount >= 6) overlapFactor -= 0.05;
  overlapFactor = clamp(overlapFactor, 0.7, 1.0);

  // Context multipliers
  const { ucMult, dMult, heatPenalty, vibeMult } = getContextMultipliers();

  // Apply multipliers
  let minAdj = minSum * overlapFactor * ucMult * dMult * heatPenalty;
  let maxAdj = maxSum * overlapFactor * ucMult * dMult * heatPenalty;

  // Slightly boost mechanical-related uplift in high vibration environments
  if(vibeMult > 1.0){
    const mechBoost =
      (togHoney.checked?1:0) + (togDamp.checked?1:0);
    if(mechBoost > 0){
      minAdj *= 1.0 + 0.03 * mechBoost;
      maxAdj *= 1.0 + 0.04 * mechBoost;
    }
  }

  // Clamp to sensible public-facing demo bounds
  minAdj = clamp(minAdj, 0, 28);
  maxAdj = clamp(maxAdj, 0, 35);

  // Ensure ordering
  if(maxAdj < minAdj) maxAdj = minAdj;

  return { minAdj, maxAdj, components, featureCount };
}

function contributionBars(components){
  // Produce relative weights based on midpoints for display
  const mids = {
    ai: (components.ai[0]+components.ai[1])/2,
    tcase: (components.tcase[0]+components.tcase[1])/2,
    air: (components.air[0]+components.air[1])/2,
    honey: (components.honey[0]+components.honey[1])/2,
    damp: (components.damp[0]+components.damp[1])/2,
    solar: (components.solar[0]+components.solar[1])/2,
  };
  const total = Object.values(mids).reduce((a,b)=>a+b,0) || 1;
  const pct = {};
  for(const k in mids){
    pct[k] = Math.round((mids[k]/total)*100);
  }
  return pct;
}

function setBar(el, txtEl, value){
  const v = clamp(value, 0, 100);
  el.style.width = v + "%";
  txtEl.textContent = v + "%";
}

function render(){
  const { minAdj, maxAdj, components, featureCount } = estimateUplift();

  // Confidence tag is a narrative hint, not a scientific grade
  let conf = "Concept-only";
  if(featureCount >= 2) conf = "Early prototype";
  if(featureCount >= 4) conf = "Pilot-ready framing";
  if(featureCount >= 5 && discipline.value !== "low") conf = "Strong claim pathway";

  confidenceTag.textContent = conf;

  // Display uplift
  lifeUplift.textContent =
    `${minAdj.toFixed(1)}% to ${maxAdj.toFixed(1)}%`;

  // Drivers text
  const active = [];
  if(togAI.checked) active.push("AI stress rules");
  if(togThermalCase.checked) active.push("thermal uniformity");
  if(togAir.checked) active.push("micro-airflow");
  if(togHoney.checked) active.push("honeycomb isolation");
  if(togDamp.checked) active.push("vibration damping");
  if(togSolar.checked) active.push("maintenance trickle");
  drivers.textContent = active.length ? active.join(" ‚Ä¢ ") : "No features selected";

  // Bars
  const pct = contributionBars(components);
  setBar(barAI, barAITxt, pct.ai || 0);
  setBar(barCase, barCaseTxt, pct.tcase || 0);
  setBar(barAir, barAirTxt, pct.air || 0);
  setBar(barHoney, barHoneyTxt, pct.honey || 0);
  setBar(barDamp, barDampTxt, pct.damp || 0);
  setBar(barSolar, barSolarTxt, pct.solar || 0);

  // Assumption audit
  const baseLifeVal = parseFloat(baseLife.value || "0");
  const baseCostVal = parseFloat(baseCost.value || "0");

  // Use midpoint uplift for projection
  const mid = (minAdj + maxAdj)/2 / 100;
  const projectedLife = baseLifeVal * (1 + mid);

  projLife.textContent = isFinite(projectedLife)
    ? `${projectedLife.toFixed(1)} years (baseline ${baseLifeVal}y)`
    : "‚Äî";

  // Rough annual value uplift range based on cost
  const annualMin = baseCostVal * (minAdj/100);
  const annualMax = baseCostVal * (maxAdj/100);
  annualValue.textContent = isFinite(annualMin)
    ? `¬£${Math.round(annualMin).toLocaleString()} to ¬£${Math.round(annualMax).toLocaleString()}`
    : "‚Äî";

  savingsTag.textContent = baseCostVal
    ? `Against ~¬£${Math.round(baseCostVal).toLocaleString()}/yr baseline`
    : "Set baseline cost";

  // Diagram label refresh (light, just to keep story coherent)
  // We won't rewrite the ASCII art every keystroke; just keep inputs available.
}

// Presets
$("btnPresetFleet").addEventListener("click", () => {
  useCase.value = "ev_fleet";
  discipline.value = "med";
  ambient.value = 18;
  vibe.value = "high";
  togAI.checked = true;
  togThermalCase.checked = true;
  togAir.checked = true;
  togHoney.checked = true;
  togDamp.checked = true;
  togSolar.checked = false;
  render();
});

$("btnPresetLight").addEventListener("click", () => {
  useCase.value = "ev_light";
  discipline.value = "med";
  ambient.value = 15;
  vibe.value = "med";
  togAI.checked = true;
  togThermalCase.checked = true;
  togAir.checked = false;
  togHoney.checked = true;
  togDamp.checked = true;
  togSolar.checked = false;
  render();
});

$("btnPresetStationary").addEventListener("click", () => {
  useCase.value = "stationary";
  discipline.value = "high";
  ambient.value = 20;
  vibe.value = "low";
  togAI.checked = true;
  togThermalCase.checked = true;
  togAir.checked = false;
  togHoney.checked = false;
  togDamp.checked = false;
  togSolar.checked = false;
  render();
});

$("btnReset").addEventListener("click", () => {
  togAI.checked = true;
  togThermalCase.checked = true;
  togAir.checked = true;
  togHoney.checked = true;
  togDamp.checked = true;
  togSolar.checked = false;
  discipline.value = "med";
  useCase.value = "ev_fleet";
  vibe.value = "med";
  ambient.value = 18;
  baseLife.value = 8;
  baseCost.value = 20000;
  render();
});

// Re-render on any input change
[
  togAI, togThermalCase, togAir, togHoney, togDamp, togSolar,
  useCase, discipline, ambient, vibe,
  baseLife, baseCost,
  L_pack, W_pack, H_pack, P_hex
].forEach(el => el.addEventListener("input", render));

// Ensure first paint updates numbers
document.addEventListener("DOMContentLoaded", render);
render();


// --- qds_battery_habitat_v1_1_build_001.html ---

  // ---------- helpers ----------
  const $ = (id)=>document.getElementById(id);

  function setClaimBadge(levelText){
    const el = $("claimBadge");
    const map = {
      "concept-only":"concept",
      "early prototype":"early",
      "strong claim pathway":"strong",
      "pilot-ready framing":"early"
    };
    const cls = map[levelText] || "concept";
    el.className = `badge ${cls}`;
    el.textContent = levelText;
  }

  function pct(n){ return Math.max(0, Math.min(100, n)); }

  function updateSolarContext(useCase){
    const note = $("solarNote");
    const toggle = $("t_solar");
    const isStationary = /Stationary|Remote/i.test(useCase);
    note.style.display = isStationary ? "block" : "none";
    if(!isStationary) toggle.checked = false;
  }

  // ---------- demo scoring ----------
  function compute(){
    const ai = $("t_ai").checked;
    const cs = $("t_case").checked;
    const air = $("t_air").checked;
    const hex = $("t_hex").checked;
    const damp = $("t_damp").checked;
    const solar = $("t_solar").checked;

    const useCase = $("use_case").value;
    const discipline = $("discipline").value;
    const temp = Number($("temp").value || 18);
    const vibe = $("vibe").value;

    updateSolarContext(useCase);

    // Base contributions (demo-weighted)
    let w_ai=0, w_case=0, w_air=0, w_hex=0, w_damp=0, w_solar=0;
    if(ai)   w_ai   = 0.33;
    if(cs)   w_case = 0.22;
    if(air)  w_air  = 0.16;
    if(hex)  w_hex  = 0.18;
    if(damp) w_damp = 0.11;
    if(solar)w_solar= 0.05;

    // Context modifiers (light touch)
    const dutyBoost = /fleet/i.test(useCase) ? 1.08 : 1.0;
    const stationaryBoost = /Stationary/i.test(useCase) ? 0.95 : 1.0;

    const disciplineMod = discipline==="High" ? 1.08 : discipline==="Low" ? 0.92 : 1.0;
    const vibeMod = vibe==="High" ? 1.08 : vibe==="Low" ? 0.96 : 1.0;

    // temperature penalty if hot
    const tempMod = temp >= 30 ? 0.9 : temp <= 5 ? 0.97 : 1.0;

    // total stack strength
    const raw = (w_ai+w_case+w_air+w_hex+w_damp+w_solar);
    const context = dutyBoost * stationaryBoost * disciplineMod * vibeMod * tempMod;

    // Map raw -> uplift range (demo)
    const low = raw*0.35*100*context;
    const high = raw*0.85*100*context;

    // Label logic by stack completeness
    let label = "concept-only";
    const count = [ai,cs,air,hex,damp,solar].filter(Boolean).length;
    if(count >= 4) label = "early prototype";
    if(count >= 5 && /fleet|Stationary/i.test(useCase)) label = "strong claim pathway";

    $("uplift_range").textContent =
      `${(low).toFixed(1)}% to ${(high).toFixed(1)}%`;

    setClaimBadge(label);

    // Drivers text
    const drivers = [];
    if(ai) drivers.push("AI stress rules");
    if(cs) drivers.push("thermal uniformity");
    if(air) drivers.push("micro-airflow");
    if(hex) drivers.push("honeycomb isolation");
    if(damp) drivers.push("vibration damping");
    if(solar) drivers.push("maintenance trickle");
    $("drivers_text").textContent = drivers.length ? drivers.join(" ‚Ä¢ ") : "‚Äî";

    // Bars (normalise to 100)
    const comp = [
      ["AI rules", w_ai],
      ["Thermal case", w_case],
      ["Micro-airflow", w_air],
      ["Honeycomb", w_hex],
      ["Damping", w_damp],
      ["Solar maintenance", w_solar],
    ];
    const sum = comp.reduce((a,c)=>a+c[1],0) || 1;
    const bars = $("bars");
    bars.innerHTML = "";
    comp.forEach(([name,val])=>{
      const p = pct((val/sum)*100);
      const row = document.createElement("div");
      row.className = "barrow";
      row.innerHTML = `
        <div class="muted" style="font-size:12px;">${name}</div>
        <div class="bartrack"><div class="barfill" style="width:${p.toFixed(0)}%"></div></div>
        <div class="muted" style="font-size:11px; text-align:right;">${p.toFixed(0)}%</div>
      `;
      bars.appendChild(row);
    });

    // Assumption audit
    const baseYears = Number($("base_years").value || 8);
    const baseCost = Number($("base_cost").value || 20000);

    // Convert mid uplift to years (demo)
    const mid = (low+high)/2 / 100;
    const projYears = baseYears * (1 + mid*0.18); // conservative conversion
    $("proj_years").textContent = `${projYears.toFixed(1)} years (baseline ${baseYears}y)`;

    // Value uplift (very rough demo)
    const valueLow = baseCost * mid * 0.55;
    const valueHigh = baseCost * mid * 1.35;
    $("proj_value").textContent = `¬£${valueLow.toFixed(0)} to ¬£${valueHigh.toFixed(0)}`;
  }

  // ---------- presets ----------
  function setPreset(type){
    if(type==="fleet"){
      $("use_case").value = "EV ‚Äî fleet / courier (high duty)";
      $("discipline").value = "Medium";
      $("vibe").value = "Medium";
      $("temp").value = 18;
      $("t_ai").checked = true;
      $("t_case").checked = true;
      $("t_air").checked = true;
      $("t_hex").checked = true;
      $("t_damp").checked = false;
      $("t_solar").checked = false;
    }
    if(type==="light"){
      $("use_case").value = "EV ‚Äî light personal";
      $("discipline").value = "High";
      $("vibe").value = "Low";
      $("temp").value = 16;
      $("t_ai").checked = true;
      $("t_case").checked = true;
      $("t_air").checked = false;
      $("t_hex").checked = true;
      $("t_damp").checked = false;
      $("t_solar").checked = false;
    }
    if(type==="stationary"){
      $("use_case").value = "Stationary ‚Äî storage / microgrid";
      $("discipline").value = "High";
      $("vibe").value = "Low";
      $("temp").value = 20;
      $("t_ai").checked = true;
      $("t_case").checked = true;
      $("t_air").checked = true;
      $("t_hex").checked = true;
      $("t_damp").checked = false;
      $("t_solar").checked = true;
    }
    compute();
  }

  function resetToggles(){
    $("t_ai").checked = false;
    $("t_case").checked = false;
    $("t_air").checked = false;
    $("t_hex").checked = false;
    $("t_damp").checked = false;
    $("t_solar").checked = false;
    compute();
  }

  // ---------- wiring ----------
  document.addEventListener("DOMContentLoaded", ()=>{
    [
      "t_ai","t_case","t_air","t_hex","t_damp","t_solar",
      "use_case","discipline","temp","vibe",
      "base_years","base_cost"
    ].forEach(id=>{
      $(id).addEventListener("change", compute);
      $(id).addEventListener("input", compute);
    });

    $("preset_fleet").addEventListener("click", ()=>setPreset("fleet"));
    $("preset_light").addEventListener("click", ()=>setPreset("light"));
    $("preset_stationary").addEventListener("click", ()=>setPreset("stationary"));
    $("reset_all").addEventListener("click", resetToggles);

    compute();
  });


// --- qds_battery_habitat_v1_2_build002.html ---

(() => {
  // --- Feature base weights (relative contribution to stress reduction) ---
  const W = {
    ai: 0.34,
    case: 0.23,
    air: 0.17,
    hex: 0.19,
    damp: 0.12,
    solar: 0.06
  };

  // --- Context multipliers (stress environment intensity) ---
  const USE = {
    fleet: 1.00,
    light: 0.72,
    stationary: 0.88
  };

  const DISCIPLINE = {
    low: 1.08,   // more chaos -> more upside from good control
    med: 1.00,
    high: 0.92
  };

  const VIBE = {
    low: 0.90,
    med: 1.00,
    high: 1.10
  };

  function tempFactor(t){
    // Hotter environments increase value of thermal control.
    if (t <= 0) return 0.92;
    if (t <= 10) return 0.96;
    if (t <= 20) return 1.00;
    if (t <= 30) return 1.06;
    if (t <= 40) return 1.12;
    return 1.18;
  }

  // --- Maturity mapping ---
  // rawScore is 0..~1 from selected features
  const LEVEL_MAP = {
    concept: { lowMul: 0.10, highMul: 0.22, capLow: 14, capHigh: 24, pill:"concept-only" },
    early:   { lowMul: 0.14, highMul: 0.30, capLow: 18, capHigh: 30, pill:"early prototype" },
    strong:  { lowMul: 0.18, highMul: 0.38, capLow: 20, capHigh: 32, pill:"strong claim pathway" }
  };

  // --- DOM ---
  const $ = (id) => document.getElementById(id);

  const toggles = {
    ai: $("f_ai"),
    case: $("f_case"),
    air: $("f_air"),
    hex: $("f_hex"),
    damp: $("f_damp"),
    solar: $("f_solar")
  };

  const bars = {
    ai: $("bar_ai"), case: $("bar_case"), air: $("bar_air"),
    hex: $("bar_hex"), damp: $("bar_damp"), solar: $("bar_solar")
  };

  const pcts = {
    ai: $("pct_ai"), case: $("pct_case"), air: $("pct_air"),
    hex: $("pct_hex"), damp: $("pct_damp"), solar: $("pct_solar")
  };

  let level = "concept";

  function selectedWeights(){
    const s = {};
    Object.keys(W).forEach(k => s[k] = toggles[k].checked ? W[k] : 0);
    return s;
  }

  function normalisedContrib(sw){
    const total = Object.values(sw).reduce((a,b)=>a+b,0) || 1;
    const out = {};
    Object.keys(sw).forEach(k => out[k] = sw[k]/total);
    return { out, total };
  }

  function computeRawScore(sw, ctx){
    // Sum of enabled weights, mildly boosted by context stress
    const base = Object.values(sw).reduce((a,b)=>a+b,0); // 0..~1.1
    // Convert to skillful diminishing returns curve
    const curved = 1 - Math.exp(-2.2 * base); // 0..~0.9
    return curved * ctx;
  }

  function contextMultiplier(){
    const use = $("useCase").value;
    const disc = $("discipline").value;
    const vibe = $("vibe").value;
    const temp = Number($("tempC").value || 18);

    return USE[use] * DISCIPLINE[disc] * VIBE[vibe] * tempFactor(temp);
  }

  function updateSolarGate(){
    const use = $("useCase").value;
    const note = $("solarNote");

    // Show helpful note when solar is enabled or use-case is stationary.
    const show = toggles.solar.checked || use === "stationary";
    note.style.display = show ? "block" : "none";

    // Soft hint: if fleet selected, solar is de-emphasised in contribution.
  }

  function updateASCII(){
    const L = Number($("L_pack").value || 1200);
    const Wp = Number($("W_pack").value || 800);
    const H = Number($("H_pack").value || 140);
    const P = Number($("P_hex").value || 55);

    $("asciiBox").textContent =
`PACK TOP VIEW (concept)
<------------------------------ L_pack ------------------------------>

+-------------------------------------------------------------------+
|                                                                   |
|   HONEYCOMB MODULE BAY BLOCKS                                     |
|                                                                   |
|     +--------------------+      +--------------------+            |
|     | BAY A (hex array)  |      | BAY B (hex array)  |            |
|     +--------------------+      +--------------------+            |
|                                                                   |
|     +--------------------+      +--------------------+            |
|     | BAY C (hex array)  |      | BAY D (hex array)  |            |
|     +--------------------+      +--------------------+            |
|                                                                   |
|   Service edge: connectors, fuses, BMS, vent routing              |
|                                                                   |
+-------------------------------------------------------------------+
<------------------------------ W_pack ------------------------------>

CROSS-SECTION STACK (concept)
[A] Outer Sacrificial Skin        t_A
[B] Damping/Impact Layer          t_B
[C] Thermal + Micro-Airflow       t_C   (channels d_air)
[D] Honeycomb Cradle              h_hex (walls t_hex, pads t_pad)
[E] Structural Inner Tray         t_E
[F] Service Zone                  h_srv

Example dimensions (placeholders)
L_pack = ${L} mm
W_pack = ${Wp} mm
H_pack = ${H} mm
Honeycomb pitch P_hex = ${P} mm`;
  }

  function updateROI(upliftMid){
    const baseLife = Number($("baseLife").value || 8);
    const baseCost = Number($("baseCost").value || 0);

    // Translate uplift into life extension factor (conservative)
    const lifeGain = upliftMid * 0.55; // not 1:1; keeps honest
    const newLife = baseLife * (1 + lifeGain);

    $("projLife").textContent =
      `Projected life: ${newLife.toFixed(1)} years (baseline ${baseLife}y)`;

    // Annual value band (simple proportional story)
    const lowVal = baseCost * Math.max(0, upliftMid * 0.35);
    const highVal = baseCost * Math.max(0, upliftMid * 0.75);

    const fmt = (n) => "¬£" + Math.round(n).toLocaleString("en-GB");

    $("roiBand").textContent =
      `Rough annual value uplift: ${fmt(lowVal)} to ${fmt(highVal)}`;
  }

  function updateImpact(){
    updateSolarGate();

    const sw = selectedWeights();
    const { out } = normalisedContrib(sw);

    // Apply soft solar de-weighting outside stationary context
    const use = $("useCase").value;
    if(use !== "stationary"){
      out.solar = out.solar * 0.35;
      // re-normalise after adjustment
      const tot = Object.values(out).reduce((a,b)=>a+b,0) || 1;
      Object.keys(out).forEach(k => out[k] = out[k]/tot);
    }

    // Bars
    Object.keys(out).forEach(k => {
      const pct = Math.round(out[k] * 100);
      bars[k].style.width = pct + "%";
      pcts[k].textContent = pct + "%";
    });

    // Context + raw score
    const ctx = contextMultiplier();
    const raw = computeRawScore(sw, ctx);

    const L = LEVEL_MAP[level];

    // Uplift in fraction terms (0..)
    let low = raw * L.lowMul;
    let high = raw * L.highMul;

    // Convert to percent
    low = low * 100;
    high = high * 100;

    // Caps per maturity
    low = Math.min(low, L.capLow);
    high = Math.min(high, L.capHigh);

    // Ensure ordering sanity
    if(high < low) high = low + 1;

    $("upliftRange").innerHTML =
      `${low.toFixed(1)}% to ${high.toFixed(1)}% <small>(capped for credibility)</small>`;

    $("levelPill").textContent = L.pill;

    // Takeaway line stays constant but feels purposeful
    $("takeawayLine").textContent =
      "Expected real-world win: fewer stress events + better thermal uniformity + safer modular isolation.";

    // ROI uses midpoint
    const mid = ((low + high) / 2) / 100;
    updateROI(mid);
  }

  // --- Legend interaction ---
  $("rangeLegend").addEventListener("click", (e) => {
    const b = e.target.closest(".badge");
    if(!b) return;
    document.querySelectorAll(".badge").forEach(x => x.classList.remove("active"));
    b.classList.add("active");
    level = b.dataset.level;
    updateImpact();
  });

  // --- Presets ---
  $("presetFleet").onclick = () => {
    $("useCase").value = "fleet";
    $("discipline").value = "med";
    $("tempC").value = 18;
    $("vibe").value = "med";
    toggles.ai.checked = true;
    toggles.case.checked = true;
    toggles.air.checked = true;
    toggles.hex.checked = true;
    toggles.damp.checked = false;
    toggles.solar.checked = false;
    level = "early";
    syncLegend();
    updateAll();
  };

  $("presetLight").onclick = () => {
    $("useCase").value = "light";
    $("discipline").value = "high";
    $("tempC").value = 16;
    $("vibe").value = "low";
    toggles.ai.checked = true;
    toggles.case.checked = true;
    toggles.air.checked = false;
    toggles.hex.checked = true;
    toggles.damp.checked = false;
    toggles.solar.checked = false;
    level = "concept";
    syncLegend();
    updateAll();
  };

  $("presetStationary").onclick = () => {
    $("useCase").value = "stationary";
    $("discipline").value = "high";
    $("tempC").value = 20;
    $("vibe").value = "low";
    toggles.ai.checked = true;
    toggles.case.checked = true;
    toggles.air.checked = true;
    toggles.hex.checked = true;
    toggles.damp.checked = false;
    toggles.solar.checked = true;
    level = "strong";
    syncLegend();
    updateAll();
  };

  $("resetAll").onclick = () => {
    Object.values(toggles).forEach(t => t.checked = false);
    toggles.ai.checked = true;
    level = "concept";
    syncLegend();
    updateAll();
  };

  function syncLegend(){
    document.querySelectorAll(".badge").forEach(x => {
      x.classList.toggle("active", x.dataset.level === level);
    });
  }

  function updateAll(){
    updateASCII();
    updateImpact();
  }

  // --- Listeners ---
  [...Object.values(toggles)].forEach(t => t.addEventListener("change", updateImpact));
  ["useCase","discipline","tempC","vibe","baseLife","baseCost"]
    .forEach(id => $(id).addEventListener("input", updateImpact));

  ["L_pack","W_pack","H_pack","P_hex"]
    .forEach(id => $(id).addEventListener("input", updateASCII));

  // Init
  syncLegend();
  updateAll();
})();


// --- qds_business_projection_posh_v1.html ---

  const money = n => "¬£" + Math.round(n).toLocaleString("en-GB");

  function getNum(id){ return Number(document.getElementById(id).value || 0); }

  function seriesCount(c1, grow){
    const yrs = [];
    let c = Math.max(0, c1);
    for(let i=0;i<5;i++){
      yrs.push(c);
      c = c * (1 + grow);
    }
    return yrs;
  }

  function recalc(){
    const batC = seriesCount(getNum("batC1"), getNum("batCG"));
    const forC = seriesCount(getNum("forC1"), getNum("forCG"));
    const cmpL = seriesCount(getNum("cmpL1"), getNum("cmpLG"));

    const batARPU = getNum("batARPU");
    const forARPU = getNum("forARPU");
    const cmpFee  = getNum("cmpFee");

    const salaryY1 = getNum("salaryY1");
    const sGrow = getNum("salaryGrow");

    const opY1 = getNum("opY1");
    const opGrow = getNum("opGrow");

    const tbody = document.querySelector("#tbl tbody");
    tbody.innerHTML = "";

    let tBat=0,tCmp=0,tFor=0,tRev=0,tSal=0,tOps=0,tNet=0;

    for(let y=1;y<=5;y++){
      const i = y-1;
      const batRev = batC[i]*batARPU;
      const cmpRev = cmpL[i]*cmpFee;
      const forRev = forC[i]*forARPU;
      const total  = batRev + cmpRev + forRev;

      const sal = salaryY1 * Math.pow(1+sGrow, i);
      const ops = opY1 * Math.pow(1+opGrow, i);
      const net = total - sal - ops;

      tBat+=batRev; tCmp+=cmpRev; tFor+=forRev; tRev+=total;
      tSal+=sal; tOps+=ops; tNet+=net;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>Year ${y}</td>
        <td class="money">${money(batRev)}</td>
        <td class="money">${money(cmpRev)}</td>
        <td class="money">${money(forRev)}</td>
        <td class="money">${money(total)}</td>
        <td class="soft">${money(sal)}</td>
        <td class="soft">${money(ops)}</td>
        <td class="${net>=0 ? 'money' : 'warn'}">${money(net)}</td>
      `;
      tbody.appendChild(tr);
    }

    document.getElementById("tBat").textContent = money(tBat);
    document.getElementById("tCmp").textContent = money(tCmp);
    document.getElementById("tFor").textContent = money(tFor);
    document.getElementById("tRev").textContent = money(tRev);
    document.getElementById("tSal").textContent = money(tSal);
    document.getElementById("tOps").textContent = money(tOps);
    document.getElementById("tNet").textContent = money(tNet);
  }

  function fillConservative(){
    seed.value=150000;
    salaryY1.value=32000; salaryGrow.value=0.08;
    batC1.value=1; batCG.value=0.50; batARPU.value=16000;
    cmpL1.value=1; cmpLG.value=0.60; cmpFee.value=20000;
    forC1.value=2; forCG.value=0.40; forARPU.value=10000;
    opY1.value=20000; opGrow.value=0.12;
    recalc();
  }

  function fillBase(){
    seed.value=150000;
    salaryY1.value=36000; salaryGrow.value=0.12;
    batC1.value=2; batCG.value=0.80; batARPU.value=18000;
    cmpL1.value=1; cmpLG.value=1.10; cmpFee.value=25000;
    forC1.value=3; forCG.value=0.60; forARPU.value=12000;
    opY1.value=22000; opGrow.value=0.15;
    recalc();
  }

  function fillOptimistic(){
    seed.value=150000;
    salaryY1.value=42000; salaryGrow.value=0.15;
    batC1.value=3; batCG.value=1.10; batARPU.value=22000;
    cmpL1.value=2; cmpLG.value=1.40; cmpFee.value=32000;
    forC1.value=4; forCG.value=0.90; forARPU.value=15000;
    opY1.value=26000; opGrow.value=0.18;
    recalc();
  }

  // auto-recalc on input
  document.querySelectorAll("input").forEach(i=>{
    i.addEventListener("input", ()=>recalc());
  });

  recalc();


// --- frontdoor_show.html ---


// --- qds_revenue_floor_STRETCH.html ---

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);

function num(id, def=0){
  const el = $(id);
  if(!el) return def;
  const v = parseFloat(String(el.value ?? "").trim());
  return Number.isFinite(v) ? v : def;
}
function clamp(x, a, b){
  if(!Number.isFinite(x)) return a;
  return Math.min(b, Math.max(a, x));
}
function fmtMoney(x){
  const cur = String($("currency").value || "¬£").trim() || "¬£";
  const n = Number.isFinite(x) ? x : 0;
  const rounded = Math.round(n);
  return cur + rounded.toLocaleString();
}

/* ---------- Core model ---------- */
function computeModel(){
  const L = Math.max(0, num("L"));
  const q = clamp(num("q"), 0, 1);
  const s = clamp(num("s"), 0, 1);
  const p = clamp(num("p"), 0, 1);
  const r = clamp(num("r"), 0, 1);

  const Sprice = Math.max(0, num("Sprice"));
  const Pprice = Math.max(0, num("Pprice"));
  const Rprice = Math.max(0, num("Rprice"));

  const Smax = Math.max(0, num("Smax"));
  const Pmax = Math.max(0, num("Pmax"));

  const M0 = Math.max(0, num("M0"));
  const churnPct = clamp(num("churn"), 0, 50);
  const churn = churnPct / 100;

  const months = clamp(Math.round(num("months", 12)), 1, 60);

  const qualified = L * q;
  const sprintsRaw = qualified * s;
  const sprints = Math.min(sprintsRaw, Smax);

  const pilotsRaw = sprints * p;
  const pilots = Math.min(pilotsRaw, Pmax);

  const newRetainers = pilots * r;

  const newMrr = newRetainers * Rprice;

  const revMonth = (sprints * Sprice) + (pilots * Pprice) + newMrr;
  const revYear = revMonth * 12;

  // MRR accumulation over horizon
  let mrr = M0;
  const mrrTimeline = [mrr];
  for(let i=1;i<=months;i++){
    mrr = (mrr + newMrr) * (1 - churn);
    mrrTimeline.push(mrr);
  }

  const at = (n)=>{
    const idx = clamp(n, 0, months);
    return mrrTimeline[idx];
  };

  return {
    L,q,s,p,r,Sprice,Pprice,Rprice,Smax,Pmax,M0,churnPct,churn,months,
    qualified,sprintsRaw,sprints,pilotsRaw,pilots,newRetainers,newMrr,
    revMonth,revYear,mrrTimeline,
    mrr3: at(3), mrr6: at(6), mrr12: at(12), mrrEnd: at(months)
  };
}

/* ---------- Presets ---------- */
const PRESETS = {
  conservative: {
    L:6, q:0.40, s:0.30, p:0.30, r:0.25,
    Sprice:2000, Pprice:5000, Rprice:1500,
    Smax:4, Pmax:2, M0:0, churn:4
  },
  base: {
    L:12, q:0.50, s:0.35, p:0.40, r:0.30,
    Sprice:2500, Pprice:6000, Rprice:2000,
    Smax:6, Pmax:3, M0:0, churn:3
  },
  optimistic: {
    L:20, q:0.60, s:0.45, p:0.45, r:0.40,
    Sprice:3000, Pprice:8000, Rprice:2500,
    Smax:8, Pmax:4, M0:0, churn:2
  }
};

function applyPreset(){
  const key = $("preset")?.value || "base";
  const p = PRESETS[key] || PRESETS.base;

  $("L").value = p.L;
  $("q").value = p.q;
  $("s").value = p.s;
  $("p").value = p.p;
  $("r").value = p.r;

  $("Sprice").value = p.Sprice;
  $("Pprice").value = p.Pprice;
  $("Rprice").value = p.Rprice;

  $("Smax").value = p.Smax;
  $("Pmax").value = p.Pmax;

  $("M0").value = p.M0;
  $("churn").value = p.churn;
}

/* ---------- Sensitivity ---------- */
function buildSensitivity(base){
  const rows = [];

  function calcWith(patch){
    // temporarily apply patch values, compute, then restore
    const ids = Object.keys(patch);
    const old = {};
    ids.forEach(id=>{
      old[id] = $(id).value;
      $(id).value = patch[id];
    });
    const m = computeModel();
    ids.forEach(id=>$(id).value = old[id]);
    return m.revYear;
  }

  const baseYear = base.revYear;

  // +1 lead
  rows.push({
    label: "+1 lead / month",
    delta: calcWith({L: num("L")+1}) - baseYear
  });

  // +0.10 sprint close
  rows.push({
    label: "+0.10 sprint close rate",
    delta: calcWith({s: clamp(num("s")+0.10, 0, 1)}) - baseYear
  });

  // +1 sprint capacity
  rows.push({
    label: "+1 sprint capacity",
    delta: calcWith({Smax: num("Smax")+1}) - baseYear
  });

  // +0.05 pilot-from-sprint
  rows.push({
    label: "+0.05 pilot-from-sprint",
    delta: calcWith({p: clamp(num("p")+0.05, 0, 1)}) - baseYear
  });

  // +0.05 retainer-from-pilot
  rows.push({
    label: "+0.05 retainer-from-pilot",
    delta: calcWith({r: clamp(num("r")+0.05, 0, 1)}) - baseYear
  });

  const body = $("sensBody");
  body.innerHTML = "";
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const td1 = document.createElement("td");
    const td2 = document.createElement("td");
    td1.textContent = r.label;
    td2.textContent = fmtMoney(r.delta);
    tr.appendChild(td1); tr.appendChild(td2);
    body.appendChild(tr);
  });
}

/* ---------- Board summary ---------- */
function buildBoardSummary(m){
  const capNote = String($("capNotes").value || "").trim();
  const cost = Math.max(0, num("cost"));

  const conf = {
    q: $("qConf")?.value || "Med",
    s: $("sConf")?.value || "Med",
    p: $("pConf")?.value || "Med",
    r: $("rConf")?.value || "Med",
    c: $("cConf")?.value || "Med",
  };

  const notes = {
    q: String($("qNote")?.value || "").trim(),
    s: String($("sNote")?.value || "").trim(),
    p: String($("pNote")?.value || "").trim(),
    r: String($("rNote")?.value || "").trim(),
    c: String($("cNote")?.value || "").trim(),
  };

  const parts = [];
  parts.push(
    `Revenue floor model (capacity-truthed): ` +
    `${m.L} leads/mo ‚Üí q ${m.q.toFixed(2)} ‚Üí s ${m.s.toFixed(2)} ‚Üí p ${m.p.toFixed(2)} ‚Üí r ${m.r.toFixed(2)}.`
  );
  parts.push(
    `Pricing: Sprint ${fmtMoney(m.Sprice)}, Pilot ${fmtMoney(m.Pprice)}, Retainer ${fmtMoney(m.Rprice)}/mo.`
  );
  parts.push(
    `Capacity: Smax ${m.Smax}, Pmax ${m.Pmax}` + (capNote ? ` (${capNote})` : "") + `.`
  );
  parts.push(
    `Expected/month: ${m.sprints.toFixed(2)} sprints, ${m.pilots.toFixed(2)} pilots, ${m.newRetainers.toFixed(2)} new retainers.`
  );
  parts.push(
    `Run-rate: ${fmtMoney(m.revMonth)}/mo (${fmtMoney(m.revYear)}/yr).`
  );
  parts.push(
    `MRR: M0 ${fmtMoney(m.M0)}, churn ${m.churnPct.toFixed(1)}%. New MRR ${fmtMoney(m.newMrr)}/mo ‚Üí projected MRR @ ${m.months} months ${fmtMoney(m.mrrEnd)}.`
  );
  if(cost>0){
    parts.push(`Cost base noted: ${fmtMoney(cost)}/mo (for margin context, not enforced in calc).`);
  }

  const confLine =
    `Assumption confidence: q ${conf.q}, s ${conf.s}, p ${conf.p}, r ${conf.r}, churn ${conf.c}.`;
  parts.push(confLine);

  const ev = [];
  if(notes.q) ev.push(`q: ${notes.q}`);
  if(notes.s) ev.push(`s: ${notes.s}`);
  if(notes.p) ev.push(`p: ${notes.p}`);
  if(notes.r) ev.push(`r: ${notes.r}`);
  if(notes.c) ev.push(`c: ${notes.c}`);
  if(ev.length) parts.push(`Evidence: ${ev.join(" | ")}`);

  parts.push(`This model is deliberately conservative: upside comes from more leads, better close rates, and capacity expansion ‚Äî not inflated assumptions.`);

  return parts.join(" ");
}

/* ---------- Render ---------- */
function render(){
  const m = computeModel();

  // update audit value cells
  $("qValCell").textContent = m.q.toFixed(2);
  $("sValCell").textContent = m.s.toFixed(2);
  $("pValCell").textContent = m.p.toFixed(2);
  $("rValCell").textContent = m.r.toFixed(2);
  $("cValCell").textContent = m.churnPct.toFixed(1) + "%";

  // KPIs
  $("revMonth").textContent = fmtMoney(m.revMonth);
  $("revYear").textContent = fmtMoney(m.revYear);
  $("newMrr").textContent = fmtMoney(m.newMrr);
  $("mrrEnd").textContent = fmtMoney(m.mrrEnd);
  $("mrrEndSub").textContent = `MRR after churn @ ${m.months} months`;

  // volumes
  $("volumesBox").innerHTML =
    `Qualified: ${m.qualified.toFixed(2)}<br/>` +
    `Sprints: ${m.sprints.toFixed(2)} (raw ${m.sprintsRaw.toFixed(2)})<br/>` +
    `Pilots: ${m.pilots.toFixed(2)} (raw ${m.pilotsRaw.toFixed(2)})<br/>` +
    `New retainers: ${m.newRetainers.toFixed(2)}`;

  // MRR accumulation snapshot
  $("mrrBox").innerHTML =
    `Starting: ${fmtMoney(m.M0)}<br/>` +
    `MRR @ 3 months: ${fmtMoney(m.mrr3)}<br/>` +
    `MRR @ 6 months: ${fmtMoney(m.mrr6)}<br/>` +
    `MRR @ 12 months: ${fmtMoney(m.mrr12)}`;

  // sensitivity
  buildSensitivity(m);

  // board summary
  const summary = buildBoardSummary(m);
  $("boardSummary").value = summary;

  // status pill
  $("statusPill").textContent = "Live";
}

/* ---------- One-pager + Print ---------- */
function toggleView(){
  document.body.classList.toggle("onepager");
}
function printOnePager(){
  // ensure onepager layout for print, but restore after
  const was = document.body.classList.contains("onepager");
  if(!was) document.body.classList.add("onepager");
  window.print();
  if(!was) document.body.classList.remove("onepager");
}

/* ---------- Copy summary ---------- */
async function copySummary(){
  const text = $("boardSummary").value || "";
  try{
    await navigator.clipboard.writeText(text);
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }catch(e){
    // fallback
    $("boardSummary").select();
    document.execCommand("copy");
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }
}

/* ---------- Reset ---------- */
function resetBase(){
  $("preset").value = "base";
  applyPreset();
  $("currency").value = "¬£";
  $("months").value = 12;
  $("Smax").value = 6;
  $("Pmax").value = 3;
  $("M0").value = 0;
  $("churn").value = 3;
  $("cost").value = 200;
  $("capNotes").value = "";

  // audit defaults
  ["qConf","sConf","pConf","rConf","cConf"].forEach(id=>{ if($(id)) $(id).value="Med"; });
  ["qNote","sNote","pNote","rNote","cNote"].forEach(id=>{ if($(id)) $(id).value=""; });

  render();
}

/* ---------- Bulletproof wiring ---------- */
function attachListeners(){
  document.querySelectorAll("input, select, textarea").forEach(el=>{
    const handler = ()=>{
      if(el.id === "preset"){ applyPreset(); }
      render();
    };
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  $("toggleViewBtn").addEventListener("click", toggleView);
  $("printBtn").addEventListener("click", printOnePager);
  $("copySummaryBtn").addEventListener("click", copySummary);
  $("resetBtn").addEventListener("click", resetBase);
}

applyPreset();
attachListeners();
render();


// --- qds_variance_lab.html ---

    // Simple QDS variance tester
    const AInput   = document.getElementById('A');
    const pInput   = document.getElementById('p');
    const tolInput = document.getElementById('tol');

    const RInput   = document.getElementById('R_in');
    const obsInput = document.getElementById('obs_in');

    const addBtn    = document.getElementById('addBtn');
    const clearBtn  = document.getElementById('clearBtn');
    const recalcBtn = document.getElementById('recalcBtn');

    const tableBody = document.querySelector('#dataTable tbody');
    const summaryEl = document.getElementById('summaryText');

    const canvas = document.getElementById('chart');
    const ctx    = canvas.getContext('2d');

    let points = []; // {R, obs, pred, diff, rel}

    function computePred(R, A, p) {
      // œÉ(H)/H = A * R^(-p), convert to percent for display
      return 100 * A * Math.pow(R, -p);
    }

    function recalcAll() {
      const A   = parseFloat(AInput.value)   || 0;
      const p   = parseFloat(pInput.value)   || 0;
      const tol = parseFloat(tolInput.value) || 0;

      points = points.map(pt => {
        const pred = computePred(pt.R, A, p);
        const diff = pt.obs - pred;
        const rel  = pred !== 0 ? (diff / pred) * 100 : 0;
        return { ...pt, pred, diff, rel, tol };
      });

      renderTable();
      renderSummary();
      drawChart();
    }

    function addPoint() {
      const Rval   = parseFloat(RInput.value);
      const obsVal = parseFloat(obsInput.value);
      if (!isFinite(Rval) || !isFinite(obsVal) || Rval <= 0) {
        alert('Please enter a valid radius (R > 0) and observed % value.');
        return;
      }

      const A   = parseFloat(AInput.value)   || 0;
      const p   = parseFloat(pInput.value)   || 0;
      const tol = parseFloat(tolInput.value) || 0;

      const pred = computePred(Rval, A, p);
      const diff = obsVal - pred;
      const rel  = pred !== 0 ? (diff / pred) * 100 : 0;

      points.push({ R: Rval, obs: obsVal, pred, diff, rel, tol });
      RInput.value = '';
      obsInput.value = '';

      renderTable();
      renderSummary();
      drawChart();
    }

    function clearAll() {
      if (!confirm('Clear all data points?')) return;
      points = [];
      renderTable();
      renderSummary();
      drawChart();
    }

    function renderTable() {
      tableBody.innerHTML = '';
      const tol = parseFloat(tolInput.value) || 0;

      points.forEach((pt, idx) => {
        const tr = document.createElement('tr');

        const pass = Math.abs(pt.rel) <= tol;
        const pill = document.createElement('span');
        pill.className = 'pill ' + (pass ? 'pill-pass' : 'pill-fail');
        pill.textContent = pass ? 'PASS' : 'FAIL';

        tr.innerHTML = `
          <td>${idx + 1}</td>
          <td>${pt.R.toFixed(1)}</td>
          <td>${pt.obs.toFixed(3)}</td>
          <td>${pt.pred.toFixed(3)}</td>
          <td>${pt.rel.toFixed(1)}</td>
          <td></td>
        `;
        tr.lastElementChild.appendChild(pill);
        tableBody.appendChild(tr);
      });
    }

    function renderSummary() {
      if (points.length === 0) {
        summaryEl.textContent = 'No points yet. Add a few radii and observed scatters to see how QDS behaves.';
        return;
      }
      const tol  = parseFloat(tolInput.value) || 0;
      const n    = points.length;
      const pass = points.filter(pt => Math.abs(pt.rel) <= tol).length;
      const frac = (pass / n) * 100;

      const minR = Math.min(...points.map(p => p.R));
      const maxR = Math.max(...points.map(p => p.R));
      summaryEl.textContent =
        `Points: ${n} | Within tolerance: ${pass} (${frac.toFixed(1)}%) | ` +
        `R range: ${minR.toFixed(1)} ‚Äì ${maxR.toFixed(1)} Mpc | ` +
        `Tolerance: ¬±${tol.toFixed(0)}% of QDS prediction.`;
    }

    function drawChart() {
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      // Background
      ctx.fillStyle = '#020617';
      ctx.fillRect(0, 0, w, h);

      ctx.save();
      ctx.translate(48, 16);
      const plotW = w - 64;
      const plotH = h - 48;

      // No points: draw frame only
      let minR = 1, maxR = 100;
      let minY = 0, maxY = 10;

      if (points.length > 0) {
        minR = Math.min(...points.map(p => p.R));
        maxR = Math.max(...points.map(p => p.R));
        const ys = points.map(p => p.obs).concat(points.map(p => p.pred));
        minY = Math.min(...ys);
        maxY = Math.max(...ys);
      }

      if (minR === maxR) { maxR = minR + 1; }
      if (minY === maxY) { maxY = minY + 1; }

      // Pad a bit
      const padR = 0.1 * (maxR - minR);
      const padY = 0.2 * (maxY - minY);
      minR -= padR; maxR += padR;
      minY = Math.max(0, minY - padY);
      maxY += padY;

      function xScale(R) {
        return ((R - minR) / (maxR - minR)) * plotW;
      }
      function yScale(y) {
        return plotH - ((y - minY) / (maxY - minY)) * plotH;
      }

      // Axes
      ctx.strokeStyle = '#1f2937';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, yScale(0));
      ctx.lineTo(plotW, yScale(0));
      ctx.moveTo(0, 0);
      ctx.lineTo(0, plotH);
      ctx.stroke();

      ctx.fillStyle = '#64748b';
      ctx.font = '10px system-ui';

      // Simple ticks
      const tickCount = 4;
      for (let i = 0; i <= tickCount; i++) {
        const tY = minY + (i / tickCount) * (maxY - minY);
        const y = yScale(tY);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(plotW, y);
        ctx.strokeStyle = 'rgba(100,116,139,0.25)';
        ctx.stroke();
        ctx.fillText(tY.toFixed(1) + '%', -40, y + 3);
      }

      ctx.fillText('R (Mpc)', plotW - 40, plotH + 14);
      ctx.fillText('œÉ(H)/H (%)', -4, -6);

      // Draw QDS predicted curve if we have at least one point
      const A   = parseFloat(AInput.value) || 0;
      const p   = parseFloat(pInput.value) || 0;

      if (points.length > 0 && A > 0) {
        ctx.beginPath();
        for (let i = 0; i <= 80; i++) {
          const t = i / 80;
          const R = minR + t * (maxR - minR);
          if (R <= 0) continue;
          const y = computePred(R, A, p);
          const xPix = xScale(R);
          const yPix = yScale(y);
          if (i === 0) ctx.moveTo(xPix, yPix);
          else ctx.lineTo(xPix, yPix);
        }
        ctx.strokeStyle = '#38bdf8';
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Draw observed points
      points.forEach(pt => {
        const x = xScale(pt.R);
        const y = yScale(pt.obs);
        const pass = Math.abs(pt.rel) <= (parseFloat(tolInput.value) || 0);
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = pass ? '#22c55e' : '#f97316';
        ctx.fill();
      });

      ctx.restore();
    }

    // Wire up events
    addBtn.addEventListener('click', addPoint);
    clearBtn.addEventListener('click', clearAll);
    recalcBtn.addEventListener('click', recalcAll);

    AInput.addEventListener('change', recalcAll);
    pInput.addEventListener('change', recalcAll);
    tolInput.addEventListener('change', recalcAll);

    // Initial draw
    drawChart();
  

// --- qds_micro_lab.html ---

    const sigma2Input = document.getElementById('sigma2');
    const tauInput    = document.getElementById('tau');
    const lambdaInput = document.getElementById('lambda');
    const recalcBtn   = document.getElementById('recalcBtn');

    const tProbeInput = document.getElementById('tProbe');
    const rProbeInput = document.getElementById('rProbe');
    const probeBtn    = document.getElementById('probeBtn');

    const outSigma2 = document.getElementById('outSigma2');
    const outK      = document.getElementById('outK');
    const outKRel   = document.getElementById('outKRel');
    const outTfac   = document.getElementById('outTfac');
    const outRfac   = document.getElementById('outRfac');

    const canvas = document.getElementById('chart');
    const ctx    = canvas.getContext('2d');

    function K_norm_t(t, tau) {
      if (tau <= 0) return 0;
      return Math.exp(-Math.abs(t) / tau);
    }

    function K_norm_r(r, lambdaC) {
      if (lambdaC <= 0) return 0;
      const x = r / lambdaC;
      return Math.exp(-0.5 * x * x);
    }

    function recomputeCurves() {
      drawChart();
      // also refresh probe display if something is already there
      if (outK.textContent !== '‚Äî') {
        doProbe();
      }
    }

    function doProbe() {
      const sigma2 = parseFloat(sigma2Input.value) || 0;
      const tau    = parseFloat(tauInput.value)    || 0;
      const lambda = parseFloat(lambdaInput.value) || 0;
      const t      = parseFloat(tProbeInput.value) || 0;
      const r      = parseFloat(rProbeInput.value) || 0;

      const tfac = K_norm_t(t, tau);
      const rfac = K_norm_r(r, lambda);
      const kRel = tfac * rfac;
      const k    = sigma2 * kRel;

      outSigma2.textContent = sigma2.toFixed(3);
      outK.textContent      = k.toExponential(4);
      outKRel.textContent   = kRel.toFixed(4);
      outTfac.textContent   = tfac.toFixed(4);
      outRfac.textContent   = rfac.toFixed(4);
    }

    function drawChart() {
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      ctx.fillStyle = '#020617';
      ctx.fillRect(0, 0, w, h);

      ctx.save();
      ctx.translate(48, 16);
      const plotW = w - 64;
      const plotH = h - 48;

      const tau    = parseFloat(tauInput.value)    || 1;
      const lambda = parseFloat(lambdaInput.value) || 1;

      // We'll split the canvas vertically: top half = temporal, bottom half = spatial
      const halfH = (plotH - 16) / 2;

      // Utility: draw one panel
      function drawPanel(yOffset, xMax, xLabel, yLabel, fn) {
        ctx.save();
        ctx.translate(0, yOffset);

        const panelW = plotW;
        const panelH = halfH;

        ctx.strokeStyle = '#1f2937';
        ctx.lineWidth = 1;
        // axes
        ctx.beginPath();
        ctx.moveTo(0, panelH);
        ctx.lineTo(panelW, panelH);
        ctx.moveTo(0, 0);
        ctx.lineTo(0, panelH);
        ctx.stroke();

        // grid + labels
        ctx.fillStyle = '#64748b';
        ctx.font = '10px system-ui';

        const tickCountY = 4;
        for (let i = 0; i <= tickCountY; i++) {
          const yVal = i / tickCountY;
          const yPix = panelH - yVal * panelH;
          ctx.beginPath();
          ctx.moveTo(0, yPix);
          ctx.lineTo(panelW, yPix);
          ctx.strokeStyle = 'rgba(100,116,139,0.25)';
          ctx.stroke();
          ctx.fillText(yVal.toFixed(1), -28, yPix + 3);
        }

        // x-axis labels: 0, xMax/2, xMax
        const tickCountX = 4;
        for (let i = 0; i <= tickCountX; i++) {
          const xVal = (i / tickCountX) * xMax;
          const xPix = (i / tickCountX) * panelW;
          ctx.fillText(xVal.toFixed(1), xPix - 6, panelH + 12);
        }

        ctx.fillText(xLabel, panelW - 40, panelH + 24);
        ctx.fillText(yLabel, -4, -6);

        // curve
        ctx.beginPath();
        const steps = 120;
        for (let i = 0; i <= steps; i++) {
          const t = (i / steps) * xMax;
          const yVal = fn(t);
          const xPix = (t / xMax) * panelW;
          const yPix = panelH - yVal * panelH;
          if (i === 0) ctx.moveTo(xPix, yPix);
          else ctx.lineTo(xPix, yPix);
        }
        ctx.strokeStyle = '#38bdf8';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();
      }

      // temporal: t in [0, 5 tau]
      const tMax = 5 * tau;
      drawPanel(
        0,
        tMax > 0 ? tMax : 5,
        't',
        'K(t,0)/œÉ¬≤',
        (t) => K_norm_t(t, tau)
      );

      // spatial: r in [0, 4 lambda]
      const rMax = 4 * lambda;
      drawPanel(
        halfH + 16,
        rMax > 0 ? rMax : 4,
        'r',
        'K(0,r)/œÉ¬≤',
        (r) => K_norm_r(r, lambda)
      );

      ctx.restore();
    }

    // Wiring
    recalcBtn.addEventListener('click', recomputeCurves);
    sigma2Input.addEventListener('change', recomputeCurves);
    tauInput.addEventListener('change', recomputeCurves);
    lambdaInput.addEventListener('change', recomputeCurves);

    probeBtn.addEventListener('click', doProbe);
    tProbeInput.addEventListener('change', doProbe);
    rProbeInput.addEventListener('change', doProbe);

    // Initial draw
    drawChart();
  

// --- growthhub_allinone_v1.html ---

  // PWA install flow
  let deferredPrompt = null;
  const btn = document.getElementById("installBtn");

  window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    deferredPrompt = e;
    btn.style.display = "inline-block";
  });

  btn.addEventListener("click", async () => {
    if (!deferredPrompt) {
      alert("If the install prompt doesn't appear, use Chrome menu: ‚ãÆ ‚Üí Add to Home screen.");
      return;
    }
    deferredPrompt.prompt();
    const choice = await deferredPrompt.userChoice;
    deferredPrompt = null;
    btn.style.display = "none";
  });

  // Register service worker
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw-growthhub.js").catch(()=>{});
    });
  }


// --- growthhub_allinone_v1_1.html ---

  // PWA install
  let deferredPrompt = null;
  const btn = document.getElementById("installBtn");
  window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    deferredPrompt = e;
    btn.style.display = "inline-block";
  });
  btn.addEventListener("click", async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    await deferredPrompt.userChoice;
    deferredPrompt = null;
    btn.style.display = "none";
  });
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw-growthhub.js").catch(()=>{});
    });
  }

  // Smart live demo buttons (no dead links)
  const liveTargets = [
    { href: "growthhub_meeting_script_v1.html", label: "GrowthHub Meeting Script" },
    { href: "all_pages_index.html", label: "All Pages Index" },
    { href: "all_pages_min.html", label: "All Pages (Min)" },
    { href: "all_pages.html", label: "All Pages (Full)" }
  ];
  const liveWrap = document.getElementById("liveDemoButtons");
  async function exists(url){
    try{
      let r = await fetch(url, { method: "HEAD" });
      if (r.ok) return true;
      r = await fetch(url, { method: "GET", cache: "no-store" });
      return r.ok;
    }catch(e){ return false; }
  }
  (async () => {
    if (!liveWrap) return;
    let any = false;
    for (const t of liveTargets){
      if (await exists(t.href)){
        any = true;
        const a = document.createElement("a");
        a.href = t.href;
        a.className = "btn";
        a.textContent = t.label;
        liveWrap.appendChild(a);
      }
    }
    if (!any){
      const span = document.createElement("span");
      span.className = "muted";
      span.textContent = "No linked demo files detected yet in this folder.";
      liveWrap.appendChild(span);
    }
  })();


// --- qds_binary_pulsar_lab.html ---

    function runCheck() {
      const name = document.getElementById('name').value.trim() || 'Unnamed system';
      const r = parseFloat(document.getElementById('sep').value);
      const alpha = parseFloat(document.getElementById('alpha').value);
      const lambda = parseFloat(document.getElementById('lambda').value);
      const eps = parseFloat(document.getElementById('eps').value);

      if (!isFinite(r) || !isFinite(alpha) || !isFinite(lambda) || !isFinite(eps) ||
          lambda <= 0 || r < 0 || eps <= 0) {
        alert('Please enter sensible numeric values (Œªc > 0, r ‚â• 0, eps > 0).');
        return;
      }

      const factor = Math.exp(-r / lambda);
      const aEff = Math.abs(alpha * factor);

      document.getElementById('out-name').textContent = name;
      document.getElementById('out-r').textContent = r.toFixed(3);
      document.getElementById('out-factor').textContent = factor.toExponential(3);
      document.getElementById('out-aeff').textContent = aEff.toExponential(3);
      document.getElementById('out-eps').textContent = eps.toExponential(3);

      const pill = document.getElementById('status-pill');
      pill.style.display = 'inline-flex';

      if (aEff <= eps) {
        pill.className = 'status-pill status-ok';
        pill.textContent = 'OK: this (Œ±, Œªc) is inside pulsar timing band at this scale.';
      } else {
        pill.className = 'status-pill status-bad';
        pill.textContent = 'Ruled out: this (Œ±, Œªc) overshoots pulsar timing limits.';
      }
    }
  

// --- qds_avian_navigation_lab.html ---

function update() {
    const tau = parseFloat(document.getElementById("tau").value);
    const lambda = parseFloat(document.getElementById("lambda").value);
    const noise = parseFloat(document.getElementById("noise").value);

    document.getElementById("tauVal").textContent = tau;
    document.getElementById("lambdaVal").textContent = lambda;
    document.getElementById("noiseVal").textContent = noise;

    // QDS-inspired kernel: K = e^(-noise) * (tau/2.5) * (2/lambda)
    const K = Math.exp(-noise) * (tau/2.5) * (2/lambda);

    document.getElementById("kernelOut").textContent = K.toFixed(3);

    const status = document.getElementById("navStatus");
    const box = document.getElementById("resultBox");

    if (K >= 1) {
        status.textContent = "Stable Orientation";
        status.className = "success";
        box.style.boxShadow = "0 0 15px #00ff8899";
    } else if (K >= 0.5) {
        status.textContent = "Partially Stable ‚Äì Increased Error";
        status.className = "value";
        box.style.boxShadow = "0 0 15px #ffaa0099";
    } else {
        status.textContent = "Disoriented ‚Äì Compass Collapse";
        status.className = "fail";
        box.style.boxShadow = "0 0 15px #ff006699";
    }
}
update();


// --- qds_avian_lab_v2.html ---

  const tcSlider   = document.getElementById('tcSlider');
  const lcSlider   = document.getElementById('lcSlider');
  const noiseSlider= document.getElementById('noiseSlider');

  const tcValue    = document.getElementById('tcValue');
  const lcValue    = document.getElementById('lcValue');
  const noiseValue = document.getElementById('noiseValue');
  const kernelValue= document.getElementById('kernelValue');
  const navStatus  = document.getElementById('navStatus');
  const compassNeedle = document.getElementById('compassNeedle');
  const activationDot = document.getElementById('activationDot');

  let fiveGOn = false;
  let isNight = false;

  function updateLabels() {
    tcValue.textContent    = tcSlider.value + ' ms';
    lcValue.textContent    = lcSlider.value + ' nm';
    noiseValue.textContent = Number(noiseSlider.value).toFixed(2);
  }

  function computeKernel() {
    const tc   = parseFloat(tcSlider.value);
    const lc   = parseFloat(lcSlider.value);
    const baseNoise = parseFloat(noiseSlider.value);
    const extraNoise = fiveGOn ? 0.15 : 0;
    const noise = Math.min(1, baseNoise + extraNoise);

    // simple toy formula
    const K = (tc * lc) / (1 + 8 * noise * noise);
    kernelValue.textContent = 'K = ' + K.toFixed(3);

    // compass and status
    let angle;   // degrees, 0 = north
    let statusClass, statusText;

    if (K > 8) {
      angle = isNight ? 0 : 10;
      statusClass = 'status-ok';
      statusText  = 'Navigation Status: Stable orientation ‚Äì migratory corridor locked.';
    } else if (K > 3) {
      angle = isNight ? 25 : 40;
      statusClass = 'status-warn';
      statusText  = 'Navigation Status: Noisy but usable compass ‚Äì flock cohesion reduced.';
    } else if (K > 1) {
      angle = 90;
      statusClass = 'status-warn';
      statusText  = 'Navigation Status: Strongly perturbed ‚Äì birds detour or delay migration.';
    } else {
      angle = 160;
      statusClass = 'status-bad';
      statusText  = 'Navigation Status: Disoriented ‚Äì compass collapse / random headings.';
    }

    compassNeedle.style.transform = 'rotate(' + angle + 'deg)';

    navStatus.classList.remove('status-ok','status-warn','status-bad');
    navStatus.classList.add(statusClass);
    navStatus.textContent = statusText;

    // cryptochrome glow
    const glow = Math.min(1, K / 8);
    const blur = 12 + glow * 18;
    const spread = 2 + glow * 6;
    activationDot.style.boxShadow =
      `0 0 ${blur}px ${spread}px rgba(56,189,248,${0.35 + glow*0.4}),
       0 0 ${blur+6}px ${spread+2}px rgba(129,230,217,${0.25 + glow*0.3})`;
    activationDot.style.background =
      `radial-gradient(circle at 30% 20%, rgba(129,230,217,1), #020617)`;
  }

  function setPreset(name) {
    if (name === 'forest') {
      tcSlider.value = 2.2;
      lcSlider.value = 2.5;
      noiseSlider.value = 0.12;
    } else if (name === 'urban') {
      tcSlider.value = 1.0;
      lcSlider.value = 1.8;
      noiseSlider.value = 0.45;
    } else if (name === 'storm') {
      tcSlider.value = 0.8;
      lcSlider.value = 1.2;
      noiseSlider.value = 0.7;
    } else if (name === 'flare') {
      tcSlider.value = 0.4;
      lcSlider.value = 0.8;
      noiseSlider.value = 0.85;
    } else if (name === 'lab') {
      tcSlider.value = 3.0;
      lcSlider.value = 3.5;
      noiseSlider.value = 0.03;
    }
    updateLabels();
    computeKernel();
  }

  function toggle5G() {
    fiveGOn = !fiveGOn;
    computeKernel();
  }

  function toggleDayNight() {
    isNight = !isNight;
    computeKernel();
  }

  function exportSnapshot() {
    const snapshot = {
      tc_ms: parseFloat(tcSlider.value),
      lc_nm: parseFloat(lcSlider.value),
      noise: parseFloat(noiseSlider.value),
      fiveGOn,
      isNight,
      timestamp: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(snapshot,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'qds_avian_lab_snapshot.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  tcSlider.addEventListener('input', () => { updateLabels(); computeKernel(); });
  lcSlider.addEventListener('input', () => { updateLabels(); computeKernel(); });
  noiseSlider.addEventListener('input', () => { updateLabels(); computeKernel(); });

  // init
  updateLabels();
  computeKernel();


// --- all_pages_index_backup_20251207_121603.html ---

    // data injected below
const PAGES = [
    { title: "index", href: "QDS-5-WEDGE-PORTFOLIO/index.html", path: "QDS-5-WEDGE-PORTFOLIO/index.html", category: "Indexes" },
    { title: "index", href: "QDS_Battery_Lab/index.html", path: "QDS_Battery_Lab/index.html", category: "Indexes" },
    { title: "all pages min", href: "all_pages_min.html", path: "all_pages_min.html", category: "Misc" },
    { title: "cannon side 2d v1", href: "cannon_side_2d_v1.html", path: "cannon_side_2d_v1.html", category: "Games / Toys" },
    { title: "cannon wall breaker v1", href: "cannon_wall_breaker_v1.html", path: "cannon_wall_breaker_v1.html", category: "Games / Toys" },
    { title: "cannon wall breaker v1 1", href: "cannon_wall_breaker_v1_1.html", path: "cannon_wall_breaker_v1_1.html", category: "Games / Toys" },
    { title: "catapult balloon pop v1", href: "catapult_balloon_pop_v1.html", path: "catapult_balloon_pop_v1.html", category: "Games / Toys" },
    { title: "ddmelts microsite v1", href: "ddmelts_microsite_v1.html", path: "ddmelts_microsite_v1.html", category: "Misc" },
    { title: "ddmelts microsite v1 1", href: "ddmelts_microsite_v1_1.html", path: "ddmelts_microsite_v1_1.html", category: "Misc" },
    { title: "ddmelts microsite v1 2 live links", href: "ddmelts_microsite_v1_2_live_links.html", path: "ddmelts_microsite_v1_2_live_links.html", category: "Misc" },
    { title: "ddmelts microsite v1 2 pink hearts", href: "ddmelts_microsite_v1_2_pink_hearts.html", path: "ddmelts_microsite_v1_2_pink_hearts.html", category: "Misc" },
    { title: "index", href: "index.html", path: "index.html", category: "Indexes" },
    { title: "indus atlas v1 qds language lab", href: "indus_atlas_v1_qds_language_lab.html", path: "indus_atlas_v1_qds_language_lab.html", category: "Language / Indus" },
    { title: "legacy hub v1", href: "legacy_hub_v1.html", path: "legacy_hub_v1.html", category: "Misc" },
    { title: "offer demo suite v1", href: "offer_demo_suite_v1.html", path: "offer_demo_suite_v1.html", category: "Misc" },
    { title: "offer index v1", href: "offer_index_v1.html", path: "offer_index_v1.html", category: "Indexes" },
    { title: "offer microsite v1", href: "offer_microsite_v1.html", path: "offer_microsite_v1.html", category: "Misc" },
    { title: "offer showcase hub v1", href: "offer_showcase_hub_v1.html", path: "offer_showcase_hub_v1.html", category: "Misc" },
    { title: "omega os index v1", href: "omega_os_index_v1.html", path: "omega_os_index_v1.html", category: "Œ© / OS" },
    { title: "omega os index v2", href: "omega_os_index_v2.html", path: "omega_os_index_v2.html", category: "Œ© / OS" },
    { title: "omega qds lab", href: "omega_qds_lab.html", path: "omega_qds_lab.html", category: "Œ© / OS" },
    { title: "portfolio", href: "portfolio.html", path: "portfolio.html", category: "Misc" },
    { title: "portfolio market allinone v1", href: "portfolio_market_allinone_v1.html", path: "portfolio_market_allinone_v1.html", category: "Misc" },
    { title: "portfolio offer v2", href: "portfolio_offer_v2.html", path: "portfolio_offer_v2.html", category: "Misc" },
    { title: "portfolio offer v2 20251206 134821", href: "portfolio_offer_v2_20251206_134821.html", path: "portfolio_offer_v2_20251206_134821.html", category: "Misc" },
    { title: "portfolio ultimate allinone v1", href: "portfolio_ultimate_allinone_v1.html", path: "portfolio_ultimate_allinone_v1.html", category: "Misc" },
    { title: "portfolio v1", href: "portfolio_v1.html", path: "portfolio_v1.html", category: "Misc" },
    { title: "proof of ship v1", href: "proof_of_ship_v1.html", path: "proof_of_ship_v1.html", category: "Misc" },
    { title: "pyramid pinball v1", href: "pyramid_pinball_v1.html", path: "pyramid_pinball_v1.html", category: "Games / Toys" },
    { title: "qds 5 pillars hub", href: "qds_5_pillars_hub.html", path: "qds_5_pillars_hub.html", category: "Pillars / Portfolio" },
    { title: "qds 5 pillars hub v1", href: "qds_5_pillars_hub_v1.html", path: "qds_5_pillars_hub_v1.html", category: "Pillars / Portfolio" },
    { title: "qds battery coach v3", href: "qds_battery_coach_v3.html", path: "qds_battery_coach_v3.html", category: "Battery" },
    { title: "qds battery hub v9 1 purple neon", href: "qds_battery_hub_v9_1_purple_neon.html", path: "qds_battery_hub_v9_1_purple_neon.html", category: "Battery" },
    { title: "qds battery hub v9 2 purple neon", href: "qds_battery_hub_v9_2_purple_neon.html", path: "qds_battery_hub_v9_2_purple_neon.html", category: "Battery" },
    { title: "qds battery hub v9 3 science neon", href: "qds_battery_hub_v9_3_science_neon.html", path: "qds_battery_hub_v9_3_science_neon.html", category: "Battery" },
    { title: "qds battery hub v9 4 science neon plus", href: "qds_battery_hub_v9_4_science_neon_plus.html", path: "qds_battery_hub_v9_4_science_neon_plus.html", category: "Battery" },
    { title: "qds battery hub v9 5 1 science neon", href: "qds_battery_hub_v9_5_1_science_neon.html", path: "qds_battery_hub_v9_5_1_science_neon.html", category: "Battery" },
    { title: "qds battery hub v9 5 science neon", href: "qds_battery_hub_v9_5_science_neon.html", path: "qds_battery_hub_v9_5_science_neon.html", category: "Battery" },
    { title: "qds battery hub v9 6 science neon", href: "qds_battery_hub_v9_6_science_neon.html", path: "qds_battery_hub_v9_6_science_neon.html", category: "Battery" },
    { title: "qds battery hub v9 7 science neon lab", href: "qds_battery_hub_v9_7_science_neon_lab.html", path: "qds_battery_hub_v9_7_science_neon_lab.html", category: "Battery" },
    { title: "qds battery index v1 neon os", href: "qds_battery_index_v1_neon_os.html", path: "qds_battery_index_v1_neon_os.html", category: "Battery" },
    { title: "qds battery lab", href: "qds_battery_lab.html", path: "qds_battery_lab.html", category: "Battery" },
    { title: "qds battery lab showcase stress bias v1", href: "qds_battery_lab_showcase_stress_bias_v1.html", path: "qds_battery_lab_showcase_stress_bias_v1.html", category: "Battery" },
    { title: "qds battery lab showcase stress bias v2", href: "qds_battery_lab_showcase_stress_bias_v2.html", path: "qds_battery_lab_showcase_stress_bias_v2.html", category: "Battery" },
    { title: "qds battery lab showcase v1", href: "qds_battery_lab_showcase_v1.html", path: "qds_battery_lab_showcase_v1.html", category: "Battery" },
    { title: "qds battery noise toy v1", href: "qds_battery_noise_toy_v1.html", path: "qds_battery_noise_toy_v1.html", category: "Battery" },
    { title: "qds battery os index v1", href: "qds_battery_os_index_v1.html", path: "qds_battery_os_index_v1.html", category: "Battery" },
    { title: "qds battery suite v4 showcase", href: "qds_battery_suite_v4_showcase.html", path: "qds_battery_suite_v4_showcase.html", category: "Battery" },
    { title: "qds battery suite v5 boss polish", href: "qds_battery_suite_v5_boss_polish.html", path: "qds_battery_suite_v5_boss_polish.html", category: "Battery" },
    { title: "qds battery suite v6 realworld", href: "qds_battery_suite_v6_realworld.html", path: "qds_battery_suite_v6_realworld.html", category: "Battery" },
    { title: "qds battery suite v8 1 fairpath", href: "qds_battery_suite_v8_1_fairpath.html", path: "qds_battery_suite_v8_1_fairpath.html", category: "Battery" },
    { title: "qds battery suite v8 2 poster tamed", href: "qds_battery_suite_v8_2_poster_tamed.html", path: "qds_battery_suite_v8_2_poster_tamed.html", category: "Battery" },
    { title: "qds battery suite v8 3 neon shell", href: "qds_battery_suite_v8_3_neon_shell.html", path: "qds_battery_suite_v8_3_neon_shell.html", category: "Battery" },
    { title: "qds battery suite v8 nextlevel", href: "qds_battery_suite_v8_nextlevel.html", path: "qds_battery_suite_v8_nextlevel.html", category: "Battery" },
    { title: "qds battery whisperer v2", href: "qds_battery_whisperer_v2.html", path: "qds_battery_whisperer_v2.html", category: "Battery" },
    { title: "qds chips noise v1", href: "qds_chips_noise_v1.html", path: "qds_chips_noise_v1.html", category: "Misc" },
    { title: "qds compression lab v1", href: "qds_compression_lab_v1.html", path: "qds_compression_lab_v1.html", category: "Misc" },
    { title: "qds sensors metrology v1", href: "qds_sensors_metrology_v1.html", path: "qds_sensors_metrology_v1.html", category: "Misc" },
    { title: "qds shed index v1", href: "qds_shed_index_v1.html", path: "qds_shed_index_v1.html", category: "Indexes" },
    { title: "qds showcase index v1", href: "qds_showcase_index_v1.html", path: "qds_showcase_index_v1.html", category: "Indexes" },
    { title: "qds showcase index v1 1", href: "qds_showcase_index_v1_1.html", path: "qds_showcase_index_v1_1.html", category: "Indexes" },
    { title: "qds solar v6 textures", href: "qds_solar_v6_textures.html", path: "qds_solar_v6_textures.html", category: "Solar" },
    { title: "qds test task pack v1", href: "qds_test_task_pack_v1.html", path: "qds_test_task_pack_v1.html", category: "Tests / Repro" },
    { title: "qds test task pack v1 1 pro", href: "qds_test_task_pack_v1_1_pro.html", path: "qds_test_task_pack_v1_1_pro.html", category: "Tests / Repro" },
    { title: "qds universe v12b mobile", href: "qds_universe_v12b_mobile.html", path: "qds_universe_v12b_mobile.html", category: "Universe" },
    { title: "qds universe v9 10 neon planet colours", href: "qds_universe_v9_10_neon_planet_colours.html", path: "qds_universe_v9_10_neon_planet_colours.html", category: "Universe" },
    { title: "qds universe v9 2 neon clear planets", href: "qds_universe_v9_2_neon_clear_planets.html", path: "qds_universe_v9_2_neon_clear_planets.html", category: "Universe" },
    { title: "qds universe v9 6 turbo pan", href: "qds_universe_v9_6_turbo_pan.html", path: "qds_universe_v9_6_turbo_pan.html", category: "Universe" },
    { title: "solar system v8 offline", href: "solar_system_v8_offline.html", path: "solar_system_v8_offline.html", category: "Solar" },
    { title: "solar system v9 2 mobile 3d showcase", href: "solar_system_v9_2_mobile_3d_showcase.html", path: "solar_system_v9_2_mobile_3d_showcase.html", category: "Solar" },
    { title: "start here 90s v1", href: "start_here_90s_v1.html", path: "start_here_90s_v1.html", category: "Maps / Local" },
    { title: "stinchcombe map", href: "stinchcombe_map.html", path: "stinchcombe_map.html", category: "Maps / Local" },
  ];
    const categorize = (name) => {
      const n = name.toLowerCase();
      if (n.includes("battery")) return "Battery";
      if (n.includes("universe")) return "Universe";
      if (n.includes("solar")) return "Solar";
      if (n.includes("omega")) return "Œ© / OS";
      if (n.includes("index")) return "Indexes";
      if (n.includes("pillar") || n.includes("wedge")) return "Pillars / Portfolio";
      if (n.includes("cannon") || n.includes("catapult") || n.includes("pinball")) return "Games / Toys";
      if (n.includes("indus")) return "Language / Indus";
      if (n.includes("stinchcombe") || n.includes("her")) return "Maps / Local";
      if (n.includes("test")) return "Tests / Repro";
      return "Misc";
    };

    const elList = document.getElementById("list");
    const elQ = document.getElementById("q");
    const elGroup = document.getElementById("group");
    const elReset = document.getElementById("reset");

    const renderFlat = (items) => {
      elList.innerHTML = "";
      for (const p of items) {
        const a = document.createElement("a");
        a.className = "card";
        a.href = p.href;
        a.innerHTML = `
          <div class="name">${p.title}</div>
          <div class="path">${p.path}</div>
          <span class="tag">${p.category}</span>
        `;
        elList.appendChild(a);
      }
    };

    const renderGrouped = (items) => {
      elList.innerHTML = "";
      const groups = {};
      for (const p of items) {
        (groups[p.category] ||= []).push(p);
      }
      const cats = Object.keys(groups).sort();
      for (const c of cats) {
        const header = document.createElement("div");
        header.style.gridColumn = "1 / -1";
        header.style.padding = "8px 6px 2px";
        header.style.color = "#a7b0c5";
        header.style.fontSize = "12px";
        header.style.letterSpacing = ".2px";
        header.textContent = c;
        elList.appendChild(header);

        for (const p of groups[c]) {
          const a = document.createElement("a");
          a.className = "card";
          a.href = p.href;
          a.innerHTML = `
            <div class="name">${p.title}</div>
            <div class="path">${p.path}</div>
            <span class="tag">${p.category}</span>
          `;
          elList.appendChild(a);
        }
      }
    };

    const apply = () => {
      const q = (elQ.value || "").toLowerCase().trim();
      let items = PAGES.filter(p =>
        !q ||
        p.title.toLowerCase().includes(q) ||
        p.path.toLowerCase().includes(q) ||
        p.category.toLowerCase().includes(q)
      );

      if (elGroup.value === "category") renderGrouped(items);
      else renderFlat(items);
    };

    elQ.addEventListener("input", apply);
    elGroup.addEventListener("change", apply);
    elReset.addEventListener("click", () => { elQ.value=""; elGroup.value="none"; apply(); });

    // init
    apply();
  

// --- qds_revenue_floor_BASE.html ---

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);

function num(id, def=0){
  const el = $(id);
  if(!el) return def;
  const v = parseFloat(String(el.value ?? "").trim());
  return Number.isFinite(v) ? v : def;
}
function clamp(x, a, b){
  if(!Number.isFinite(x)) return a;
  return Math.min(b, Math.max(a, x));
}
function fmtMoney(x){
  const cur = String($("currency").value || "¬£").trim() || "¬£";
  const n = Number.isFinite(x) ? x : 0;
  const rounded = Math.round(n);
  return cur + rounded.toLocaleString();
}

/* ---------- Core model ---------- */
function computeModel(){
  const L = Math.max(0, num("L"));
  const q = clamp(num("q"), 0, 1);
  const s = clamp(num("s"), 0, 1);
  const p = clamp(num("p"), 0, 1);
  const r = clamp(num("r"), 0, 1);

  const Sprice = Math.max(0, num("Sprice"));
  const Pprice = Math.max(0, num("Pprice"));
  const Rprice = Math.max(0, num("Rprice"));

  const Smax = Math.max(0, num("Smax"));
  const Pmax = Math.max(0, num("Pmax"));

  const M0 = Math.max(0, num("M0"));
  const churnPct = clamp(num("churn"), 0, 50);
  const churn = churnPct / 100;

  const months = clamp(Math.round(num("months", 12)), 1, 60);

  const qualified = L * q;
  const sprintsRaw = qualified * s;
  const sprints = Math.min(sprintsRaw, Smax);

  const pilotsRaw = sprints * p;
  const pilots = Math.min(pilotsRaw, Pmax);

  const newRetainers = pilots * r;

  const newMrr = newRetainers * Rprice;

  const revMonth = (sprints * Sprice) + (pilots * Pprice) + newMrr;
  const revYear = revMonth * 12;

  // MRR accumulation over horizon
  let mrr = M0;
  const mrrTimeline = [mrr];
  for(let i=1;i<=months;i++){
    mrr = (mrr + newMrr) * (1 - churn);
    mrrTimeline.push(mrr);
  }

  const at = (n)=>{
    const idx = clamp(n, 0, months);
    return mrrTimeline[idx];
  };

  return {
    L,q,s,p,r,Sprice,Pprice,Rprice,Smax,Pmax,M0,churnPct,churn,months,
    qualified,sprintsRaw,sprints,pilotsRaw,pilots,newRetainers,newMrr,
    revMonth,revYear,mrrTimeline,
    mrr3: at(3), mrr6: at(6), mrr12: at(12), mrrEnd: at(months)
  };
}

/* ---------- Presets ---------- */
const PRESETS = {
  conservative: {
    L:6, q:0.40, s:0.30, p:0.30, r:0.25,
    Sprice:2000, Pprice:5000, Rprice:1500,
    Smax:4, Pmax:2, M0:0, churn:4
  },
  base: {
    L:12, q:0.50, s:0.35, p:0.40, r:0.30,
    Sprice:2500, Pprice:6000, Rprice:2000,
    Smax:6, Pmax:3, M0:0, churn:3
  },
  optimistic: {
    L:20, q:0.60, s:0.45, p:0.45, r:0.40,
    Sprice:3000, Pprice:8000, Rprice:2500,
    Smax:8, Pmax:4, M0:0, churn:2
  }
};

function applyPreset(){
  const key = $("preset")?.value || "base";
  const p = PRESETS[key] || PRESETS.base;

  $("L").value = p.L;
  $("q").value = p.q;
  $("s").value = p.s;
  $("p").value = p.p;
  $("r").value = p.r;

  $("Sprice").value = p.Sprice;
  $("Pprice").value = p.Pprice;
  $("Rprice").value = p.Rprice;

  $("Smax").value = p.Smax;
  $("Pmax").value = p.Pmax;

  $("M0").value = p.M0;
  $("churn").value = p.churn;
}

/* ---------- Sensitivity ---------- */
function buildSensitivity(base){
  const rows = [];

  function calcWith(patch){
    // temporarily apply patch values, compute, then restore
    const ids = Object.keys(patch);
    const old = {};
    ids.forEach(id=>{
      old[id] = $(id).value;
      $(id).value = patch[id];
    });
    const m = computeModel();
    ids.forEach(id=>$(id).value = old[id]);
    return m.revYear;
  }

  const baseYear = base.revYear;

  // +1 lead
  rows.push({
    label: "+1 lead / month",
    delta: calcWith({L: num("L")+1}) - baseYear
  });

  // +0.10 sprint close
  rows.push({
    label: "+0.10 sprint close rate",
    delta: calcWith({s: clamp(num("s")+0.10, 0, 1)}) - baseYear
  });

  // +1 sprint capacity
  rows.push({
    label: "+1 sprint capacity",
    delta: calcWith({Smax: num("Smax")+1}) - baseYear
  });

  // +0.05 pilot-from-sprint
  rows.push({
    label: "+0.05 pilot-from-sprint",
    delta: calcWith({p: clamp(num("p")+0.05, 0, 1)}) - baseYear
  });

  // +0.05 retainer-from-pilot
  rows.push({
    label: "+0.05 retainer-from-pilot",
    delta: calcWith({r: clamp(num("r")+0.05, 0, 1)}) - baseYear
  });

  const body = $("sensBody");
  body.innerHTML = "";
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const td1 = document.createElement("td");
    const td2 = document.createElement("td");
    td1.textContent = r.label;
    td2.textContent = fmtMoney(r.delta);
    tr.appendChild(td1); tr.appendChild(td2);
    body.appendChild(tr);
  });
}

/* ---------- Board summary ---------- */
function buildBoardSummary(m){
  const capNote = String($("capNotes").value || "").trim();
  const cost = Math.max(0, num("cost"));

  const conf = {
    q: $("qConf")?.value || "Med",
    s: $("sConf")?.value || "Med",
    p: $("pConf")?.value || "Med",
    r: $("rConf")?.value || "Med",
    c: $("cConf")?.value || "Med",
  };

  const notes = {
    q: String($("qNote")?.value || "").trim(),
    s: String($("sNote")?.value || "").trim(),
    p: String($("pNote")?.value || "").trim(),
    r: String($("rNote")?.value || "").trim(),
    c: String($("cNote")?.value || "").trim(),
  };

  const parts = [];
  parts.push(
    `Revenue floor model (capacity-truthed): ` +
    `${m.L} leads/mo ‚Üí q ${m.q.toFixed(2)} ‚Üí s ${m.s.toFixed(2)} ‚Üí p ${m.p.toFixed(2)} ‚Üí r ${m.r.toFixed(2)}.`
  );
  parts.push(
    `Pricing: Sprint ${fmtMoney(m.Sprice)}, Pilot ${fmtMoney(m.Pprice)}, Retainer ${fmtMoney(m.Rprice)}/mo.`
  );
  parts.push(
    `Capacity: Smax ${m.Smax}, Pmax ${m.Pmax}` + (capNote ? ` (${capNote})` : "") + `.`
  );
  parts.push(
    `Expected/month: ${m.sprints.toFixed(2)} sprints, ${m.pilots.toFixed(2)} pilots, ${m.newRetainers.toFixed(2)} new retainers.`
  );
  parts.push(
    `Run-rate: ${fmtMoney(m.revMonth)}/mo (${fmtMoney(m.revYear)}/yr).`
  );
  parts.push(
    `MRR: M0 ${fmtMoney(m.M0)}, churn ${m.churnPct.toFixed(1)}%. New MRR ${fmtMoney(m.newMrr)}/mo ‚Üí projected MRR @ ${m.months} months ${fmtMoney(m.mrrEnd)}.`
  );
  if(cost>0){
    parts.push(`Cost base noted: ${fmtMoney(cost)}/mo (for margin context, not enforced in calc).`);
  }

  const confLine =
    `Assumption confidence: q ${conf.q}, s ${conf.s}, p ${conf.p}, r ${conf.r}, churn ${conf.c}.`;
  parts.push(confLine);

  const ev = [];
  if(notes.q) ev.push(`q: ${notes.q}`);
  if(notes.s) ev.push(`s: ${notes.s}`);
  if(notes.p) ev.push(`p: ${notes.p}`);
  if(notes.r) ev.push(`r: ${notes.r}`);
  if(notes.c) ev.push(`c: ${notes.c}`);
  if(ev.length) parts.push(`Evidence: ${ev.join(" | ")}`);

  parts.push(`This model is deliberately conservative: upside comes from more leads, better close rates, and capacity expansion ‚Äî not inflated assumptions.`);

  return parts.join(" ");
}

/* ---------- Render ---------- */
function render(){
  const m = computeModel();

  // update audit value cells
  $("qValCell").textContent = m.q.toFixed(2);
  $("sValCell").textContent = m.s.toFixed(2);
  $("pValCell").textContent = m.p.toFixed(2);
  $("rValCell").textContent = m.r.toFixed(2);
  $("cValCell").textContent = m.churnPct.toFixed(1) + "%";

  // KPIs
  $("revMonth").textContent = fmtMoney(m.revMonth);
  $("revYear").textContent = fmtMoney(m.revYear);
  $("newMrr").textContent = fmtMoney(m.newMrr);
  $("mrrEnd").textContent = fmtMoney(m.mrrEnd);
  $("mrrEndSub").textContent = `MRR after churn @ ${m.months} months`;

  // volumes
  $("volumesBox").innerHTML =
    `Qualified: ${m.qualified.toFixed(2)}<br/>` +
    `Sprints: ${m.sprints.toFixed(2)} (raw ${m.sprintsRaw.toFixed(2)})<br/>` +
    `Pilots: ${m.pilots.toFixed(2)} (raw ${m.pilotsRaw.toFixed(2)})<br/>` +
    `New retainers: ${m.newRetainers.toFixed(2)}`;

  // MRR accumulation snapshot
  $("mrrBox").innerHTML =
    `Starting: ${fmtMoney(m.M0)}<br/>` +
    `MRR @ 3 months: ${fmtMoney(m.mrr3)}<br/>` +
    `MRR @ 6 months: ${fmtMoney(m.mrr6)}<br/>` +
    `MRR @ 12 months: ${fmtMoney(m.mrr12)}`;

  // sensitivity
  buildSensitivity(m);

  // board summary
  const summary = buildBoardSummary(m);
  $("boardSummary").value = summary;

  // status pill
  $("statusPill").textContent = "Live";
}

/* ---------- One-pager + Print ---------- */
function toggleView(){
  document.body.classList.toggle("onepager");
}
function printOnePager(){
  // ensure onepager layout for print, but restore after
  const was = document.body.classList.contains("onepager");
  if(!was) document.body.classList.add("onepager");
  window.print();
  if(!was) document.body.classList.remove("onepager");
}

/* ---------- Copy summary ---------- */
async function copySummary(){
  const text = $("boardSummary").value || "";
  try{
    await navigator.clipboard.writeText(text);
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }catch(e){
    // fallback
    $("boardSummary").select();
    document.execCommand("copy");
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }
}

/* ---------- Reset ---------- */
function resetBase(){
  $("preset").value = "base";
  applyPreset();
  $("currency").value = "¬£";
  $("months").value = 12;
  $("Smax").value = 6;
  $("Pmax").value = 3;
  $("M0").value = 0;
  $("churn").value = 3;
  $("cost").value = 200;
  $("capNotes").value = "";

  // audit defaults
  ["qConf","sConf","pConf","rConf","cConf"].forEach(id=>{ if($(id)) $(id).value="Med"; });
  ["qNote","sNote","pNote","rNote","cNote"].forEach(id=>{ if($(id)) $(id).value=""; });

  render();
}

/* ---------- Bulletproof wiring ---------- */
function attachListeners(){
  document.querySelectorAll("input, select, textarea").forEach(el=>{
    const handler = ()=>{
      if(el.id === "preset"){ applyPreset(); }
      render();
    };
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  $("toggleViewBtn").addEventListener("click", toggleView);
  $("printBtn").addEventListener("click", printOnePager);
  $("copySummaryBtn").addEventListener("click", copySummary);
  $("resetBtn").addEventListener("click", resetBase);
}

applyPreset();
attachListeners();
render();


// --- qds_rotation_lab.html ---

    const alphaInput = document.getElementById('alpha');
    const lambdaInput = document.getElementById('lambda');
    const tolInput    = document.getElementById('tol');

    const rInput    = document.getElementById('r_in');
    const vNInput   = document.getElementById('vN_in');
    const vObsInput = document.getElementById('vObs_in');

    const addBtn    = document.getElementById('addBtn');
    const clearBtn  = document.getElementById('clearBtn');
    const recalcBtn = document.getElementById('recalcBtn');

    const tableBody = document.querySelector('#dataTable tbody');
    const summaryEl = document.getElementById('summaryText');

    const canvas = document.getElementById('chart');
    const ctx    = canvas.getContext('2d');

    let points = []; // {r, vN, vObs, vQDS, diff, rel}

    function computeVQDS(r, vN, alpha, lambdaC) {
      if (r <= 0 || vN <= 0) return 0;
      const boost = 1 + alpha * Math.exp(-r / lambdaC);
      return vN * Math.sqrt(Math.max(boost, 0));
    }

    function recalcAll() {
      const alpha  = parseFloat(alphaInput.value)  || 0;
      const lambda = parseFloat(lambdaInput.value) || 1;
      const tol    = parseFloat(tolInput.value)    || 0;

      points = points.map(pt => {
        const vQDS = computeVQDS(pt.r, pt.vN, alpha, lambda);
        const diff = pt.vObs - vQDS;
        const rel  = vQDS !== 0 ? (diff / vQDS) * 100 : 0;
        return { ...pt, vQDS, diff, rel, tol };
      });

      renderTable();
      renderSummary();
      drawChart();
    }

    function addPoint() {
      const rval   = parseFloat(rInput.value);
      const vNval  = parseFloat(vNInput.value);
      const vOval  = parseFloat(vObsInput.value);

      if (!isFinite(rval) || rval <= 0 || !isFinite(vNval) || vNval <= 0 || !isFinite(vOval) || vOval < 0) {
        alert('Please enter valid positive numbers for r, vN and v_obs.');
        return;
      }

      const alpha  = parseFloat(alphaInput.value)  || 0;
      const lambda = parseFloat(lambdaInput.value) || 1;
      const tol    = parseFloat(tolInput.value)    || 0;

      const vQDS = computeVQDS(rval, vNval, alpha, lambda);
      const diff = vOval - vQDS;
      const rel  = vQDS !== 0 ? (diff / vQDS) * 100 : 0;

      points.push({ r: rval, vN: vNval, vObs: vOval, vQDS, diff, rel, tol });

      rInput.value = '';
      vNInput.value = '';
      vObsInput.value = '';

      renderTable();
      renderSummary();
      drawChart();
    }

    function clearAll() {
      if (!confirm('Clear all data points?')) return;
      points = [];
      renderTable();
      renderSummary();
      drawChart();
    }

    function renderTable() {
      tableBody.innerHTML = '';
      const tol = parseFloat(tolInput.value) || 0;

      points.forEach((pt, idx) => {
        const tr = document.createElement('tr');
        const pass = Math.abs(pt.rel) <= tol;

        const pill = document.createElement('span');
        pill.className = 'pill ' + (pass ? 'pill-pass' : 'pill-fail');
        pill.textContent = pass ? 'PASS' : 'FAIL';

        tr.innerHTML = `
          <td>${idx + 1}</td>
          <td>${pt.r.toFixed(2)}</td>
          <td>${pt.vN.toFixed(1)}</td>
          <td>${pt.vObs.toFixed(1)}</td>
          <td>${pt.vQDS.toFixed(1)}</td>
          <td>${pt.rel.toFixed(1)}</td>
          <td></td>
        `;
        tr.lastElementChild.appendChild(pill);
        tableBody.appendChild(tr);
      });
    }

    function renderSummary() {
      if (points.length === 0) {
        summaryEl.textContent = 'No points yet. Add some radii and speeds to see how QDS behaves.';
        return;
      }
      const tol  = parseFloat(tolInput.value) || 0;
      const n    = points.length;
      const pass = points.filter(pt => Math.abs(pt.rel) <= tol).length;
      const frac = (pass / n) * 100;

      const minR = Math.min(...points.map(p => p.r));
      const maxR = Math.max(...points.map(p => p.r));
      summaryEl.textContent =
        `Points: ${n} | Within tolerance: ${pass} (${frac.toFixed(1)}%) | ` +
        `r range: ${minR.toFixed(2)} ‚Äì ${maxR.toFixed(2)} kpc | ` +
        `Tolerance: ¬±${tol.toFixed(0)}% of v_QDS.`;
    }

    function drawChart() {
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      ctx.fillStyle = '#020617';
      ctx.fillRect(0, 0, w, h);

      ctx.save();
      ctx.translate(48, 16);
      const plotW = w - 64;
      const plotH = h - 48;

      let minR = 0, maxR = 10;
      let minV = 0, maxV = 200;

      if (points.length > 0) {
        minR = Math.min(...points.map(p => p.r));
        maxR = Math.max(...points.map(p => p.r));
        const vs = points.map(p => p.vN)
          .concat(points.map(p => p.vObs))
          .concat(points.map(p => p.vQDS));
        minV = Math.min(...vs);
        maxV = Math.max(...vs);
      }

      if (minR === maxR) maxR = minR + 1;
      if (minV === maxV) maxV = minV + 1;

      const padR = 0.1 * (maxR - minR);
      const padV = 0.2 * (maxV - minV);
      minR -= padR; maxR += padR;
      minV = Math.max(0, minV - padV);
      maxV += padV;

      function xScale(r) {
        return ((r - minR) / (maxR - minR)) * plotW;
      }
      function yScale(v) {
        return plotH - ((v - minV) / (maxV - minV)) * plotH;
      }

      // Axes + grid
      ctx.strokeStyle = '#1f2937';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, yScale(0));
      ctx.lineTo(plotW, yScale(0));
      ctx.moveTo(0, 0);
      ctx.lineTo(0, plotH);
      ctx.stroke();

      ctx.fillStyle = '#64748b';
      ctx.font = '10px system-ui';
      const tickCount = 4;
      for (let i = 0; i <= tickCount; i++) {
        const tV = minV + (i / tickCount) * (maxV - minV);
        const y  = yScale(tV);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(plotW, y);
        ctx.strokeStyle = 'rgba(100,116,139,0.25)';
        ctx.stroke();
        ctx.fillText(tV.toFixed(0), -32, y + 3);
      }
      ctx.fillText('r (kpc)', plotW - 40, plotH + 14);
      ctx.fillText('v (km/s)', -4, -6);

      const alpha  = parseFloat(alphaInput.value)  || 0;
      const lambda = parseFloat(lambdaInput.value) || 1;

      // Draw Newtonian and QDS curves if we have points
      if (points.length > 0) {
        // sort by radius
        const sorted = [...points].sort((a,b) => a.r - b.r);

        // Newtonian
        ctx.beginPath();
        sorted.forEach((pt, i) => {
          const x = xScale(pt.r);
          const y = yScale(pt.vN);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = '#38bdf8';
        ctx.lineWidth = 2;
        ctx.stroke();

        // QDS
        ctx.beginPath();
        sorted.forEach((pt, i) => {
          const vQ = computeVQDS(pt.r, pt.vN, alpha, lambda);
          const x = xScale(pt.r);
          const y = yScale(vQ);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = '#22c55e';
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Observed points
      points.forEach(pt => {
        const x = xScale(pt.r);
        const y = yScale(pt.vObs);
        const pass = Math.abs(pt.rel) <= (parseFloat(tolInput.value) || 0);
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = pass ? '#22c55e' : '#f97316';
        ctx.fill();
      });

      ctx.restore();
    }

    addBtn.addEventListener('click', addPoint);
    clearBtn.addEventListener('click', clearAll);
    recalcBtn.addEventListener('click', recalcAll);

    alphaInput.addEventListener('change', recalcAll);
    lambdaInput.addEventListener('change', recalcAll);
    tolInput.addEventListener('change', recalcAll);

    drawChart();
  

// --- q.html ---

    const sigma2Input = document.getElementById('sigma2');
    const tauInput    = document.getElementById('tau');
    const lambdaInput = document.getElementById('lambda');
    const recalcBtn   = document.getElementById('recalcBtn');

    const tProbeInput = document.getElementById('tProbe');
    const rProbeInput = document.getElementById('rProbe');
    const probeBtn    = document.getElementById('probeBtn');

    const outSigma2 = document.getElementById('outSigma2');
    const outK      = document.getElementById('outK');
    const outKRel   = document.getElementById('outKRel');
    const outTfac   = document.getElementById('outTfac');
    const outRfac   = document.getElementById('outRfac');

    const canvas = document.getElementById('chart');
    const ctx    = canvas.getContext('2d');

    function K_norm_t(t, tau) {
      if (tau <= 0) return 0;
      return Math.exp(-Math.abs(t) / tau);
    }

    function K_norm_r(r, lambdaC) {
      if (lambdaC <= 0) return 0;
      const x = r / lambdaC;
      return Math.exp(-0.5 * x * x);
    }

    function recomputeCurves() {
      drawChart();
      // also refresh probe display if something is already there
      if (outK.textContent !== '‚Äî') {
        doProbe();
      }
    }

    function doProbe() {
      const sigma2 = parseFloat(sigma2Input.value) || 0;
      const tau    = parseFloat(tauInput.value)    || 0;
      const lambda = parseFloat(lambdaInput.value) || 0;
      const t      = parseFloat(tProbeInput.value) || 0;
      const r      = parseFloat(rProbeInput.value) || 0;

      const tfac = K_norm_t(t, tau);
      const rfac = K_norm_r(r, lambda);
      const kRel = tfac * rfac;
      const k    = sigma2 * kRel;

      outSigma2.textContent = sigma2.toFixed(3);
      outK.textContent      = k.toExponential(4);
      outKRel.textContent   = kRel.toFixed(4);
      outTfac.textContent   = tfac.toFixed(4);
      outRfac.textContent   = rfac.toFixed(4);
    }

    function drawChart() {
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      ctx.fillStyle = '#020617';
      ctx.fillRect(0, 0, w, h);

      ctx.save();
      ctx.translate(48, 16);
      const plotW = w - 64;
      const plotH = h - 48;

      const tau    = parseFloat(tauInput.value)    || 1;
      const lambda = parseFloat(lambdaInput.value) || 1;

      // We'll split the canvas vertically: top half = temporal, bottom half = spatial
      const halfH = (plotH - 16) / 2;

      // Utility: draw one panel
      function drawPanel(yOffset, xMax, xLabel, yLabel, fn) {
        ctx.save();
        ctx.translate(0, yOffset);

        const panelW = plotW;
        const panelH = halfH;

        ctx.strokeStyle = '#1f2937';
        ctx.lineWidth = 1;
        // axes
        ctx.beginPath();
        ctx.moveTo(0, panelH);
        ctx.lineTo(panelW, panelH);
        ctx.moveTo(0, 0);
        ctx.lineTo(0, panelH);
        ctx.stroke();

        // grid + labels
        ctx.fillStyle = '#64748b';
        ctx.font = '10px system-ui';

        const tickCountY = 4;
        for (let i = 0; i <= tickCountY; i++) {
          const yVal = i / tickCountY;
          const yPix = panelH - yVal * panelH;
          ctx.beginPath();
          ctx.moveTo(0, yPix);
          ctx.lineTo(panelW, yPix);
          ctx.strokeStyle = 'rgba(100,116,139,0.25)';
          ctx.stroke();
          ctx.fillText(yVal.toFixed(1), -28, yPix + 3);
        }

        // x-axis labels: 0, xMax/2, xMax
        const tickCountX = 4;
        for (let i = 0; i <= tickCountX; i++) {
          const xVal = (i / tickCountX) * xMax;
          const xPix = (i / tickCountX) * panelW;
          ctx.fillText(xVal.toFixed(1), xPix - 6, panelH + 12);
        }

        ctx.fillText(xLabel, panelW - 40, panelH + 24);
        ctx.fillText(yLabel, -4, -6);

        // curve
        ctx.beginPath();
        const steps = 120;
        for (let i = 0; i <= steps; i++) {
          const t = (i / steps) * xMax;
          const yVal = fn(t);
          const xPix = (t / xMax) * panelW;
          const yPix = panelH - yVal * panelH;
          if (i === 0) ctx.moveTo(xPix, yPix);
          else ctx.lineTo(xPix, yPix);
        }
        ctx.strokeStyle = '#38bdf8';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();
      }

      // temporal: t in [0, 5 tau]
      const tMax = 5 * tau;
      drawPanel(
        0,
        tMax > 0 ? tMax : 5,
        't',
        'K(t,0)/œÉ¬≤',
        (t) => K_norm_t(t, tau)
      );

      // spatial: r in [0, 4 lambda]
      const rMax = 4 * lambda;
      drawPanel(
        halfH + 16,
        rMax > 0 ? rMax : 4,
        'r',
        'K(0,r)/œÉ¬≤',
        (r) => K_norm_r(r, lambda)
      );

      ctx.restore();
    }

    // Wiring
    recalcBtn.addEventListener('click', recomputeCurves);
    sigma2Input.addEventListener('change', recomputeCurves);
    tauInput.addEventListener('change', recomputeCurves);
    lambdaInput.addEventListener('change', recomputeCurves);

    probeBtn.addEventListener('click', doProbe);
    tProbeInput.addEventListener('change', doProbe);
    rProbeInput.addEventListener('change', doProbe);

    // Initial draw
    drawChart();
  

// --- qds_domain_map_animated_v1.html ---

function toggleDomain(id) {
    const box = document.getElementById(id);
    box.classList.toggle("active");
}


// --- qds_production_dashboard_v1.html ---

function animateValue(id, end, duration) {
    let obj = document.getElementById(id);
    let start = 0;
    let range = end - start;
    let increment = end > start ? 1 : -1;
    let stepTime = Math.abs(Math.floor(duration / range));

    let timer = setInterval(function() {
        start += increment;
        obj.textContent = start.toLocaleString();
        if (start == end) clearInterval(timer);
    }, stepTime);
}

animateValue("devCount", 2182, 1500);
animateValue("docCount", 793, 1300);
animateValue("photoCount", 6797, 1700);
animateValue("totalCount", 2182 + 793 + 6797, 2000);

document.getElementById("trophyMode").onclick = function() {
    let msg = document.getElementById("trophyMessage");
    msg.style.display = (msg.style.display === "none") ? "block" : "none";
};


// --- growthhub_allinone_v1.backup.html ---

  // PWA install flow
  let deferredPrompt = null;
  const btn = document.getElementById("installBtn");

  window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    deferredPrompt = e;
    btn.style.display = "inline-block";
  });

  btn.addEventListener("click", async () => {
    if (!deferredPrompt) {
      alert("If the install prompt doesn't appear, use Chrome menu: ‚ãÆ ‚Üí Add to Home screen.");
      return;
    }
    deferredPrompt.prompt();
    const choice = await deferredPrompt.userChoice;
    deferredPrompt = null;
    btn.style.display = "none";
  });

  // Register service worker
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./sw-growthhub.js").catch(()=>{});
    });
  }


// --- dev_door_space.html ---

  const ITEMS = [
    {"file":"QDS-5-WEDGE-PORTFOLIO/index.html","title":"index","cat":"Business/Offers"},{"file":"QDS_Battery_Lab/index.html","title":"index","cat":"Battery"},{"file":"all_pages.html","title":"all pages","cat":"Other"},{"file":"all_pages_compact.html","title":"all pages compact","cat":"Other"},{"file":"all_pages_index.html","title":"all pages index","cat":"Other"},{"file":"all_pages_min.html","title":"all pages min","cat":"Other"},{"file":"cannon_side_2d_v1.html","title":"cannon side 2d v1","cat":"Games/Toys"},{"file":"cannon_wall_breaker_v1.html","title":"cannon wall breaker v1","cat":"Games/Toys"},{"file":"cannon_wall_breaker_v1_1.html","title":"cannon wall breaker v1 1","cat":"Games/Toys"},{"file":"catapult_balloon_pop_v1.html","title":"catapult balloon pop v1","cat":"Games/Toys"},{"file":"ddmelts_microsite_v1.html","title":"ddmelts microsite v1","cat":"Other"},{"file":"ddmelts_microsite_v1_1.html","title":"ddmelts microsite v1 1","cat":"Other"},{"file":"ddmelts_microsite_v1_2_live_links.html","title":"ddmelts microsite v1 2 live links","cat":"Other"},{"file":"ddmelts_microsite_v1_2_pink_hearts.html","title":"ddmelts microsite v1 2 pink hearts","cat":"Other"},{"file":"dev_door_space.html","title":"dev door space","cat":"Dev/Index"},{"file":"dev_hub.html","title":"dev hub","cat":"Dev/Index"},{"file":"f/index.html","title":"index","cat":"Other"},{"file":"frontdoor.html","title":"frontdoor","cat":"Front Doors"},{"file":"frontdoor_show.html","title":"frontdoor show","cat":"Front Doors"},{"file":"growthhub.html","title":"growthhub","cat":"GrowthHub"},{"file":"growthhub_allinone_v1.html","title":"growthhub allinone v1","cat":"GrowthHub"},{"file":"growthhub_allinone_v1_1.html","title":"growthhub allinone v1 1","cat":"GrowthHub"},{"file":"growthhub_demo_front_20251207_170108.html","title":"growthhub demo front 20251207 170108","cat":"GrowthHub"},{"file":"growthhub_demo_front_20251207_172220.html","title":"growthhub demo front 20251207 172220","cat":"GrowthHub"},{"file":"growthhub_jargon_v1.html","title":"growthhub jargon v1","cat":"GrowthHub"},{"file":"growthhub_linked_20251207_162635.html","title":"growthhub linked 20251207 162635","cat":"GrowthHub"},{"file":"growthhub_linked_20251207_162917.html","title":"growthhub linked 20251207 162917","cat":"GrowthHub"},{"file":"growthhub_linked_20251207_163105.html","title":"growthhub linked 20251207 163105","cat":"GrowthHub"},{"file":"growthhub_linked_20251207_163119.html","title":"growthhub linked 20251207 163119","cat":"GrowthHub"},{"file":"growthhub_linked_20251207_163619.html","title":"growthhub linked 20251207 163619","cat":"GrowthHub"},{"file":"growthhub_linked_20251207_163635.html","title":"growthhub linked 20251207 163635","cat":"GrowthHub"},{"file":"growthhub_linked_20251207_165546.html","title":"growthhub linked 20251207 165546","cat":"GrowthHub"},{"file":"growthhub_linked_20251207_165600.html","title":"growthhub linked 20251207 165600","cat":"GrowthHub"},{"file":"growthhub_linked_20251207_165721.html","title":"growthhub linked 20251207 165721","cat":"GrowthHub"},{"file":"growthhub_meeting_script_v1.html","title":"growthhub meeting script v1","cat":"GrowthHub"},{"file":"growthhub_multi_area_stack_v1.html","title":"growthhub multi area stack v1","cat":"GrowthHub"},{"file":"growthhub_official_top5.html","title":"growthhub official top5","cat":"GrowthHub"},{"file":"growthhub_official_top5_demo_front_20251207_170108.html","title":"growthhub official top5 demo front 20251207 170108","cat":"GrowthHub"},{"file":"growthhub_official_top5_demo_front_20251207_172220.html","title":"growthhub official top5 demo front 20251207 172220","cat":"GrowthHub"},{"file":"growthhub_official_top5_with_offer_20251207_165318.html","title":"growthhub official top5 with offer 20251207 165318","cat":"GrowthHub"},{"file":"growthhub_official_top5_with_offer_20251207_165325.html","title":"growthhub official top5 with offer 20251207 165325","cat":"GrowthHub"},{"file":"growthhub_official_top5_with_offer_20251207_165411.html","title":"growthhub official top5 with offer 20251207 165411","cat":"GrowthHub"},{"file":"growthhub_official_top5_with_offer_20251207_165424.html","title":"growthhub official top5 with offer 20251207 165424","cat":"GrowthHub"},{"file":"growthhub_official_top5_with_offer_20251207_165431.html","title":"growthhub official top5 with offer 20251207 165431","cat":"GrowthHub"},{"file":"growthhub_official_top5_with_offer_20251207_165545.html","title":"growthhub official top5 with offer 20251207 165545","cat":"GrowthHub"},{"file":"growthhub_official_top5_with_offer_20251207_165559.html","title":"growthhub official top5 with offer 20251207 165559","cat":"GrowthHub"},{"file":"growthhub_official_top5_with_offer_20251207_165720.html","title":"growthhub official top5 with offer 20251207 165720","cat":"GrowthHub"},{"file":"growthhub_stroud_demo.html","title":"growthhub stroud demo","cat":"GrowthHub"},{"file":"growthhub_with_offer_20251207_165318.html","title":"growthhub with offer 20251207 165318","cat":"GrowthHub"},{"file":"growthhub_with_offer_20251207_165325.html","title":"growthhub with offer 20251207 165325","cat":"GrowthHub"},{"file":"growthhub_with_offer_20251207_165411.html","title":"growthhub with offer 20251207 165411","cat":"GrowthHub"},{"file":"growthhub_with_offer_20251207_165424.html","title":"growthhub with offer 20251207 165424","cat":"GrowthHub"},{"file":"growthhub_with_offer_20251207_165431.html","title":"growthhub with offer 20251207 165431","cat":"GrowthHub"},{"file":"growthhub_with_offer_20251207_165545.html","title":"growthhub with offer 20251207 165545","cat":"GrowthHub"},{"file":"growthhub_with_offer_20251207_165559.html","title":"growthhub with offer 20251207 165559","cat":"GrowthHub"},{"file":"growthhub_with_offer_20251207_165720.html","title":"growthhub with offer 20251207 165720","cat":"GrowthHub"},{"file":"index.html","title":"index","cat":"Other"},{"file":"index_demo_front_20251207_170108.html","title":"index demo front 20251207 170108","cat":"Other"},{"file":"index_demo_front_20251207_172220.html","title":"index demo front 20251207 172220","cat":"Other"},{"file":"index_with_offer_20251207_165318.html","title":"index with offer 20251207 165318","cat":"Business/Offers"},{"file":"index_with_offer_20251207_165325.html","title":"index with offer 20251207 165325","cat":"Business/Offers"},{"file":"index_with_offer_20251207_165411.html","title":"index with offer 20251207 165411","cat":"Business/Offers"},{"file":"index_with_offer_20251207_165424.html","title":"index with offer 20251207 165424","cat":"Business/Offers"},{"file":"index_with_offer_20251207_165431.html","title":"index with offer 20251207 165431","cat":"Business/Offers"},{"file":"index_with_offer_20251207_165545.html","title":"index with offer 20251207 165545","cat":"Business/Offers"},{"file":"index_with_offer_20251207_165559.html","title":"index with offer 20251207 165559","cat":"Business/Offers"},{"file":"index_with_offer_20251207_165720.html","title":"index with offer 20251207 165720","cat":"Business/Offers"},{"file":"indus_atlas_v1_qds_language_lab.html","title":"indus atlas v1 qds language lab","cat":"Language/Heritage"},{"file":"last5days_index.html","title":"last5days index","cat":"Other"},{"file":"legacy_hub_v1.html","title":"legacy hub v1","cat":"Other"},{"file":"offer_demo_suite_v1.html","title":"offer demo suite v1","cat":"Business/Offers"},{"file":"offer_index_v1.html","title":"offer index v1","cat":"Business/Offers"},{"file":"offer_microsite_v1.html","title":"offer microsite v1","cat":"Business/Offers"},{"file":"offer_showcase_hub_v1.html","title":"offer showcase hub v1","cat":"Business/Offers"},{"file":"omega_os_index_v1.html","title":"omega os index v1","cat":"Other"},{"file":"omega_os_index_v2.html","title":"omega os index v2","cat":"Other"},{"file":"omega_qds_lab.html","title":"omega qds lab","cat":"Other"},{"file":"portfolio.html","title":"portfolio","cat":"Business/Offers"},{"file":"portfolio_market_allinone_v1.html","title":"portfolio market allinone v1","cat":"Business/Offers"},{"file":"portfolio_offer_v2.html","title":"portfolio offer v2","cat":"Business/Offers"},{"file":"portfolio_offer_v2_20251206_134821.html","title":"portfolio offer v2 20251206 134821","cat":"Business/Offers"},{"file":"portfolio_ultimate_allinone_v1.html","title":"portfolio ultimate allinone v1","cat":"Business/Offers"},{"file":"portfolio_v1.html","title":"portfolio v1","cat":"Business/Offers"},{"file":"proof_of_ship_v1.html","title":"proof of ship v1","cat":"Other"},{"file":"pyramid_pinball_v1.html","title":"pyramid pinball v1","cat":"Games/Toys"},{"file":"q.html","title":"q","cat":"Other"},{"file":"qds_5_pillars_hub.html","title":"qds 5 pillars hub","cat":"Other"},{"file":"qds_5_pillars_hub_v1.html","title":"qds 5 pillars hub v1","cat":"Other"},{"file":"qds_battery_coach_v3.html","title":"qds battery coach v3","cat":"Battery"},{"file":"qds_battery_design_v1.html","title":"qds battery design v1","cat":"Battery"},{"file":"qds_battery_habitat_demo.html","title":"qds battery habitat demo","cat":"Battery"},{"file":"qds_battery_habitat_v1_1_build_001.html","title":"qds battery habitat v1 1 build 001","cat":"Battery"},{"file":"qds_battery_habitat_v1_2_build002.html","title":"qds battery habitat v1 2 build002","cat":"Battery"},{"file":"qds_battery_hub_v9_1_purple_neon.html","title":"qds battery hub v9 1 purple neon","cat":"Battery"},{"file":"qds_battery_hub_v9_2_purple_neon.html","title":"qds battery hub v9 2 purple neon","cat":"Battery"},{"file":"qds_battery_hub_v9_3_science_neon.html","title":"qds battery hub v9 3 science neon","cat":"Battery"},{"file":"qds_battery_hub_v9_4_science_neon_plus.html","title":"qds battery hub v9 4 science neon plus","cat":"Battery"},{"file":"qds_battery_hub_v9_5_1_science_neon.html","title":"qds battery hub v9 5 1 science neon","cat":"Battery"},{"file":"qds_battery_hub_v9_5_science_neon.html","title":"qds battery hub v9 5 science neon","cat":"Battery"},{"file":"qds_battery_hub_v9_6_science_neon.html","title":"qds battery hub v9 6 science neon","cat":"Battery"},{"file":"qds_battery_hub_v9_7_science_neon_lab.html","title":"qds battery hub v9 7 science neon lab","cat":"Battery"},{"file":"qds_battery_index_v1_neon_os.html","title":"qds battery index v1 neon os","cat":"Battery"},{"file":"qds_battery_lab.html","title":"qds battery lab","cat":"Battery"},{"file":"qds_battery_lab_showcase_stress_bias_v1.html","title":"qds battery lab showcase stress bias v1","cat":"Battery"},{"file":"qds_battery_lab_showcase_stress_bias_v2.html","title":"qds battery lab showcase stress bias v2","cat":"Battery"},{"file":"qds_battery_lab_showcase_v1.html","title":"qds battery lab showcase v1","cat":"Battery"},{"file":"qds_battery_noise_toy_v1.html","title":"qds battery noise toy v1","cat":"Battery"},{"file":"qds_battery_os_index_v1.html","title":"qds battery os index v1","cat":"Battery"},{"file":"qds_battery_suite_v4_showcase.html","title":"qds battery suite v4 showcase","cat":"Battery"},{"file":"qds_battery_suite_v5_boss_polish.html","title":"qds battery suite v5 boss polish","cat":"Battery"},{"file":"qds_battery_suite_v6_realworld.html","title":"qds battery suite v6 realworld","cat":"Battery"},{"file":"qds_battery_suite_v8_1_fairpath.html","title":"qds battery suite v8 1 fairpath","cat":"Battery"},{"file":"qds_battery_suite_v8_2_poster_tamed.html","title":"qds battery suite v8 2 poster tamed","cat":"Battery"},{"file":"qds_battery_suite_v8_3_neon_shell.html","title":"qds battery suite v8 3 neon shell","cat":"Battery"},{"file":"qds_battery_suite_v8_nextlevel.html","title":"qds battery suite v8 nextlevel","cat":"Battery"},{"file":"qds_battery_whisperer_v2.html","title":"qds battery whisperer v2","cat":"Battery"},{"file":"qds_business_projection_posh_v1.html","title":"qds business projection posh v1","cat":"Business/Offers"},{"file":"qds_chips_noise_v1.html","title":"qds chips noise v1","cat":"Other"},{"file":"qds_compression_lab_v1.html","title":"qds compression lab v1","cat":"Compression"},{"file":"qds_domain_map.html","title":"qds domain map","cat":"Maps/Local"},{"file":"qds_domain_map_animated_v1.html","title":"qds domain map animated v1","cat":"Maps/Local"},{"file":"qds_micro_lab.html","title":"qds micro lab","cat":"Other"},{"file":"qds_offer_bundle_v1_20251207_165042.html","title":"qds offer bundle v1 20251207 165042","cat":"Business/Offers"},{"file":"qds_offer_bundle_v1_20251207_165051.html","title":"qds offer bundle v1 20251207 165051","cat":"Business/Offers"},{"file":"qds_production_dashboard_v1.html","title":"qds production dashboard v1","cat":"Other"},{"file":"qds_revenue_floor_BASE.html","title":"qds revenue floor BASE","cat":"Business/Offers"},{"file":"qds_revenue_floor_STRETCH.html","title":"qds revenue floor STRETCH","cat":"Business/Offers"},{"file":"qds_revenue_floor_v2.html","title":"qds revenue floor v2","cat":"Business/Offers"},{"file":"qds_revenue_onepager.html","title":"qds revenue onepager","cat":"Business/Offers"},{"file":"qds_revenue_predictor_v1.html","title":"qds revenue predictor v1","cat":"Business/Offers"},{"file":"qds_rotation_lab.html","title":"qds rotation lab","cat":"Other"},{"file":"qds_sensors_metrology_v1.html","title":"qds sensors metrology v1","cat":"Other"},{"file":"qds_shed_index_v1.html","title":"qds shed index v1","cat":"Other"},{"file":"qds_showcase_index_v1.html","title":"qds showcase index v1","cat":"Other"},{"file":"qds_showcase_index_v1_1.html","title":"qds showcase index v1 1","cat":"Other"},{"file":"qds_solar_v6_textures.html","title":"qds solar v6 textures","cat":"Universe/Demos"},{"file":"qds_test_platform.html","title":"qds test platform","cat":"Other"},{"file":"qds_test_task_pack_v1.html","title":"qds test task pack v1","cat":"Other"},{"file":"qds_test_task_pack_v1_1_pro.html","title":"qds test task pack v1 1 pro","cat":"Other"},{"file":"qds_universe_v12b_mobile.html","title":"qds universe v12b mobile","cat":"Universe/Demos"},{"file":"qds_universe_v9_10_neon_planet_colours.html","title":"qds universe v9 10 neon planet colours","cat":"Universe/Demos"},{"file":"qds_universe_v9_2_neon_clear_planets.html","title":"qds universe v9 2 neon clear planets","cat":"Universe/Demos"},{"file":"qds_universe_v9_6_turbo_pan.html","title":"qds universe v9 6 turbo pan","cat":"Universe/Demos"},{"file":"qds_variance_lab.html","title":"qds variance lab","cat":"Other"},{"file":"solar_system_v8_offline.html","title":"solar system v8 offline","cat":"Universe/Demos"},{"file":"solar_system_v9_2_mobile_3d_showcase.html","title":"solar system v9 2 mobile 3d showcase","cat":"Universe/Demos"},{"file":"start_here_90s_v1.html","title":"start here 90s v1","cat":"Other"},{"file":"stinchcombe_map.html","title":"stinchcombe map","cat":"Maps/Local"}
  ];

  // Tiny helper to sort newest-ish by filename fallback
  // (We avoid fs calls since this is a static page).
  function scoreName(s){
    // prefer timestamp-like chunks
    const m = s.match(/(20\d{6})_(\d{6})|(20\d{2})(\d{2})(\d{2})/);
    if (!m) return 0;
    return 1;
  }

  const q = document.getElementById("q");
  const cat = document.getElementById("cat");
  const list = document.getElementById("list");
  const count = document.getElementById("count");
  const latestBtn = document.getElementById("latestBtn");
  const allBtn = document.getElementById("allBtn");
  const listTitle = document.getElementById("listTitle");

  // Populate categories
  const cats = Array.from(new Set(ITEMS.map(i => i.cat))).sort();
  for (const c of cats){
    const opt = document.createElement("option");
    opt.value = c;
    opt.textContent = c;
    cat.appendChild(opt);
  }

  let mode = "ALL";

  function render(){
    const term = (q.value || "").toLowerCase().trim();
    const csel = cat.value;

    let data = ITEMS.slice();

    if (csel !== "ALL"){
      data = data.filter(i => i.cat === csel);
    }

    if (term){
      data = data.filter(i =>
        i.title.toLowerCase().includes(term) ||
        i.file.toLowerCase().includes(term)
      );
    }

    if (mode === "LATEST"){
      // crude "latest-ish": prioritize names with timestamps and longer versions
      data = data
        .sort((a,b) => (scoreName(b.file) - scoreName(a.file)) || (b.file.localeCompare(a.file)))
        .slice(0,20);
      listTitle.textContent = "Latest 20 (name-ranked)";
    } else {
      listTitle.textContent = "Files";
    }

    list.innerHTML = "";
    count.textContent = ITEMS.length;

    for (const i of data){
      const row = document.createElement("div");
      row.className = "item";

      const left = document.createElement("div");
      left.className = "left";

      const t = document.createElement("div");
      t.className = "item-title";
      t.textContent = i.title;

      const p = document.createElement("div");
      p.className = "item-path mono";
      p.textContent = i.file;

      const tag = document.createElement("span");
      tag.className = "tag";
      tag.textContent = i.cat;

      left.appendChild(tag);
      left.appendChild(t);
      left.appendChild(p);

      const right = document.createElement("div");
      right.className = "right";

      const open = document.createElement("a");
      open.className = "btn";
      open.href = i.file;
      open.textContent = "Open";

      const copy = document.createElement("button");
      copy.className = "btn btn-quiet";
      copy.textContent = "Copy path";
      copy.addEventListener("click", async () => {
        try{
          await navigator.clipboard.writeText(i.file);
          copy.textContent = "Copied";
          setTimeout(()=>copy.textContent="Copy path", 800);
        }catch(e){
          copy.textContent = "No clipboard";
          setTimeout(()=>copy.textContent="Copy path", 900);
        }
      });

      right.appendChild(open);
      right.appendChild(copy);

      row.appendChild(left);
      row.appendChild(right);
      list.appendChild(row);
    }

    if (!data.length){
      const empty = document.createElement("div");
      empty.className = "muted tiny";
      empty.textContent = "No matches. Try clearing filters.";
      list.appendChild(empty);
    }
  }

  q.addEventListener("input", render);
  cat.addEventListener("change", render);

  latestBtn.addEventListener("click", () => { mode="LATEST"; render(); });
  allBtn.addEventListener("click", () => { mode="ALL"; render(); });

  render();


// --- frontdoor_show_backup_20251210_222432.html ---


// --- frontdoor_show_fix_revenue_20251210_223127.html ---


// --- h_code_warning_nodes_demo.html ---

    // === H-Code Warning Nodes Demo ===
    // Each node emits [Node][State][Trend] codewords:
    // Node: C,G,R,V,S,P,A
    // State: O,W,S,D,F
    // Trend: +,-,~,?

    const nodeDefinitions = [
      { id: "C", name: "CPU Corefield", role: "Compute" },
      { id: "G", name: "GPU Array", role: "Graphics" },
      { id: "R", name: "RAM Lattice", role: "Memory" },
      { id: "V", name: "VRM Spine", role: "Power Rail" },
      { id: "S", name: "SSD Channel", role: "Storage" },
      { id: "P", name: "PSU Anchor", role: "Supply" },
      { id: "A", name: "Ambient Shell", role: "Chassis" }
    ];

    // Internal state for simulation
    const nodesState = {};
    const loadBaseline = {
      C: 0.35,
      G: 0.30,
      R: 0.25,
      V: 0.28,
      S: 0.22,
      P: 0.26,
      A: 0.18
    };

    const nodeElements = {};
    let simInterval = null;
    let simRunning = true;
    let lastEventLevel = "ok";

    // DOM references
    const nodesGridEl = document.getElementById("nodesGrid");
    const logListEl = document.getElementById("logList");
    const logSummaryEl = document.getElementById("logSummary");
    const globalSummaryEl = document.getElementById("globalSummary");
    const toggleSimBtn = document.getElementById("toggleSimBtn");
    const simStatusDot = document.getElementById("simStatusDot");
    const simStatusText = document.getElementById("simStatusText");
    const injectEventBtn = document.getElementById("injectEventBtn");

    // Utility: random with normal-ish flavour
    function jitter(scale = 0.05) {
      return (Math.random() - 0.5) * scale * 2;
    }

    function clamp(x, min, max) {
      return x < min ? min : x > max ? max : x;
    }

    // Map load (0..1) to H-state
    function loadToState(load, degradingFlag) {
      if (degradingFlag && load < 0.85) {
        // occasional quiet degradation
        return "D";
      }
      if (load < 0.35) return "O";
      if (load < 0.6) return "W";
      if (load < 0.8) return "S";
      if (load < 0.95) return degradingFlag ? "D" : "S";
      return degradingFlag ? "F" : "S";
    }

    function stateToLabel(state) {
      switch (state) {
        case "O": return "OK";
        case "W": return "Warming";
        case "S": return "Stressed";
        case "D": return "Degrading";
        case "F": return "Critical";
        default:  return "Unknown";
      }
    }

    function stateToLevel(state) {
      if (state === "O" || state === "W") return "ok";
      if (state === "S" || state === "D") return "warn";
      return "crit";
    }

    function trendToText(trend) {
      switch (trend) {
        case "+": return "Rising";
        case "-": return "Recovering";
        case "~": return "Stable";
        case "?": return "Noisy";
        default: return "";
      }
    }

    // Build node cards
    function buildNodes() {
      nodeDefinitions.forEach(def => {
        const outer = document.createElement("div");
        outer.className = "node-card";
        outer.dataset.nodeId = def.id;

        outer.innerHTML = `
          <div class="node-header">
            <div class="node-name">
              <div class="node-icon">${def.id}</div>
              <div>${def.name}</div>
            </div>
            <div class="node-role">${def.role}</div>
          </div>
          <div class="node-main">
            <div class="node-code">
              <span class="node-id">${def.id}</span><span class="state">O</span><span class="trend">~</span>
            </div>
            <div class="node-status">
              <div class="status-label">
                <div class="status-dot ok"></div>
                <span class="status-text">OK ¬∑ Stable</span>
              </div>
            </div>
          </div>
          <div class="node-bar">
            <div class="node-bar-fill" style="width:30%"></div>
          </div>
          <div class="node-footer">
            <span class="node-last">Last change: ‚Äî</span>
            <span class="node-rate">0.0 pkt/s</span>
          </div>
        `;

        nodesGridEl.appendChild(outer);

        // keep references
        nodeElements[def.id] = {
          root: outer,
          codeId: outer.querySelector(".node-code .node-id"),
          codeState: outer.querySelector(".node-code .state"),
          codeTrend: outer.querySelector(".node-code .trend"),
          statusLabel: outer.querySelector(".status-text"),
          statusDot: outer.querySelector(".status-dot"),
          barFill: outer.querySelector(".node-bar-fill"),
          lastChange: outer.querySelector(".node-last"),
          rate: outer.querySelector(".node-rate")
        };

        // initial state
        nodesState[def.id] = {
          load: clamp(loadBaseline[def.id] + jitter(0.08), 0.05, 0.6),
          lastLoad: loadBaseline[def.id],
          degradingScore: 0,
          lastTimestamp: performance.now(),
          packetCountWindow: 0,
          lastRateUpdate: performance.now(),
          lastCode: null
        };
      });
    }

    // Logging
    function addLogEntry(nodeId, state, trend) {
      const now = new Date();
      const t = now.toLocaleTimeString(undefined, { hour12: false });

      const level = stateToLevel(state);
      lastEventLevel = level;

      const li = document.createElement("li");
      li.className = "log-item";

      li.innerHTML = `
        <div class="log-left">
          <div class="log-top">
            <span class="log-node">${nodeId}</span>
            <span class="log-code">${nodeId}${state}${trend}</span>
          </div>
          <div class="log-meta">
            <span class="log-desc"></span>
          </div>
        </div>
        <div class="log-time">${t}</div>
      `;

      const descSpan = li.querySelector(".log-desc");
      const humanState = stateToLabel(state);
      const trendText = trendToText(trend);
      descSpan.textContent = `${humanState}${trendText ? " ¬∑ " + trendText : ""}`;

      if (level === "ok") {
        li.querySelector(".log-code").classList.add("log-level-ok");
      } else if (level === "warn") {
        li.querySelector(".log-code").classList.add("log-level-warn");
      } else {
        li.querySelector(".log-code").classList.add("log-level-crit");
      }

      // Prepend
      logListEl.insertBefore(li, logListEl.firstChild);

      // Trim log
      const maxItems = 28;
      while (logListEl.children.length > maxItems) {
        logListEl.removeChild(logListEl.lastChild);
      }

      // Update summary
      if (level === "ok") {
        logSummaryEl.textContent = "Recent packets: calm to medium load.";
      } else if (level === "warn") {
        logSummaryEl.textContent = "Recent packets: nodes reporting stress / degradation.";
      } else {
        logSummaryEl.textContent = "Recent packets: CRITICAL activity detected.";
      }
    }

    // Update node visual state
    function updateNodeVisual(nodeId, state, trend, load, ts) {
      const els = nodeElements[nodeId];
      const st = nodesState[nodeId];
      if (!els || !st) return;

      els.codeState.textContent = state;
      els.codeTrend.textContent = trend;

      const label = stateToLabel(state);
      const trendText = trendToText(trend);
      els.statusLabel.textContent = `${label}${trendText ? " ¬∑ " + trendText : ""}`;

      // Status dot colour
      els.statusDot.classList.remove("ok", "warn", "danger");
      const level = stateToLevel(state);
      if (level === "ok") {
        els.statusDot.classList.add("ok");
      } else if (level === "warn") {
        els.statusDot.classList.add("warn");
      } else {
        els.statusDot.classList.add("danger");
      }

      // Bar fill as load (15‚Äì96%)
      const width = 15 + load * 81;
      els.barFill.style.width = `${width.toFixed(0)}%`;

      // Last change text
      els.lastChange.textContent = "Last change: just now";

      // Rate estimate (simple window)
      st.packetCountWindow++;
      const nowMs = ts;
      if (nowMs - st.lastRateUpdate > 2000) {
        const dt = (nowMs - st.lastRateUpdate) / 1000;
        const rate = st.packetCountWindow / dt;
        els.rate.textContent = `${rate.toFixed(1)} pkt/s`;
        st.packetCountWindow = 0;
        st.lastRateUpdate = nowMs;
      }

      // Log when code actually changed
      const newCode = nodeId + state + trend;
      if (newCode !== st.lastCode) {
        addLogEntry(nodeId, state, trend);
        st.lastCode = newCode;
      }
    }

    function updateGlobalSummary() {
      let totalLoad = 0;
      let count = 0;
      let worstLevel = "ok";
      for (const id in nodesState) {
        const st = nodesState[id];
        totalLoad += st.load;
        count++;
        const state = loadToState(st.load, st.degradingScore > 0.6);
        const level = stateToLevel(state);
        if (worstLevel === "ok" && (level === "warn" || level === "crit")) {
          worstLevel = level;
        } else if (worstLevel === "warn" && level === "crit") {
          worstLevel = "crit";
        }
      }
      const avgLoad = totalLoad / Math.max(1, count);
      let text;
      if (worstLevel === "ok") {
        if (avgLoad < 0.35) text = "Baseline load pattern ¬∑ Calm";
        else text = "Normal activity ¬∑ Load oscillating safely";
      } else if (worstLevel === "warn") {
        text = "Mesh reporting stress ¬∑ Watch conditions";
      } else {
        text = "Mesh in critical band ¬∑ Intervene now";
      }
      globalSummaryEl.textContent = text;
    }

    // Simulation step
    function stepSimulation() {
      const now = performance.now();

      nodeDefinitions.forEach(def => {
        const id = def.id;
        const st = nodesState[id];

        // Drift load toward baseline with jitter
        const baseline = loadBaseline[id];
        const relax = 0.08;
        const toBaseline = baseline - st.load;
        let load = st.load + toBaseline * relax + jitter(0.04);

        // Occasionally push into stress bands
        if (Math.random() < 0.02) {
          load += 0.25 + Math.random() * 0.25;
        }

        // Slow degradation creep for storage / PSU
        if (id === "S" || id === "P" || id === "V") {
          if (Math.random() < 0.01) {
            st.degradingScore = clamp(st.degradingScore + 0.08, 0, 1);
          } else {
            st.degradingScore = clamp(st.degradingScore - 0.01, 0, 1);
          }
        }

        load = clamp(load, 0, 1);
        const trend =
          Math.abs(load - st.lastLoad) < 0.02
            ? (Math.random() < 0.15 ? "?" : "~")
            : load > st.lastLoad
              ? "+"
              : "-";

        const state = loadToState(load, st.degradingScore > 0.6);

        st.lastLoad = st.load;
        st.load = load;
        st.lastTimestamp = now;

        updateNodeVisual(id, state, trend, load, now);
      });

      updateGlobalSummary();
    }

    // Inject stress burst (for button)
    function injectStressEvent() {
      Object.keys(nodesState).forEach(id => {
        const st = nodesState[id];
        // Stress CPU & GPU hardest, others moderately
        let bump = 0.0;
        if (id === "C" || id === "G") bump = 0.35 + Math.random() * 0.2;
        else if (id === "V" || id === "P" || id === "S") bump = 0.18 + Math.random() * 0.18;
        else bump = 0.12 + Math.random() * 0.12;

        st.load = clamp(st.load + bump, 0, 1);
        if (id === "S" || id === "P") {
          st.degradingScore = clamp(st.degradingScore + 0.2, 0, 1);
        }
      });

      // Run a couple of extra steps to make it lively
      stepSimulation();
      setTimeout(stepSimulation, 220);
      setTimeout(stepSimulation, 520);
    }

    // Simulation controls
    function startSimulation() {
      if (simInterval) return;
      simInterval = setInterval(stepSimulation, 850);
      simRunning = true;
      simStatusText.textContent = "Running";
      simStatusDot.style.boxShadow = "0 0 10px rgba(123,255,107,0.9)";
    }

    function stopSimulation() {
      if (!simInterval) return;
      clearInterval(simInterval);
      simInterval = null;
      simRunning = false;
      simStatusText.textContent = "Paused";
      simStatusDot.style.boxShadow = "0 0 3px rgba(148,163,184,0.8)";
    }

    // Init
    buildNodes();
    // First few steps to populate UI
    for (let i = 0; i < 3; i++) {
      stepSimulation();
    }
    startSimulation();

    toggleSimBtn.addEventListener("click", () => {
      if (simRunning) stopSimulation();
      else startSimulation();
    });

    injectEventBtn.addEventListener("click", () => {
      injectStressEvent();
    });
  

// --- qds_binary_pulsar_lab_v2_max.html ---

(function(){
  "use strict";

  // ---- Units (optional display conversions) ----
  const UNITS = {
    "1": { name:"custom", toBase:x=>x, fromBase:x=>x, suffix:"" },
    "m": { name:"m", toBase:x=>x, fromBase:x=>x, suffix:" m" },
    "km": { name:"km", toBase:x=>x*1000, fromBase:x=>x/1000, suffix:" km" },
    "AU": { name:"AU", toBase:x=>x*149597870700, fromBase:x=>x/149597870700, suffix:" AU" },
    "ls": { name:"light-second", toBase:x=>x*299792458, fromBase:x=>x/299792458, suffix:" ls" }
  };

  // ---- DOM ----
  const $ = (id)=>document.getElementById(id);

  const el = {
    sys: $("sys"),
    unit: $("unit"),
    r: $("r"),
    alpha: $("alpha"),
    lam: $("lam"),
    band: $("band"),
    useAccel: $("useAccel"),
    useAbs: $("useAbs"),
    autoRun: $("autoRun"),
    eps: $("eps"),
    epsLabel: $("epsLabel"),

    btnEval: $("btnEval"),
    btnShare: $("btnShare"),
    btnExport: $("btnExport"),
    btnReset: $("btnReset"),

    kvMain: $("kvMain"),
    badge: $("badge"),

    // inverse
    btnAlphaMax: $("btnAlphaMax"),
    btnSetAlphaMax: $("btnSetAlphaMax"),
    kvAlphaMax: $("kvAlphaMax"),

    lamLo: $("lamLo"),
    lamHi: $("lamHi"),
    btnLamMin: $("btnLamMin"),
    btnSetLamMin: $("btnSetLamMin"),
    kvLamMin: $("kvLamMin"),

    // sweep
    alogLo: $("alogLo"),
    alogHi: $("alogHi"),
    llogLo: $("llogLo"),
    llogHi: $("llogHi"),
    res: $("res"),
    resLabel: $("resLabel"),
    btnDraw: $("btnDraw"),
    btnPick: $("btnPick"),
    map: $("map"),

    // tests
    btnSelf: $("btnSelf"),
    btnClearTests: $("btnClearTests"),
    kvTests: $("kvTests"),
    testLog: $("testLog"),

    // presets
    presetName: $("presetName"),
    presetList: $("presetList"),
    btnSavePreset: $("btnSavePreset"),
    btnLoadPreset: $("btnLoadPreset"),
    btnDelPreset: $("btnDelPreset"),

    backLink: $("backLink"),
    toast: $("toast"),
  };

  // ---- State ----
  const SKEY = "QDS_PULSAR_V2_MAX_PRESETS";
  let lastLamMin = null;
  let lastAlphaMax = null;

  let mapState = {
    lastImage: null,
    pickArmed: false,
    lastParams: null
  };

  function toast(msg){
    el.toast.textContent = msg;
    el.toast.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(()=>el.toast.classList.remove("show"), 1800);
  }

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function isFiniteNum(x){ return typeof x === "number" && Number.isFinite(x); }

  function fmt(x, sig=6){
    if(!isFiniteNum(x)) return "‚Äî";
    const ax = Math.abs(x);
    if(ax === 0) return "0";
    if(ax < 1e-3 || ax >= 1e6) return x.toExponential(3);
    // trim trailing zeros
    const s = x.toPrecision(sig);
    return String(Number(s));
  }

  function getEps(){
    // slider is log10(eps)
    const loge = parseFloat(el.eps.value);
    const eps = Math.pow(10, loge);
    return eps;
  }

  function updateEpsLabel(){
    const eps = getEps();
    el.epsLabel.textContent = eps.toExponential(1);
  }

  // ---- Core physics (toy) ----
  function kernelFactor(r, lam, useAccel){
    // protect
    if(!(r>=0) || !(lam>0)) return NaN;
    const x = r/lam;
    const e = Math.exp(-x);
    if(useAccel){
      // stricter "acceleration-like" Yukawa correction
      return (1 + x) * e;
    }
    // potential-like
    return e;
  }

  function classify(value, band, eps){
    // using magnitude check outside
    // EDGE if within eps of boundary
    const d = Math.abs(value - band);
    if(d <= eps) return "EDGE";
    return (value <= band) ? "OK" : "FAIL";
  }

  function compute(){
    const sys = (el.sys.value || "").trim() || "‚Äî";
    const unitKey = el.unit.value in UNITS ? el.unit.value : "1";
    const unit = UNITS[unitKey];

    const r = parseFloat(el.r.value);
    const alpha = parseFloat(el.alpha.value);
    const lam = parseFloat(el.lam.value);
    const band = parseFloat(el.band.value);

    const useAccel = !!el.useAccel.checked;
    const useAbs = !!el.useAbs.checked;

    // validation
    const errs = [];
    if(!isFiniteNum(r) || r < 0) errs.push("r must be a finite number ‚â• 0");
    if(!isFiniteNum(lam) || lam <= 0) errs.push("Œª must be a finite number > 0");
    if(!isFiniteNum(alpha)) errs.push("Œ± must be a finite number");
    if(!isFiniteNum(band) || band <= 0) errs.push("band must be a finite number > 0");

    const eps = getEps();

    if(errs.length){
      return {
        ok:false,
        sys, unitKey,
        errs,
        r, alpha, lam, band,
        eps,
        useAccel, useAbs
      };
    }

    const f = kernelFactor(r, lam, useAccel);
    const af = alpha * f;
    const mag = useAbs ? Math.abs(af) : af;
    const cls = classify(Math.abs(af), band, eps); // classification uses magnitude by default
    // if user disabled abs display, still compare magnitude for safety
    // (this avoids accidental "negative passes" by sign)
    return {
      ok:true,
      sys, unitKey,
      r, alpha, lam, band,
      x: r/lam,
      f, af, magAbs: Math.abs(af),
      eps,
      useAccel, useAbs,
      cls
    };
  }

  function setMainKV(res){
    const rows = el.kvMain.querySelectorAll(".v");
    // order matches kvMain definitions
    const mode = res.ok ? (res.useAccel ? "Strict accel: (1+r/Œª) e^{-r/Œª}" : "Potential: e^{-r/Œª}") : "‚Äî";
    const unit = UNITS[res.unitKey || "1"];
    const suf = unit?.suffix || "";

    const values = [
      res.sys ?? "‚Äî",
      res.ok ? (fmt(res.r) + suf) : "‚Äî",
      res.ok ? (fmt(res.lam) + suf) : "‚Äî",
      res.ok ? fmt(res.x) : "‚Äî",
      res.ok ? fmt(res.f) : "‚Äî",
      res.ok ? fmt(res.af) : "‚Äî",
      res.ok ? fmt(res.magAbs) : "‚Äî",
      res.ok ? fmt(res.band) : "‚Äî",
      mode
    ];
    for(let i=0;i<rows.length && i<values.length;i++){
      rows[i].textContent = values[i];
      rows[i].classList.remove("muted");
      if(!res.ok) rows[i].classList.add("muted");
    }
  }

  function setBadge(res){
    if(!res.ok){
      el.badge.className = "badge bad";
      el.badge.textContent = "Input error: " + res.errs[0] + (res.errs.length>1 ? ` (+${res.errs.length-1} more)` : "");
      return;
    }
    if(res.cls === "OK"){
      el.badge.className = "badge ok";
      el.badge.textContent = "OK: (Œ±, Œª) is inside pulsar timing band at this scale.";
    }else if(res.cls === "EDGE"){
      el.badge.className = "badge edge";
      el.badge.textContent = "EDGE: borderline at the band (within Œµ). Treat as ‚Äúneeds data-fit‚Äù.";
    }else{
      el.badge.className = "badge bad";
      el.badge.textContent = "Ruled out: (Œ±, Œª) overshoots pulsar timing limits (toy band).";
    }
  }

  function evaluate(){
    const res = compute();
    setMainKV(res);
    setBadge(res);
    mapState.lastParams = res.ok ? res : null;
    if(el.autoRun.checked){
      // keep heatmap marker updated (no auto redraw)
      drawMarkerOnly();
    }
    return res;
  }

  // ---- Inverse: alpha max ----
  function computeAlphaMax(){
    const res = compute();
    if(!res.ok){
      setAlphaMaxKV({ok:false, msg: res.errs.join("; ")});
      return null;
    }
    const f = res.f;
    if(!isFiniteNum(f) || f <= 0){
      setAlphaMaxKV({ok:false, msg:"invalid kernel factor (check r, Œª)"});
      return null;
    }
    const amax = res.band / f;
    lastAlphaMax = amax;
    setAlphaMaxKV({ok:true, amax, f, note:"Œ±max = band / f(r,Œª)"});
    return amax;
  }

  function setAlphaMaxKV(o){
    const rows = el.kvAlphaMax.querySelectorAll(".v");
    if(!o.ok){
      rows[0].textContent = "‚Äî";
      rows[1].textContent = "‚Äî";
      rows[2].textContent = o.msg || "‚Äî";
      rows[2].classList.remove("muted");
      return;
    }
    rows[0].textContent = fmt(o.amax);
    rows[1].textContent = fmt(o.f);
    rows[2].textContent = o.note || "‚Äî";
  }

  // ---- Inverse: lambda min (bisection) ----
  function solveLamMin(){
    const res = compute();
    if(!res.ok){
      setLamMinKV({ok:false, status: res.errs.join("; ")});
      return null;
    }

    const lamLo = parseFloat(el.lamLo.value);
    const lamHi = parseFloat(el.lamHi.value);
    if(!isFiniteNum(lamLo) || !isFiniteNum(lamHi) || lamLo <= 0 || lamHi <= 0 || lamLo >= lamHi){
      setLamMinKV({ok:false, status:"Bad Œª bounds: require 0 < Œªmin < Œªmax"});
      return null;
    }

    const r = res.r;
    const alpha = res.alpha;
    const band = res.band;
    const eps = res.eps;
    const useAccel = res.useAccel;

    function passAt(lam){
      const f = kernelFactor(r, lam, useAccel);
      const mag = Math.abs(alpha * f);
      return (mag <= band + eps); // allow epsilon cushion as pass
    }

    // If already passing at current Œª, show that and offer ‚ÄúŒªmin maybe smaller‚Äù
    // But we still solve for minimal within bounds.
    let lo = lamLo, hi = lamHi;

    // ensure hi passes; if not, no solution within bounds
    if(!passAt(hi)){
      setLamMinKV({ok:false, status:"No solution in bounds: even Œªmax fails. Increase Œª search max."});
      return null;
    }
    // ensure lo fails; if it already passes at lo, then Œªmin is at/below lo
    if(passAt(lo)){
      lastLamMin = lo;
      setLamMinKV({ok:true, lamMin: lo, it: 0, status:"Already OK at Œªmin bound. Œªmin ‚â§ ŒªminBound."});
      return lo;
    }

    const MAX_IT = 80;
    let it = 0;
    while(it < MAX_IT){
      const mid = 0.5*(lo+hi);
      if(passAt(mid)) hi = mid; else lo = mid;
      // stop when interval is tiny relative to mid
      const rel = (hi-lo) / Math.max(1e-30, mid);
      if(rel < 1e-9) break;
      it++;
    }
    lastLamMin = hi;
    setLamMinKV({ok:true, lamMin: hi, it, status:"Solved Œªmin (within bounds)."});
    return hi;
  }

  function setLamMinKV(o){
    const rows = el.kvLamMin.querySelectorAll(".v");
    if(!o.ok){
      rows[0].textContent = "‚Äî";
      rows[1].textContent = "‚Äî";
      rows[2].textContent = o.status || "‚Äî";
      return;
    }
    rows[0].textContent = fmt(o.lamMin);
    rows[1].textContent = String(o.it ?? "‚Äî");
    rows[2].textContent = o.status || "‚Äî";
  }

  // ---- Heatmap ----
  const ctx = el.map.getContext("2d");

  function colorFor(cls){
    // RGBA bytes
    if(cls === "OK")   return [57,255,136, 170];
    if(cls === "EDGE") return [255,209,102, 190];
    return [255,59,106, 190];
  }

  function drawHeatmap(){
    const base = compute();
    if(!base.ok){
      toast("Fix inputs before drawing heatmap.");
      return;
    }

    const al0 = parseFloat(el.alogLo.value);
    const al1 = parseFloat(el.alogHi.value);
    const ll0 = parseFloat(el.llogLo.value);
    const ll1 = parseFloat(el.llogHi.value);
    if(!isFiniteNum(al0)||!isFiniteNum(al1)||!isFiniteNum(ll0)||!isFiniteNum(ll1)||!(al0<al1)||!(ll0<ll1)){
      toast("Bad log ranges for Œ±/Œª.");
      return;
    }

    const w = parseInt(el.res.value, 10);
    const h = Math.max(24, Math.round(w * 0.75));
    el.resLabel.textContent = `${w} √ó ${h}`;

    const img = ctx.createImageData(w, h);
    const data = img.data;

    const r = base.r;
    const band = base.band;
    const eps = base.eps;
    const useAccel = base.useAccel;

    for(let j=0;j<h;j++){
      // y: alpha log
      const tY = j/(h-1);
      const aLog = al1 + (al0 - al1)*tY; // top = high
      const a = Math.pow(10, aLog);
      for(let i=0;i<w;i++){
        // x: lambda log
        const tX = i/(w-1);
        const lLog = ll0 + (ll1-ll0)*tX;
        const lam = Math.pow(10, lLog);

        const f = kernelFactor(r, lam, useAccel);
        const mag = Math.abs(a*f);
        const cls = classify(mag, band, eps);
        const [R,G,B,A] = colorFor(cls);
        const idx = 4*(j*w+i);
        data[idx+0]=R;
        data[idx+1]=G;
        data[idx+2]=B;
        data[idx+3]=A;
      }
    }

    // draw scaled image to canvas size
    ctx.save();
    ctx.clearRect(0,0,el.map.width, el.map.height);

    // place image into an offscreen canvas to scale nicely
    const off = document.createElement("canvas");
    off.width = w; off.height = h;
    off.getContext("2d").putImageData(img,0,0);

    // nice border margin inside
    const pad = 10;
    const drawW = el.map.width - pad*2;
    const drawH = el.map.height - pad*2;

    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(off, 0,0,w,h, pad,pad, drawW,drawH);

    // axes + labels
    ctx.imageSmoothingEnabled = true;
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(214,226,255,.35)";
    ctx.lineWidth = 1;
    ctx.strokeRect(pad, pad, drawW, drawH);

    ctx.fillStyle = "rgba(214,226,255,.75)";
    ctx.font = "12px system-ui";
    ctx.fillText("log10(Œª)", pad + 6, pad + drawH + 18);
    ctx.save();
    ctx.translate(12, pad + drawH/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText("log10(Œ±)", 0, 0);
    ctx.restore();

    // markers
    mapState.lastImage = {w,h, al0,al1,ll0,ll1, pad, drawW, drawH};
    ctx.restore();
    drawMarkerOnly();
    toast("Heatmap drawn.");
  }

  function drawMarkerOnly(){
    const meta = mapState.lastImage;
    const base = mapState.lastParams;
    if(!meta || !base || !base.ok) return;

    // redraw a small marker without rebuilding entire heatmap:
    // simplest: draw a ring marker over existing canvas
    const {al0,al1,ll0,ll1,pad,drawW,drawH} = meta;
    const a = Math.abs(base.alpha);
    const lam = base.lam;

    if(!(a>0) || !(lam>0)) return;

    const aLog = Math.log10(a);
    const lLog = Math.log10(lam);

    const tX = (lLog - ll0)/(ll1-ll0);
    const tY = (al1 - aLog)/(al1-al0); // because top is al1
    if(!isFiniteNum(tX)||!isFiniteNum(tY)) return;

    const x = pad + clamp(tX,0,1)*drawW;
    const y = pad + clamp(tY,0,1)*drawH;

    // draw marker
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = "rgba(45,243,255,.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x,y, 8, 0, Math.PI*2);
    ctx.stroke();
    ctx.strokeStyle = "rgba(255,230,109,.75)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(x,y, 12, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  function pickPointToInputs(){
    if(!mapState.lastImage){
      toast("Draw heatmap first.");
      return;
    }
    mapState.pickArmed = true;
    toast("Tap heatmap to pick Œ±, Œª.");
  }

  el.map.addEventListener("click", (ev)=>{
    if(!mapState.pickArmed) return;
    const meta = mapState.lastImage;
    if(!meta) return;

    const rect = el.map.getBoundingClientRect();
    const cx = (ev.clientX - rect.left) * (el.map.width / rect.width);
    const cy = (ev.clientY - rect.top)  * (el.map.height/ rect.height);

    const {al0,al1,ll0,ll1,pad,drawW,drawH} = meta;
    const tx = clamp((cx - pad)/drawW, 0, 1);
    const ty = clamp((cy - pad)/drawH, 0, 1);

    const lLog = ll0 + (ll1-ll0)*tx;
    const aLog = al1 + (al0-al1)*ty;

    const lam = Math.pow(10, lLog);
    const alpha = Math.pow(10, aLog);

    el.lam.value = String(lam);
    el.alpha.value = String(alpha);
    mapState.pickArmed = false;
    evaluate();
    toast("Picked point ‚Üí inputs updated.");
  });

  // ---- Self-tests ----
  function runSelfTests(){
    const logs = [];
    let pass=0, fail=0;

    function expect(name, got, want){
      const ok = (got === want);
      if(ok) pass++; else fail++;
      logs.push(`${ok ? "‚úÖ" : "‚ùå"} ${name}: got=${got} want=${want}`);
      return ok;
    }

    // Boundary test in potential mode:
    // r=1, Œª=10 => f=e^-0.1
    // Œ±_threshold = band / f
    // band=0.002 => Œ±‚âà0.00221034
    const band = 0.002;
    const r=1, lam=10;
    const f = kernelFactor(r, lam, false);
    const ath = band / f;
    const eps = 1e-8;

    // helper classify magnitude
    function cls(a, r, lam, band, useAccel){
      const ff = kernelFactor(r, lam, useAccel);
      const mag = Math.abs(a*ff);
      return classify(mag, band, eps);
    }

    expect("factor e^-0.1 approx", Math.abs(f - 0.9048374180) < 1e-6 ? "OK" : "BAD", "OK");
    expect("at threshold => EDGE", cls(ath, r, lam, band, false), "EDGE");
    expect("below threshold => OK", cls(ath*0.95, r, lam, band, false), "OK");
    expect("above threshold => FAIL", cls(ath*1.05, r, lam, band, false), "FAIL");

    // r=0 => f=1 potential, accel also =1
    expect("r=0 potential Œ±=band => EDGE", cls(band, 0, 10, band, false), "EDGE");
    expect("r=0 accel Œ±=band => EDGE", cls(band, 0, 10, band, true), "EDGE");

    // large x => tiny factor => OK
    expect("large r/Œª => OK", cls(1, 100, 1, band, false), "OK");

    // strict accel should be harder than potential for same (r,Œª)
    // i.e. f_accel = (1+x)e^-x >= e^-x
    const fA = kernelFactor(1,10,true);
    expect("accel factor >= potential", (fA >= f) ? "OK" : "BAD", "OK");

    // input validation check (NaN)
    const bad = kernelFactor(-1,10,false);
    expect("kernelFactor negative r -> NaN", Number.isNaN(bad) ? "OK" : "BAD", "OK");

    const status = (fail===0) ? "All tests passed" : "Some tests failed";
    el.testLog.textContent = logs.join("\n");
    const rows = el.kvTests.querySelectorAll(".v");
    rows[0].textContent = status;
    rows[1].textContent = String(pass);
    rows[2].textContent = String(fail);
    rows[3].textContent = (fail===0) ? "Boundary & edge behaviour consistent." : "Check failing lines above.";
    toast(status);
  }

  function clearTests(){
    el.testLog.textContent = "";
    const rows = el.kvTests.querySelectorAll(".v");
    rows[0].textContent = "‚Äî";
    rows[1].textContent = "‚Äî";
    rows[2].textContent = "‚Äî";
    rows[3].textContent = "‚Äî";
  }

  // ---- Export / share ----
  function currentParams(){
    return {
      sys: el.sys.value || "",
      unit: el.unit.value,
      r: el.r.value,
      alpha: el.alpha.value,
      lam: el.lam.value,
      band: el.band.value,
      useAccel: el.useAccel.checked ? 1 : 0,
      useAbs: el.useAbs.checked ? 1 : 0,
      epsLog: el.eps.value,
      lamLo: el.lamLo.value,
      lamHi: el.lamHi.value,
      alogLo: el.alogLo.value,
      alogHi: el.alogHi.value,
      llogLo: el.llogLo.value,
      llogHi: el.llogHi.value,
      res: el.res.value
    };
  }

  function applyParams(q){
    // Apply carefully (don't break if missing)
    if(q.sys!=null) el.sys.value = q.sys;
    if(q.unit!=null) el.unit.value = q.unit;
    if(q.r!=null) el.r.value = q.r;
    if(q.alpha!=null) el.alpha.value = q.alpha;
    if(q.lam!=null) el.lam.value = q.lam;
    if(q.band!=null) el.band.value = q.band;
    if(q.useAccel!=null) el.useAccel.checked = (q.useAccel==="1"||q.useAccel===1);
    if(q.useAbs!=null) el.useAbs.checked = (q.useAbs==="1"||q.useAbs===1);
    if(q.epsLog!=null) el.eps.value = q.epsLog;

    if(q.lamLo!=null) el.lamLo.value = q.lamLo;
    if(q.lamHi!=null) el.lamHi.value = q.lamHi;

    if(q.alogLo!=null) el.alogLo.value = q.alogLo;
    if(q.alogHi!=null) el.alogHi.value = q.alogHi;
    if(q.llogLo!=null) el.llogLo.value = q.llogLo;
    if(q.llogHi!=null) el.llogHi.value = q.llogHi;
    if(q.res!=null) el.res.value = q.res;

    updateEpsLabel();
    evaluate();
  }

  function copyShareLink(){
    const p = currentParams();
    const url = new URL(window.location.href);
    // wipe current query except bust
    url.search = "";
    for(const [k,v] of Object.entries(p)){
      url.searchParams.set(k, String(v));
    }
    url.searchParams.set("bust", String(Date.now()));
    navigator.clipboard.writeText(url.toString()).then(()=>{
      toast("Share link copied.");
    }).catch(()=>{
      toast("Clipboard blocked. Long-press address bar and copy.");
    });
  }

  function exportReport(){
    const res = compute();
    const dt = new Date();
    const lines = [];
    lines.push("QDS Binary Pulsar Constraint Lab v2 MAX");
    lines.push("======================================");
    lines.push(`Time: ${dt.toISOString()}`);
    lines.push("");
    const p = currentParams();
    lines.push("Inputs:");
    for(const k of ["sys","unit","r","alpha","lam","band","useAccel","useAbs","epsLog"]){
      lines.push(`- ${k}: ${p[k]}`);
    }
    lines.push("");
    if(!res.ok){
      lines.push("RESULT: INPUT ERROR");
      lines.push(res.errs.join("\n"));
    }else{
      lines.push("Derived:");
      lines.push(`- x=r/Œª: ${res.x}`);
      lines.push(`- f(r,Œª): ${res.f}`);
      lines.push(`- Œ±¬∑f: ${res.af}`);
      lines.push(`- |Œ±¬∑f|: ${res.magAbs}`);
      lines.push(`- band: ${res.band}`);
      lines.push(`- eps: ${res.eps}`);
      lines.push(`- mode: ${res.useAccel ? "acceleration (1+r/Œª)e^-r/Œª" : "potential e^-r/Œª"}`);
      lines.push("");
      lines.push(`Classification: ${res.cls}`);
      if(lastAlphaMax!=null) lines.push(`Œ±max(last): ${lastAlphaMax}`);
      if(lastLamMin!=null) lines.push(`Œªmin(last): ${lastLamMin}`);
      lines.push("");
      lines.push("Notes:");
      lines.push("- Demo sanity-filter only; not a full timing data analysis.");
      lines.push("- Compare across real pulsar systems requires proper post-Keplerian fits.");
    }

    const blob = new Blob([lines.join("\n")], {type:"text/plain;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `qds_pulsar_report_${dt.toISOString().replace(/[:.]/g,"-")}.txt`;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 250);
    toast("Report exported.");
  }

  // ---- Presets ----
  function loadPresetStore(){
    try{
      const raw = localStorage.getItem(SKEY);
      if(!raw) return {};
      const obj = JSON.parse(raw);
      return (obj && typeof obj === "object") ? obj : {};
    }catch(e){
      return {};
    }
  }
  function savePresetStore(obj){
    localStorage.setItem(SKEY, JSON.stringify(obj));
  }
  function refreshPresetList(){
    const store = loadPresetStore();
    const keys = Object.keys(store).sort((a,b)=>a.localeCompare(b));
    el.presetList.innerHTML = "";
    if(keys.length===0){
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "(no presets yet)";
      el.presetList.appendChild(opt);
      return;
    }
    for(const k of keys){
      const opt = document.createElement("option");
      opt.value = k;
      opt.textContent = k;
      el.presetList.appendChild(opt);
    }
  }
  function savePreset(){
    const name = (el.presetName.value || "").trim();
    if(!name){ toast("Give the preset a name."); return; }
    const store = loadPresetStore();
    store[name] = currentParams();
    savePresetStore(store);
    refreshPresetList();
    el.presetList.value = name;
    toast("Preset saved.");
  }
  function loadPreset(){
    const name = el.presetList.value;
    const store = loadPresetStore();
    if(!name || !store[name]){ toast("No preset selected."); return; }
    applyParams(store[name]);
    toast("Preset loaded.");
  }
  function delPreset(){
    const name = el.presetList.value;
    const store = loadPresetStore();
    if(!name || !store[name]){ toast("No preset selected."); return; }
    delete store[name];
    savePresetStore(store);
    refreshPresetList();
    toast("Preset deleted.");
  }

  // ---- Reset ----
  function resetAll(){
    el.sys.value = "PSR B1913+16 (example)";
    el.unit.value = "1";
    el.r.value = "1.0";
    el.alpha.value = "0.01";
    el.lam.value = "10.0";
    el.band.value = "0.002";
    el.useAccel.checked = false;
    el.useAbs.checked = true;
    el.autoRun.checked = true;
    el.eps.value = "-5.7";

    el.lamLo.value = "1e-6";
    el.lamHi.value = "1e6";

    el.alogLo.value = "-6";
    el.alogHi.value = "0";
    el.llogLo.value = "-3";
    el.llogHi.value = "3";
    el.res.value = "80";

    lastLamMin = null;
    lastAlphaMax = null;
    mapState.lastImage = null;
    mapState.pickArmed = false;
    clearTests();
    updateEpsLabel();
    evaluate();
    toast("Reset.");
  }

  // ---- Back link (best-effort) ----
  function setBackLink(){
    // try common platform filenames you use
    const candidates = [
      "qds_test_platformV3.html",
      "all_pages_index.html",
      "index.html"
    ];
    // if referrer exists and looks local, prefer it
    try{
      const ref = document.referrer || "";
      if(ref.includes("127.0.0.1") || ref.includes("localhost")){
        el.backLink.href = ref;
        return;
      }
    }catch(e){}
    el.backLink.href = candidates[0];
  }

  // ---- Events ----
  function wireAuto(){
    const inputs = [el.sys, el.unit, el.r, el.alpha, el.lam, el.band, el.useAccel, el.useAbs, el.eps];
    inputs.forEach(x=>{
      x.addEventListener("input", ()=>{ updateEpsLabel(); if(el.autoRun.checked) evaluate(); });
      x.addEventListener("change", ()=>{ updateEpsLabel(); if(el.autoRun.checked) evaluate(); });
    });
  }

  el.btnEval.addEventListener("click", ()=>evaluate());
  el.btnShare.addEventListener("click", copyShareLink);
  el.btnExport.addEventListener("click", exportReport);
  el.btnReset.addEventListener("click", resetAll);

  el.btnAlphaMax.addEventListener("click", ()=>computeAlphaMax());
  el.btnSetAlphaMax.addEventListener("click", ()=>{
    if(lastAlphaMax==null){ computeAlphaMax(); }
    if(lastAlphaMax!=null){
      el.alpha.value = String(lastAlphaMax);
      evaluate();
      toast("Œ± set to Œ±max.");
    }
  });

  el.btnLamMin.addEventListener("click", ()=>solveLamMin());
  el.btnSetLamMin.addEventListener("click", ()=>{
    if(lastLamMin==null){ solveLamMin(); }
    if(lastLamMin!=null){
      el.lam.value = String(lastLamMin);
      evaluate();
      toast("Œª set to Œªmin.");
    }
  });

  el.btnDraw.addEventListener("click", drawHeatmap);
  el.btnPick.addEventListener("click", pickPointToInputs);

  el.btnSelf.addEventListener("click", runSelfTests);
  el.btnClearTests.addEventListener("click", clearTests);

  el.btnSavePreset.addEventListener("click", savePreset);
  el.btnLoadPreset.addEventListener("click", loadPreset);
  el.btnDelPreset.addEventListener("click", delPreset);

  // ---- Boot ----
  function boot(){
    updateEpsLabel();
    refreshPresetList();
    setBackLink();

    // Apply query params if present
    const url = new URL(window.location.href);
    const q = {};
    for(const [k,v] of url.searchParams.entries()){
      q[k]=v;
    }
    if(Object.keys(q).some(k=>k in currentParams())){
      applyParams(q);
      toast("Loaded from link params.");
    }else{
      evaluate();
    }

    wireAuto();
  }

  boot();

})();


// --- qds_pulsar_suite_onebutton_MAX.html ---

/* =========================
   Utilities (no deps)
========================= */
const $ = (id)=>document.getElementById(id);

function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function isFiniteNum(x){ return Number.isFinite(x) && !Number.isNaN(x); }
function fmt(x, sig=4){
  if(!isFiniteNum(x)) return "‚Äî";
  const ax = Math.abs(x);
  if(ax === 0) return "0";
  if(ax >= 1e4 || ax < 1e-3) return x.toExponential(sig-1);
  return x.toPrecision(sig);
}
function nowISO(){
  const d = new Date();
  return d.toISOString().replace("T"," ").replace("Z","");
}
function logLine(s){
  const el = $("log");
  el.textContent += (el.textContent ? "\n" : "") + s;
  el.scrollTop = el.scrollHeight;
}
function setBadge(kind, text){
  const b = $("runBadge");
  b.className = "badge " + (kind || "neutral");
  b.textContent = text;
}
function safeJsonParse(s){
  try{ return {ok:true, val: JSON.parse(s)}; }catch(e){ return {ok:false, err: String(e)}; }
}

/* =========================
   Model
   Toy check:
     value = Œ± * f(r,Œª)
     pass if |value| <= band
   with f:
     potential: exp(-r/Œª)
     accel(strict): (1 + r/Œª) exp(-r/Œª)
========================= */
function kernelFactor(r, lam, strict){
  if(!(r>=0) || !(lam>0)) return NaN;
  const x = r/lam;
  const e = Math.exp(-x);
  return strict ? (1 + x)*e : e;
}
function alphaMaxAllowed(band, f){
  if(!(band>=0) || !isFiniteNum(f) || f<=0) return NaN;
  return band / f;
}

/* =========================
   Defaults (DEMO VALUES)
   Replace with literature / your dataset.
========================= */
const DEFAULT_SYSTEMS = [
  {name:"PSR B1913+16 (demo)", r:1.0, band:0.002, units:"custom"},
  {name:"Double Pulsar J0737‚àí3039 (demo)", r:0.6, band:0.0015, units:"custom"},
  {name:"PSR J0348+0432 (demo)", r:0.25, band:0.0010, units:"custom"},
  {name:"PSR J1738+0333 (demo)", r:0.35, band:0.0012, units:"custom"}
];

/* =========================
   State
========================= */
let state = {
  systems: [],
  strict: false,
  absMode: true,
  eps: 2e-6,
  lamGrid: [],
  curves: null,     // { perSystem:[{name, xs, ys}], envelope:{xs, ys}, meta:{} }
  probeLam: 1
};

function loadDefaults(){
  $("systemsJson").value = JSON.stringify(DEFAULT_SYSTEMS, null, 2);
}
function readControls(){
  state.strict = $("strictMode").checked;
  state.absMode = $("absMode").checked;

  // epsilon slider is log10(eps)
  const logeps = parseFloat($("epsSlider").value);
  state.eps = Math.pow(10, logeps);
  $("epsRead").textContent = state.eps.toExponential(1);

  const lmin = parseFloat($("lamMin").value);
  const lmax = parseFloat($("lamMax").value);
  const n = Math.floor(parseFloat($("lamN").value));
  $("lamRangeRead").textContent = `${lmin} ‚Üí ${lmax}`;
  const N = clamp(n, 20, 800);
  const a = Math.min(lmin,lmax), b = Math.max(lmin,lmax);

  // build logspace grid in lambda
  state.lamGrid = [];
  for(let i=0;i<N;i++){
    const t = (N===1)?0 : i/(N-1);
    const logL = a + (b-a)*t;
    state.lamGrid.push(Math.pow(10, logL));
  }
}

function validateSystems(systems){
  const out = [];
  const errs = [];
  if(!Array.isArray(systems)){
    return {ok:false, errs:["Systems JSON must be an array of objects."]};
  }
  for(let i=0;i<systems.length;i++){
    const it = systems[i] || {};
    const name = String(it.name ?? `System_${i+1}`).trim();
    const r = Number(it.r);
    const band = Number(it.band);
    const units = String(it.units ?? "").trim();
    if(!name) errs.push(`Row ${i+1}: missing name`);
    if(!(r>=0)) errs.push(`Row ${i+1} (${name}): r must be >= 0`);
    if(!(band>=0)) errs.push(`Row ${i+1} (${name}): band must be >= 0`);
    out.push({name, r, band, units});
  }
  if(out.length===0) errs.push("No systems provided.");
  return {ok: errs.length===0, systems: out, errs};
}

/* =========================
   Suite run
========================= */
function runSuite(){
  $("log").textContent = "";
  setBadge("neutral", "Running suite‚Ä¶");
  readControls();

  const parsed = safeJsonParse($("systemsJson").value);
  if(!parsed.ok){
    setBadge("bad", "Invalid JSON");
    logLine("‚ùå Systems JSON parse error: " + parsed.err);
    return;
  }

  const v = validateSystems(parsed.val);
  if(!v.ok){
    setBadge("bad", "Systems invalid");
    v.errs.forEach(e => logLine("‚ùå " + e));
    return;
  }
  state.systems = v.systems;

  logLine("=== QDS Pulsar Suite ‚Ä¢ One-Button MAX ===");
  logLine("Time: " + nowISO());
  logLine("Mode: " + (state.strict ? "STRICT accel f=(1+r/Œª)e^{-r/Œª}" : "Potential f=e^{-r/Œª}"));
  logLine("Abs: " + (state.absMode ? "|Œ±¬∑f| vs band" : "Œ±¬∑f vs band (signed)"));
  logLine("EDGE eps: " + state.eps.toExponential(1));
  logLine("Systems: " + state.systems.length);
  logLine("Œª grid points: " + state.lamGrid.length);

  const xs = state.lamGrid.slice();
  const perSystem = [];

  // compute Œ±max(Œª) for each system
  for(const sys of state.systems){
    const ys = new Array(xs.length);
    for(let i=0;i<xs.length;i++){
      const lam = xs[i];
      const f = kernelFactor(sys.r, lam, state.strict);
      const amax = alphaMaxAllowed(sys.band, f);
      ys[i] = amax;
    }
    perSystem.push({name: sys.name, r: sys.r, band: sys.band, units: sys.units, xs, ys});
  }

  // envelope: min Œ±max across systems at each Œª (tightest)
  const envY = xs.map((_,i)=>{
    let m = Infinity;
    for(const c of perSystem){
      const y = c.ys[i];
      if(isFiniteNum(y) && y < m) m = y;
    }
    return (m===Infinity)?NaN:m;
  });

  state.curves = {
    perSystem,
    envelope: {xs, ys: envY},
    meta: {
      strict: state.strict,
      absMode: state.absMode,
      eps: state.eps,
      lamMin: $("lamMin").value,
      lamMax: $("lamMax").value,
      lamN: $("lamN").value,
      created: nowISO()
    }
  };

  setBadge("ok", "Suite complete ‚úì graphs updated");
  logLine("‚úÖ Suite finished. (Curves computed; see plots & table.)");

  drawAll();
  updateProbeTable();
}

/* =========================
   Plotting (canvas)
========================= */
function niceLogBounds(vals){
  // vals in linear; return {ymin,ymax} in log10
  let lo = Infinity, hi = -Infinity;
  for(const v of vals){
    if(isFiniteNum(v) && v>0){
      const lv = Math.log10(v);
      if(lv<lo) lo=lv;
      if(lv>hi) hi=lv;
    }
  }
  if(lo===Infinity){ lo=-6; hi=0; }
  // pad a bit
  const pad = 0.25*(hi-lo || 1);
  return {ymin: lo - pad, ymax: hi + pad};
}

function clearCanvas(cv){
  const g = cv.getContext("2d");
  g.clearRect(0,0,cv.width,cv.height);
  // subtle background
  g.fillStyle = "rgba(0,0,0,0.18)";
  g.fillRect(0,0,cv.width,cv.height);
  return g;
}

function drawAxes(g, w, h, xMin, xMax, yMin, yMax, title){
  const padL=62, padR=18, padT=34, padB=48;
  const plot = {x0:padL, y0:padT, x1:w-padR, y1:h-padB};
  // border
  g.strokeStyle = "rgba(255,255,255,0.10)";
  g.lineWidth = 1;
  g.strokeRect(plot.x0, plot.y0, plot.x1-plot.x0, plot.y1-plot.y0);

  // grid lines (log-ish ticks)
  g.strokeStyle = "rgba(255,255,255,0.06)";
  g.lineWidth = 1;

  for(let i=0;i<=6;i++){
    const t = i/6;
    const x = plot.x0 + (plot.x1-plot.x0)*t;
    g.beginPath(); g.moveTo(x, plot.y0); g.lineTo(x, plot.y1); g.stroke();
  }
  for(let i=0;i<=6;i++){
    const t = i/6;
    const y = plot.y0 + (plot.y1-plot.y0)*t;
    g.beginPath(); g.moveTo(plot.x0, y); g.lineTo(plot.x1, y); g.stroke();
  }

  // labels
  g.fillStyle = "rgba(233,241,255,0.92)";
  g.font = "800 14px ui-sans-serif, system-ui";
  g.fillText(title, padL, 20);

  g.fillStyle = "rgba(168,183,211,0.95)";
  g.font = "700 12px ui-sans-serif, system-ui";
  g.fillText("log10(Œª)", (plot.x0+plot.x1)/2 - 28, h-14);
  g.save();
  g.translate(14, (plot.y0+plot.y1)/2 + 30);
  g.rotate(-Math.PI/2);
  g.fillText("log10(Œ±max)", 0, 0);
  g.restore();

  // tick numbers (approx)
  g.fillStyle = "rgba(127,144,182,0.95)";
  g.font = "600 11px ui-sans-serif, system-ui";
  for(let i=0;i<=6;i++){
    const t = i/6;
    const xv = xMin + (xMax-xMin)*t;
    const x = plot.x0 + (plot.x1-plot.x0)*t;
    g.fillText(xv.toFixed(1), x-10, plot.y1+18);
  }
  for(let i=0;i<=6;i++){
    const t = i/6;
    const yv = yMax - (yMax-yMin)*t;
    const y = plot.y0 + (plot.y1-plot.y0)*t;
    g.fillText(yv.toFixed(1), 18, y+4);
  }

  return {plot, padL,padR,padT,padB};
}

function mapX(plot, x, xMin, xMax){
  const t = (x - xMin) / (xMax - xMin);
  return plot.x0 + (plot.x1-plot.x0)*t;
}
function mapY(plot, y, yMin, yMax){
  const t = (y - yMin) / (yMax - yMin);
  return plot.y1 - (plot.y1-plot.y0)*t;
}

function drawCurve(g, plot, xsLog, ysLog, xMin, xMax, yMin, yMax, strokeStyle){
  g.strokeStyle = strokeStyle;
  g.lineWidth = 2;
  g.beginPath();
  let started=false;
  for(let i=0;i<xsLog.length;i++){
    const x = xsLog[i], y = ysLog[i];
    if(!isFiniteNum(x) || !isFiniteNum(y)) continue;
    const X = mapX(plot, x, xMin, xMax);
    const Y = mapY(plot, y, yMin, yMax);
    if(!started){ g.moveTo(X,Y); started=true; }
    else g.lineTo(X,Y);
  }
  g.stroke();
}

function drawLegend(g, items){
  // items: [{name,color}]
  const x0 = 62, y0 = 44;
  g.font = "700 11px ui-sans-serif, system-ui";
  let y = y0;
  for(const it of items.slice(0,7)){ // keep it compact on phone
    g.fillStyle = it.color;
    g.fillRect(x0, y-8, 10, 10);
    g.fillStyle = "rgba(233,241,255,.90)";
    g.fillText(it.name, x0+14, y);
    y += 16;
  }
  if(items.length>7){
    g.fillStyle="rgba(127,144,182,.95)";
    g.fillText(`+${items.length-7} more‚Ä¶`, x0, y);
  }
}

function drawAll(){
  if(!state.curves) return;

  // x axis is log10(lambda)
  const xs = state.curves.envelope.xs.map(v=>Math.log10(v));
  const xMin = Math.min(...xs), xMax = Math.max(...xs);

  // gather all y values for bounds
  const allY = [];
  for(const c of state.curves.perSystem) for(const y of c.ys) allY.push(y);
  for(const y of state.curves.envelope.ys) allY.push(y);

  const {ymin, ymax} = niceLogBounds(allY);

  // Plot A
  {
    const cv = $("cvA");
    const g = clearCanvas(cv);
    const {plot} = drawAxes(g, cv.width, cv.height, xMin, xMax, ymin, ymax, "Per-system Œ±max(Œª)");
    const legend = [];

    // choose distinct-ish neon-ish strokes (no external libs)
    const palette = [
      "rgba(52,214,255,0.95)",
      "rgba(40,245,163,0.95)",
      "rgba(255,210,74,0.95)",
      "rgba(164,107,255,0.95)",
      "rgba(255,176,0,0.95)",
      "rgba(233,241,255,0.90)"
    ];

    state.curves.perSystem.forEach((c, idx)=>{
      const col = palette[idx % palette.length];
      const ysLog = c.ys.map(v=> (isFiniteNum(v) && v>0) ? Math.log10(v) : NaN);
      drawCurve(g, plot, xs, ysLog, xMin, xMax, ymin, ymax, col);
      legend.push({name: c.name, color: col});
    });

    drawLegend(g, legend);
  }

  // Plot B (envelope)
  {
    const cv = $("cvB");
    const g = clearCanvas(cv);
    const {plot} = drawAxes(g, cv.width, cv.height, xMin, xMax, ymin, ymax, "Combined envelope (tightest Œ±max)");
    const ysLog = state.curves.envelope.ys.map(v=> (isFiniteNum(v) && v>0) ? Math.log10(v) : NaN);

    // thick envelope
    g.strokeStyle = "rgba(255,176,0,0.30)";
    g.lineWidth = 7;
    g.beginPath();
    let started=false;
    for(let i=0;i<xs.length;i++){
      const x = xs[i], y = ysLog[i];
      if(!isFiniteNum(y)) continue;
      const X = mapX(plot, x, xMin, xMax);
      const Y = mapY(plot, y, ymin, ymax);
      if(!started){ g.moveTo(X,Y); started=true; }
      else g.lineTo(X,Y);
    }
    g.stroke();

    // crisp line on top
    drawCurve(g, plot, xs, ysLog, xMin, xMax, ymin, ymax, "rgba(255,210,74,0.95)");

    // marker for probe Œª
    const px = Math.log10(state.probeLam);
    const nearest = nearestIndex(state.curves.envelope.xs, state.probeLam);
    const py = state.curves.envelope.ys[nearest];
    if(isFiniteNum(py) && py>0){
      const X = mapX(plot, px, xMin, xMax);
      const Y = mapY(plot, Math.log10(py), ymin, ymax);
      g.fillStyle = "rgba(52,214,255,0.95)";
      g.beginPath(); g.arc(X, Y, 6, 0, Math.PI*2); g.fill();
      g.fillStyle = "rgba(233,241,255,0.92)";
      g.font = "800 12px ui-sans-serif, system-ui";
      g.fillText("probe", X+10, Y+4);
    }
  }
}

function nearestIndex(arr, x){
  let best=0, bd=Infinity;
  for(let i=0;i<arr.length;i++){
    const d = Math.abs(arr[i]-x);
    if(d<bd){ bd=d; best=i; }
  }
  return best;
}

function updateProbeTable(){
  if(!state.curves) return;
  const lam = state.probeLam;
  $("probeRead").textContent = `Œª = ${fmt(lam,4)} (log10=${Math.log10(lam).toFixed(2)})`;

  const i = nearestIndex(state.curves.envelope.xs, lam);
  const tbody = $("tbl").querySelector("tbody");
  tbody.innerHTML = "";

  // per system rows
  for(const c of state.curves.perSystem){
    const f = kernelFactor(c.r, state.curves.envelope.xs[i], state.strict);
    const amax = c.ys[i];
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${escapeHtml(c.name)}</td>
      <td class="mono">${fmt(c.r,4)}</td>
      <td class="mono">${fmt(c.band,4)}</td>
      <td class="mono">${fmt(f,4)}</td>
      <td class="mono">${fmt(amax,4)}</td>
    `;
    tbody.appendChild(tr);
  }

  // envelope row
  const env = state.curves.envelope.ys[i];
  const tr = document.createElement("tr");
  tr.innerHTML = `
    <td><b>ENVELOPE (tightest)</b></td>
    <td class="mono">‚Äî</td>
    <td class="mono">‚Äî</td>
    <td class="mono">‚Äî</td>
    <td class="mono"><b>${fmt(env,4)}</b></td>
  `;
  tbody.appendChild(tr);

  drawAll();
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (c)=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[c]));
}

/* =========================
   Self tests (try to break it)
========================= */
function runSelfTests(){
  $("log").textContent = "";
  setBadge("neutral","Running self-tests‚Ä¶");

  readControls();

  let pass=0, fail=0;
  const out = [];
  function ok(cond, msg){
    if(cond){ pass++; out.push("‚úÖ " + msg); }
    else{ fail++; out.push("‚ùå " + msg); }
  }

  // basic kernel sanity
  ok(Math.abs(Math.exp(-0.1)-0.9048374180) < 5e-7, "exp(-0.1) approx correct");
  ok(Number.isNaN(kernelFactor(-1, 1, false)), "negative r => NaN");
  ok(Number.isNaN(kernelFactor(1, -1, false)), "negative Œª => NaN");
  ok(Math.abs(kernelFactor(0, 5, false)-1) < 1e-12, "r=0 => f=1 (potential)");
  ok(Math.abs(kernelFactor(0, 5, true)-1) < 1e-12, "r=0 => f=1 (strict accel)");

  // strict should be >= potential for same r,Œª (since (1+x)e^{-x} >= e^{-x})
  {
    const r=2, lam=3;
    ok(kernelFactor(r,lam,true) >= kernelFactor(r,lam,false), "strict f >= potential f");
  }

  // Œ±max = band/f
  {
    const band=0.002, r=1, lam=10;
    const f = kernelFactor(r,lam,false);
    const amax = alphaMaxAllowed(band,f);
    ok(Math.abs(amax*f - band) < 1e-12, "alphaMaxAllowed inverts correctly");
  }

  // monotonic: for fixed r, f increases with Œª (less suppression), so alphaMax decreases
  {
    const r=1, band=0.002;
    const f1 = kernelFactor(r, 0.1, false);
    const f2 = kernelFactor(r, 10, false);
    const a1 = alphaMaxAllowed(band,f1);
    const a2 = alphaMaxAllowed(band,f2);
    ok(f2 > f1, "f increases with Œª");
    ok(a2 < a1, "Œ±max decreases with Œª");
  }

  // envelope correctness (min across systems)
  {
    const systems = [
      {name:"A", r:1, band:0.002},
      {name:"B", r:1, band:0.001}
    ];
    const lam=10;
    const f = kernelFactor(1,lam,false);
    const aA = alphaMaxAllowed(0.002,f);
    const aB = alphaMaxAllowed(0.001,f);
    ok(aB < aA, "smaller band => tighter Œ±max");
  }

  setBadge(fail===0 ? "ok" : "bad", `Self-tests: ${pass} pass, ${fail} fail`);
  logLine("=== SELF-TEST SUITE ===");
  logLine("Pass: " + pass);
  logLine("Fail: " + fail);
  logLine("");
  out.forEach(l=>logLine(l));
}

/* =========================
   CSV import
========================= */
function parseCSV(text){
  // simple CSV (no quoted commas). good enough for our use.
  const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  if(lines.length===0) return [];
  const head = lines[0].split(",").map(s=>s.trim().toLowerCase());
  const idxName = head.indexOf("name");
  const idxR = head.indexOf("r");
  const idxBand = head.indexOf("band");
  const idxUnits = head.indexOf("units");

  const rows = [];
  for(let i=1;i<lines.length;i++){
    const parts = lines[i].split(",").map(s=>s.trim());
    const name = idxName>=0 ? parts[idxName] : parts[0];
    const r = Number(idxR>=0 ? parts[idxR] : parts[1]);
    const band = Number(idxBand>=0 ? parts[idxBand] : parts[2]);
    const units = idxUnits>=0 ? (parts[idxUnits]||"") : "";
    if(name) rows.push({name, r, band, units});
  }
  return rows;
}

/* =========================
   Export
========================= */
function download(name, text, mime="text/plain"){
  const blob = new Blob([text], {type:mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 5000);
}

function exportReportJSON(){
  if(!state.curves){
    setBadge("bad","Nothing to export");
    logLine("‚ùå Run the suite first.");
    return;
  }
  const report = {
    type: "QDS_Pulsar_Suite_OneButton_MAX",
    created: nowISO(),
    meta: state.curves.meta,
    systems: state.systems,
    note: "Toy mapping: compares |Œ±¬∑f(r,Œª)| to band. Replace demo system values with literature values or your dataset.",
    curves: {
      lambda: state.curves.envelope.xs,
      envelope_alphaMax: state.curves.envelope.ys,
      perSystem: state.curves.perSystem.map(c=>({
        name: c.name, r: c.r, band: c.band, units: c.units, alphaMax: c.ys
      }))
    }
  };
  download(`qds_pulsar_suite_report_${Date.now()}.json`, JSON.stringify(report, null, 2), "application/json");
  setBadge("ok","Exported JSON ‚úì");
}

function exportCurvesCSV(){
  if(!state.curves){
    setBadge("bad","Nothing to export");
    logLine("‚ùå Run the suite first.");
    return;
  }
  const lam = state.curves.envelope.xs;
  const cols = ["lambda","envelope_alphaMax"].concat(state.curves.perSystem.map(c=>c.name.replaceAll(","," ")));
  const lines = [cols.join(",")];

  for(let i=0;i<lam.length;i++){
    const row = [lam[i], state.curves.envelope.ys[i]];
    for(const c of state.curves.perSystem) row.push(c.ys[i]);
    lines.push(row.join(","));
  }
  download(`qds_pulsar_suite_curves_${Date.now()}.csv`, lines.join("\n"), "text/csv");
  setBadge("ok","Exported CSV ‚úì");
}

function copyShareLink(){
  // encode minimal state in hash (small)
  try{
    const sys = safeJsonParse($("systemsJson").value);
    if(!sys.ok) throw new Error("Systems JSON invalid");
    const payload = {
      strict: $("strictMode").checked ? 1 : 0,
      abs: $("absMode").checked ? 1 : 0,
      eps: $("epsSlider").value,
      lmin: $("lamMin").value,
      lmax: $("lamMax").value,
      n: $("lamN").value,
      systems: sys.val
    };
    const enc = btoa(unescape(encodeURIComponent(JSON.stringify(payload)))).slice(0, 6000);
    const url = location.origin + location.pathname + "#S=" + enc;
    navigator.clipboard.writeText(url);
    setBadge("ok","Share link copied ‚úì");
    logLine("üîó Copied share link (hash state).");
  }catch(e){
    setBadge("bad","Copy failed");
    logLine("‚ùå Share link error: " + e.message);
  }
}

/* =========================
   Hash restore
========================= */
function tryRestoreFromHash(){
  const h = location.hash || "";
  const m = h.match(/#S=([A-Za-z0-9+/=]+)/);
  if(!m) return;
  try{
    const json = decodeURIComponent(escape(atob(m[1])));
    const p = JSON.parse(json);

    $("strictMode").checked = !!p.strict;
    $("absMode").checked = !!p.abs;
    $("epsSlider").value = String(p.eps ?? "-5.7");
    $("lamMin").value = String(p.lmin ?? "-3");
    $("lamMax").value = String(p.lmax ?? "3");
    $("lamN").value = String(p.n ?? "140");
    $("systemsJson").value = JSON.stringify(p.systems ?? DEFAULT_SYSTEMS, null, 2);

    setBadge("neutral","Restored from share link. Run suite.");
  }catch(e){
    // ignore
  }
}

/* =========================
   Wire up
========================= */
loadDefaults();
tryRestoreFromHash();
readControls();

$("btnLoadDefaults").addEventListener("click", ()=>{
  loadDefaults();
  setBadge("neutral","Defaults loaded.");
});

$("btnValidate").addEventListener("click", ()=>{
  const parsed = safeJsonParse($("systemsJson").value);
  if(!parsed.ok){ setBadge("bad","Invalid JSON"); logLine("‚ùå " + parsed.err); return; }
  const v = validateSystems(parsed.val);
  if(v.ok){ setBadge("ok","Systems valid ‚úì"); logLine("‚úÖ Systems valid ("+v.systems.length+")."); }
  else { setBadge("bad","Systems invalid"); v.errs.forEach(e=>logLine("‚ùå "+e)); }
});

$("btnRun").addEventListener("click", runSuite);
$("btnSelfTest").addEventListener("click", runSelfTests);

$("btnClear").addEventListener("click", ()=>{
  $("log").textContent="";
  setBadge("neutral","Cleared.");
  const gA = clearCanvas($("cvA"));
  const gB = clearCanvas($("cvB"));
  $("tbl").querySelector("tbody").innerHTML="";
  state.curves=null;
});

$("btnExportJson").addEventListener("click", exportReportJSON);
$("btnExportCsv").addEventListener("click", exportCurvesCSV);
$("btnCopyLink").addEventListener("click", copyShareLink);

$("epsSlider").addEventListener("input", ()=>{
  readControls();
  if(state.curves){ drawAll(); updateProbeTable(); }
});

$("probeSlider").addEventListener("input", ()=>{
  const logL = parseFloat($("probeSlider").value);
  state.probeLam = Math.pow(10, logL);
  updateProbeTable();
});

$("strictMode").addEventListener("change", ()=>{ if(state.curves) runSuite(); });
$("absMode").addEventListener("change", ()=>{ if(state.curves) runSuite(); });

$("csvFile").addEventListener("change", async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const text = await f.text();
  const rows = parseCSV(text);
  if(!rows.length){
    setBadge("bad","CSV empty");
    logLine("‚ùå CSV parsed 0 rows.");
    return;
  }
  $("systemsJson").value = JSON.stringify(rows, null, 2);
  setBadge("ok", "CSV loaded ‚úì");
  logLine("‚úÖ Loaded CSV rows: " + rows.length);
});

/* set probe slider bounds to follow lamMin/lamMax inputs */
function syncProbeBounds(){
  const a = parseFloat($("lamMin").value);
  const b = parseFloat($("lamMax").value);
  $("probeSlider").min = String(Math.min(a,b));
  $("probeSlider").max = String(Math.max(a,b));
}
$("lamMin").addEventListener("input", syncProbeBounds);
$("lamMax").addEventListener("input", syncProbeBounds);
syncProbeBounds();

/* init probe */
state.probeLam = 1;
$("probeSlider").value = "0";
updateProbeTable();


// --- qds_rotmod_extreme_lab.html ---

(() => {
  // ---------- Helpers ----------
  const $ = (id) => document.getElementById(id);
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const fmt = (x, d=3) => (Number.isFinite(x)? x.toFixed(d) : "‚Äî");
  const pct = (x, d=1) => (Number.isFinite(x)? x.toFixed(d)+"%" : "‚Äî");
  const median = (arr) => {
    const a = arr.slice().sort((x,y)=>x-y);
    const n = a.length; if(!n) return NaN;
    return (n%2? a[(n-1)/2] : 0.5*(a[n/2-1]+a[n/2]));
  };
  const mean = (arr) => arr.length? arr.reduce((s,x)=>s+x,0)/arr.length : NaN;
  const quantile = (arr,q) => {
    const a = arr.slice().sort((x,y)=>x-y);
    if(!a.length) return NaN;
    const pos = (a.length-1)*q;
    const lo = Math.floor(pos), hi = Math.ceil(pos);
    if(lo===hi) return a[lo];
    return a[lo]*(hi-pos)+a[hi]*(pos-lo);
  };
  const parseCSV = (text) => {
    // Simple CSV parser (handles quotes)
    const rows = [];
    let i=0, field="", row=[], inQ=false;
    while(i<text.length){
      const c = text[i];
      if(inQ){
        if(c === '"'){
          if(text[i+1] === '"'){ field += '"'; i++; }
          else inQ=false;
        } else field += c;
      } else {
        if(c === '"') inQ=true;
        else if(c === ','){ row.push(field); field=""; }
        else if(c === '\n'){ row.push(field); rows.push(row); row=[]; field=""; }
        else if(c === '\r'){ /* skip */ }
        else field += c;
      }
      i++;
    }
    if(field.length || row.length){ row.push(field); rows.push(row); }
    return rows;
  };

  function mapSummaryHeader(header){
    // Accept either named headers or fallback positions:
    // expected: galaxy,n,chi2_bary,redchi2_bary,chi2_qds,redchi2_qds,improve_pct,v0,lam
    const H = header.map(h => (h||"").trim().toLowerCase());
    const idx = (names) => {
      for(const name of names){
        const j = H.indexOf(name);
        if(j>=0) return j;
      }
      return -1;
    };

    const m = {
      galaxy: idx(["galaxy","name","id"]),
      n: idx(["n","npts","points","num_points"]),
      chi2_b: idx(["chi2_bary","chi2_b","chi2_baryon","chi2_baryonic","chi2_baryons","bary_chi2"]),
      red_b: idx(["redchi2_bary","redchi2_b","red_bary","bary_redchi2"]),
      chi2_q: idx(["chi2_qds","chi2_q","qds_chi2","chi2_model"]),
      red_q: idx(["redchi2_qds","redchi2_q","qds_redchi2","red_model"]),
      imp: idx(["improve_pct","improve","improve_percent","pct_improve"]),
      v0: idx(["v0","v_0","v0_kms"]),
      lam: idx(["lam","lambda","lambda_c","l","scale"])
    };

    // Fallback by position if missing
    const fallback = ["galaxy","n","chi2_b","red_b","chi2_q","red_q","imp","v0","lam"];
    fallback.forEach((k, pos) => { if(m[k] < 0) m[k] = pos; });
    return m;
  }

  function aicc(chi2, n, k){
    const base = chi2 + 2*k;
    if(n > (k+1)) return base + (2*k*(k+1))/(n-k-1);
    return base; // fallback if too small n
  }

  // ---------- State ----------
  let summaryRaw = null;
  let summary = [];       // normalized objects
  let bestfits = new Map(); // galaxy -> {header, rows, colsMap}
  let headerInfo = {cols:[], map:null};

  // ---------- UI elements ----------
  const status = $("status");
  const kRows = $("kRows");
  const kCols = $("kCols");
  const kWins = $("kWins");
  const kWinFrac = $("kWinFrac");
  const kMeanImp = $("kMeanImp");
  const kMedImp = $("kMedImp");
  const kBound = $("kBound");
  const kBoundNote = $("kBoundNote");
  const checkV0 = $("checkV0");
  const checkLam = $("checkLam");
  const checkOutliers = $("checkOutliers");
  const tbl = $("tbl");
  const qSearch = $("qSearch");
  const qSort = $("qSort");
  const qShow = $("qShow");
  const selCurve = $("selCurve");
  const curveInfo = $("curveInfo");
  const bestfitCount = $("bestfitCount");
  const btnExport = $("btnExport");
  const btnAutoPick = $("btnAutoPick");

  // ---------- Plotters ----------
  function clearCanvas(cv){
    const ctx = cv.getContext("2d");
    const dpr = window.devicePixelRatio || 1;
    const w = cv.clientWidth, h = cv.clientHeight;
    cv.width = Math.floor(w*dpr); cv.height = Math.floor(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h);
    return {ctx,w,h};
  }

  function drawAxes(ctx,w,h, pad=34){
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(160,190,255,.22)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad, pad);
    ctx.lineTo(pad, h-pad);
    ctx.lineTo(w-pad, h-pad);
    ctx.stroke();
    return {pad};
  }

  function drawHist(cv, values){
    const {ctx,w,h} = clearCanvas(cv);
    const {pad} = drawAxes(ctx,w,h,34);
    if(!values.length){
      ctx.fillStyle="rgba(159,179,217,.9)";
      ctx.fillText("Load SUMMARY to see histogram", pad, pad+12);
      return;
    }
    // bins 0..100
    const bins = 20;
    const min=0, max=100;
    const counts = new Array(bins).fill(0);
    for(const v of values){
      const x = clamp(v, min, max);
      let b = Math.floor((x-min)/(max-min)*bins);
      b = clamp(b,0,bins-1);
      counts[b]++;
    }
    const maxC = Math.max(...counts,1);
    const bw = (w-2*pad)/bins;
    for(let i=0;i<bins;i++){
      const x0 = pad + i*bw;
      const barH = (h-2*pad) * (counts[i]/maxC);
      const y0 = h-pad - barH;
      ctx.fillStyle = "rgba(0,229,255,.22)";
      ctx.fillRect(x0+2, y0, bw-4, barH);
      ctx.strokeStyle = "rgba(0,229,255,.35)";
      ctx.strokeRect(x0+2, y0, bw-4, barH);
    }
    ctx.fillStyle="rgba(159,179,217,.9)";
    ctx.font="12px ui-monospace, Menlo, Consolas, monospace";
    ctx.fillText("0", pad-10, h-pad+18);
    ctx.fillText("100", w-pad-28, h-pad+18);
    ctx.fillText("œá¬≤-improve%", pad, pad-12);
  }

  function drawScatter(cv, pts){
    const {ctx,w,h} = clearCanvas(cv);
    const {pad} = drawAxes(ctx,w,h,34);
    if(!pts.length){
      ctx.fillStyle="rgba(159,179,217,.9)";
      ctx.fillText("Load SUMMARY to see scatter", pad, pad+12);
      return;
    }
    // Use quantile bounds to reduce crazy scaling
    const xb = pts.map(p=>p.x), yb=pts.map(p=>p.y);
    const x0 = Math.max(0, quantile(xb,0.02));
    const x1 = quantile(xb,0.98);
    const y0 = Math.max(0, quantile(yb,0.02));
    const y1 = quantile(yb,0.98);
    const sx = (x)=> pad + (w-2*pad) * ( (x-x0) / (x1-x0 || 1) );
    const sy = (y)=> (h-pad) - (h-2*pad) * ( (y-y0) / (y1-y0 || 1) );

    // diag line
    ctx.strokeStyle = "rgba(0,255,133,.35)";
    ctx.beginPath();
    ctx.moveTo(sx(x0), sy(x0));
    ctx.lineTo(sx(Math.min(x1,y1)), sy(Math.min(x1,y1)));
    ctx.stroke();

    for(const p of pts){
      const x = sx(p.x), y = sy(p.y);
      ctx.fillStyle = p.win ? "rgba(0,255,133,.42)" : "rgba(255,61,129,.40)";
      ctx.beginPath(); ctx.arc(x,y,2.4,0,Math.PI*2); ctx.fill();
    }

    ctx.fillStyle="rgba(159,179,217,.9)";
    ctx.font="12px ui-monospace, Menlo, Consolas, monospace";
    ctx.fillText("bary œá¬≤/n", pad, pad-12);
    ctx.fillText("qds œá¬≤/n", pad-30, pad+10);
  }

  function mapBestfitHeader(header){
    const H = header.map(h => (h||"").trim().toLowerCase());
    const pick = (keys) => {
      for(const k of keys){ const i = H.indexOf(k); if(i>=0) return i; }
      return -1;
    };
    const m = {
      r: pick(["r","radius","rad"]),
      vobs: pick(["v_obs","vobs","v","vrot","v_rot","vdata"]),
      verr: pick(["e_v","err","v_err","sigma","dv","v_sigma"]),
      vbary: pick(["v_bary","vbary","vbar","v_b"]),
      vqds: pick(["v_qds","vqds","v_model","vmod","v_fit","v_total","v_q"])
    };
    return m;
  }

  function drawCurve(cv, bf){
    const {ctx,w,h} = clearCanvas(cv);
    const {pad} = drawAxes(ctx,w,h,40);

    if(!bf){
      ctx.fillStyle="rgba(159,179,217,.9)";
      ctx.fillText("Load *_QDS_bestfit.csv then select one above.", pad, pad+12);
      return;
    }

    const {rows, map, galaxy} = bf;
    const ri = map.r, vo = map.vobs, ve = map.verr, vb = map.vbary, vq = map.vqds;

    if(ri<0 || vo<0){
      ctx.fillStyle="rgba(255,200,87,.95)";
      ctx.fillText("Could not detect r and v_obs columns in this bestfit CSV.", pad, pad+12);
      return;
    }

    const R = [], V=[], E=[], VB=[], VQ=[];
    for(const row of rows){
      const r = Number(row[ri]);
      const v = Number(row[vo]);
      if(!Number.isFinite(r) || !Number.isFinite(v)) continue;
      R.push(r); V.push(v);
      E.push(ve>=0 ? Number(row[ve]) : NaN);
      VB.push(vb>=0 ? Number(row[vb]) : NaN);
      VQ.push(vq>=0 ? Number(row[vq]) : NaN);
    }
    if(R.length < 3){
      ctx.fillStyle="rgba(255,200,87,.95)";
      ctx.fillText("Not enough numeric rows to plot.", pad, pad+12);
      return;
    }

    const r0 = Math.min(...R), r1 = Math.max(...R);
    const v0 = Math.min(...V.filter(Number.isFinite));
    const v1 = Math.max(...V.filter(Number.isFinite));

    const sx = (x)=> pad + (w-2*pad) * ((x-r0)/(r1-r0 || 1));
    const sy = (y)=> (h-pad) - (h-2*pad) * ((y-v0)/(v1-v0 || 1));

    // plot data points
    for(let i=0;i<R.length;i++){
      const x=sx(R[i]), y=sy(V[i]);
      ctx.fillStyle="rgba(0,229,255,.65)";
      ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill();

      const e = E[i];
      if(Number.isFinite(e) && e>0){
        ctx.strokeStyle="rgba(0,229,255,.25)";
        ctx.beginPath();
        ctx.moveTo(x, sy(V[i]-e));
        ctx.lineTo(x, sy(V[i]+e));
        ctx.stroke();
      }
    }

    // bary line (if present)
    if(VB.some(Number.isFinite)){
      ctx.strokeStyle="rgba(255,200,87,.55)";
      ctx.beginPath();
      let started=false;
      for(let i=0;i<R.length;i++){
        const yv=VB[i]; if(!Number.isFinite(yv)) continue;
        const x=sx(R[i]), y=sy(yv);
        if(!started){ ctx.moveTo(x,y); started=true; } else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    // qds line (if present)
    if(VQ.some(Number.isFinite)){
      ctx.strokeStyle="rgba(0,255,133,.60)";
      ctx.beginPath();
      let started=false;
      for(let i=0;i<R.length;i++){
        const yv=VQ[i]; if(!Number.isFinite(yv)) continue;
        const x=sx(R[i]), y=sy(yv);
        if(!started){ ctx.moveTo(x,y); started=true; } else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    ctx.fillStyle="rgba(159,179,217,.9)";
    ctx.font="12px ui-monospace, Menlo, Consolas, monospace";
    ctx.fillText(`${galaxy}  (points=${R.length})`, pad, pad-14);
    ctx.fillText(`r:[${fmt(r0,2)}..${fmt(r1,2)}]  v:[${fmt(v0,1)}..${fmt(v1,1)}]`, pad, h-12);

    curveInfo.textContent = `curve: ${galaxy} ¬∑ rows=${R.length} ¬∑ cols=${bf.header.length}`;
  }

  // ---------- Summary processing ----------
  function normalizeSummary(rows){
    const header = rows[0];
    const map = mapSummaryHeader(header);
    headerInfo = {cols: header, map};

    const out = [];
    for(let i=1;i<rows.length;i++){
      const r = rows[i];
      if(!r || !r.length) continue;

      const galaxy = (r[map.galaxy] ?? "").trim();
      if(!galaxy) continue;

      const n = Number(r[map.n]);
      const cb = Number(r[map.chi2_b]);
      const cq = Number(r[map.chi2_q]);
      const rb = Number(r[map.red_b]);
      const rq = Number(r[map.red_q]);
      const imp_in = Number(r[map.imp]);
      const v0 = Number(r[map.v0]);
      const lam = Number(r[map.lam]);

      // œá¬≤-based improvement (robust) + effective (clip negatives)
      const imp_chi2 = (Number.isFinite(cb) && cb>0 && Number.isFinite(cq)) ? 100*(cb-cq)/cb : NaN;
      const imp_eff = Number.isFinite(imp_chi2) ? Math.max(0, imp_chi2) : NaN;

      // comparable reduced chi2 for visuals: œá¬≤/n
      const b_vis = (Number.isFinite(cb) && Number.isFinite(n) && n>0) ? cb/n : (Number.isFinite(rb)? rb : NaN);
      const q_vis = (Number.isFinite(cq) && Number.isFinite(n) && n>0) ? cq/n : (Number.isFinite(rq)? rq : NaN);

      // AICc
      const aiccb = (Number.isFinite(cb) && Number.isFinite(n)) ? aicc(cb,n,0) : NaN;
      const aiccq = (Number.isFinite(cq) && Number.isFinite(n)) ? aicc(cq,n,2) : NaN;
      const daicc = (Number.isFinite(aiccb) && Number.isFinite(aiccq)) ? (aiccq - aiccb) : NaN; // negative => QDS better
      const win = Number.isFinite(daicc) ? (daicc < 0) : false;

      out.push({
        galaxy, n,
        chi2_b: cb, chi2_q: cq,
        red_b: rb, red_q: rq,
        imp_in, imp_chi2, imp_eff,
        v0, lam,
        b_vis, q_vis,
        aiccb, aiccq, daicc, win
      });
    }
    return out;
  }

  function computeBoundary(summary){
    const v0s = summary.map(d=>d.v0).filter(Number.isFinite);
    const lams = summary.map(d=>d.lam).filter(Number.isFinite);
    const v0min = v0s.length? Math.min(...v0s) : NaN;
    const v0max = v0s.length? Math.max(...v0s) : NaN;
    const lammin = lams.length? Math.min(...lams) : NaN;
    const lammax = lams.length? Math.max(...lams) : NaN;

    for(const d of summary){
      const flags = [];
      if(Number.isFinite(d.v0) && Number.isFinite(v0min) && d.v0===v0min) flags.push("v0=min");
      if(Number.isFinite(d.v0) && Number.isFinite(v0max) && d.v0===v0max) flags.push("v0=max");
      if(Number.isFinite(d.lam) && Number.isFinite(lammin) && d.lam===lammin) flags.push("Œª=min");
      if(Number.isFinite(d.lam) && Number.isFinite(lammax) && d.lam===lammax) flags.push("Œª=max");
      d.flags = flags;
      d.bound = flags.length>0;
    }
    return {v0min,v0max,lammin,lammax};
  }

  function refreshKPIs(){
    if(!summary.length){
      kRows.textContent="‚Äî"; kCols.textContent="‚Äî";
      kWins.textContent="‚Äî"; kWinFrac.textContent="‚Äî";
      kMeanImp.textContent="‚Äî"; kMedImp.textContent="‚Äî";
      kBound.textContent="‚Äî"; kBoundNote.textContent="‚Äî";
      checkV0.textContent="v0=0 check: ‚Äî";
      checkLam.textContent="Œª boundary check: ‚Äî";
      checkOutliers.textContent="outliers: ‚Äî";
      return;
    }
    const n = summary.length;
    const wins = summary.filter(d=>d.win).length;
    const imp = summary.map(d=>d.imp_eff).filter(Number.isFinite);
    const bound = summary.filter(d=>d.bound).length;

    kRows.textContent = String(n);
    kCols.textContent = `cols: ${headerInfo.cols.length} ¬∑ header mapped`;
    kWins.textContent = `${wins}/${n}`;
    kWinFrac.textContent = `win_frac=${fmt(wins/n,3)}`;
    kMeanImp.textContent = pct(mean(imp),1);
    kMedImp.textContent = `median=${pct(median(imp),1)}`;
    kBound.textContent = String(bound);
    kBoundNote.textContent = `hits on v0/Œª min/max`;

    // v0=0 sanity: max |chi2_q-chi2_b| among v0=0 rows
    const v0z = summary.filter(d=>Number.isFinite(d.v0) && d.v0===0 && Number.isFinite(d.chi2_b) && Number.isFinite(d.chi2_q));
    if(v0z.length){
      const deltas = v0z.map(d=>Math.abs(d.chi2_q - d.chi2_b));
      const mx = Math.max(...deltas);
      const ok = mx < 1e-6 ? "OK" : (mx < 1e-2 ? "tiny" : "WARN");
      checkV0.textContent = `v0=0 check: rows=${v0z.length} max|Œîœá¬≤|=${fmt(mx,6)} (${ok})`;
    } else checkV0.textContent = `v0=0 check: rows=0`;

    // Œª boundaries
    const lamMinHits = summary.filter(d=>d.flags?.includes("Œª=min")).length;
    const lamMaxHits = summary.filter(d=>d.flags?.includes("Œª=max")).length;
    checkLam.textContent = `Œª boundary check: Œª=min hits=${lamMinHits} ¬∑ Œª=max hits=${lamMaxHits}`;

    // outliers in œá¬≤/n space using robust fences
    const b = summary.map(d=>d.b_vis).filter(Number.isFinite);
    const q = summary.map(d=>d.q_vis).filter(Number.isFinite);
    const bq1=quantile(b,.25), bq3=quantile(b,.75), biqr=bq3-bq1;
    const qq1=quantile(q,.25), qq3=quantile(q,.75), qiqr=qq3-qq1;
    const bHi=bq3+3*biqr, qHi=qq3+3*qiqr;
    const outc = summary.filter(d=>Number.isFinite(d.b_vis) && Number.isFinite(d.q_vis) && (d.b_vis>bHi || d.q_vis>qHi)).length;
    checkOutliers.textContent = `outliers: ${outc} (3√óIQR fence in œá¬≤/n)`;
  }

  function applyFilters(){
    if(!summary.length){ tbl.innerHTML=""; return; }

    const s = (qSearch.value||"").trim().toLowerCase();
    const mode = qShow.value;
    const sort = qSort.value;

    let rows = summary.slice();

    if(s) rows = rows.filter(d => d.galaxy.toLowerCase().includes(s));

    if(mode==="wins") rows = rows.filter(d=>d.win);
    else if(mode==="losses") rows = rows.filter(d=>!d.win);
    else if(mode==="bound") rows = rows.filter(d=>d.bound);
    else if(mode==="v0zero") rows = rows.filter(d=>Number.isFinite(d.v0) && d.v0===0);

    const keySorters = {
      imp_desc: (a,b)=> (b.imp_eff||-1e9) - (a.imp_eff||-1e9),
      imp_asc:  (a,b)=> (a.imp_eff||1e9) - (b.imp_eff||1e9),
      aicc_best:(a,b)=> (a.daicc||1e9) - (b.daicc||1e9),
      rb_desc:  (a,b)=> (b.b_vis||-1e9) - (a.b_vis||-1e9),
      rb_asc:   (a,b)=> (a.b_vis||1e9) - (b.b_vis||1e9),
    };
    rows.sort(keySorters[sort] || keySorters.imp_desc);

    // render table
    const frag = document.createDocumentFragment();
    for(const d of rows.slice(0, 220)){ // keep snappy
      const tr = document.createElement("tr");
      const flags = (d.flags||[]).join(" ");
      const impClass = (d.imp_eff>=80) ? "ok" : (d.imp_eff>=20 ? "mid" : (d.imp_eff>0 ? "mid" : "bad"));
      const aiccClass = d.win ? "ok" : "bad";
      tr.innerHTML = `
        <td class="mono">${d.galaxy}</td>
        <td class="mono">${Number.isFinite(d.n)? d.n : "‚Äî"}</td>
        <td class="mono">${fmt(d.b_vis,6)}</td>
        <td class="mono">${fmt(d.q_vis,6)}</td>
        <td class="${impClass} mono">${pct(d.imp_eff,1)}</td>
        <td class="${aiccClass} mono">${Number.isFinite(d.daicc)? fmt(d.daicc,3) : "‚Äî"}</td>
        <td class="mono">${Number.isFinite(d.v0)? fmt(d.v0,3) : "‚Äî"}</td>
        <td class="mono">${Number.isFinite(d.lam)? fmt(d.lam,3) : "‚Äî"}</td>
        <td class="mono">${flags || ""}</td>
      `;
      tr.addEventListener("click", ()=>{
        // if bestfit exists, select it
        if(bestfits.has(d.galaxy)){
          selCurve.value = d.galaxy;
          drawCurve($("cvCurve"), bestfits.get(d.galaxy));
        }
      });
      frag.appendChild(tr);
    }
    tbl.innerHTML="";
    tbl.appendChild(frag);

    // plots from FULL summary (not filtered) for consistency
    const impVals = summary.map(d=>d.imp_eff).filter(Number.isFinite);
    drawHist($("cvHist"), impVals);

    const pts = summary
      .filter(d=>Number.isFinite(d.b_vis) && Number.isFinite(d.q_vis))
      .map(d=>({x:d.b_vis, y:d.q_vis, win:d.win}));
    drawScatter($("cvScatter"), pts);
  }

  // ---------- File loading ----------
  $("fileSummary").addEventListener("change", async (ev)=>{
    const f = ev.target.files[0];
    if(!f) return;
    const text = await f.text();
    const rows = parseCSV(text);
    if(rows.length < 2){
      status.textContent = "SUMMARY parse failed (too few rows).";
      return;
    }
    summaryRaw = rows;
    summary = normalizeSummary(rows);
    const bounds = computeBoundary(summary);

    status.textContent = `Loaded SUMMARY: ${f.name} ¬∑ rows=${summary.length} ¬∑ Œª[min,max]=[${fmt(bounds.lammin,3)}, ${fmt(bounds.lammax,3)}]`;
    refreshKPIs();
    applyFilters();
  });

  $("fileBestfits").addEventListener("change", async (ev)=>{
    const files = Array.from(ev.target.files || []);
    if(!files.length) return;

    for(const f of files){
      const text = await f.text();
      const rows = parseCSV(text);
      if(rows.length < 2) continue;

      const header = rows[0];
      const map = mapBestfitHeader(header);

      // try to guess galaxy name from filename: GALAXY_QDS_bestfit.csv
      let galaxy = f.name.replace(/_QDS_bestfit\.csv$/i,"").replace(/\.csv$/i,"");
      // in case user renamed
      if(!galaxy) galaxy = f.name;

      bestfits.set(galaxy, {galaxy, header, rows: rows.slice(1), map});
    }

    // refresh dropdown
    const keys = Array.from(bestfits.keys()).sort((a,b)=>a.localeCompare(b));
    selCurve.innerHTML = `<option value="">‚Äî select galaxy bestfit ‚Äî</option>` +
      keys.map(k=>`<option value="${k}">${k}</option>`).join("");

    bestfitCount.textContent = `bestfits: ${bestfits.size}`;
  });

  selCurve.addEventListener("change", ()=>{
    const g = selCurve.value;
    if(!g) { drawCurve($("cvCurve"), null); curveInfo.textContent="curve: ‚Äî"; return; }
    drawCurve($("cvCurve"), bestfits.get(g));
  });

  btnAutoPick.addEventListener("click", ()=>{
    if(!summary.length) return;
    // pick the best AICc (lowest daicc)
    const cand = summary.filter(d=>Number.isFinite(d.daicc)).slice().sort((a,b)=>a.daicc-b.daicc)[0];
    if(cand && bestfits.has(cand.galaxy)){
      selCurve.value = cand.galaxy;
      drawCurve($("cvCurve"), bestfits.get(cand.galaxy));
    } else if(cand){
      status.textContent = `Top AICc row: ${cand.galaxy} (no bestfit CSV loaded for it).`;
    }
  });

  qSearch.addEventListener("input", applyFilters);
  qSort.addEventListener("change", applyFilters);
  qShow.addEventListener("change", applyFilters);

  // ---------- Export augmented CSV ----------
  btnExport.addEventListener("click", ()=>{
    if(!summary.length){
      status.textContent="Nothing to export (load SUMMARY first).";
      return;
    }
    const header = [
      "galaxy","n",
      "chi2_bary","chi2_qds",
      "chi2n_bary","chi2n_qds",
      "imp_chi2_pct","imp_effective_pct",
      "aicc_bary","aicc_qds","daicc","qds_wins",
      "v0","lam","flags"
    ];
    const lines = [header.join(",")];
    for(const d of summary){
      const line = [
        d.galaxy, d.n,
        d.chi2_b, d.chi2_q,
        d.b_vis, d.q_vis,
        d.imp_chi2, d.imp_eff,
        d.aiccb, d.aiccq, d.daicc, d.win?1:0,
        d.v0, d.lam,
        (d.flags||[]).join("|")
      ].map(x => (x===null||x===undefined) ? "" : String(x));
      lines.push(line.join(","));
    }
    const blob = new Blob([lines.join("\n")], {type:"text/csv"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `SUMMARY_augmented_${new Date().toISOString().replace(/[-:]/g,"").slice(0,15)}.csv`;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  });

  // initial blank plots
  drawHist($("cvHist"), []);
  drawScatter($("cvScatter"), []);
  drawCurve($("cvCurve"), null);

})();


// --- physorg_supervault_v4.html ---

const LS_TRIAGE = "SV4_TRIAGE";
const LS_NOTES  = "SV4_NOTES";

let STATE = {
  dates: [],
  latest: null,
  date: null,
  items: [],
  triage: loadJSON(LS_TRIAGE, {}),
  notes:  loadJSON(LS_NOTES, {}),
  snapshotMeta: null
};

function loadJSON(key, fallback){
  try{ return JSON.parse(localStorage.getItem(key) || ""); }catch(e){ return fallback; }
}
function saveJSON(key, obj){ localStorage.setItem(key, JSON.stringify(obj)); }

function esc(s){ return (s||"").replace(/[&<>"]/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[c])); }
function nowISO(){ return new Date().toISOString().slice(0,19); }

async function api(path){
  const r = await fetch(path, {cache:"no-store"});
  if(!r.ok) throw new Error(`${path} -> HTTP ${r.status}`);
  return r.json();
}

function setReady(ok, msg){
  const el = document.getElementById("ready");
  el.textContent = msg;
  el.className = "pill " + (ok ? "ok" : "bad");
}

function fmtBucket(b){
  if(b==="vs") return "QDS vs MAINSTREAM";
  if(b==="comp") return "QDS complements MAINSTREAM";
  if(b==="broken") return "QDS broken by data?";
  return "untriaged";
}

function bucketTagClass(b){
  if(b==="vs") return "vs";
  if(b==="comp") return "comp";
  if(b==="broken") return "broken";
  return "un";
}

function computeCounts(){
  const t = STATE.triage || {};
  let vs=0, comp=0, broken=0, triaged=0;
  for(const k in t){
    triaged++;
    if(t[k]==="vs") vs++;
    else if(t[k]==="comp") comp++;
    else if(t[k]==="broken") broken++;
  }
  const items = STATE.items.length;
  return {items, triaged, vs, comp, broken, untriaged: Math.max(0, items - triaged)};
}

function renderStats(){
  const c = computeCounts();
  const el = document.getElementById("stats");
  el.innerHTML = `
    <div class="stat">Items: <b>${c.items}</b></div>
    <div class="stat">Triaged: <b>${c.triaged}</b></div>
    <div class="stat">vs: <b>${c.vs}</b></div>
    <div class="stat">complements: <b>${c.comp}</b></div>
    <div class="stat">broken?: <b>${c.broken}</b></div>
    <div class="stat">untriaged: <b>${c.untriaged}</b></div>
  `;
}

function populateDates(){
  const sel = document.getElementById("dateSel");
  sel.innerHTML = "";
  for(const d of STATE.dates){
    const o = document.createElement("option");
    o.value = d; o.textContent = d;
    sel.appendChild(o);
  }
  sel.value = STATE.date || STATE.latest || (STATE.dates[0]||"");
}

function sortItems(arr, mode){
  const tri = STATE.triage || {};
  const pr = b => (b==="broken"?0 : b==="vs"?1 : b==="comp"?2 : 3);
  const ts = it => new Date(it.published || it.pubDate || 0).getTime() || 0;

  if(mode==="oldest") return arr.sort((a,b)=>ts(a)-ts(b));
  if(mode==="priority"){
    return arr.sort((a,b)=>{
      const pa = pr(tri[a.id]||"untriaged");
      const pb = pr(tri[b.id]||"untriaged");
      if(pa!==pb) return pa-pb;
      return ts(b)-ts(a);
    });
  }
  // newest default
  return arr.sort((a,b)=>ts(b)-ts(a));
}

function filterItems(){
  const view = document.getElementById("viewSel").value;
  const bucket = document.getElementById("bucketSel").value;
  const q = (document.getElementById("q").value||"").toLowerCase().trim();

  const tri = STATE.triage || {};
  let out = STATE.items.slice();

  out = out.filter(it=>{
    const b = tri[it.id] || "untriaged";
    if(view==="triaged" && b==="untriaged") return false;
    if(view==="untriaged" && b!=="untriaged") return false;

    if(bucket==="vs" && b!=="vs") return false;
    if(bucket==="comp" && b!=="comp") return false;
    if(bucket==="broken" && b!=="broken") return false;
    if(bucket==="untriaged" && b!=="untriaged") return false;

    if(q){
      const hay = `${it.title||""} ${it.category||""} ${it.summary||it.description||""} ${STATE.notes[it.id]||""}`.toLowerCase();
      if(!hay.includes(q)) return false;
    }
    return true;
  });

  out = sortItems(out, document.getElementById("sortSel").value);
  return out;
}

function renderList(){
  renderStats();
  const list = document.getElementById("list");
  const arr = filterItems();

  list.innerHTML = arr.map(it=>{
    const b = (STATE.triage[it.id] || "untriaged");
    const note = (STATE.notes[it.id] || "");
    const published = it.published || it.pubDate || "";
    const src = it.source || "phys.org";
    const cat = it.category || "‚Äî";
    const sum = it.summary || it.description || "";
    const link = it.link || it.url || "";

    return `
      <div class="item">
        <div class="meta">
          <span class="tag ${bucketTagClass(b)}">${esc(fmtBucket(b))}</span>
          <span class="tag">${esc(published || "‚Äî")}</span>
          <span class="tag src">${esc(src)}</span>
          <span class="tag">${esc(cat)}</span>
        </div>
        <div class="t">${esc(it.title||"(no title)")}</div>
        <div class="desc">${esc(sum)}</div>

        <div class="triageBtns">
          <button class="btn ghost" onclick="setTriage('${it.id}','vs')">QDS vs</button>
          <button class="btn ghost" onclick="setTriage('${it.id}','comp')">Complements</button>
          <button class="btn ghost" onclick="setTriage('${it.id}','broken')">Broken?</button>
          <button class="btn ghost" onclick="setTriage('${it.id}','untriaged')">Clear</button>
          <button class="btn ghost" onclick="openLink('${esc(link)}')">Open</button>
          <button class="btn ghost" onclick="copyOne('${it.id}')">Copy 1-line</button>
        </div>

        <div class="hr"></div>
        <textarea placeholder="Notes / why you filed it here (saved locally)‚Ä¶" oninput="setNote('${it.id}', this.value)">${esc(note)}</textarea>
        <div class="small">ID: ${esc(it.id||"‚Äî")}</div>
      </div>
    `;
  }).join("");

  if(!arr.length){
    list.innerHTML = `<div class="item"><div class="t">No results</div><div class="small">Try clearing filters/search.</div></div>`;
  }
}

window.setTriage = (id, v)=>{
  if(v==="untriaged") delete STATE.triage[id];
  else STATE.triage[id]=v;
  saveJSON(LS_TRIAGE, STATE.triage);
  renderList();
  buildBrief(); // keep brief fresh
};

window.setNote = (id, txt)=>{
  STATE.notes[id]=txt;
  saveJSON(LS_NOTES, STATE.notes);
};

window.openLink = (url)=>{
  if(!url) return;
  // on android termux-open-url will catch normal open in browser too
  window.open(url, "_blank");
};

window.copyOne = async (id)=>{
  const it = STATE.items.find(x=>x.id===id);
  if(!it) return;
  const b = STATE.triage[id] || "untriaged";
  const line = `[${b.toUpperCase()}] ${it.title||""} ‚Äî ${it.link||""}`.trim();
  await navigator.clipboard.writeText(line);
};

function buildBrief(){
  const maxLines = parseInt(document.getElementById("lineSel").value||"40",10);
  const tri = STATE.triage || {};
  const counts = computeCounts();

  // priority-sorted, triaged first
  const pr = b => (b==="broken"?0 : b==="vs"?1 : b==="comp"?2 : 3);
  const items = STATE.items.slice().sort((a,b)=>{
    const pa = pr(tri[a.id]||"untriaged");
    const pb = pr(tri[b.id]||"untriaged");
    if(pa!==pb) return pa-pb;
    const ta = new Date(a.published||0).getTime()||0;
    const tb = new Date(b.published||0).getTime()||0;
    return tb-ta;
  });

  const header = [
    "QDS SuperVault Brief",
    `Snapshot: ${STATE.snapshotMeta?.master_path ? (STATE.snapshotMeta.master_path.split("/").pop() || "MASTER.json") : "MASTER.json"}`,
    `Updated: ${STATE.snapshotMeta?.created_at || nowISO()}`,
    `Counts: items=${counts.items}, triaged=${counts.triaged}, broken=${counts.broken}, vs=${counts.vs}, comp=${counts.comp}, neutral=${counts.untriaged}`,
    "---",
    "Top items (priority-sorted). Please assess: does any item directly contradict a QDS prediction, or is it neutral/adjacent?"
  ];

  let lines = header.slice();
  let n = 0;
  for(const it of items){
    const b = tri[it.id] || "untriaged";
    if(b==="untriaged") continue; // brief focuses triaged only
    n++;
    const label = b==="broken" ? "[BROKEN?]" : b==="vs" ? "[VS]" : "[COMP]";
    const t = (it.title||"").replace(/\s+/g," ").trim();
    const s = ((it.summary||it.description||"")+"").replace(/\s+/g," ").trim();
    const link = it.link||"";
    const note = (STATE.notes[it.id]||"").replace(/\s+/g," ").trim();
    const line = `${String(n).padStart(2,"0")}. ${label} ${t} ‚Äî ${s.slice(0,160)}‚Ä¶ ${link}${note?(" | note: "+note.slice(0,120)):""}`;
    lines.push(line);

    if(lines.length >= maxLines) break;
  }

  if(n===0){
    lines.push("(No triaged items yet. Tag a few as VS/COMP/BROKEN? and hit refresh.)");
  }

  document.getElementById("brief").textContent = lines.join("\n");
}

async function loadDates(){
  try{
    const d = await api("/api/dates");
    STATE.dates = d.dates || [];
    STATE.latest = d.latest || (STATE.dates[STATE.dates.length-1]||null);
    STATE.date = STATE.latest;
    populateDates();
    setReady(true, "ready");
  }catch(e){
    setReady(false, "server?");
    document.getElementById("log").textContent = "Could not reach /api/dates.\nRun: python ~/qds_vault_server.py --port 8011 --root ~/OMEGA_EMPIRE/UV_QDS/www";
  }
}

async function loadSnapshot(date){
  const snap = await api("/api/snapshot?date="+encodeURIComponent(date));
  STATE.items = snap.items || [];
  STATE.snapshotMeta = snap;
  renderList();
  buildBrief();
}

async function doRefresh(){
  setReady(true, "refreshing‚Ä¶");
  try{
    const r = await api("/api/refresh");
    document.getElementById("log").textContent = r.ok ? (r.log||"(ok)") : ("ERROR: "+(r.error||r.log||"unknown"));
    await loadDates();
    const date = r.latest || STATE.latest || document.getElementById("dateSel").value;
    STATE.date = date;
    document.getElementById("dateSel").value = date;
    await loadSnapshot(date);
    setReady(true, "ready");
  }catch(e){
    document.getElementById("log").textContent = String(e);
    setReady(false, "error");
  }
}

function downloadJSON(name, obj){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
}

function exportPack(){
  const pack = {
    version: "SV4_evidence_pack_v1",
    exported_at: new Date().toISOString(),
    snapshot: {
      source: "phys.org rss (local rip)",
      created_at: STATE.snapshotMeta?.created_at || nowISO(),
      item_count: STATE.items.length,
      master_path: STATE.snapshotMeta?.master_path || ""
    },
    items: STATE.items,
    triage: STATE.triage,
    notes: STATE.notes
  };
  const date = document.getElementById("dateSel").value || "unknown";
  downloadJSON(`qds_evidence_pack_${date}.json`, pack);
}

function importPack(file){
  const fr = new FileReader();
  fr.onload = ()=>{
    try{
      const obj = JSON.parse(fr.result);
      if(obj.triage) STATE.triage = obj.triage;
      if(obj.notes)  STATE.notes  = obj.notes;
      saveJSON(LS_TRIAGE, STATE.triage);
      saveJSON(LS_NOTES, STATE.notes);
      renderList();
      buildBrief();
      document.getElementById("log").textContent = "Imported pack OK.";
    }catch(e){
      document.getElementById("log").textContent = "Import failed: "+e;
    }
  };
  fr.readAsText(file);
}

document.getElementById("btnRefresh").onclick = doRefresh;
document.getElementById("btnReload").onclick = async ()=>{
  const date = document.getElementById("dateSel").value;
  await loadSnapshot(date);
  document.getElementById("log").textContent = "(reloaded)";
};
document.getElementById("btnOpenRip").onclick = ()=>{
  // opens a static path; your Android file handler may download instead ‚Äî still useful.
  const date = document.getElementById("dateSel").value;
  window.open(`/news_rips/physorg/${date}/MASTER.json`, "_blank");
};
document.getElementById("btnCopyBrief").onclick = async ()=>{
  await navigator.clipboard.writeText(document.getElementById("brief").textContent || "");
};
document.getElementById("btnExportPack").onclick = exportPack;
document.getElementById("btnImportPack").onclick = ()=> document.getElementById("fileIn").click();
document.getElementById("fileIn").addEventListener("change", e=>{
  const f = e.target.files && e.target.files[0];
  if(f) importPack(f);
});
document.getElementById("btnClear").onclick = ()=>{
  document.getElementById("q").value = "";
  renderList();
};
document.getElementById("dateSel").onchange = async (e)=>{
  await loadSnapshot(e.target.value);
};
["viewSel","bucketSel","sortSel"].forEach(id=>{
  document.getElementById(id).onchange = ()=> renderList();
});
document.getElementById("q").oninput = ()=> renderList();
document.getElementById("lineSel").onchange = ()=> buildBrief();

(async function boot(){
  await loadDates();
  const date = document.getElementById("dateSel").value || STATE.latest;
  if(date) await loadSnapshot(date);
  buildBrief();
})();


// --- qds_page_forge_v1.html ---

    function getThemePalette(key) {
      switch (key) {
        case "orangePink":
          return {
            primary: "#ff9a3c",
            secondary: "#ff4b8b",
            glow: "rgba(255, 154, 60, 0.4)"
          };
        case "cyberLime":
          return {
            primary: "#b8ff3b",
            secondary: "#ad55ff",
            glow: "rgba(184, 255, 59, 0.4)"
          };
        case "matrix":
          return {
            primary: "#1eff6b",
            secondary: "#41ffb0",
            glow: "rgba(30, 255, 107, 0.45)"
          };
        case "blueGreen":
        default:
          return {
            primary: "#00f6ff",
            secondary: "#00ffb3",
            glow: "rgba(0, 244, 217, 0.45)"
          };
      }
    }

    function escapeHtml(str) {
      return (str || "").replace(/[&<>]/g, s => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" }[s]));
    }

    function buildBodyContent(opts, theme) {
      const sections = (opts.sections || []).filter(Boolean);
      const t = theme;
      const hasHero = opts.modHero;
      const hasStats = opts.modStats;
      const hasNav = opts.modNav;
      const hasFooter = opts.modFooter;

      let html = "";

      if (hasNav) {
        html += `
  <header class="qds-nav">
    <div class="qds-nav-left">
      <div class="qds-orb"></div>
      <div class="qds-nav-text">
        <span class="qds-nav-label">QDS LAB</span>
        <span class="qds-nav-title">${escapeHtml(opts.mainHeading || "New Dashboard")}</span>
      </div>
    </div>
    <div class="qds-nav-right">
      <span class="qds-pill">LOCAL</span>
      <span class="qds-pill qds-pill-accent">${escapeHtml(opts.layoutLabel)}</span>
    </div>
  </header>`;
      }

      if (hasHero) {
        html += `
  <section class="qds-hero">
    <div class="qds-hero-main">
      <h1>${escapeHtml(opts.mainHeading || "QDS Neon Board")}</h1>
      <p>${escapeHtml(opts.subHeading || "Describe experiment, wire inputs, read outputs.")}</p>
      <div class="qds-hero-tags">
        <span class="qds-tag">Phone-lab</span>
        <span class="qds-tag">Offline-ready</span>
        <span class="qds-tag">Neon-HTML</span>
      </div>
    </div>
    <div class="qds-hero-meta">
      <div class="qds-metric">
        <div class="qds-metric-label">LAYOUT</div>
        <div class="qds-metric-value">${escapeHtml(opts.layoutShort)}</div>
      </div>
      <div class="qds-metric">
        <div class="qds-metric-label">THEME</div>
        <div class="qds-metric-value">${escapeHtml(opts.themeLabel)}</div>
      </div>
      <div class="qds-metric">
        <div class="qds-metric-label">SECTIONS</div>
        <div class="qds-metric-value">${sections.length || 0}</div>
      </div>
    </div>
  </section>`;
      }

      if (hasStats) {
        html += `
  <section class="qds-strip">
    <div class="qds-strip-item">
      <span class="qds-strip-label">MODE</span>
      <span class="qds-strip-value">Design</span>
    </div>
    <div class="qds-strip-item">
      <span class="qds-strip-label">DEVICE</span>
      <span class="qds-strip-value">Termux Micro-Lab</span>
    </div>
    <div class="qds-strip-item">
      <span class="qds-strip-label">STATUS</span>
      <span class="qds-strip-value qds-online">Ready</span>
    </div>
  </section>`;
      }

      if (opts.layoutType === "dashboard") {
        html += `
  <main class="qds-main-grid">`;
        sections.forEach((sec, idx) => {
          html += `
    <section class="qds-panel">
      <div class="qds-panel-header">
        <h2>${escapeHtml(sec)}</h2>
        <span class="qds-panel-pill">Panel ${idx + 1}</span>
      </div>
      <div class="qds-panel-body">
        <p>Describe what lives here: controls, tables, charts, or notes.</p>
      </div>
    </section>`;
        });
        html += `
  </main>`;
      } else if (opts.layoutType === "single") {
        html += `
  <main class="qds-main-single">
    <section class="qds-panel qds-panel-full">
      <div class="qds-panel-header">
        <h2>${escapeHtml(sections[0] || "Main workspace")}</h2>
        <span class="qds-panel-pill">Core</span>
      </div>
      <div class="qds-panel-body">
        <p>Use this wide panel for a single flow: inputs on top, live readout below, notes at the bottom.</p>
      </div>
    </section>`;
        if (sections.length > 1) {
          html += `
    <section class="qds-panel-row">`;
          sections.slice(1).forEach((sec, idx) => {
            html += `
      <div class="qds-panel qds-panel-mini">
        <div class="qds-panel-header">
          <h3>${escapeHtml(sec)}</h3>
        </div>
        <div class="qds-panel-body">
          <p>Secondary panel ${idx + 1}. Logs, stats or quick controls.</p>
        </div>
      </div>`;
          });
          html += `
    </section>`;
        }
        html += `
  </main>`;
      } else if (opts.layoutType === "news") {
        html += `
  <main class="qds-main-news">
    <section class="qds-news-column">
      <h2>QDS vs Mainstream</h2>
      <p class="qds-news-hint">Paste articles and mark: supports, contradicts, or neutral to a QDS prediction.</p>
      <div class="qds-news-lane qds-news-lane-vs">
        <h3>Potentially vs QDS</h3>
        <ul class="qds-list" id="qds-vs-list">
          <li>‚Ä¢ Drop bullet points here while reading.</li>
        </ul>
      </div>
      <div class="qds-news-lane qds-news-lane-comp">
        <h3>Complementary / supporting</h3>
        <ul class="qds-list" id="qds-comp-list">
          <li>‚Ä¢ Use this lane for ‚Äúnice match‚Äù notes.</li>
        </ul>
      </div>
      <div class="qds-news-lane qds-news-lane-neutral">
        <h3>Neutral / background</h3>
        <ul class="qds-list" id="qds-neutral-list">
          <li>‚Ä¢ Good context, but not decisive.</li>
        </ul>
      </div>
    </section>
    <section class="qds-news-column">
      <h2>Triage scratchpad</h2>
      <textarea class="qds-scratch" placeholder="Drop quotes, numbers, and quick verdicts here‚Ä¶"></textarea>
      <p class="qds-news-hint">When done, copy this whole block into your QDS log / evidence pack.</p>
    </section>
  </main>`;
      } else {
        html += `
  <main class="qds-main-blank">
    <section class="qds-panel qds-panel-full">
      <div class="qds-panel-header">
        <h2>${escapeHtml(sections[0] || "Blank canvas")}</h2>
        <span class="qds-panel-pill">Skeleton</span>
      </div>
      <div class="qds-panel-body">
        <p>Start from scratch. Add your own layout, grids, charts and widgets.</p>
      </div>
    </section>
  </main>`;
      }

      if (hasFooter) {
        html += `
  <footer class="qds-footer">
    <span>Built with <strong>QDS Page Forge v1</strong> on a phone-lab.</span>
    <span class="qds-footer-meta">File: ${escapeHtml(opts.fileName || "new_page.html")}</span>
  </footer>`;
      }

      return html;
    }

    function generateHtml() {
      const fileName = (document.getElementById("fileName").value || "").trim();
      const layoutType = document.getElementById("layoutType").value;
      const pageTitle = (document.getElementById("pageTitle").value || "").trim() || "QDS Neon Page";
      const mainHeading = document.getElementById("mainHeading").value.trim();
      const subHeading = document.getElementById("subHeading").value.trim();
      const sectionsRaw = document.getElementById("sections").value;
      const sections = sectionsRaw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const themeKey = document.getElementById("theme").value;

      const modNav = document.getElementById("modNav").checked;
      const modHero = document.getElementById("modHero").checked;
      const modStats = document.getElementById("modStats").checked;
      const modFooter = document.getElementById("modFooter").checked;

      let layoutLabel, layoutShort;
      switch (layoutType) {
        case "dashboard":
          layoutLabel = "Neon dashboard";
          layoutShort = "DASH";
          break;
        case "single":
          layoutLabel = "Single panel";
          layoutShort = "SINGLE";
          break;
        case "news":
          layoutLabel = "News / QDS Vault";
          layoutShort = "NEWS";
          break;
        case "blank":
        default:
          layoutLabel = "Blank skeleton";
          layoutShort = "RAW";
          break;
      }

      let themeLabel;
      switch (themeKey) {
        case "orangePink": themeLabel = "Orange / Magenta"; break;
        case "cyberLime": themeLabel = "Cyber Lime / Violet"; break;
        case "matrix": themeLabel = "Matrix Green"; break;
        default: themeLabel = "Blue / Green"; break;
      }

      const palette = getThemePalette(themeKey);

      const opts = {
        fileName,
        layoutType,
        layoutLabel,
        layoutShort,
        mainHeading,
        subHeading,
        sections,
        modNav,
        modHero,
        modStats,
        modFooter,
        themeLabel
      };

      const bodyContent = buildBodyContent(opts, palette);

      const fullHtml = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>${escapeHtml(pageTitle)}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --qds-bg: #050410;
      --qds-panel: #0c0c1c;
      --qds-border: #25254a;
      --qds-text: #f6f7ff;
      --qds-muted: #8e94c5;
      --qds-primary: ${palette.primary};
      --qds-secondary: ${palette.secondary};
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #141432 0, var(--qds-bg) 55%, #020208 100%);
      color: var(--qds-text);
      min-height: 100vh;
      padding: 12px;
    }
    .qds-shell {
      max-width: 1200px;
      margin: 0 auto 32px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .qds-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.06);
      background: linear-gradient(120deg, rgba(0,0,0,0.75), rgba(20,20,60,0.9));
      box-shadow: 0 0 22px rgba(0,0,0,0.65), 0 0 30px ${palette.glow};
    }
    .qds-nav-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .qds-orb {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, #fff, var(--qds-primary));
      box-shadow: 0 0 14px var(--qds-primary), 0 0 26px var(--qds-secondary);
    }
    .qds-nav-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .qds-nav-label {
      font-size: 0.7rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--qds-muted);
    }
    .qds-nav-title {
      font-size: 0.9rem;
      font-weight: 600;
    }
    .qds-nav-right {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .qds-pill {
      font-size: 0.7rem;
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.09);
      background: rgba(5,5,14,0.95);
      color: var(--qds-muted);
    }
    .qds-pill-accent {
      border-color: var(--qds-primary);
      color: var(--qds-primary);
    }
    .qds-hero {
      margin-top: 8px;
      padding: 14px 14px 16px;
      border-radius: 20px;
      border: 1px solid var(--qds-border);
      background:
        radial-gradient(circle at top left, rgba(255,255,255,0.12), transparent 55%),
        radial-gradient(circle at bottom right, rgba(0,0,0,0.85), #050414);
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1.3fr);
      gap: 10px;
    }
    @media (max-width: 800px) {
      .qds-hero {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .qds-hero-main h1 {
      margin: 0 0 4px;
      font-size: 1.4rem;
    }
    .qds-hero-main p {
      margin: 0 0 7px;
      font-size: 0.9rem;
      color: var(--qds-muted);
    }
    .qds-hero-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 3px;
    }
    .qds-tag {
      font-size: 0.72rem;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(5,5,18,0.9);
    }
    .qds-hero-meta {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      align-content: flex-start;
    }
    .qds-metric {
      padding: 7px 9px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(3,5,18,0.95);
    }
    .qds-metric-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.11em;
      color: var(--qds-muted);
      margin-bottom: 3px;
    }
    .qds-metric-value {
      font-size: 0.9rem;
    }
    .qds-strip {
      margin-top: 10px;
      padding: 8px 11px;
      border-radius: 999px;
      border: 1px dashed rgba(255,255,255,0.12);
      background: rgba(5,6,20,0.92);
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      font-size: 0.78rem;
    }
    @media (max-width: 640px) {
      .qds-strip {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .qds-strip-item {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    .qds-strip-label {
      color: var(--qds-muted);
    }
    .qds-strip-value {
      font-weight: 600;
    }
    .qds-online {
      color: var(--qds-primary);
    }
    .qds-main-grid {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }
    .qds-panel {
      border-radius: 18px;
      border: 1px solid var(--qds-border);
      background: radial-gradient(circle at top left, rgba(255,255,255,0.08), transparent 60%), #050412;
      padding: 10px 11px 12px;
      min-height: 80px;
    }
    .qds-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 4px;
    }
    .qds-panel-header h2,
    .qds-panel-header h3 {
      margin: 0;
      font-size: 0.95rem;
    }
    .qds-panel-pill {
      font-size: 0.7rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.1);
      color: var(--qds-muted);
    }
    .qds-panel-body {
      font-size: 0.82rem;
      color: var(--qds-muted);
    }
    .qds-main-single {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .qds-panel-full {
      width: 100%;
    }
    .qds-panel-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
    }
    .qds-panel-mini h3 {
      font-size: 0.9rem;
    }
    .qds-main-news {
      margin-top: 10px;
      display: grid;
      grid-template-columns: minmax(0, 1.5fr) minmax(0, 1.3fr);
      gap: 12px;
    }
    @media (max-width: 880px) {
      .qds-main-news {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .qds-news-column h2 {
      margin: 0 0 4px;
      font-size: 1.05rem;
    }
    .qds-news-hint {
      margin: 0 0 8px;
      font-size: 0.78rem;
      color: var(--qds-muted);
    }
    .qds-news-lane {
      border-radius: 14px;
      border: 1px solid var(--qds-border);
      background: rgba(5,5,20,0.95);
      padding: 8px 10px;
      margin-bottom: 8px;
    }
    .qds-news-lane h3 {
      margin: 0 0 4px;
      font-size: 0.9rem;
    }
    .qds-news-lane-vs { border-color: #ff6a88; }
    .qds-news-lane-comp { border-color: var(--qds-primary); }
    .qds-news-lane-neutral { border-style: dashed; }
    .qds-list {
      margin: 0;
      padding-left: 14px;
      font-size: 0.8rem;
      color: var(--qds-muted);
    }
    .qds-scratch {
      width: 100%;
      min-height: 150px;
      border-radius: 14px;
      border: 1px solid var(--qds-border);
      background: rgba(5,6,24,0.96);
      color: var(--qds-text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
      padding: 8px 9px;
      resize: vertical;
    }
    .qds-main-blank {
      margin-top: 10px;
    }
    .qds-footer {
      margin-top: 12px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.09);
      background: rgba(4,4,16,0.94);
      font-size: 0.78rem;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: space-between;
      color: var(--qds-muted);
    }
    .qds-footer-meta {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
  </style>
</head>
<body>
  <div class="qds-shell">
${buildBodyContent(opts, palette)}
  </div>
</body>
</html>`;

      const codeBox = document.getElementById("generatedCode");
      codeBox.value = fullHtml;

      const iframe = document.getElementById("livePreview");
      iframe.srcdoc = fullHtml;
    }

    function copyCode() {
      const codeBox = document.getElementById("generatedCode");
      if (!codeBox.value.trim()) {
        alert("Nothing to copy yet. Generate a page first.");
        return;
      }
      codeBox.select();
      try {
        document.execCommand("copy");
        alert("HTML copied to clipboard. Paste into nano on the target file.");
      } catch (e) {
        alert("Clipboard copy may not be supported here. Long-press and copy manually.");
      }
    }

    function downloadHtml() {
      const code = document.getElementById("generatedCode").value;
      if (!code.trim()) {
        alert("Generate some HTML first.");
        return;
      }
      const rawName = document.getElementById("fileName").value.trim();
      const name = rawName || "qds_neon_page.html";
      const blob = new Blob([code], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = name;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function clearForm() {
      document.getElementById("fileName").value = "";
      document.getElementById("layoutType").value = "dashboard";
      document.getElementById("pageTitle").value = "";
      document.getElementById("mainHeading").value = "";
      document.getElementById("subHeading").value = "";
      document.getElementById("sections").value = "";
      document.getElementById("theme").value = "blueGreen";
      document.getElementById("modNav").checked = true;
      document.getElementById("modHero").checked = true;
      document.getElementById("modStats").checked = true;
      document.getElementById("modFooter").checked = true;
      document.getElementById("generatedCode").value = "";
      document.getElementById("livePreview").srcdoc = "";
    }

    // Auto-generate a starter layout on load
    window.addEventListener("load", () => {
      document.getElementById("layoutType").value = "dashboard";
      document.getElementById("theme").value = "blueGreen";
      document.getElementById("fileName").value = "qds_new_lab.html";
      document.getElementById("pageTitle").value = "QDS New Lab ¬∑ Neon Board";
      document.getElementById("mainHeading").value = "QDS Experimental Board";
      document.getElementById("subHeading").value = "Fast neon scaffold for the next micro-lab idea.";
      document.getElementById("sections").value =
        "Inputs ¬∑ Controls\nLive metrics\nNotes / scratchpad";
      generateHtml();
    });
  

// --- qds_learning_alphabet_lab_v1.html ---

    // --- Proto-phoneme kernel ---
    const PHONEMES = [
      // consonants
      {
        id: "m",
        label: "m",
        example: "m-at",
        type: "consonant",
        place: "lips",
        manner: "nasal",
        voiced: true,
        color: "#22c55e",
        gesture: "tap chest once"
      },
      {
        id: "n",
        label: "n",
        example: "n-et",
        type: "consonant",
        place: "front",
        manner: "nasal",
        voiced: true,
        color: "#22c55e",
        gesture: "touch nose"
      },
      {
        id: "p",
        label: "p",
        example: "p-at",
        type: "consonant",
        place: "lips",
        manner: "stop",
        voiced: false,
        color: "#38bdf8",
        gesture: "small finger pop"
      },
      {
        id: "t",
        label: "t",
        example: "t-ap",
        type: "consonant",
        place: "front",
        manner: "stop",
        voiced: false,
        color: "#38bdf8",
        gesture: "tap finger on table"
      },
      {
        id: "k",
        label: "k",
        example: "k-it",
        type: "consonant",
        place: "back",
        manner: "stop",
        voiced: false,
        color: "#38bdf8",
        gesture: "small head nod"
      },
      {
        id: "s",
        label: "s",
        example: "s-un",
        type: "consonant",
        place: "front",
        manner: "fricative",
        voiced: false,
        color: "#f97316",
        gesture: "snake hand wiggle"
      },
      {
        id: "sh",
        label: "sh",
        example: "sh-ip",
        type: "consonant",
        place: "middle",
        manner: "fricative",
        voiced: false,
        color: "#a855f7",
        gesture: "finger to lips ü§´"
      },
      {
        id: "ch",
        label: "ch",
        example: "ch-ip",
        type: "consonant",
        place: "front",
        manner: "affricate",
        voiced: false,
        color: "#ec4899",
        gesture: "two-finger tap"
      },
      {
        id: "th",
        label: "th",
        example: "th-in",
        type: "consonant",
        place: "front",
        manner: "fricative",
        voiced: "mixed",
        color: "#f97316",
        gesture: "thumb on chin"
      },

      // vowels / chunks
      {
        id: "a",
        label: "a",
        example: "c-a-t",
        type: "vowel",
        place: "front",
        manner: "short",
        voiced: true,
        color: "#facc15",
        gesture: "open hand forward"
      },
      {
        id: "e",
        label: "e",
        example: "b-e-d",
        type: "vowel",
        place: "front",
        manner: "short",
        voiced: true,
        color: "#facc15",
        gesture: "small step"
      },
      {
        id: "i",
        label: "i",
        example: "f-i-sh",
        type: "vowel",
        place: "front",
        manner: "short",
        voiced: true,
        color: "#facc15",
        gesture: "point up"
      },
      {
        id: "o",
        label: "o",
        example: "h-o-t",
        type: "vowel",
        place: "back",
        manner: "short",
        voiced: true,
        color: "#facc15",
        gesture: "small circle in air"
      },
      {
        id: "ai",
        label: "ai",
        example: "r-ai-n",
        type: "vowel",
        place: "front",
        manner: "long",
        voiced: true,
        color: "#fbbf24",
        gesture: "two steps forward"
      },
      {
        id: "ee",
        label: "ee",
        example: "s-ee",
        type: "vowel",
        place: "front",
        manner: "long",
        voiced: true,
        color: "#fbbf24",
        gesture: "big smile"
      },
      {
        id: "oo",
        label: "oo",
        example: "m-oo-n",
        type: "vowel",
        place: "back",
        manner: "long",
        voiced: true,
        color: "#fbbf24",
        gesture: "hands make circle"
      }
    ];

    // Mini word bank that uses the same kernel
    const WORDS = [
      {
        text: "ship",
        spelling: "ship",
        phonemes: ["sh", "i", "p"],
        note: "Shows chunk [sh] instead of s+h."
      },
      {
        text: "math",
        spelling: "math",
        phonemes: ["m", "a", "th"],
        note: "Simple front-mouth consonants + short vowel."
      },
      {
        text: "tree",
        spelling: "tree",
        phonemes: ["t", "r?", "ee"],
        note: "Prototype: r? could be a later-stage add-on."
      },
      {
        text: "book",
        spelling: "book",
        phonemes: ["b?", "oo", "k"],
        note: "Focus on [oo] as a stable vowel chunk."
      },
      {
        text: "night",
        spelling: "night",
        phonemes: ["n", "ai", "t"],
        note: "Classic tricky spelling, clean phoneme path."
      }
    ];

    const modeDescriptions = {
      classic: "Plain phonics view ‚Äì label, example, basic type.",
      visual: "Colour-coded chunks, good for visual pattern brains.",
      logic: "Feature grid: place / manner / voice. For rule-brains.",
      movement: "Gestures & rhythm notes ‚Äì sound as motion."
    };

    const modeSelect = document.getElementById("modeSelect");
    const modeHint = document.getElementById("modeHint");
    const phonemeGrid = document.getElementById("phonemeGrid");
    const phonemePanel = document.getElementById("phonemePanel");
    const phonemeSub = document.getElementById("phonemeSub");
    const wordsList = document.getElementById("wordsList");

    function renderPhonemes(mode) {
      phonemeGrid.innerHTML = "";
      phonemePanel.classList.remove("mode-classic", "mode-visual", "mode-logic", "mode-movement");
      phonemePanel.classList.add("mode-" + mode);

      phonemeSub.textContent = modeDescriptions[mode] || "Shared sound set for all learners.";

      PHONEMES.forEach(p => {
        const card = document.createElement("div");
        card.className = "phoneme-card";

        // visual mode: add accent border
        if (mode === "visual" && p.color) {
          card.style.borderColor = p.color;
        }

        const label = document.createElement("div");
        label.className = "phoneme-label";
        label.textContent = p.label;
        card.appendChild(label);

        const ex = document.createElement("div");
        ex.className = "phoneme-example";
        ex.textContent = p.example || "";
        card.appendChild(ex);

        if (mode === "classic") {
          const feature = document.createElement("div");
          feature.className = "phoneme-feature";
          feature.textContent = `${p.type} sound`;
          card.appendChild(feature);
        } else if (mode === "visual") {
          const feature = document.createElement("div");
          feature.className = "phoneme-feature";
          feature.textContent = p.type === "vowel" ? "vowel chunk" : "consonant chunk";
          card.appendChild(feature);
        } else if (mode === "logic") {
          const feature = document.createElement("div");
          feature.className = "phoneme-feature";
          feature.textContent = `place: ${p.place}, manner: ${p.manner}, voice: ${p.voiced}`;
          card.appendChild(feature);
        } else if (mode === "movement") {
          const feature = document.createElement("div");
          feature.className = "phoneme-feature";
          feature.textContent = p.type === "vowel" ? "voice / breath shape" : "mouth action";
          card.appendChild(feature);

          const gest = document.createElement("div");
          gest.className = "phoneme-gesture";
          gest.textContent = p.gesture || "";
          card.appendChild(gest);
        }

        phonemeGrid.appendChild(card);
      });
    }

    function getPhonemeById(id) {
      return PHONEMES.find(p => p.id === id) || null;
    }

    function renderWords(mode) {
      wordsList.innerHTML = "";

      WORDS.forEach(w => {
        const card = document.createElement("div");
        card.className = "word-card";

        const head = document.createElement("div");
        head.className = "word-head";

        const left = document.createElement("div");
        const wordText = document.createElement("div");
        wordText.className = "word-text";
        wordText.textContent = w.text;

        const wordSpell = document.createElement("div");
        wordSpell.className = "word-spelling";
        wordSpell.textContent = `spelling: ${w.spelling}`;

        left.appendChild(wordText);
        left.appendChild(wordSpell);

        const right = document.createElement("div");
        right.className = "word-spelling";
        right.textContent = `${w.phonemes.join(" ‚Ä¢ ")}`;

        head.appendChild(left);
        head.appendChild(right);
        card.appendChild(head);

        const chips = document.createElement("div");
        chips.className = "chips";

        w.phonemes.forEach(pid => {
          const chip = document.createElement("div");
          chip.className = "chip";

          const p = getPhonemeById(pid.replace("?", ""));
          const dot = document.createElement("span");
          dot.className = "chip-dot";

          if (p && p.color && mode === "visual") {
            dot.style.background = p.color;
          } else if (mode === "logic") {
            dot.style.background = "#38bdf8";
          } else if (mode === "movement") {
            dot.style.background = "#facc15";
          }

          chip.appendChild(dot);

          const label = document.createElement("span");
          label.textContent = pid;
          chip.appendChild(label);

          if (mode === "movement" && p && p.gesture) {
            const gest = document.createElement("span");
            gest.className = "chip-note";
            gest.textContent = p.gesture;
            chip.appendChild(gest);
          }

          chips.appendChild(chip);
        });

        card.appendChild(chips);

        if (w.note) {
          const note = document.createElement("div");
          note.className = "chip-note";
          note.style.marginTop = "0.2rem";
          note.textContent = w.note;
          card.appendChild(note);
        }

        wordsList.appendChild(card);
      });
    }

    function setMode(mode) {
      modeHint.textContent = modeDescriptions[mode] || "";
      renderPhonemes(mode);
      renderWords(mode);
    }

    modeSelect.addEventListener("change", () => setMode(modeSelect.value));

    // boot
    setMode("visual");
    modeSelect.value = "visual";
  

// --- qds_learning_alphabet_lab_vmax.html ---

    // --- Data ---------------------------------------------------------------

    const phonemes = [
      {
        id: "m",
        label: "m",
        example: "m-at",
        typeChunk: "consonant chunk",
        typeClassic: "consonant sound",
        place: "lips",
        manner: "nasal",
        voice: true,
        movement: "tap chest once",
        emoji: "üêª"
      },
      {
        id: "n",
        label: "n",
        example: "n-et",
        typeChunk: "consonant chunk",
        typeClassic: "consonant sound",
        place: "front",
        manner: "nasal",
        voice: true,
        movement: "touch nose",
        emoji: "üëÉ"
      },
      {
        id: "p",
        label: "p",
        example: "p-at",
        typeChunk: "consonant chunk",
        typeClassic: "consonant sound",
        place: "lips",
        manner: "stop",
        voice: false,
        movement: "small finger pop",
        emoji: "üéà"
      },
      {
        id: "t",
        label: "t",
        example: "t-ap",
        typeChunk: "consonant chunk",
        typeClassic: "consonant sound",
        place: "front",
        manner: "stop",
        voice: false,
        movement: "tap finger on table",
        emoji: "ü™µ"
      },
      {
        id: "k",
        label: "k",
        example: "k-it",
        typeChunk: "consonant chunk",
        typeClassic: "consonant sound",
        place: "back",
        manner: "stop",
        voice: false,
        movement: "small head nod",
        emoji: "üéØ"
      },
      {
        id: "s",
        label: "s",
        example: "s-un",
        typeChunk: "consonant chunk",
        typeClassic: "consonant sound",
        place: "front",
        manner: "fricative",
        voice: false,
        movement: "snake hand wiggle",
        emoji: "üêç"
      },
      {
        id: "sh",
        label: "sh",
        example: "sh-ip",
        typeChunk: "consonant chunk",
        typeClassic: "consonant sound",
        place: "middle",
        manner: "fricative",
        voice: false,
        movement: "finger to lips",
        emoji: "ü§´"
      },
      {
        id: "ch",
        label: "ch",
        example: "ch-ip",
        typeChunk: "consonant chunk",
        typeClassic: "consonant sound",
        place: "front",
        manner: "affricate",
        voice: false,
        movement: "two-finger tap",
        emoji: "üß±"
      },
      {
        id: "th",
        label: "th",
        example: "th-in",
        typeChunk: "consonant chunk",
        typeClassic: "consonant sound",
        place: "front",
        manner: "fricative",
        voice: "mixed",
        movement: "thumb on chin",
        emoji: "ü¶∑"
      },
      {
        id: "a",
        label: "a",
        example: "c-a-t",
        typeChunk: "vowel chunk",
        typeClassic: "vowel sound",
        place: "front",
        manner: "short",
        voice: true,
        movement: "open hand forward",
        emoji: "‚≠ê"
      },
      {
        id: "e",
        label: "e",
        example: "b-e-d",
        typeChunk: "vowel chunk",
        typeClassic: "vowel sound",
        place: "front",
        manner: "short",
        voice: true,
        movement: "small step",
        emoji: "üìè"
      },
      {
        id: "i",
        label: "i",
        example: "f-i-sh",
        typeChunk: "vowel chunk",
        typeClassic: "vowel sound",
        place: "front",
        manner: "short",
        voice: true,
        movement: "small step forward",
        emoji: "üìå"
      },
      {
        id: "o",
        label: "o",
        example: "h-o-t",
        typeChunk: "vowel chunk",
        typeClassic: "vowel sound",
        place: "back",
        manner: "short",
        voice: true,
        movement: "round lips",
        emoji: "üî•"
      },
      {
        id: "ai",
        label: "ai",
        example: "r-ai-n",
        typeChunk: "vowel chunk",
        typeClassic: "vowel sound",
        place: "front",
        manner: "long",
        voice: true,
        movement: "two steps forward",
        emoji: "üåà"
      },
      {
        id: "ee",
        label: "ee",
        example: "s-ee",
        typeChunk: "vowel chunk",
        typeClassic: "vowel sound",
        place: "front",
        manner: "long",
        voice: true,
        movement: "big smile",
        emoji: "üòä"
      },
      {
        id: "oo",
        label: "oo",
        example: "m-oo-n",
        typeChunk: "vowel chunk",
        typeClassic: "vowel sound",
        place: "back",
        manner: "long",
        voice: true,
        movement: "round lips long",
        emoji: "üåï"
      }
    ];

    const words = [
      {
        id: "ship",
        icon: "üö¢",
        spelling: "ship",
        phonemes: ["sh", "i", "p"],
        pathPretty: "sh ‚Ä¢ i ‚Ä¢ p",
        note: "Shows chunk [sh] instead of s+h."
      },
      {
        id: "math",
        icon: "üßÆ",
        spelling: "math",
        phonemes: ["m", "a", "th"],
        pathPretty: "m ‚Ä¢ a ‚Ä¢ th",
        note: "Simple front-mouth consonants + short vowel."
      },
      {
        id: "tree",
        icon: "üå≥",
        spelling: "tree",
        phonemes: ["t", "r?", "ee"],
        pathPretty: "t ‚Ä¢ r? ‚Ä¢ ee",
        note: "Prototype: r? could be a later-stage add-on."
      },
      {
        id: "book",
        icon: "üìö",
        spelling: "book",
        phonemes: ["b?", "oo", "k"],
        pathPretty: "b? ‚Ä¢ oo ‚Ä¢ k",
        note: "Focus on [oo] as a stable vowel chunk."
      },
      {
        id: "night",
        icon: "üåô",
        spelling: "night",
        phonemes: ["n", "ai", "t"],
        pathPretty: "n ‚Ä¢ ai ‚Ä¢ t",
        note: "Classic tricky spelling, clean phoneme path."
      }
    ];

    const profileDescriptions = {
      default:
        "Mixed group: start visual + emoji, then visit movement and logic views when they‚Äôre ready.",
      movement:
        "Needs motion first. Say the sound and do the gesture together every time.",
      nd:
        "ND blend: keep colour + gesture, avoid overload. Short bursts, lots of wins, no pressure.",
      dyslexia:
        "Dyslexia-friendly: emphasise shared chunks (sh, th, oo) and patterns over single letters.",
      eal:
        "EAL / language-learner: combine emoji + gesture with examples in their home language out loud."
    };

    const viewModeDescriptions = {
      visual: "Colour-coded chunks ‚Äì good for visual pattern brains.",
      movement: "Gestures & rhythm notes ‚Äì sound as motion.",
      classic: "Plain phonics view ‚Äì label, example, basic type.",
      logic: "Feature grid: place / manner / voice. For rule-brains."
    };

    // --- Helpers ------------------------------------------------------------

    function byId(id) {
      return document.getElementById(id);
    }

    const profileSelect = byId("profileSelect");
    const viewModeSelect = byId("viewModeSelect");
    const profileDescription = byId("profileDescription");
    const viewModeDescription = byId("viewModeDescription");
    const phonemeCaption = byId("phonemeCaption");
    const phonemeGrid = byId("phonemeGrid");
    const wordsList = byId("wordsList");

    const buildPathDisplay = byId("buildPathDisplay");
    const buildSpelling = byId("buildSpelling");
    const clearBuild = byId("clearBuild");
    const buildChips = byId("buildChips");

    const quizWordLabel = byId("quizWordLabel");
    const quizPrompt = byId("quizPrompt");
    const quizAnswer = byId("quizAnswer");
    const showQuizPath = byId("showQuizPath");
    const nextQuizWord = byId("nextQuizWord");

    let buildPath = [];
    let quizIndex = 0;
    let quizRevealed = false;

    // --- Rendering ----------------------------------------------------------

    function renderPhonemes() {
      const mode = viewModeSelect.value;
      phonemeGrid.innerHTML = "";

      phonemeCaption.textContent = viewModeDescriptions[mode];

      phonemes.forEach((ph) => {
        const card = document.createElement("div");
        card.className =
          "phoneme-card phoneme-border-" + ph.id.replace("?", "");

        const head = document.createElement("div");
        head.className = "phoneme-head";

        const label = document.createElement("div");
        label.className = "phoneme-label";
        label.textContent = ph.label;

        const emoji = document.createElement("div");
        emoji.className = "phoneme-emoji";
        emoji.textContent = ph.emoji;

        head.appendChild(label);
        head.appendChild(emoji);
        card.appendChild(head);

        const ex = document.createElement("div");
        ex.className = "phoneme-example";
        ex.textContent = ph.example;
        card.appendChild(ex);

        const type = document.createElement("div");
        type.className = "phoneme-type";

        if (mode === "visual") {
          type.textContent = ph.typeChunk;
        } else if (mode === "movement") {
          type.textContent = "mouth action ‚Ä¢ " + ph.movement;
        } else if (mode === "classic") {
          type.textContent = ph.typeClassic;
        } else {
          // logic
          type.textContent =
            "place: " +
            ph.place +
            ", manner: " +
            ph.manner +
            ", voice: " +
            ph.voice;
        }

        card.appendChild(type);

        if (mode === "logic") {
          const extra = document.createElement("div");
          extra.className = "phoneme-extra";
          extra.textContent = "Great for sorting into rule groups.";
          card.appendChild(extra);
        }

        phonemeGrid.appendChild(card);
      });
    }

    function renderWords() {
      wordsList.innerHTML = "";

      words.forEach((w) => {
        const card = document.createElement("div");
        card.className = "word-card";

        const head = document.createElement("div");
        head.className = "word-head";

        const main = document.createElement("div");
        main.className = "word-main";

        const title = document.createElement("div");
        title.className = "word-title";
        title.innerHTML =
          "<span>" + w.icon + "</span><span>" + w.spelling + "</span>";

        const spelling = document.createElement("div");
        spelling.className = "word-spelling";
        spelling.textContent = "spelling: " + w.spelling;

        main.appendChild(title);
        main.appendChild(spelling);

        const path = document.createElement("div");
        path.className = "word-path";
        path.textContent = w.pathPretty;

        head.appendChild(main);
        head.appendChild(path);
        card.appendChild(head);

        const note = document.createElement("div");
        note.className = "word-note";
        note.textContent = w.note;
        card.appendChild(note);

        wordsList.appendChild(card);
      });
    }

    function renderBuildChips() {
      buildChips.innerHTML = "";
      phonemes.forEach((ph) => {
        const chip = document.createElement("button");
        chip.type = "button";
        chip.className = "sound-chip";
        chip.innerHTML =
          '<span class="emoji">' +
          ph.emoji +
          '</span><span class="label">' +
          ph.label +
          "</span>";
        chip.addEventListener("click", () => {
          buildPath.push(ph.id);
          updateBuildPathDisplay();
        });
        buildChips.appendChild(chip);
      });
    }

    function updateBuildPathDisplay() {
      if (!buildPath.length) {
        buildPathDisplay.textContent = "tap sounds below‚Ä¶";
        return;
      }
      const labels = buildPath.map((id) => {
        const ph = phonemes.find((p) => p.id === id);
        return ph ? ph.label : id;
      });
      buildPathDisplay.textContent = labels.join(" ‚Ä¢ ");
    }

    function clearBuildPath() {
      buildPath = [];
      buildSpelling.value = "";
      updateBuildPathDisplay();
    }

    function renderQuizWord() {
      const w = words[quizIndex];
      quizWordLabel.textContent = w.spelling;
      quizPrompt.innerHTML =
        "Predict the kernel path. Then tap <b>Show kernel path</b>.";
      quizAnswer.textContent =
        "kernel path: " + w.pathPretty + " ‚Äî " + w.note;
      quizAnswer.style.opacity = quizRevealed ? "1" : "0.15";
    }

    // --- Event wiring -------------------------------------------------------

    profileSelect.addEventListener("change", () => {
      const val = profileSelect.value;
      profileDescription.textContent = profileDescriptions[val];

      // Light-touch auto view hints
      if (val === "movement") {
        viewModeSelect.value = "movement";
      } else if (val === "dyslexia") {
        viewModeSelect.value = "visual";
      } else if (val === "eal") {
        viewModeSelect.value = "visual";
      } else if (val === "nd") {
        viewModeSelect.value = "visual";
      } else {
        viewModeSelect.value = viewModeSelect.value || "visual";
      }
      viewModeDescription.textContent =
        viewModeDescriptions[viewModeSelect.value];
      renderPhonemes();
    });

    viewModeSelect.addEventListener("change", () => {
      const mode = viewModeSelect.value;
      viewModeDescription.textContent = viewModeDescriptions[mode];
      renderPhonemes();
    });

    clearBuild.addEventListener("click", (e) => {
      e.preventDefault();
      clearBuildPath();
    });

    showQuizPath.addEventListener("click", (e) => {
      e.preventDefault();
      quizRevealed = true;
      renderQuizWord();
    });

    nextQuizWord.addEventListener("click", (e) => {
      e.preventDefault();
      quizIndex = (quizIndex + 1) % words.length;
      quizRevealed = false;
      renderQuizWord();
    });

    // --- Init ---------------------------------------------------------------

    function init() {
      profileDescription.textContent = profileDescriptions["default"];
      viewModeDescription.textContent = viewModeDescriptions["visual"];
      renderPhonemes();
      renderWords();
      renderBuildChips();
      clearBuildPath();
      renderQuizWord();
    }

    init();
  

// --- frontdoor_showroom.html ---

    // ===== Config: showroom links (edit anytime) =====
    const LINKS = [
      // Core labs
      { group:"core", name:"Mega Suite ‚Ä¢ One-Button MAX", href:"qds_megasuite_onebutton_MAX.html", meta:"Sanity + integration runner (kernel, UV, H0, rotation, pulsar proxy, bird).", tag:"core" },
      { group:"core", name:"Reality-Check Labs (Test Platform V3)", href:"qds_test_platformV3.html", meta:"Falsification-first launchpad for targeted QDS checks.", tag:"tests" },
      { group:"core", name:"Battery Habitat RW Lab v1.3", href:"qds_battery_habitat_rw_v1_3.html", meta:"Random-walk battery stress + lifetime sketch tools.", tag:"battery" },
      { group:"core", name:"Rotation Curve Lab Ultra", href:"qds_rc_lab_ultra.html", meta:"Rotation curve sanity testing and quick plots.", tag:"galaxy" },
      { group:"core", name:"ROTMOD Extreme Lab", href:"qds_rotmod_extreme_lab.html", meta:"Extended rotation-curve workflows + checks.", tag:"rotmod" },
      { group:"core", name:"Binary Pulsar Lab v2 (MAX)", href:"qds_binary_pulsar_lab_v2_max.html", meta:"Binary/pulsar constraint proxy tooling.", tag:"pulsar" },
      { group:"core", name:"Pulsar Suite One-Button MAX", href:"qds_pulsar_suite_onebutton_MAX.html", meta:"Multi-system run + curves export (proxy).", tag:"suite" },
      { group:"core", name:"Bird Migration Lab", href:"bird_migration_lab.html", meta:"Coherence & cohort comparison lab (local).", tag:"bio" },
      { group:"core", name:"Alphabet Learning Lab (vMAX)", href:"qds_learning_alphabet_lab_vmax.html", meta:"Kid-friendly learning sandbox (local).", tag:"kids" },

      // News / vault
      { group:"news", name:"Phys.org News Dashboard", href:"physorg_news_dashboard.html", meta:"Local rip dashboard, browsing + quick sorting.", tag:"news" },
      { group:"news", name:"QDS News Triage Vault", href:"physorg_qds_triage.html", meta:"Bucket + mode triage vault for local MASTER.json rips.", tag:"vault" },
      { group:"news", name:"Phys.org Supervault (v4)", href:"physorg_supervault_v4.html", meta:"Deep vault mode / super index view.", tag:"super" },

      // Reference / reports
      { group:"ref", name:"NASA RW3 Condensed Report (local)", href:"nasa_rw3/NASA_RW3_report.html", meta:"RW3 summary + plots (local report page).", tag:"report" },

      // Optional: personal dev door (kept separate but available)
      { group:"ref", name:"Dev Door (personal) ‚Ä¢ QDS √ó NASA Lab Suite", href:"qds_nasa_lab_suite.html", meta:"Personal dev launchpad (not for formal showroom).", tag:"dev" },
    ];

    const el = (id)=>document.getElementById(id);

    function badgeFor(tag){
      // keep minimal, professional
      const map = {
        core:"CORE", tests:"TESTS", battery:"BATTERY", galaxy:"GALAXY",
        rotmod:"ROTMOD", pulsar:"PULSAR", suite:"SUITE", bio:"BIO",
        kids:"KIDS", news:"NEWS", vault:"VAULT", super:"VAULT",
        report:"REPORT", dev:"DEV"
      };
      return map[tag] || "LINK";
    }

    function renderList(targetId, group){
      const target = el(targetId);
      target.innerHTML = "";

      LINKS.filter(x => x.group === group).forEach(item => {
        const row = document.createElement("a");
        row.className = "item";
        row.href = item.href;

        const left = document.createElement("div");
        left.className = "left";

        const name = document.createElement("div");
        name.className = "name";
        name.textContent = item.name;

        const meta = document.createElement("div");
        meta.className = "meta";
        meta.textContent = item.meta + "  ‚Ä¢  file: " + item.href;

        left.appendChild(name);
        left.appendChild(meta);

        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = badgeFor(item.tag);

        row.appendChild(left);
        row.appendChild(badge);
        target.appendChild(row);
      });
    }

    function applySearch(q){
      q = (q||"").trim().toLowerCase();
      const allItems = document.querySelectorAll(".list .item");
      allItems.forEach(a=>{
        const txt = a.textContent.toLowerCase();
        a.style.display = (!q || txt.includes(q)) ? "" : "none";
      });
    }

    function updateStatus(){
      const now = new Date();
      el("tsV").textContent = now.toISOString().replace("T"," ").slice(0,19) + "Z";

      const isFile = location.protocol === "file:";
      el("modeV").textContent = isFile ? "File (offline-ready)" : "Localhost / local server";

      const online = navigator.onLine;
      el("connV").textContent = online ? "Online" : "Offline";
      el("connV").className = "v " + (online ? "good" : "warn");

      const netPill = el("netPill");
      netPill.textContent = online ? "Online" : "Offline";
      netPill.style.borderColor = online ? "rgba(76,245,154,.35)" : "rgba(247,200,90,.35)";
    }

    // Boot
    renderList("coreList","core");
    renderList("newsList","news");
    renderList("refList","ref");

    updateStatus();
    window.addEventListener("online", updateStatus);
    window.addEventListener("offline", updateStatus);

    el("q").addEventListener("input", (e)=>applySearch(e.target.value));
  

// --- qds_revenue_floor_v2_sensfix_v3.html ---

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);

function num(id, def=0){
  const el = $(id);
  if(!el) return def;
  const v = parseFloat(String(el.value ?? "").trim());
  return Number.isFinite(v) ? v : def;
}
function clamp(x, a, b){
  if(!Number.isFinite(x)) return a;
  return Math.min(b, Math.max(a, x));
}
function fmtMoney(x){
  const cur = String($("currency").value || "¬£").trim() || "¬£";
  const n = Number.isFinite(x) ? x : 0;
  const rounded = Math.round(n);
  return cur + rounded.toLocaleString();
}

/* ---------- Core model ---------- */
function computeModel(){
  const L = Math.max(0, num("L"));
  const q = clamp(num("q"), 0, 1);
  const s = clamp(num("s"), 0, 1);
  const p = clamp(num("p"), 0, 1);
  const r = clamp(num("r"), 0, 1);

  const Sprice = Math.max(0, num("Sprice"));
  const Pprice = Math.max(0, num("Pprice"));
  const Rprice = Math.max(0, num("Rprice"));

  const Smax = Math.max(0, num("Smax"));
  const Pmax = Math.max(0, num("Pmax"));

  const M0 = Math.max(0, num("M0"));
  const churnPct = clamp(num("churn"), 0, 50);
  const churn = churnPct / 100;

  const months = clamp(Math.round(num("months", 12)), 1, 60);

  const qualified = L * q;
  const sprintsRaw = qualified * s;
  const sprints = Math.min(sprintsRaw, Smax);

  const pilotsRaw = sprints * p;
  const pilots = Math.min(pilotsRaw, Pmax);

  const newRetainers = pilots * r;

  const newMrr = newRetainers * Rprice;

  const revMonth = (sprints * Sprice) + (pilots * Pprice) + newMrr;
  const revYear = revMonth * 12;

  // MRR accumulation over horizon
  let mrr = M0;
  const mrrTimeline = [mrr];
  for(let i=1;i<=months;i++){
    mrr = (mrr + newMrr) * (1 - churn);
    mrrTimeline.push(mrr);
  }

  const at = (n)=>{
    const idx = clamp(n, 0, months);
    return mrrTimeline[idx];
  };

  return {
    L,q,s,p,r,Sprice,Pprice,Rprice,Smax,Pmax,M0,churnPct,churn,months,
    qualified,sprintsRaw,sprints,pilotsRaw,pilots,newRetainers,newMrr,
    revMonth,revYear,mrrTimeline,
    mrr3: at(3), mrr6: at(6), mrr12: at(12), mrrEnd: at(months)
  };
}

/* ---------- Presets ---------- */
const PRESETS = {
  conservative: {
    L:6, q:0.40, s:0.30, p:0.30, r:0.25,
    Sprice:2000, Pprice:5000, Rprice:1500,
    Smax:4, Pmax:2, M0:0, churn:4
  },
  base: {
    L:12, q:0.50, s:0.35, p:0.40, r:0.30,
    Sprice:2500, Pprice:6000, Rprice:2000,
    Smax:6, Pmax:3, M0:0, churn:3
  },
  optimistic: {
    L:20, q:0.60, s:0.45, p:0.45, r:0.40,
    Sprice:3000, Pprice:8000, Rprice:2500,
    Smax:8, Pmax:4, M0:0, churn:2
  }
};

function applyPreset(){
  const key = $("preset")?.value || "base";
  const p = PRESETS[key] || PRESETS.base;

  $("L").value = p.L;
  $("q").value = p.q;
  $("s").value = p.s;
  $("p").value = p.p;
  $("r").value = p.r;

  $("Sprice").value = p.Sprice;
  $("Pprice").value = p.Pprice;
  $("Rprice").value = p.Rprice;

  $("Smax").value = p.Smax;
  $("Pmax").value = p.Pmax;

  $("M0").value = p.M0;
  $("churn").value = p.churn;
}

/* ---------- Sensitivity ---------- */
function buildSensitivity(base){
  const rows = [];

  function calcWith(patch){
    // temporarily apply patch values, compute, then restore
    const ids = Object.keys(patch);
    const old = {};
    ids.forEach(id=>{
      old[id] = $(id).value;
      $(id).value = patch[id];
    });
    const m = computeModel();
    ids.forEach(id=>$(id).value = old[id]);
    return m.revYear;
  }

  const baseYear = base.revYear;

  // +1 lead
  rows.push({
    label: "+1 lead / month",
    delta: calcWith({L: num("L")+1}) - baseYear
  });

  // +0.10 sprint close
  rows.push({
    label: "+0.10 sprint close rate",
    delta: calcWith({s: clamp(num("s")+0.10, 0, 1)}) - baseYear
  });

  // +1 sprint capacity
  rows.push({
    label: "+1 sprint capacity",
    delta: calcWith({Smax: num("Smax")+1}) - baseYear
  });

  // +0.05 pilot-from-sprint
  rows.push({
    label: "+0.05 pilot-from-sprint",
    delta: calcWith({p: clamp(num("p")+0.05, 0, 1)}) - baseYear
  });

  // +0.05 retainer-from-pilot
  rows.push({
    label: "+0.05 retainer-from-pilot",
    delta: calcWith({r: clamp(num("r")+0.05, 0, 1)}) - baseYear
  });

  const body = $("sensBody");
  body.innerHTML = "";
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const td1 = document.createElement("td");
    const td2 = document.createElement("td");
    td1.textContent = r.label;
    td2.textContent = fmtMoney(r.delta);
    tr.appendChild(td1); tr.appendChild(td2);
    body.appendChild(tr);
  });
}

/* ---------- Board summary ---------- */
function buildBoardSummary(m){
  const capNote = String($("capNotes").value || "").trim();
  const cost = Math.max(0, num("cost"));

  const conf = {
    q: $("qConf")?.value || "Med",
    s: $("sConf")?.value || "Med",
    p: $("pConf")?.value || "Med",
    r: $("rConf")?.value || "Med",
    c: $("cConf")?.value || "Med",
  };

  const notes = {
    q: String($("qNote")?.value || "").trim(),
    s: String($("sNote")?.value || "").trim(),
    p: String($("pNote")?.value || "").trim(),
    r: String($("rNote")?.value || "").trim(),
    c: String($("cNote")?.value || "").trim(),
  };

  const parts = [];
  parts.push(
    `Revenue floor model (capacity-truthed): ` +
    `${m.L} leads/mo ‚Üí q ${m.q.toFixed(2)} ‚Üí s ${m.s.toFixed(2)} ‚Üí p ${m.p.toFixed(2)} ‚Üí r ${m.r.toFixed(2)}.`
  );
  parts.push(
    `Pricing: Sprint ${fmtMoney(m.Sprice)}, Pilot ${fmtMoney(m.Pprice)}, Retainer ${fmtMoney(m.Rprice)}/mo.`
  );
  parts.push(
    `Capacity: Smax ${m.Smax}, Pmax ${m.Pmax}` + (capNote ? ` (${capNote})` : "") + `.`
  );
  parts.push(
    `Expected/month: ${m.sprints.toFixed(2)} sprints, ${m.pilots.toFixed(2)} pilots, ${m.newRetainers.toFixed(2)} new retainers.`
  );
  parts.push(
    `Run-rate: ${fmtMoney(m.revMonth)}/mo (${fmtMoney(m.revYear)}/yr).`
  );
  parts.push(
    `MRR: M0 ${fmtMoney(m.M0)}, churn ${m.churnPct.toFixed(1)}%. New MRR ${fmtMoney(m.newMrr)}/mo ‚Üí projected MRR @ ${m.months} months ${fmtMoney(m.mrrEnd)}.`
  );
  if(cost>0){
    parts.push(`Cost base noted: ${fmtMoney(cost)}/mo (for margin context, not enforced in calc).`);
  }

  const confLine =
    `Assumption confidence: q ${conf.q}, s ${conf.s}, p ${conf.p}, r ${conf.r}, churn ${conf.c}.`;
  parts.push(confLine);

  const ev = [];
  if(notes.q) ev.push(`q: ${notes.q}`);
  if(notes.s) ev.push(`s: ${notes.s}`);
  if(notes.p) ev.push(`p: ${notes.p}`);
  if(notes.r) ev.push(`r: ${notes.r}`);
  if(notes.c) ev.push(`c: ${notes.c}`);
  if(ev.length) parts.push(`Evidence: ${ev.join(" | ")}`);

  parts.push(`This model is deliberately conservative: upside comes from more leads, better close rates, and capacity expansion ‚Äî not inflated assumptions.`);

  return parts.join(" ");
}

/* ---------- Render ---------- */
function render(){
  const m = computeModel();

  // update audit value cells
  $("qValCell").textContent = m.q.toFixed(2);
  $("sValCell").textContent = m.s.toFixed(2);
  $("pValCell").textContent = m.p.toFixed(2);
  $("rValCell").textContent = m.r.toFixed(2);
  $("cValCell").textContent = m.churnPct.toFixed(1) + "%";

  // KPIs
  $("revMonth").textContent = fmtMoney(m.revMonth);
  $("revYear").textContent = fmtMoney(m.revYear);
  $("newMrr").textContent = fmtMoney(m.newMrr);
  $("mrrEnd").textContent = fmtMoney(m.mrrEnd);
  $("mrrEndSub").textContent = `MRR after churn @ ${m.months} months`;

  // volumes
  $("volumesBox").innerHTML =
    `Qualified: ${m.qualified.toFixed(2)}<br/>` +
    `Sprints: ${m.sprints.toFixed(2)} (raw ${m.sprintsRaw.toFixed(2)})<br/>` +
    `Pilots: ${m.pilots.toFixed(2)} (raw ${m.pilotsRaw.toFixed(2)})<br/>` +
    `New retainers: ${m.newRetainers.toFixed(2)}`;

  // MRR accumulation snapshot
  $("mrrBox").innerHTML =
    `Starting: ${fmtMoney(m.M0)}<br/>` +
    `MRR @ 3 months: ${fmtMoney(m.mrr3)}<br/>` +
    `MRR @ 6 months: ${fmtMoney(m.mrr6)}<br/>` +
    `MRR @ 12 months: ${fmtMoney(m.mrr12)}`;

  // sensitivity
  buildSensitivity(m);

  // board summary
  const summary = buildBoardSummary(m);
  $("boardSummary").value = summary;

  // status pill
  $("statusPill").textContent = "Live";
}

/* ---------- One-pager + Print ---------- */
function toggleView(){
  document.body.classList.toggle("onepager");
}
function printOnePager(){
  // ensure onepager layout for print, but restore after
  const was = document.body.classList.contains("onepager");
  if(!was) document.body.classList.add("onepager");
  window.print();
  if(!was) document.body.classList.remove("onepager");
}

/* ---------- Copy summary ---------- */
async function copySummary(){
  const text = $("boardSummary").value || "";
  try{
    await navigator.clipboard.writeText(text);
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }catch(e){
    // fallback
    $("boardSummary").select();
    document.execCommand("copy");
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }
}

/* ---------- Reset ---------- */
function resetBase(){
  $("preset").value = "base";
  applyPreset();
  $("currency").value = "¬£";
  $("months").value = 12;
  $("Smax").value = 6;
  $("Pmax").value = 3;
  $("M0").value = 0;
  $("churn").value = 3;
  $("cost").value = 200;
  $("capNotes").value = "";

  // audit defaults
  ["qConf","sConf","pConf","rConf","cConf"].forEach(id=>{ if($(id)) $(id).value="Med"; });
  ["qNote","sNote","pNote","rNote","cNote"].forEach(id=>{ if($(id)) $(id).value=""; });

  render();
}

/* ---------- Bulletproof wiring ---------- */
function attachListeners(){
  document.querySelectorAll("input, select, textarea").forEach(el=>{
    const handler = ()=>{
      if(el.id === "preset"){ applyPreset(); }
      render();
    };
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  $("toggleViewBtn").addEventListener("click", toggleView);
  $("printBtn").addEventListener("click", printOnePager);
  $("copySummaryBtn").addEventListener("click", copySummary);
  $("resetBtn").addEventListener("click", resetBase);
}

applyPreset();
attachListeners();
render();


(function(){
  const TAG = "[QDS sensfix v3]";
  function parseNum(x){
    if(x==null) return NaN;
    const s = String(x).replace(/,/g,'').replace(/[^\d.\-]/g,'').trim();
    return s ? Number(s) : NaN;
  }
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function moneySym(){
    // try: explicit currency input, else any symbol on page
    const sym = (document.body.innerText.match(/[¬£$‚Ç¨]/)||[])[0];
    return sym || "¬£";
  }
  function fmtMoneySigned(x, sym){
    if(!isFinite(x)) return "‚Äî";
    const sign = x >= 0 ? "+" : "‚àí";
    const v = Math.abs(x);
    return sign + (sym||"¬£") + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  // Find section containing some text
  function findSection(re){
    const all = Array.from(document.querySelectorAll("h1,h2,h3,h4,div,section,p,span,strong"));
    const el = all.find(n => re.test((n.textContent||"").trim()));
    return el ? (el.closest("section,article,div") || el.parentElement || document.body) : null;
  }

  // Try to find numeric inputs in the Inputs area by order (fallback-safe)
  function readInputs(){
    // 1) narrow to Inputs block if possible
    const inputsBlock = findSection(/^Inputs$/i) || findSection(/Revenue Floor|Capacity Truth/i) || document.body;

    // 2) collect inputs
    const ins = Array.from(inputsBlock.querySelectorAll("input,select,textarea"))
      .filter(el => el && (el.tagName==="SELECT" || (el.tagName==="INPUT" && (el.type==="number" || el.type==="text" || el.type==="range"))));

    // helper: pick numeric value from element
    const v = (i)=> (i>=0 && i<ins.length) ? parseNum(ins[i].value) : NaN;

    // Heuristic order (matches your page layout 99% of the time):
    // Demand: L,q,s,p,r
    // Pricing: sprint, pilot, retainer
    // Capacity: Smax, Pmax
    const L  = v(0);
    const q  = v(1);
    const s  = v(2);
    const p  = v(3);
    const r  = v(4);

    const sprintPrice   = v(5);
    const pilotPrice    = v(6);
    const retainerMonth = v(7);

    const Smax = v(8);
    const Pmax = v(9);

    return {
      L, q:clamp01(q), s:clamp01(s), p:clamp01(p), r:clamp01(r),
      sprintPrice, pilotPrice, retainerMonth,
      Smax, Pmax
    };
  }

  function model(inp){
    const qualified = inp.L * inp.q;
    const sprintsRaw = qualified * inp.s;
    const sprints = isFinite(inp.Smax) ? Math.min(sprintsRaw, inp.Smax) : sprintsRaw;

    const pilotsRaw = sprints * inp.p;
    const pilots = isFinite(inp.Pmax) ? Math.min(pilotsRaw, inp.Pmax) : pilotsRaw;

    const newRetainers = pilots * inp.r;

    const revMonth =
      sprints * inp.sprintPrice +
      pilots * inp.pilotPrice +
      newRetainers * inp.retainerMonth;

    const runRateYear = revMonth * 12;
    return {qualified, sprintsRaw, sprints, pilotsRaw, pilots, newRetainers, revMonth, runRateYear};
  }

  function findSensitivityRoot(){
    const root = findSection(/What Moves the Needle/i) || findSection(/Sensitivity/i);
    return root || document.body;
  }

  // Works for table rows OR grid/div rows
  function setRowValue(root, labelText, valueText){
    // try exact text match element
    const all = Array.from(root.querySelectorAll("*"))
      .filter(el => (el.children?.length||0) < 6) // avoid huge containers
      .filter(el => ((el.textContent||"").trim() === labelText));

    for(const labEl of all){
      // TABLE: if inside tr
      const tr = labEl.closest("tr");
      if(tr){
        const cells = tr.querySelectorAll("td,th");
        if(cells.length >= 2){
          cells[cells.length-1].textContent = valueText;
          return true;
        }
      }
      // DIV GRID: assume label + value are siblings
      const parent = labEl.parentElement;
      if(parent){
        const kids = Array.from(parent.children);
        const idx = kids.indexOf(labEl);
        if(idx !== -1 && idx+1 < kids.length){
          kids[idx+1].textContent = valueText;
          return true;
        }
      }
      // LAST RESORT: nextElementSibling
      if(labEl.nextElementSibling){
        labEl.nextElementSibling.textContent = valueText;
        return true;
      }
    }
    return false;
  }

  function renameHeader(root){
    const targets = Array.from(root.querySelectorAll("*"))
      .filter(el => /Effect on yearly run-rate/i.test((el.textContent||"").trim()));
    targets.forEach(el => {
      el.textContent = el.textContent.replace(/Effect on yearly run-rate/i, "Œî yearly run-rate");
    });
  }

  function fix(){
    const inp = readInputs();
    const sym = moneySym();

    // sanity: must have core numbers
    if(!isFinite(inp.L) || !isFinite(inp.sprintPrice) || !isFinite(inp.pilotPrice) || !isFinite(inp.retainerMonth)){
      // don't spam
      return;
    }

    const base = model(inp);
    const scenarios = [
      {label:"+1 lead / month",            mod: x => ({...x, L: x.L + 1})},
      {label:"+0.10 sprint close rate",    mod: x => ({...x, s: clamp01(x.s + 0.10)})},
      {label:"+1 sprint capacity",         mod: x => ({...x, Smax: isFinite(x.Smax) ? x.Smax + 1 : x.Smax})},
      {label:"+0.05 pilot-from-sprint",    mod: x => ({...x, p: clamp01(x.p + 0.05)})},
      {label:"+0.05 retainer-from-pilot",  mod: x => ({...x, r: clamp01(x.r + 0.05)})},
    ];

    const root = findSensitivityRoot();
    renameHeader(root);

    let ok = 0;
    for(const sc of scenarios){
      const m = model(sc.mod(inp));
      const delta = m.runRateYear - base.runRateYear;
      if(setRowValue(root, sc.label, fmtMoneySigned(delta, sym))) ok++;
    }

    // one-time debug ping
    if(!window.__QDS_SENS_V3_LOGGED){
      window.__QDS_SENS_V3_LOGGED = true;
      console.log(TAG, "running. Updated rows:", ok, "Base rev/mo:", base.revMonth.toFixed(2), "Base run-rate/yr:", base.runRateYear.toFixed(2));
    }
  }

  fix();
  document.addEventListener("input", fix, true);
  document.addEventListener("change", fix, true);
})();


// --- qds_avian_magnetoreception_lab_v5_fairplus.html ---

/* ---------- tiny utils ---------- */
const $ = id => document.getElementById(id);
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const lerp = (a,b,t)=>a+(b-a)*t;
const fmt = (x,n=2)=>Number(x).toFixed(n);
const nowStamp = ()=>new Date().toISOString().replace('T',' ').replace('Z',' UTC');
function dl(name, text, mime="application/json"){
  const blob = new Blob([text], {type:mime});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 500);
}

/* ---------- species presets (toy-level) ---------- */
const SPECIES = [
  {id:"robin", name:"European Robin", base:{tau:260, lam:1.55, sig:0.32, em:0.22, wl:500, lint:0.70, rf:0.10, cal:0.82, map:0.70, mot:0.78, sts:0.18, exp:0.55, B:50, inc:60, anom:0.10}},
  {id:"pigeon", name:"Racing Pigeon", base:{tau:220, lam:1.45, sig:0.36, em:0.28, wl:510, lint:0.75, rf:0.12, cal:0.78, map:0.88, mot:0.72, sts:0.22, exp:0.70, B:50, inc:60, anom:0.10}},
  {id:"albatross", name:"Wandering Albatross", base:{tau:300, lam:1.65, sig:0.30, em:0.18, wl:520, lint:0.80, rf:0.08, cal:0.86, map:0.92, mot:0.80, sts:0.12, exp:0.75, B:45, inc:55, anom:0.08}},
  {id:"blackcap", name:"Blackcap Warbler", base:{tau:240, lam:1.50, sig:0.34, em:0.24, wl:490, lint:0.70, rf:0.11, cal:0.80, map:0.68, mot:0.82, sts:0.20, exp:0.50, B:50, inc:60, anom:0.10}},
  {id:"tern", name:"Arctic Tern", base:{tau:320, lam:1.70, sig:0.28, em:0.20, wl:520, lint:0.85, rf:0.09, cal:0.88, map:0.90, mot:0.86, sts:0.14, exp:0.65, B:48, inc:58, anom:0.08}},
];

/* ---------- environment presets (apply deltas) ---------- */
function applyPreset(name){
  // start from current sliders, then nudge.
  let em = +$("em").value, rf=+$("rf").value, an=+$("anom").value, lint=+$("lint").value;
  if(name==="quiet"){ em=0.15; rf=0.06; an=0.05; lint=Math.max(lint,0.60); }
  if(name==="urban"){ em=0.55; rf=0.18; an=0.12; lint=Math.max(lint,0.55); }
  if(name==="storm"){ em=0.40; rf=0.15; an=0.65; lint=Math.max(lint,0.40); }
  if(name==="flare"){ em=0.48; rf=0.22; an=0.80; lint=Math.max(lint,0.35); }
  if(name==="lab"){ em=0.02; rf=0.00; an=0.00; lint=Math.max(lint,0.75); }
  if(name==="rfjam"){ em=Math.max(em,0.22); rf=0.85; an=Math.max(an,0.10); lint=Math.max(lint,0.55); }
  $("em").value=em; $("rf").value=rf; $("anom").value=an; $("lint").value=lint;
}

/* ---------- core model (toy, but confound-aware) ---------- */
function lightMultiplier(wl, lint){
  // ‚Äúwindow‚Äù around blue-green (toy): peak ~505nm, width ~55nm
  const mu=505, s=55;
  const g = Math.exp(-0.5*Math.pow((wl-mu)/s,2));
  const inten = 1 - Math.exp(-3.0*lint); // saturating intensity
  return clamp(g*inten, 0, 1);
}
function rfMultiplier(rf){
  // rf is 0..1 disruption strength; convert to survival factor
  return clamp(Math.exp(-3.2*rf), 0, 1);
}
function calMultiplier(cal){
  // calibration state 0..1
  return clamp(0.15 + 0.85*cal, 0, 1);
}
function mapMultiplier(map){
  // map channel helps overall nav; if low, nav suffers even if compass is fine
  return clamp(0.20 + 0.80*map, 0, 1);
}
function behaviourMultiplier(mot, sts, exp){
  // motivation helps, stress hurts, experience helps
  const drive = 0.35 + 0.65*mot;
  const stress = Math.exp(-2.4*sts);
  const learn = 0.55 + 0.45*exp;
  return clamp(drive*stress*learn, 0, 1);
}
function geomFactor(B, inc, anom){
  // toy Gaussian preference around typical mid-latitude field & inclination + disturbance penalty
  const Bref=50, sB=12;
  const incRef=60, sI=18;
  const gB = Math.exp(-0.5*Math.pow((B-Bref)/sB,2));
  const gI = Math.exp(-0.5*Math.pow((inc-incRef)/sI,2));
  const dist = Math.exp(-1.8*anom);
  return clamp(gB*gI*dist, 0, 1);
}
function compute(){
  const p = {
    species: $("species").value,
    preset: $("preset").value,
    tau: +$("tau").value,      // ¬µs
    lam: +$("lam").value,      // nm
    sig: +$("sig").value,      // variance
    em:  +$("em").value,       // 0..1
    wl:  +$("wl").value,       // nm
    lint:+$("lint").value,     // 0..1
    rf:  +$("rf").value,       // 0..1
    cal: +$("cal").value,      // 0..1
    map: +$("map").value,      // 0..1
    mot: +$("mot").value,      // 0..1
    sts: +$("sts").value,      // 0..1
    exp: +$("exp").value,      // 0..1
    B:   +$("B").value,        // ¬µT
    inc: +$("inc").value,      // deg
    anom:+$("anom").value      // 0..1
  };

  // K_raw: coherence & spatial coherence help; œÉ¬≤ & EM noise hurt; geom helps; anomaly hurts
  const tauRef=250, lamRef=1.6;
  const coh = Math.pow(p.tau/tauRef, 0.62) * Math.pow(p.lam/lamRef, 0.38);
  const noise = Math.exp(-1.55*p.em) / (0.18 + p.sig);
  const g = geomFactor(p.B, p.inc, p.anom);
  let K_raw = 1.25 * coh * noise * (0.35 + 0.65*g);
  K_raw = clamp(K_raw, 0, 6);

  // Map to 0..1 ‚Äúcompass confidence‚Äù
  const compass = clamp(1 - Math.exp(-K_raw), 0, 1);

  // Fairness multipliers
  const L = lightMultiplier(p.wl, p.lint);
  const R = rfMultiplier(p.rf);
  const C = calMultiplier(p.cal);
  const M = mapMultiplier(p.map);
  const Bf = behaviourMultiplier(p.mot, p.sts, p.exp);

  const nav = clamp(compass * L * R * C * M * Bf, 0, 1);

  // false negative risk: K high but nav low => confounds likely
  const fnr = clamp((K_raw/2.2) * (1 - nav) * (nav < 0.45 ? 1.1 : 0.7), 0, 1);

  // Limiter ranking
  const factors = [
    {k:"Light", v:L, hint:"Try blue/green (~480‚Äì540nm) and adequate intensity."},
    {k:"RF", v:R, hint:"MHz-band disruption can kill orientation even if K_raw is fine."},
    {k:"Calibration", v:C, hint:"Low calibration makes behaviour look like ‚Äúno compass‚Äù."},
    {k:"Map channel", v:M, hint:"If map is weak, navigation suffers despite good compass."},
    {k:"Behaviour", v:Bf, hint:"Low drive / high stress / low experience can mask sensing."},
    {k:"Geom/stability", v:(0.35+0.65*g), hint:"Disturbance/anomaly can dominate field cues."},
  ].sort((a,b)=>a.v-b.v);

  return {p, K_raw, compass, nav, fnr, L,R,C,M,Bf,g, limiters:factors};
}

/* ---------- UI render ---------- */
function dotFor(x){
  if(x>=0.75) return ["good","Stable Navigation ‚Äî corridor likely coherent."];
  if(x>=0.45) return ["warn","Mixed Navigation ‚Äî borderline / context-sensitive."];
  return ["bad","Unstable Navigation ‚Äî confounds dominate or signal weak."];
}
function pct(x){ return Math.round(100*x)+"%"; }

function render(res){
  const {p, K_raw, compass, nav, fnr, limiters} = res;
  $("stamp").textContent = nowStamp();

  $("v_tau").textContent = fmt(p.tau,0)+" ¬µs";
  $("v_lam").textContent = fmt(p.lam,2)+" nm";
  $("v_sig").textContent = fmt(p.sig,2);
  $("v_em").textContent  = fmt(p.em,2);

  $("v_wl").textContent  = fmt(p.wl,0)+" nm";
  $("v_int").textContent = fmt(p.lint,2);
  $("v_rf").textContent  = fmt(p.rf,2);
  $("v_cal").textContent = fmt(p.cal,2);
  $("v_map").textContent = fmt(p.map,2);
  $("v_mot").textContent = fmt(p.mot,2);
  $("v_sts").textContent = fmt(p.sts,2);
  $("v_exp").textContent = fmt(p.exp,2);
  $("v_B").textContent   = fmt(p.B,0)+" ¬µT";
  $("v_inc").textContent = fmt(p.inc,0)+"¬∞";
  $("v_anom").textContent= fmt(p.anom,2);

  $("kraw").textContent = fmt(K_raw,3);
  $("conf").textContent = pct(compass);
  $("nav").textContent  = pct(nav);
  $("fnr").textContent  = pct(fnr);

  $("bar_conf").style.width = (100*compass).toFixed(1)+"%";
  $("bar_nav").style.width  = (100*nav).toFixed(1)+"%";

  const [cls, msg] = dotFor(nav);
  $("dot").className = "dot "+cls;
  $("status").textContent = msg;

  // limiters: show bottom 3 (worst)
  const worst = limiters.slice(0,3);
  $("limiters").innerHTML = worst.map(w=>`<li><b>${w.k}</b> = ${pct(w.v)} ‚Äî ${w.hint}</li>`).join("");

  const trail = {
    stamp: nowStamp(),
    species: p.species,
    preset: p.preset,
    inputs: p,
    outputs: {
      K_raw: +fmt(K_raw,6),
      compass_confidence: +fmt(compass,6),
      navigation_reliability: +fmt(nav,6),
      false_negative_risk: +fmt(fnr,6)
    }
  };
  $("trail").textContent = JSON.stringify(trail, null, 2);
  window.__QDS_LAST = trail;
}

/* ---------- Monte Carlo ---------- */
function mcRun(N=200){
  const base = compute();
  const sims = [];
  for(let i=0;i<N;i++){
    // jitter nuisance channels more than kernel itself
    const j = (x, s)=>clamp(x + (Math.random()*2-1)*s, 0, 1);
    const pj = JSON.parse(JSON.stringify(base.p));
    pj.em   = j(pj.em, 0.10);
    pj.rf   = j(pj.rf, 0.12);
    pj.cal  = j(pj.cal,0.12);
    pj.anom = j(pj.anom,0.18);
    pj.lint = j(pj.lint,0.10);
    // slight jitter on kernel too (smaller)
    pj.sig  = clamp(pj.sig + (Math.random()*2-1)*0.05, 0.05, 1.2);
    pj.tau  = clamp(pj.tau + (Math.random()*2-1)*25, 5, 6000);

    // temporarily set sliders? no ‚Äî compute inline by mapping to DOM-free compute
    const tmp = domlessCompute(pj);
    sims.push(tmp.nav);
  }
  sims.sort((a,b)=>a-b);
  const mean = sims.reduce((a,b)=>a+b,0)/sims.length;
  const p10 = sims[Math.floor(0.10*(sims.length-1))];
  const p50 = sims[Math.floor(0.50*(sims.length-1))];
  const p90 = sims[Math.floor(0.90*(sims.length-1))];

  drawHist(sims);
  $("mcstats").textContent =
    `MC(${N})  mean=${pct(mean)}  p10=${pct(p10)}  median=${pct(p50)}  p90=${pct(p90)}  (spread=${pct(p90-p10)})`;
}

function domlessCompute(p){
  const tauRef=250, lamRef=1.6;
  const coh = Math.pow(p.tau/tauRef, 0.62) * Math.pow(p.lam/lamRef, 0.38);
  const noise = Math.exp(-1.55*p.em) / (0.18 + p.sig);
  const g = geomFactor(p.B, p.inc, p.anom);
  let K_raw = 1.25 * coh * noise * (0.35 + 0.65*g);
  K_raw = clamp(K_raw, 0, 6);
  const compass = clamp(1 - Math.exp(-K_raw), 0, 1);
  const L = lightMultiplier(p.wl, p.lint);
  const R = rfMultiplier(p.rf);
  const C = calMultiplier(p.cal);
  const M = mapMultiplier(p.map);
  const Bf= behaviourMultiplier(p.mot, p.sts, p.exp);
  const nav = clamp(compass * L * R * C * M * Bf, 0, 1);
  return {K_raw, compass, nav};
}

function drawHist(vals){
  const c = $("plot");
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);

  // axes
  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(160,190,255,.35)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(40, 20); ctx.lineTo(40, c.height-30); ctx.lineTo(c.width-20, c.height-30);
  ctx.stroke();

  // bins
  const bins = 24;
  const hist = Array.from({length:bins}, ()=>0);
  for(const v of vals){
    const b = clamp(Math.floor(v*bins), 0, bins-1);
    hist[b]++;
  }
  const maxH = Math.max(...hist, 1);

  const W = c.width-60, H = c.height-60;
  const x0 = 40, y0 = c.height-30;
  const bw = W/bins;

  for(let i=0;i<bins;i++){
    const h = hist[i]/maxH;
    const x = x0 + i*bw + 1;
    const y = y0 - h*H;
    const w = bw - 2;
    const hh = h*H;
    ctx.fillStyle = "rgba(124,247,255,.35)";
    ctx.fillRect(x, y, w, hh);
    ctx.strokeStyle = "rgba(119,255,154,.25)";
    ctx.strokeRect(x, y, w, hh);
  }

  // labels
  ctx.fillStyle = "rgba(232,236,255,.75)";
  ctx.font = "12px ui-monospace, Menlo, Consolas, monospace";
  ctx.fillText("0%", 38, c.height-10);
  ctx.fillText("100%", c.width-52, c.height-10);
  ctx.fillText("MC nav reliability histogram", 40, 14);
}

/* ---------- wiring ---------- */
function fillSpecies(){
  $("species").innerHTML = SPECIES.map(s=>`<option value="${s.id}">${s.name}</option>`).join("");
  $("species").value = "robin";
}
function applySpecies(id){
  const s = SPECIES.find(x=>x.id===id) || SPECIES[0];
  const b = s.base;
  $("tau").value=b.tau; $("lam").value=b.lam; $("sig").value=b.sig; $("em").value=b.em;
  $("wl").value=b.wl; $("lint").value=b.lint; $("rf").value=b.rf; $("cal").value=b.cal; $("map").value=b.map;
  $("mot").value=b.mot; $("sts").value=b.sts; $("exp").value=b.exp;
  $("B").value=b.B; $("inc").value=b.inc; $("anom").value=b.anom;
}
function recompute(){
  const res = compute();
  render(res);
}
function copySummary(){
  const t = window.__QDS_LAST || {};
  const out = [
    "QDS Avian Magnetoreception Lab v5 FAIR+",
    `stamp: ${t.stamp||"‚Äî"}`,
    `species: ${t.species||"‚Äî"}  preset: ${t.preset||"‚Äî"}`,
    `K_raw: ${t.outputs?.K_raw ?? "‚Äî"}`,
    `compass_confidence: ${(t.outputs?.compass_confidence ?? 0)*100 | 0}%`,
    `navigation_reliability: ${(t.outputs?.navigation_reliability ?? 0)*100 | 0}%`,
    `false_negative_risk: ${(t.outputs?.false_negative_risk ?? 0)*100 | 0}%`
  ].join("\n");
  navigator.clipboard?.writeText(out);
  alert("Copied summary to clipboard.");
}
function exportJSON(){
  const t = window.__QDS_LAST || {};
  const name = "qds_avian_lab_v5_fairplus_"+new Date().toISOString().slice(0,10)+".json";
  dl(name, JSON.stringify(t, null, 2), "application/json");
}
function snapshotPNG(){
  // draw a small ‚Äúreceipt‚Äù to a canvas, export PNG
  const t = window.__QDS_LAST || {};
  const c = document.createElement("canvas");
  c.width = 1200; c.height = 700;
  const ctx = c.getContext("2d");

  ctx.fillStyle = "#06070b"; ctx.fillRect(0,0,c.width,c.height);
  ctx.fillStyle = "rgba(124,247,255,.15)";
  ctx.fillRect(40,40,1120,620);

  ctx.fillStyle="#e8ecff";
  ctx.font="34px ui-monospace, Menlo, Consolas, monospace";
  ctx.fillText("QDS Avian Magnetoreception Lab v5 FAIR+ Snapshot", 60, 100);

  ctx.font="24px ui-monospace, Menlo, Consolas, monospace";
  const lines = [
    `stamp: ${t.stamp||"‚Äî"}`,
    `species: ${t.species||"‚Äî"}  preset: ${t.preset||"‚Äî"}`,
    `K_raw: ${t.outputs?.K_raw ?? "‚Äî"}`,
    `compass_confidence: ${Math.round((t.outputs?.compass_confidence ?? 0)*100)}%`,
    `navigation_reliability: ${Math.round((t.outputs?.navigation_reliability ?? 0)*100)}%`,
    `false_negative_risk: ${Math.round((t.outputs?.false_negative_risk ?? 0)*100)}%`,
    "",
    "inputs:",
    JSON.stringify(t.inputs||{}, null, 2)
  ];

  let y=150;
  ctx.fillStyle="rgba(232,236,255,.9)";
  ctx.font="20px ui-monospace, Menlo, Consolas, monospace";
  for(const L of lines){
    const chunks = (""+L).split("\n");
    for(const ch of chunks){
      if(y>640) break;
      ctx.fillText(ch.slice(0,120), 60, y);
      y += 26;
    }
    if(y>640) break;
  }

  const url = c.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = url;
  a.download = "qds_avian_lab_v5_snapshot_"+new Date().toISOString().slice(0,10)+".png";
  document.body.appendChild(a);
  a.click();
  a.remove();
}

function bind(){
  const ids = ["tau","lam","sig","em","wl","lint","rf","cal","map","mot","sts","exp","B","inc","anom"];
  ids.forEach(id=>$(id).addEventListener("input", recompute));
  $("species").addEventListener("change", e=>{ applySpecies(e.target.value); recompute(); });
  $("preset").addEventListener("change", e=>{ applyPreset(e.target.value); recompute(); });
  $("run").addEventListener("click", recompute);
  $("mc").addEventListener("click", ()=>mcRun(200));
  $("expjson").addEventListener("click", exportJSON);
  $("copy").addEventListener("click", copySummary);
  $("snap").addEventListener("click", snapshotPNG);
}

/* ---------- boot ---------- */
fillSpecies();
applySpecies($("species").value);
applyPreset($("preset").value);
bind();
recompute();


// --- qds_avian_lab_v3_pro.html ---

/* ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
   JAVASCRIPT ENGINE v3 PRO+
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî */

let fiveG = false;

/* SPECIES PARAM SETS */
const species = {
  robin:       { tau: [0.8,1.4],  lambda:[0.3,0.8],  sens:1.0, jitter:0.9 },
  pigeon:      { tau: [1.0,2.0],  lambda:[0.4,1.2],  sens:0.6, jitter:0.5 },
  albatross:   { tau: [2.5,5.0],  lambda:[0.7,2.0],  sens:0.3, jitter:0.2 },
  hummingbird: { tau: [0.4,0.9],  lambda:[0.2,0.6],  sens:1.5, jitter:1.4 },
  crow:        { tau: [1.8,3.2],  lambda:[0.6,1.4],  sens:0.5, jitter:0.6 }
};

/* UI ELEMENTS */
const tc    = document.getElementById("tc");
const lc    = document.getElementById("lc");
const noise = document.getElementById("noise");
const tcVal = document.getElementById("tcVal");
const lcVal = document.getElementById("lcVal");
const noiseVal = document.getElementById("noiseVal");
const needle = document.getElementById("needle");
const statusBox = document.getElementById("status");
const sphere = document.getElementById("activationSphere");
const speciesSelect = document.getElementById("speciesSelect");

/* UPDATE LABELS */
function updateLabels() {
  tcVal.textContent = tc.value + " ms";
  lcVal.textContent = lc.value + " nm";
  noiseVal.textContent = Number(noise.value).toFixed(2);
}

/* KERNEL COMPUTATION */
function computeK() {
  const T = parseFloat(tc.value);
  const L = parseFloat(lc.value);
  let N = parseFloat(noise.value);

  if (fiveG) N += 0.2;

  const K = (T * L) / (1 + 6*N*N);
  return K;
}

/* COMPASS UPDATE */
let angle = 0;
function updateCompass(K, sp) {
  const sens = species[sp].sens;
  const jitter = species[sp].jitter;

  let baseAngle;
  if (K > 8) baseAngle = 0;
  else if (K > 4) baseAngle = 20;
  else if (K > 2) baseAngle = 70;
  else baseAngle = 150;

  const jitterAmp = jitter * (1/(K+0.3));
  const randomKick = (Math.random()-0.5)*jitterAmp*10;

  angle = angle*0.7 + (baseAngle+randomKick)*0.3;
  needle.style.transform = "rotate("+angle+"deg)";
}

/* STATUS */
function updateStatus(K) {
  if (K > 8) {
    statusBox.textContent="Stable Navigation ‚Äî Ideal Conditions";
    statusBox.className="status ok";
  } else if (K > 4) {
    statusBox.textContent="Functional Navigation ‚Äî Mild Noise";
    statusBox.className="status warn";
  } else if (K > 2) {
    statusBox.textContent="Compromised ‚Äî Navigation Drift Likely";
    statusBox.className="status warn";
  } else {
    statusBox.textContent="Compass Collapse ‚Äî Disorientation";
    statusBox.className="status bad";
  }
}

/* CRYPTOCHROME SPHERE */
function updateSphere(K) {
  const glow = Math.min(1, K/8);
  sphere.style.boxShadow = 
    "0 0 "+(20+glow*40)+"px "+(4+glow*10)+"px rgba(56,189,248,"+(0.2+0.5*glow)+")";
}

/* PRESETS */
function preset(type) {
  if (type=="forest")     { tc.value=1.6; lc.value=1.0; noise.value=0.12; }
  if (type=="urban")      { tc.value=1.2; lc.value=0.8; noise.value=0.42; }
  if (type=="storm")      { tc.value=0.9; lc.value=0.5; noise.value=0.7; }
  if (type=="flare")      { tc.value=0.6; lc.value=0.3; noise.value=0.88; }
  if (type=="lab")        { tc.value=3.5; lc.value=1.6; noise.value=0.03; }
  updateLabels();
}

/* 5G Toggle */
function toggle5G() {
  fiveG = !fiveG;
}

/* Species Change */
speciesSelect.addEventListener("change", () => {
  let sp = speciesSelect.value;
  const s = species[sp];
  tc.min = s.tau[0];
  tc.max = s.tau[1];
  lc.min = s.lambda[0];
  lc.max = s.lambda[1];
});

/* EXPORT SNAPSHOT */
function snapshot() {
  const data = {
    tc: tc.value,
    lc: lc.value,
    noise: noise.value,
    fiveG,
    species: speciesSelect.value,
    K: computeK(),
    timestamp: new Date().toISOString()
  };
  const blob = new Blob([JSON.stringify(data,null,2)],{type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url;
  a.download="qds_avian_lab_v3_snapshot.json";
  a.click();
  URL.revokeObjectURL(url);
}

/* MAIN LOOP */
function loop() {
  updateLabels();
  const K = computeK();
  updateCompass(K, speciesSelect.value);
  updateStatus(K);
  updateSphere(K);
  requestAnimationFrame(loop);
}
loop();


// --- all_pages_index_backup_20251211_234406.html ---

    // --- data: add/extend this list as needed --------------------
    const PAGES = [
      // core hubs (examples ‚Äì keep / extend with your full list)
      { title: "index", href: "index.html", path: "index.html" },
      { title: "all pages (mini)", href: "all_pages_min.html", path: "all_pages_min.html" },
      { title: "QDS Battery Lab", href: "qds_battery_lab.html", path: "qds_battery_lab.html" },
      { title: "QDS Universe v12b mobile", href: "qds_universe_v12b_mobile.html", path: "qds_universe_v12b_mobile.html" },
      { title: "Solar system v9 mobile 3D showcase", href: "solar_system_v9_2_mobile_3d_showcase.html", path: "solar_system_v9_2_mobile_3d_showcase.html" },
      { title: "Stinchcombe map", href: "stinchcombe_map.html", path: "stinchcombe_map.html" },

      // NEW: H-Code demo
      { title: "H-Code Warning Nodes ¬∑ PC / Battery / Beacon mesh",
        href: "h_code_warning_nodes_demo.html",
        path: "h_code_warning_nodes_demo.html"
      },

      // ------------------------------------------------------------
      // ‚¨ÜÔ∏è You can paste your big auto-generated list here from a
      // backup all_pages_index*.html ‚Äì just keep it inside the
      // PAGES array and before this closing bracket.
      // ------------------------------------------------------------
    ];
    // ------------------------------------------------------------

    const categorize = (name) => {
      const n = name.toLowerCase();
      if (n.includes("battery")) return "Battery";
      if (n.includes("universe")) return "Universe";
      if (n.includes("solar")) return "Solar";
      if (n.includes("omega")) return "Œ© / OS";
      if (n.includes("index")) return "Indexes";
      if (n.includes("pillar") || n.includes("wedge")) return "Pillars / Wedges";
      if (n.includes("cannon") || n.includes("catapult") || n.includes("pyramid")) return "Play / Demos";
      if (n.includes("indus")) return "Language / Indus";
      if (n.includes("stinchcombe") || n.includes("her")) return "Maps / Local";
      if (n.includes("growthhub") || n.includes("offer")) return "GrowthHub / Business";
      if (n.includes("test")) return "Tests / Repro";
      if (n.includes("h-code") || n.includes("warning")) return "H-Code / Diagnostics";
      return "Misc";
    };

    // enrich with category + sorted copy
    const ENRICHED = PAGES.map(p => ({
      ...p,
      category: p.category || categorize(p.title || p.path || "")
    })).sort((a, b) =>
      (a.title || "").toLowerCase().localeCompare((b.title || "").toLowerCase())
    );

    const elList  = document.getElementById("list");
    const elQ     = document.getElementById("q");
    const elGroup = document.getElementById("group");
    const elReset = document.getElementById("reset");
    const elStats = document.getElementById("stats");

    const highlight = (text, q) => {
      if (!q) return text;
      const re = new RegExp("(" + q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + ")", "ig");
      return text.replace(re, "<span class=\"highlight\">$1</span>");
    };

    const renderFlat = (items, q) => {
      elList.innerHTML = "";
      for (const p of items) {
        const a = document.createElement("a");
        a.className = "card";
        a.href = p.href;
        const safeTitle = highlight(p.title, q);
        const safePath  = highlight(p.path, q);
        a.innerHTML = `
          <div class="name">${safeTitle}</div>
          <div class="path">${safePath}</div>
          <span class="tag">${p.category}</span>
        `;
        elList.appendChild(a);
      }
    };

    const renderGrouped = (items, q) => {
      elList.innerHTML = "";
      const groups = {};
      for (const p of items) {
        (groups[p.category] ||= []).push(p);
      }
      const cats = Object.keys(groups).sort();
      for (const c of cats) {
        const header = document.createElement("div");
        header.className = "group-header";
        header.textContent = c;
        elList.appendChild(header);

        for (const p of groups[c]) {
          const a = document.createElement("a");
          a.className = "card";
          a.href = p.href;
          const safeTitle = highlight(p.title, q);
          const safePath  = highlight(p.path, q);
          a.innerHTML = `
            <div class="name">${safeTitle}</div>
            <div class="path">${safePath}</div>
            <span class="tag">${p.category}</span>
          `;
          elList.appendChild(a);
        }
      }
    };

    const apply = () => {
      const q = (elQ.value || "").toLowerCase().trim();
      const mode = elGroup.value;
      let items = ENRICHED.filter(p =>
        !q ||
        (p.title || "").toLowerCase().includes(q) ||
        (p.path || "").toLowerCase().includes(q) ||
        (p.category || "").toLowerCase().includes(q)
      );

      // stats
      elStats.textContent = `${items.length} of ${ENRICHED.length} pages`;

      if (mode === "category") renderGrouped(items, q);
      else renderFlat(items, q);

      // persist
      try {
        localStorage.setItem("all_pages_index_q", elQ.value);
        localStorage.setItem("all_pages_index_group", mode);
      } catch (e) {}
    };

    // events
    elQ.addEventListener("input", apply);
    elGroup.addEventListener("change", apply);
    elReset.addEventListener("click", () => {
      elQ.value = "";
      elGroup.value = "none";
      apply();
    });

    // shortcut: "/" focuses search
    window.addEventListener("keydown", (e) => {
      if (e.key === "/" && document.activeElement !== elQ) {
        e.preventDefault();
        elQ.focus();
        elQ.select();
      }
    });

    // restore last filter if present
    try {
      const savedQ = localStorage.getItem("all_pages_index_q");
      const savedG = localStorage.getItem("all_pages_index_group");
      if (savedQ !== null) elQ.value = savedQ;
      if (savedG === "category" || savedG === "none") elGroup.value = savedG;
    } catch (e) {}

    // init
    apply();
  

// --- physorg_supervault.html ---

(() => {
  const $ = (id)=>document.getElementById(id);

  const TRIAGE_KEY = "qds_news_triage_v1";
  const NOTES_KEY  = "qds_news_notes_v1";

  const state = {
    items: [],
    triage: loadJson(TRIAGE_KEY, {}),
    notes: loadJson(NOTES_KEY, {}),
    source: "latest",
    probeDates: [],
    probeDate: "",
    snapMeta: { created_at:"", item_count:0, master_path:"", source:"" }
  };

  function loadJson(k, fallback){
    try { return JSON.parse(localStorage.getItem(k) || "") || fallback; }
    catch { return fallback; }
  }
  function setStatus(kind, msg){
    $("status").textContent = msg;
    $("dot").className = "dot " + (kind==="ok"?"ok":kind==="bad"?"bad":"warn");
  }

  function normalizeItem(x){
    const it = {...x};
    it.title = it.title || it.TITLE || "Untitled";
    it.link  = it.link  || it.LINK  || it.url || "";
    it.pubDate = it.pubDate || it.date || it.published || it.pub || "";
    it.category = it.category || it.cat || it.section || it.feed || "";
    it.summary  = it.summary  || it.description || it.desc || it.contentSnippet || "";
    it.source   = it.source   || it.site || "phys.org";
    return it;
  }

  function itemKey(it){
    return (it.guid || it.link || (it.title+"|"+(it.pubDate||""))).slice(0,512);
  }

  function bucketOf(it){
    return state.triage[itemKey(it)] || "none";
  }

  function bucketLabel(b){
    if(b==="broken") return "QDS broken by data?";
    if(b==="vs") return "QDS vs MAINSTREAM";
    if(b==="comp") return "QDS complements MAINSTREAM";
    return "untriaged";
  }

  function bucketClass(b){
    if(b==="broken") return "b-broken";
    if(b==="vs") return "b-vs";
    if(b==="comp") return "b-comp";
    return "b-none";
  }

  function priorityScore(b){
    if(b==="broken") return 0;
    if(b==="vs") return 1;
    if(b==="comp") return 2;
    return 3;
  }

  function timeVal(pubDate){
    const t = Date.parse(pubDate);
    return isNaN(t) ? 0 : t;
  }

  async function loadLatestSnapshot(){
    const url = "physorg_latest_snapshot.json";
    $("snapPath").textContent = url;
    const r = await fetch(url, {cache:"no-store"});
    if(!r.ok) throw new Error("No latest snapshot found (run ~/qdsnews.sh first)");
    const j = await r.json();
    state.snapMeta = {
      source: j.source || "snapshot",
      created_at: j.created_at || "",
      item_count: j.item_count || (j.items?j.items.length:0),
      master_path: j.master_path || ""
    };
    const items = (j.items || []).map(normalizeItem);
    state.items = items;
  }

  async function listProbeDates(){
    const days = 21;
    const out = [];
    const today = new Date();
    for(let i=0;i<days;i++){
      const d = new Date(today.getTime() - i*86400e3);
      const yyyy=d.getFullYear();
      const mm=String(d.getMonth()+1).padStart(2,"0");
      const dd=String(d.getDate()).padStart(2,"0");
      const s=`${yyyy}-${mm}-${dd}`;
      const url=`news_rips/physorg/${s}/MASTER.json`;
      try{
        const r = await fetch(url, {cache:"no-store"});
        if(r.ok) out.push(s);
      }catch(e){}
    }
    return out;
  }

  async function loadProbeDate(dateStr){
    const url = `news_rips/physorg/${dateStr}/MASTER.json`;
    $("snapPath").textContent = url;
    const r = await fetch(url, {cache:"no-store"});
    if(!r.ok) throw new Error("Probe MASTER.json fetch failed");
    const j = await r.json();
    const items = (Array.isArray(j) ? j : (j.items || j.ITEMS || j.master || [])).map(normalizeItem);
    state.snapMeta = { source:"probe", created_at:dateStr, item_count:items.length, master_path:url };
    state.items = items;
  }

  function computeStats(){
    const c = {broken:0,vs:0,comp:0,none:0};
    let triaged = 0;
    for(const it of state.items){
      const b = bucketOf(it);
      if(b!=="none") triaged++;
      c[b] = (c[b]||0)+1;
    }
    $("nItems").textContent = state.items.length;
    $("nTriaged").textContent = triaged;
    $("nBroken").textContent = c.broken||0;
    $("nVs").textContent = c.vs||0;
    $("nComp").textContent = c.comp||0;
    $("nNone").textContent = c.none||0;
  }

  function filteredItems(){
    const view = $("viewSel").value;
    const bucket = $("bucketSel").value;
    const q = $("q").value.trim().toLowerCase();
    const sort = $("sortSel").value;

    $("qChip").textContent = q ? q : "‚Äî";

    let items = state.items.slice();

    items = items.filter(it=>{
      const b = bucketOf(it);
      if(view==="triaged" && b==="none") return false;
      if(view==="untriaged" && b!=="none") return false;
      if(bucket==="any") return true;
      if(bucket==="none") return b==="none";
      return b===bucket;
    });

    if(q){
      items = items.filter(it=>{
        const k=itemKey(it);
        const note=(state.notes[k]||"");
        const hay = `${it.title} ${it.category} ${it.summary} ${note}`.toLowerCase();
        return hay.includes(q);
      });
    }

    items.sort((a,b)=>{
      const ba=bucketOf(a), bb=bucketOf(b);
      if(sort==="priority"){
        const pa=priorityScore(ba), pb=priorityScore(bb);
        if(pa!==pb) return pa-pb;
        return timeVal(b.pubDate)-timeVal(a.pubDate);
      }
      if(sort==="newest") return timeVal(b.pubDate)-timeVal(a.pubDate);
      if(sort==="title") return (a.title||"").localeCompare(b.title||"");
      if(sort==="bucket") return (ba+(a.title||"")).localeCompare(bb+(b.title||""));
      return 0;
    });

    return items;
  }

  function renderList(){
    const list = $("list");
    list.innerHTML = "";
    const items = filteredItems().slice(0, 120); // display cap for speed

    for(const it of items){
      list.appendChild(renderCard(it));
    }
  }

  function renderCard(it){
    const k=itemKey(it);
    const b=bucketOf(it);
    const note = state.notes[k] || "";

    const card = document.createElement("div");
    card.className="card";

    const top=document.createElement("div");
    top.className="top";

    const left=document.createElement("div");
    left.style.flex="1";

    const h=document.createElement("h3");
    h.className="title";
    h.textContent=it.title||"Untitled";

    const meta=document.createElement("div");
    meta.className="meta";
    meta.innerHTML = `
      <span class="tag">${escapeHtml(it.pubDate||"‚Äî")}</span>
      <span class="tag">${escapeHtml(it.category||"‚Äî")}</span>
      <span class="tag">${escapeHtml(it.source||"phys.org")}</span>
      ${note ? `<span class="tag">note</span>` : ``}
    `;

    left.append(h, meta);

    const right=document.createElement("div");
    const buck=document.createElement("span");
    buck.className=`bucket ${bucketClass(b)}`;
    buck.textContent=bucketLabel(b);
    right.appendChild(buck);

    top.append(left,right);

    const desc=document.createElement("div");
    desc.className="desc";
    desc.textContent=(it.summary||"").trim() || "‚Äî";

    const actions=document.createElement("div");
    actions.className="actions";

    const open=document.createElement("button");
    open.className="aBtn";
    open.textContent="Open";
    open.onclick=()=>{ if(it.link) window.open(it.link,"_blank"); };

    const copyLine=document.createElement("button");
    copyLine.className="aBtn";
    copyLine.textContent="Copy 1-line";
    copyLine.onclick=()=>{
      const line = formatOneLine(it);
      navigator.clipboard.writeText(line);
    };

    actions.append(open, copyLine);

    card.append(top, desc, actions);
    return card;
  }

  function formatOneLine(it){
    const b = bucketOf(it);
    const tag = (b==="broken")?"[BROKEN?]":(b==="vs")?"[VS]":(b==="comp")?"[COMP]":"[NEUTRAL]";
    const title = (it.title||"").replace(/\s+/g," ").trim();
    const link  = it.link || "";
    const summ  = (it.summary||"").replace(/\s+/g," ").trim();
    const short = summ.length>140 ? (summ.slice(0,137)+"‚Ä¶") : summ;
    return `${tag} ${title} ‚Äî ${short} ${link}`.trim();
  }

  function buildBrief(){
    const maxLines = parseInt($("lineSel").value,10) || 40;
    const items = filteredItems();

    // brief priority list: broken first, then vs, then comp, then neutral
    const pick = items.slice(0, 60);

    const lines = [];
    lines.push(`QDS SuperVault Brief`);
    lines.push(`Snapshot: ${$("snapPath").textContent}`);
    lines.push(`Updated: ${$("updated").textContent}`);
    lines.push(`Counts: items=${$("nItems").textContent}, triaged=${$("nTriaged").textContent}, broken=${$("nBroken").textContent}, vs=${$("nVs").textContent}, comp=${$("nComp").textContent}, neutral=${$("nNone").textContent}`);
    const q = $("q").value.trim();
    if(q) lines.push(`Filter: query="${q}", bucket="${$("bucketSel").value}", view="${$("viewSel").value}"`);
    lines.push(`---`);
    lines.push(`Top items (priority-sorted). Please assess: does any item directly contradict a QDS prediction, or is it neutral/adjacent?`);

    let n=1;
    for(const it of pick){
      const one = `${String(n).padStart(2,"0")}. ${formatOneLine(it)}`;
      lines.push(one);
      const k=itemKey(it);
      const note=(state.notes[k]||"").trim();
      if(note){
        lines.push(`    note: ${note.replace(/\s+/g," ").slice(0,200)}`);
      }
      n++;
      if(lines.length >= maxLines) break;
    }

    // hard cap
    const out = lines.slice(0, maxLines).join("\n");
    $("brief").value = out;
  }

  function exportEvidencePack(){
    // Export: filtered snapshot items + full triage/notes + meta
    const payload = {
      version: 1,
      exported_at: new Date().toISOString(),
      snapshot: state.snapMeta,
      items: state.items,
      triage: state.triage,
      notes: state.notes
    };
    const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `qds_evidence_pack_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  async function reload(){
    setStatus("warn","loading‚Ä¶");
    state.triage = loadJson(TRIAGE_KEY, {});
    state.notes  = loadJson(NOTES_KEY, {});
    state.source = $("sourceSel").value;

    try{
      if(state.source==="latest"){
        $("dateSel").disabled = true;
        await loadLatestSnapshot();
      }else{
        $("dateSel").disabled = false;
        state.probeDates = await listProbeDates();
        $("dateSel").innerHTML = state.probeDates.map(d=>`<option value="${d}">${d}</option>`).join("") || `<option value="">‚Äî</option>`;
        const chosen = $("dateSel").value || state.probeDates[0] || "";
        $("dateSel").value = chosen;
        if(chosen) await loadProbeDate(chosen);
      }

      $("updated").textContent = state.snapMeta.created_at || new Date().toISOString().slice(0,19);
      computeStats();
      renderList();
      setStatus("ok","ready");
    }catch(e){
      console.error(e);
      computeStats();
      renderList();
      setStatus("bad","error");
      $("brief").value = "ERROR: Could not load snapshot.\n\nFix:\n1) run ~/qdsnews.sh (creates physorg_latest_snapshot.json)\n2) refresh this page.\n\nOr switch SOURCE to 'probe'.";
    }
  }

  // Wire up
  $("sourceSel").onchange = async ()=>{
    $("dateSel").disabled = $("sourceSel").value==="latest";
    await reload();
    buildBrief();
  };

  $("dateSel").onchange = async ()=>{
    if($("sourceSel").value!=="probe") return;
    setStatus("warn","loading‚Ä¶");
    try{
      await loadProbeDate($("dateSel").value);
      $("updated").textContent = state.snapMeta.created_at || $("dateSel").value;
      computeStats();
      renderList();
      setStatus("ok","ready");
      buildBrief();
    }catch(e){
      console.error(e);
      setStatus("bad","error");
    }
  };

  for(const id of ["viewSel","bucketSel","sortSel","lineSel"]){
    $(id).onchange = ()=>{ computeStats(); renderList(); buildBrief(); };
  }
  $("q").addEventListener("input", ()=>{
    window.clearTimeout(window.__qt);
    window.__qt = setTimeout(()=>{ computeStats(); renderList(); buildBrief(); }, 140);
  });

  $("runBtn").onclick = async ()=>{ await reload(); buildBrief(); };
  $("reloadBtn").onclick = async ()=>{ await reload(); };
  $("openTriageBtn").onclick = ()=>{ window.open("physorg_qds_triage.html?x="+Date.now(), "_blank"); };
  $("exportBtn").onclick = exportEvidencePack;
  $("copyBtn").onclick = async ()=>{
    try{
      await navigator.clipboard.writeText($("brief").value || "");
      setStatus("ok","copied brief ‚úÖ");
      setTimeout(()=>setStatus("ok","ready"), 900);
    }catch{
      alert("Copy failed (browser permission). Long-press to select/copy manually.");
    }
  };

  // Boot
  reload().then(buildBrief);
})();


// --- qds_battery_habitat_rw_v1_3.html ---

    const $ = (id) => document.getElementById(id);

    const inputs = [
      "nominalCapacity","eolThreshold","cyclesPerDay","intensity",
      "c1_cycles","c1_cap","c2_cycles","c2_cap","c3_cycles","c3_cap","fitShape"
    ];

    function linearFit(xs, ys) {
      const n = xs.length;
      if (n < 2) return null;
      let sumx = 0, sumy = 0, sumxy = 0, sumx2 = 0;
      for (let i = 0; i < n; i++) {
        const x = xs[i], y = ys[i];
        sumx += x; sumy += y;
        sumxy += x * y;
        sumx2 += x * x;
      }
      const denom = n * sumx2 - sumx * sumx;
      if (Math.abs(denom) < 1e-9) return null;
      const m = (n * sumxy - sumx * sumy) / denom;
      const b = (sumy - m * sumx) / n;
      return { m, b };
    }

    function expFit(xs, ys) {
      // crude exponential fit: C(N) = a * exp(kN)
      const n = xs.length;
      if (n < 2) return null;
      let sumx = 0, sumlny = 0, sumxlny = 0, sumx2 = 0;
      let valid = 0;
      for (let i = 0; i < n; i++) {
        const x = xs[i], y = ys[i];
        if (y <= 0) continue;
        const ly = Math.log(y);
        sumx += x; sumlny += ly;
        sumxlny += x * ly;
        sumx2 += x * x;
        valid++;
      }
      if (valid < 2) return null;
      const denom = valid * sumx2 - sumx * sumx;
      if (Math.abs(denom) < 1e-9) return null;
      const k = (valid * sumxlny - sumx * sumlny) / denom;
      const lnA = (sumlny - k * sumx) / valid;
      const a = Math.exp(lnA);
      return { a, k };
    }

    function computeModel() {
      const C_nom = parseFloat($("nominalCapacity").value) || 2.0;
      const eolPct = Math.min(100, Math.max(10, parseFloat($("eolThreshold").value) || 80));
      const cyclesPerDay = Math.max(0, parseFloat($("cyclesPerDay").value) || 0);
      const intensity = parseFloat($("intensity").value) || 1.0;

      $("nominalCapacityEcho").textContent = C_nom.toFixed(2);
      $("eolThresholdEcho").textContent = eolPct.toFixed(0);
      $("cyclesPerDayEcho").textContent = cyclesPerDay.toFixed(1);

      let intensityLabel = "NASA-like";
      if (intensity < 0.8) intensityLabel = "gentler than NASA";
      else if (intensity > 1.2) intensityLabel = "harsher than NASA";
      $("intensityEcho").textContent = intensityLabel;

      const xs = [];
      const ys = [];

      ["1","2","3"].forEach(idx => {
        const c = parseFloat($("c" + idx + "_cycles").value);
        const cap = parseFloat($("c" + idx + "_cap").value);
        if (Number.isFinite(c) && Number.isFinite(cap) && c >= 0 && cap > 0) {
          xs.push(c);
          ys.push(cap);
        }
      });

      let cyclesToEol = null;
      let fadePer100 = null;
      const C_eol = C_nom * eolPct / 100;

      let curveFn = null, maxCycle = null;

      if (xs.length >= 2) {
        const shape = $("fitShape").value;
        if (shape === "exp") {
          const p = expFit(xs, ys);
          if (p) {
            curveFn = (N) => p.a * Math.exp(p.k * N);
            // rough bracket for EOL search
            maxCycle = Math.max(...xs) * 2.0;
            const f0 = curveFn(0);
            const fEnd = curveFn(maxCycle);
            // if already below threshold, assume EOL within dataset
            if (f0 <= C_eol) {
              cyclesToEol = 0;
            } else if (fEnd > C_eol) {
              // fade too gentle; no EOL within bracket
              cyclesToEol = Infinity;
            } else {
              // bisection search
              let lo = 0, hi = maxCycle;
              for (let i = 0; i < 40; i++) {
                const mid = 0.5 * (lo + hi);
                if (curveFn(mid) > C_eol) lo = mid; else hi = mid;
              }
              cyclesToEol = 0.5 * (lo + hi);
            }

            // effective fade per 100 cycles near centre
            const Nmid = (Math.min(...xs) + Math.max(...xs)) / 2;
            const cA = curveFn(Nmid);
            const cB = curveFn(Nmid + 100);
            if (cA > 0) fadePer100 = 100 * (cA - cB) / C_nom;
          }
        } else {
          const p = linearFit(xs, ys);
          if (p) {
            curveFn = (N) => p.m * N + p.b;
            maxCycle = Math.max(...xs) * 2.0;
            if (Math.abs(p.m) < 1e-9) {
              cyclesToEol = Infinity;
            } else {
              const N_eol = (C_eol - p.b) / p.m;
              cyclesToEol = N_eol;
            }
            const cA = curveFn(0);
            const cB = curveFn(100);
            if (Number.isFinite(cA) && Number.isFinite(cB)) {
              fadePer100 = 100 * (cA - cB) / C_nom;
            }
          }
        }
      }

      const stressVsNasa = intensity; // direct mapping; can tweak later.

      // Update metrics
      const mvCycles = $("mv_cycles");
      const mvDays = $("mv_days");
      const mvFade = $("mv_faderate");
      const mvStress = $("mv_stress");

      const mfCycles = $("mf_cycles");
      const mfDays = $("mf_days");
      const mfFade = $("mf_faderate");
      const mfStress = $("mf_stress");

      function setMetric(el, cls, text) {
        el.classList.remove("good","warn","bad");
        if (cls) el.classList.add(cls);
        el.firstElementChild.textContent = text;
      }

      if (!curveFn || !Number.isFinite(cyclesToEol) || cyclesToEol <= 0) {
        setMetric(mvCycles, null, "‚Äî");
        mfCycles.textContent = "Need at least two sensible calibration points.";
        setMetric(mvDays, null, "‚Äî");
        mfDays.textContent = "Lifetime in days shows once cycles to EOL is known.";
        setMetric(mvFade, null, "‚Äî");
        mfFade.textContent = "Fade per 100 cycles appears once a curve is fitted.";
      } else {
        const cycClean = Math.max(0, cyclesToEol);
        let cls = "good";
        if (cycClean < 400) cls = "bad";
        else if (cycClean < 800) cls = "warn";

        setMetric(mvCycles, cls, cycClean.toFixed(0));
        mfCycles.textContent = "From NASA-style calibration ‚Üí " + eolPct.toFixed(0) + "% of nominal.";

        if (cyclesPerDay > 0) {
          const days = cycClean / (cyclesPerDay * stressVsNasa);
          let clsD = "good";
          if (days < 365) clsD = "bad";
          else if (days < 730) clsD = "warn";
          setMetric(mvDays, clsD, days.toFixed(0));
          mfDays.textContent = "If you keep cycling at ~" +
            cyclesPerDay.toFixed(1) + " RW/day and intensity " + stressVsNasa.toFixed(2) + "√ó NASA.";
        } else {
          setMetric(mvDays, null, "‚Äî");
          mfDays.textContent = "Set cycles/day to see calendar life.";
        }

        if (fadePer100 != null && Number.isFinite(fadePer100)) {
          let clsF = "good";
          if (fadePer100 > 4) clsF = "bad";
          else if (fadePer100 > 2) clsF = "warn";
          setMetric(mvFade, clsF, fadePer100.toFixed(2));
          mfFade.textContent = "Average drop in usable capacity per 100 RW cycles (relative to nominal).";
        } else {
          setMetric(mvFade, null, "‚Äî");
          mfFade.textContent = "Fade per 100 cycles appears once a curve is fitted.";
        }
      }

      // Stress metric
      let clsS = "good";
      if (stressVsNasa > 1.25) clsS = "bad";
      else if (stressVsNasa > 1.05) clsS = "warn";
      setMetric(mvStress, clsS, stressVsNasa.toFixed(2));
      mfStress.textContent = "1.0 ‚âà NASA random walk. <1.0 = softer use, >1.0 = harder.";

      // Draw chart
      drawChart(curveFn, xs, ys, C_nom, C_eol, cyclesToEol);
    }

    function drawChart(curveFn, xs, ys, C_nom, C_eol, cyclesToEol) {
      const canvas = $("capChart");
      const ctx = canvas.getContext("2d");

      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);

      // background gradient
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, "rgba(5,10,40,1)");
      grad.addColorStop(1, "rgba(1,3,14,1)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);

      ctx.save();
      const padLeft = 38;
      const padRight = 10;
      const padTop = 10;
      const padBottom = 22;

      const plotW = w - padLeft - padRight;
      const plotH = h - padTop - padBottom;

      const allCycles = xs.slice();
      if (Number.isFinite(cyclesToEol) && cyclesToEol > 0 && cyclesToEol !== Infinity) {
        allCycles.push(cyclesToEol);
      }
      const maxX = allCycles.length ? Math.max(...allCycles) * 1.05 : 1200;
      const maxY = C_nom * 1.05;

      function xToPx(x) {
        return padLeft + (x / maxX) * plotW;
      }
      function yToPx(y) {
        return padTop + (1 - (y / maxY)) * plotH;
      }

      // Axes
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padLeft, padTop);
      ctx.lineTo(padLeft, padTop + plotH);
      ctx.lineTo(padLeft + plotW, padTop + plotH);
      ctx.stroke();

      // Threshold line
      if (C_eol > 0) {
        ctx.strokeStyle = "rgba(255,75,106,0.7)";
        ctx.setLineDash([4,4]);
        ctx.beginPath();
        ctx.moveTo(padLeft, yToPx(C_eol));
        ctx.lineTo(padLeft + plotW, yToPx(C_eol));
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Model curve
      if (curveFn && Number.isFinite(maxX) && maxX > 0) {
        ctx.strokeStyle = "rgba(0,245,255,0.85)";
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        const steps = 80;
        for (let i = 0; i <= steps; i++) {
          const frac = i / steps;
          const N = frac * maxX;
          let C = curveFn(N);
          if (!Number.isFinite(C)) continue;
          C = Math.max(0, Math.min(maxY, C));
          const px = xToPx(N);
          const py = yToPx(C);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }

      // NASA calibration points
      ctx.fillStyle = "#ffb83b";
      for (let i = 0; i < xs.length; i++) {
        const px = xToPx(xs[i]);
        const py = yToPx(ys[i]);
        ctx.beginPath();
        ctx.arc(px, py, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // Axes labels (simple ticks)
      ctx.fillStyle = "rgba(163,177,217,0.9)";
      ctx.font = "10px system-ui, -apple-system, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";

      const tickCount = 4;
      for (let i = 0; i <= tickCount; i++) {
        const cyc = (maxX * i) / tickCount;
        const x = xToPx(cyc);
        ctx.fillText(Math.round(cyc), x, padTop + plotH + 4);
      }
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for (let i = 0; i <= 4; i++) {
        const cap = (maxY * i) / 4;
        const y = yToPx(cap);
        ctx.fillText(cap.toFixed(1), padLeft - 4, y);
      }

      ctx.restore();
    }

    inputs.forEach(id => {
      const el = $(id);
      if (!el) return;
      el.addEventListener("input", computeModel);
      el.addEventListener("change", computeModel);
    });

    window.addEventListener("load", computeModel);
  

// --- qds_revenue_floor_v3_WORK.html ---

(function(){
  "use strict";

  const $ = (id)=>document.getElementById(id);
  const clamp01 = (x)=>Math.max(0, Math.min(1, x));
  const num = (x)=> {
    const v = Number(String(x).replace(/,/g,'').trim());
    return Number.isFinite(v) ? v : 0;
  };

  function sym(){
    const s = ($("sym").value || "¬£").trim();
    return s.length ? s : "¬£";
  }

  function fmtMoney(x){
    const S = sym();
    const v = Math.round(x);
    return S + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  function fmtDeltaYear(x){
    const S = sym();
    if(!Number.isFinite(x)) return "‚Äî";
    if(Math.abs(x) < 0.5) return "¬±" + S + "0";
    const sign = x >= 0 ? "+" : "‚àí";
    const v = Math.round(Math.abs(x));
    return sign + S + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  function toast(msg){
    const t = $("toast");
    t.textContent = msg;
    t.style.display = "block";
    clearTimeout(window.__toastT);
    window.__toastT = setTimeout(()=>{ t.style.display="none"; }, 1600);
  }

  function readInputs(){
    return {
      mode: $("mode").value,
      sym: sym(),
      months: Math.max(1, Math.min(60, Math.round(num($("months").value)))),
      L: Math.max(0, num($("L").value)),
      q: clamp01(num($("q").value)),
      s: clamp01(num($("s").value)),
      p: clamp01(num($("p").value)),
      r: clamp01(num($("r").value)),
      priceSprint: Math.max(0, num($("priceSprint").value)),
      pricePilot: Math.max(0, num($("pricePilot").value)),
      priceRet: Math.max(0, num($("priceRet").value)),
      Smax: Math.max(0, num($("Smax").value)),
      Pmax: Math.max(0, num($("Pmax").value)),
      m0: Math.max(0, num($("m0").value)),
      churnPct: Math.max(0, Math.min(50, num($("churn").value))),
      cost: Math.max(0, num($("cost").value)),
      notes: ($("notes").value || "").trim()
    };
  }

  function model(inp){
    // Funnel volumes
    const qualified = inp.L * inp.q;
    const sprintsRaw = qualified * inp.s;
    const sprints = Math.min(sprintsRaw, inp.Smax);
    const pilotsRaw = sprints * inp.p;
    const pilots = Math.min(pilotsRaw, inp.Pmax);
    const newRetainers = pilots * inp.r;

    // Revenue
    const revSprints = sprints * inp.priceSprint;
    const revPilots  = pilots  * inp.pricePilot;
    const newMRR     = newRetainers * inp.priceRet; // per month

    const revMonth = revSprints + revPilots + newMRR;
    const runRateYear = revMonth * 12;

    // MRR accumulation with churn: M_{t+1} = (M_t + newMRR) * (1 - c)
    const c = inp.churnPct / 100;
    let M = inp.m0;
    let M3 = null, M6 = null, M12 = null;
    for(let t=1; t<=inp.months; t++){
      M = (M + newMRR) * (1 - c);
      if(t===3) M3 = M;
      if(t===6) M6 = M;
      if(t===12) M12 = M;
    }

    // Optional net (cost)
    const netMonth = revMonth - inp.cost;

    return {
      qualified, sprintsRaw, sprints, pilotsRaw, pilots, newRetainers,
      revSprints, revPilots, newMRR, revMonth, runRateYear, netMonth,
      M_end: M, M3, M6, M12
    };
  }

  function setPreset(mode){
    // You can tweak these any time ‚Äî they‚Äôre sane starting points.
    const presets = {
      con:  {L:6,  q:0.35, s:0.30, p:0.35, r:0.25, priceSprint:3500, pricePilot:5000, priceRet:1500, Smax:2, Pmax:1, churn:4.0, months:12},
      base: {L:12, q:0.50, s:0.35, p:0.40, r:0.30, priceSprint:4500, pricePilot:6000, priceRet:2000, Smax:3, Pmax:2, churn:3.0, months:12},
      opt:  {L:18, q:0.55, s:0.40, p:0.45, r:0.35, priceSprint:5500, pricePilot:7500, priceRet:2500, Smax:4, Pmax:3, churn:2.5, months:12},
    };
    const P = presets[mode] || presets.base;
    $("L").value = P.L;
    $("q").value = P.q;
    $("s").value = P.s;
    $("p").value = P.p;
    $("r").value = P.r;
    $("priceSprint").value = P.priceSprint;
    $("pricePilot").value = P.pricePilot;
    $("priceRet").value = P.priceRet;
    $("Smax").value = P.Smax;
    $("Pmax").value = P.Pmax;
    $("churn").value = P.churn;
    $("months").value = P.months;
    $("m0").value = 0;
    $("cost").value = 0;
    // don't wipe notes
  }

  function buildAudit(inp){
    // Minimal: keep it simple + editable narrative (stored in notes)
    const rows = [
      {name:"Qualified rate (q)", val: inp.q.toFixed(2), conf:"Med", note:"How many leads are actually in-scope."},
      {name:"Sprint close (s)", val: inp.s.toFixed(2), conf:"Med", note:"Conversion from qualified to paid sprint."},
      {name:"Pilot-from-sprint (p)", val: inp.p.toFixed(2), conf:"Med", note:"Who extends from sprint into pilot."},
      {name:"Retainer-from-pilot (r)", val: inp.r.toFixed(2), conf:"Med", note:"Pilot ‚Üí ongoing retainer conversion."},
      {name:"Churn (c)", val: inp.churnPct.toFixed(1) + "%", conf:"Low", note:"Until you have 6‚Äì12 months data."},
      {name:"Capacity caps", val: `Smax=${inp.Smax}, Pmax=${inp.Pmax}`, conf:"High", note:"Your time/ops reality (non-negotiable)."},
    ];
    const tb = $("auditBody");
    tb.innerHTML = "";
    for(const r of rows){
      const tr = document.createElement("tr");
      const td1 = document.createElement("td"); td1.textContent = r.name;
      const td2 = document.createElement("td"); td2.className="right"; td2.textContent = r.val;
      const td3 = document.createElement("td");
      const badge = document.createElement("span");
      badge.className = "badge" + (r.conf==="Low" ? " warn" : r.conf==="High" ? "" : "");
      badge.innerHTML = `<i></i>${r.conf}`;
      td3.appendChild(badge);
      const td4 = document.createElement("td"); td4.className="muted"; td4.textContent = r.note;
      tr.append(td1, td2, td3, td4);
      tb.appendChild(tr);
    }
  }

  function updateSensitivity(inp, base){
    const scenarios = [
      {key:"L",    label:"+1 lead / month",           apply:(x)=>({...x, L:x.L+1})},
      {key:"s",    label:"+0.10 sprint close rate",   apply:(x)=>({...x, s:clamp01(x.s+0.10)})},
      {key:"Smax", label:"+1 sprint capacity",        apply:(x)=>({...x, Smax:x.Smax+1})},
      {key:"p",    label:"+0.05 pilot-from-sprint",   apply:(x)=>({...x, p:clamp01(x.p+0.05)})},
      {key:"r",    label:"+0.05 retainer-from-pilot", apply:(x)=>({...x, r:clamp01(x.r+0.05)})},
    ];

    for(const sc of scenarios){
      const m = model(sc.apply(inp));
      const deltaYear = m.runRateYear - base.runRateYear;
      const cell = document.querySelector(`[data-sens="${sc.key}"]`);
      if(cell){
        cell.textContent = fmtDeltaYear(deltaYear);
        cell.classList.remove("deltaPos","deltaNeg","deltaZero");
        if(deltaYear > 0.5) cell.classList.add("deltaPos");
        else if(deltaYear < -0.5) cell.classList.add("deltaNeg");
        else cell.classList.add("deltaZero");
      }
    }
  }

  function update(){
    const inp = readInputs();
    const m = model(inp);

    $("kpiRevMo").textContent = fmtMoney(m.revMonth);
    $("kpiRunRate").textContent = fmtMoney(m.runRateYear);

    $("kpiNewMRR").textContent = fmtMoney(m.newMRR);
    $("kpiMRRH").textContent = fmtMoney(m.M_end);
    $("kpiMRRHNote").textContent = `MRR after churn @ ${inp.months} months`;

    const vol = [
      `Qualified: <strong>${m.qualified.toFixed(2)}</strong>`,
      `Sprints: <strong>${m.sprints.toFixed(2)}</strong> <span class="muted">(raw ${m.sprintsRaw.toFixed(2)})</span>`,
      `Pilots: <strong>${m.pilots.toFixed(2)}</strong> <span class="muted">(raw ${m.pilotsRaw.toFixed(2)})</span>`,
      `New retainers: <strong>${m.newRetainers.toFixed(2)}</strong>`
    ].join(" ‚Ä¢ ");
    $("volumes").innerHTML = vol;

    const pick = (x)=> (x==null ? "‚Äî" : fmtMoney(x));
    const mrrLine = [
      `Starting: <strong>${fmtMoney(inp.m0)}</strong>`,
      `MRR @ 3 mo: <strong>${pick(m.M3)}</strong>`,
      `MRR @ 6 mo: <strong>${pick(m.M6)}</strong>`,
      `MRR @ 12 mo: <strong>${pick(m.M12)}</strong>`,
      `MRR @ horizon: <strong>${fmtMoney(m.M_end)}</strong>`
    ].join(" ‚Ä¢ ");
    $("mrrLine").innerHTML = mrrLine;

    const netNote = inp.cost > 0 ? ` ‚Ä¢ Net after costs: ${fmtMoney(m.netMonth)}/mo` : "";
    const capNote = (m.sprintsRaw > inp.Smax || m.pilotsRaw > inp.Pmax) ? " (capacity-capped)" : "";
    $("boardLine").innerHTML =
      `Base plan: <strong>${fmtMoney(m.revMonth)}/mo</strong> revenue${capNote} ‚Üí <strong>${fmtMoney(m.runRateYear)}/yr</strong> run-rate.
       Adds <strong>${fmtMoney(m.newMRR)}/mo</strong> new MRR; projected MRR @ ${inp.months} months: <strong>${fmtMoney(m.M_end)}</strong>.${netNote}`;

    buildAudit(inp);
    updateSensitivity(inp, m);
  }

  function saveLocal(){
    const inp = readInputs();
    localStorage.setItem("QDS_REV_FLOOR_V3", JSON.stringify(inp));
    toast("Saved to localStorage");
  }

  function loadLocal(){
    const raw = localStorage.getItem("QDS_REV_FLOOR_V3");
    if(!raw){ toast("Nothing saved yet"); return; }
    try{
      const x = JSON.parse(raw);
      if(x.mode) $("mode").value = x.mode;
      if(x.sym) $("sym").value = x.sym;
      if(x.months!=null) $("months").value = x.months;
      $("L").value = x.L ?? $("L").value;
      $("q").value = x.q ?? $("q").value;
      $("s").value = x.s ?? $("s").value;
      $("p").value = x.p ?? $("p").value;
      $("r").value = x.r ?? $("r").value;
      $("priceSprint").value = x.priceSprint ?? $("priceSprint").value;
      $("pricePilot").value = x.pricePilot ?? $("pricePilot").value;
      $("priceRet").value = x.priceRet ?? $("priceRet").value;
      $("Smax").value = x.Smax ?? $("Smax").value;
      $("Pmax").value = x.Pmax ?? $("Pmax").value;
      $("m0").value = x.m0 ?? $("m0").value;
      $("churn").value = x.churnPct ?? $("churn").value;
      $("cost").value = x.cost ?? $("cost").value;
      $("notes").value = x.notes ?? $("notes").value;
      toast("Loaded from localStorage");
      update();
    }catch(e){
      toast("Load failed (bad JSON)");
    }
  }

  function copyBoard(){
    const text = document.getElementById("boardLine").innerText.replace(/\s+/g,' ').trim();
    navigator.clipboard?.writeText(text).then(()=>toast("Board summary copied")).catch(()=>toast("Copy blocked (browser)"));
  }

  // Wire buttons
  $("btnOnePager").addEventListener("click", ()=>{
    document.body.classList.toggle("onepager");
  });
  $("btnPrint").addEventListener("click", ()=>window.print());
  $("btnCopy").addEventListener("click", copyBoard);
  $("btnReset").addEventListener("click", ()=>{
    $("mode").value = "base";
    setPreset("base");
    $("sym").value = "¬£";
    $("notes").value = "";
    toast("Reset to Base");
    update();
  });

  $("btnSave").addEventListener("click", saveLocal);
  $("btnLoad").addEventListener("click", loadLocal);
  $("btnDefaults").addEventListener("click", ()=>{
    setPreset($("mode").value);
    toast("Defaults loaded");
    update();
  });

  $("mode").addEventListener("change", ()=>{
    setPreset($("mode").value);
    toast("Preset applied");
    update();
  });

  // Live update on any input
  document.addEventListener("input", (e)=>{
    if(e && e.target && (e.target.tagName==="INPUT" || e.target.tagName==="SELECT" || e.target.tagName==="TEXTAREA")) update();
  }, true);
  document.addEventListener("change", update, true);

  // Init
  setPreset($("mode").value);
  update();

})();


// --- qds_revenue_floor_v5_1.html ---

(function(){
  const $ = (id)=>document.getElementById(id);
  const KEY = "QDS_GrowthHub_RevenueFloor_v5_1";

  // IMPORTANT FIX: presets store churn as FRACTION (0.03 = 3%), not percent (3.0).
  const presets = {
    conservative: {
      L:4, q:0.35, s:0.20, p:0.25, r:0.15,
      sprintPrice:2200, pilotPrice:3200, retainerMonth:650,
      Smax:1, Pmax:1, months:12, m0:0, c:0.035, cost:0
    },
    base: {
      L:6, q:0.40, s:0.25, p:0.30, r:0.20,
      sprintPrice:2500, pilotPrice:3500, retainerMonth:800,
      Smax:2, Pmax:1, months:12, m0:0, c:0.03, cost:0
    },
    optimistic: {
      L:10, q:0.50, s:0.30, p:0.35, r:0.25,
      sprintPrice:3000, pilotPrice:4200, retainerMonth:1000,
      Smax:3, Pmax:2, months:12, m0:0, c:0.025, cost:0
    }
  };

  function clamp01(x){ x = Number(x); if(!isFinite(x)) return 0; return Math.max(0, Math.min(1, x)); }
  function num(x, def=0){ x = Number(x); return isFinite(x) ? x : def; }

  function sym(){
    const s = String($("sym").value || "¬£").trim();
    return s.length ? s : "¬£";
  }

  function fmtMoney(x){
    const s = sym();
    if(!isFinite(x)) return "‚Äî";
    const v = Math.round(x);
    return s + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  function fmtMoneySigned(x){
    const s = sym();
    if(!isFinite(x)) return "‚Äî";
    const sign = x > 0 ? "+" : (x < 0 ? "‚àí" : "¬±");
    const v = Math.round(Math.abs(x));
    return sign + s + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  function readInputs(){
    // c entered as % in UI -> fraction internally; clamp to avoid nonsense >99%
    const cFrac = Math.min(0.99, Math.max(0, num($("c").value)/100));
    return {
      L: num($("L").value),
      q: clamp01($("q").value),
      s: clamp01($("s").value),
      p: clamp01($("p").value),
      r: clamp01($("r").value),
      sprintPrice: num($("sprintPrice").value),
      pilotPrice: num($("pilotPrice").value),
      retainerMonth: num($("retainerMonth").value),
      Smax: num($("Smax").value),
      Pmax: num($("Pmax").value),
      months: Math.max(1, Math.floor(num($("months").value, 12))),
      m0: Math.max(0, num($("m0").value)),
      c: cFrac,
      cost: Math.max(0, num($("cost").value)),
      notes: String($("notes").value||"")
    };
  }

  // Core model: demand -> conversion -> caps -> revenue; MRR accum with churn
  function model(inp){
    const qualified = inp.L * inp.q;

    const sprintsRaw = qualified * inp.s;
    const sprints = (isFinite(inp.Smax) && inp.Smax >= 0) ? Math.min(sprintsRaw, inp.Smax) : sprintsRaw;

    const pilotsRaw = sprints * inp.p;
    const pilots = (isFinite(inp.Pmax) && inp.Pmax >= 0) ? Math.min(pilotsRaw, inp.Pmax) : pilotsRaw;

    const newRetainers = pilots * inp.r;

    const revMonth =
      sprints * inp.sprintPrice +
      pilots  * inp.pilotPrice +
      newRetainers * inp.retainerMonth;

    const runRateYear = revMonth * 12;

    const mrrTrack = [];
    let mrr = inp.m0;
    for(let t=1; t<=inp.months; t++){
      mrr = mrr * (1 - inp.c) + newRetainers * inp.retainerMonth;
      mrrTrack.push(mrr);
    }

    function mAt(month){
      if(month <= 0) return inp.m0;
      if(month > mrrTrack.length) return mrrTrack[mrrTrack.length-1] ?? inp.m0;
      return mrrTrack[month-1];
    }

    return {
      qualified,
      sprintsRaw, sprints,
      pilotsRaw, pilots,
      newRetainers,
      revMonth, runRateYear,
      mrrTrack,
      mrr3: mAt(3),
      mrr6: mAt(6),
      mrr12: mAt(12),
      mrrH: mAt(inp.months),
    };
  }

  function confChip(level){
    let cls="chip cMed", dot="var(--teal)";
    if(level==="Low"){ cls="chip cLow"; dot="var(--warn)"; }
    if(level==="High"){ cls="chip cHigh"; dot="var(--lime)"; }
    return `<span class="${cls}"><span class="cDot" style="background:${dot}"></span>${level}</span>`;
  }

  function setAudit(inp){
    const tbody = $("auditBody");
    tbody.innerHTML = "";

    const rows = [
      {k:"Qualified rate (q)", v: inp.q.toFixed(2), conf:"Med", note:"How many leads are actually in-scope."},
      {k:"Sprint close (s)", v: inp.s.toFixed(2), conf:"Med", note:"Conversion from qualified to paid sprint."},
      {k:"Pilot-from-sprint (p)", v: inp.p.toFixed(2), conf:"Med", note:"Who extends from sprint into pilot."},
      {k:"Retainer-from-pilot (r)", v: inp.r.toFixed(2), conf:"Med", note:"Pilot ‚Üí ongoing retainer conversion."},
      {k:"Churn (c)", v: (inp.c*100).toFixed(1) + "%", conf:"Low", note:"Until you have 6‚Äì12 months data."},
      {k:"Capacity caps", v: `Smax=${inp.Smax}, Pmax=${inp.Pmax}`, conf:"High", note:"Your time/ops reality (non-negotiable)."},
    ];

    for(const r of rows){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${r.k}</td>
        <td>${r.v}</td>
        <td>${confChip(r.conf)}</td>
      `;
      tbody.appendChild(tr);

      const tr2 = document.createElement("tr");
      tr2.innerHTML = `<td colspan="3"><div class="noteBox"><b>Evidence note:</b> ${r.note}</div></td>`;
      tbody.appendChild(tr2);
    }
  }

  function setSensitivity(inp, base){
    const scenarios = [
      { idy:"s_y1", idm:"s_m1", mod: x => ({...x, L: x.L + 1}) },
      { idy:"s_y2", idm:"s_m2", mod: x => ({...x, s: clamp01(x.s + 0.10)}) },
      { idy:"s_y3", idm:"s_m3", mod: x => ({...x, Smax: (isFinite(x.Smax) ? x.Smax + 1 : x.Smax)}) },
      { idy:"s_y4", idm:"s_m4", mod: x => ({...x, p: clamp01(x.p + 0.05)}) },
      { idy:"s_y5", idm:"s_m5", mod: x => ({...x, r: clamp01(x.r + 0.05)}) },
    ];

    for(const sc of scenarios){
      const m = model(sc.mod(inp));
      const dy = m.runRateYear - base.runRateYear;
      const dm = m.revMonth - base.revMonth;

      const yEl = $(sc.idy);
      const mEl = $(sc.idm);

      yEl.textContent = fmtMoneySigned(dy);
      mEl.textContent = fmtMoneySigned(dm);

      const cls = (dy > 1e-9) ? "good" : (dy < -1e-9) ? "bad" : "neutral";
      yEl.className = cls;
      mEl.className = cls;
    }
  }

  function render(){
    const inp = readInputs();

    // currency hints
    const s = sym();
    $("labSprint").textContent = `${s} / sprint`;
    $("labPilot").textContent  = `${s} / pilot`;
    $("labRet").textContent    = `${s} / mo`;

    const m = model(inp);

    $("revMonthOut").textContent = fmtMoney(m.revMonth);
    $("runRateOut").textContent  = fmtMoney(m.runRateYear);
    $("newMRROut").textContent   = fmtMoney(m.newRetainers * inp.retainerMonth);
    $("mrrHOut").textContent     = fmtMoney(m.mrrH);
    $("mrrHSub").textContent     = `MRR after churn @ ${inp.months} month${inp.months===1?"":"s"}`;

    $("volLine").innerHTML =
      `<b>Expected volumes / month</b><br/>
      Qualified: <b>${m.qualified.toFixed(2)}</b> ‚Ä¢
      Sprints: <b>${m.sprints.toFixed(2)}</b> <span style="opacity:.8">(raw ${m.sprintsRaw.toFixed(2)})</span> ‚Ä¢
      Pilots: <b>${m.pilots.toFixed(2)}</b> <span style="opacity:.8">(raw ${m.pilotsRaw.toFixed(2)})</span> ‚Ä¢
      New retainers: <b>${m.newRetainers.toFixed(2)}</b>`;

    const m3  = (inp.months >= 3)  ? fmtMoney(m.mrr3)  : "‚Äî";
    const m6  = (inp.months >= 6)  ? fmtMoney(m.mrr6)  : "‚Äî";
    const m12 = (inp.months >= 12) ? fmtMoney(m.mrr12) : "‚Äî";

    $("mrrLine").innerHTML =
      `<b>MRR accumulation</b><br/>
      Starting: <b>${fmtMoney(inp.m0)}</b> ‚Ä¢
      MRR @ 3 mo: <b>${m3}</b> ‚Ä¢
      MRR @ 6 mo: <b>${m6}</b> ‚Ä¢
      MRR @ 12 mo: <b>${m12}</b> ‚Ä¢
      MRR @ horizon: <b>${fmtMoney(m.mrrH)}</b>`;

    const board = `Base plan: ${fmtMoney(m.revMonth)}/mo revenue ‚Üí ${fmtMoney(m.runRateYear)}/yr run-rate. Adds ${fmtMoney(m.newRetainers * inp.retainerMonth)}/mo new MRR; projected MRR @ ${inp.months} months: ${fmtMoney(m.mrrH)}.`;
    $("boardSummaryText").textContent = board;

    setAudit(inp);
    setSensitivity(inp, m);
  }

  function applyPreset(name){
    const p = presets[name] || presets.base;
    $("L").value = p.L;
    $("q").value = p.q;
    $("s").value = p.s;
    $("p").value = p.p;
    $("r").value = p.r;
    $("sprintPrice").value = p.sprintPrice;
    $("pilotPrice").value = p.pilotPrice;
    $("retainerMonth").value = p.retainerMonth;
    $("Smax").value = p.Smax;
    $("Pmax").value = p.Pmax;
    $("months").value = p.months;
    $("m0").value = p.m0;
    $("c").value = (p.c*100).toFixed(1); // fraction -> %
    $("cost").value = p.cost;
    render();
  }

  function saveLS(){
    const inp = readInputs();
    localStorage.setItem(KEY, JSON.stringify({
      sym: $("sym").value,
      months: inp.months,
      m0: inp.m0,
      L: inp.L, q: inp.q, s: inp.s, p: inp.p, r: inp.r,
      sprintPrice: inp.sprintPrice,
      pilotPrice: inp.pilotPrice,
      retainerMonth: inp.retainerMonth,
      Smax: inp.Smax, Pmax: inp.Pmax,
      c: (inp.c*100), // store as %
      cost: inp.cost,
      notes: inp.notes
    }));
  }

  function loadLS(){
    const raw = localStorage.getItem(KEY);
    if(!raw) return;
    try{
      const x = JSON.parse(raw);
      if(x.sym!==undefined) $("sym").value = x.sym;
      if(x.months!==undefined) $("months").value = x.months;
      if(x.m0!==undefined) $("m0").value = x.m0;
      if(x.L!==undefined) $("L").value = x.L;
      if(x.q!==undefined) $("q").value = x.q;
      if(x.s!==undefined) $("s").value = x.s;
      if(x.p!==undefined) $("p").value = x.p;
      if(x.r!==undefined) $("r").value = x.r;
      if(x.sprintPrice!==undefined) $("sprintPrice").value = x.sprintPrice;
      if(x.pilotPrice!==undefined) $("pilotPrice").value = x.pilotPrice;
      if(x.retainerMonth!==undefined) $("retainerMonth").value = x.retainerMonth;
      if(x.Smax!==undefined) $("Smax").value = x.Smax;
      if(x.Pmax!==undefined) $("Pmax").value = x.Pmax;
      if(x.c!==undefined) $("c").value = x.c;
      if(x.cost!==undefined) $("cost").value = x.cost;
      if(x.notes!==undefined) $("notes").value = x.notes;
      render();
    }catch(e){}
  }

  // Events
  document.addEventListener("input", (e)=>{
    if(e.target && (e.target.tagName==="INPUT"||e.target.tagName==="SELECT"||e.target.tagName==="TEXTAREA")) render();
  }, true);
  document.addEventListener("change", (e)=>{
    if(e.target && (e.target.tagName==="INPUT"||e.target.tagName==="SELECT"||e.target.tagName==="TEXTAREA")) render();
  }, true);

  $("mode").addEventListener("change", ()=>applyPreset($("mode").value));

  $("btnToggleOnePager").addEventListener("click", ()=>{ document.body.classList.toggle("onepager"); });
  $("btnPrint").addEventListener("click", ()=>window.print());

  $("btnCopyBoard").addEventListener("click", async ()=>{
    const text = $("boardSummaryText").textContent || "";
    try{
      await navigator.clipboard.writeText(text);
      $("btnCopyBoard").textContent = "Copied ‚úì";
      setTimeout(()=> $("btnCopyBoard").textContent="Copy Board Summary", 900);
    }catch(e){
      const ta = document.createElement("textarea");
      ta.value = text; document.body.appendChild(ta);
      ta.select(); document.execCommand("copy");
      ta.remove();
    }
  });

  $("btnReset").addEventListener("click", ()=>{
    $("mode").value = "base";
    $("sym").value = "¬£";
    $("notes").value = "";
    applyPreset("base");
  });

  $("btnSaveLS").addEventListener("click", ()=>saveLS());
  $("btnLoadLS").addEventListener("click", ()=>loadLS());
  $("btnDefaults").addEventListener("click", ()=>{
    $("mode").value="base"; $("sym").value="¬£"; $("notes").value="";
    applyPreset("base");
  });

  // Boot
  applyPreset("base");
})();


// --- qds_avian_magnetoreception_lab_v6_omega_pro.html ---

/* ---------- utils ---------- */
const $ = id => document.getElementById(id);
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const fmt = (x,n=2)=>Number(x).toFixed(n);
const pct = x => Math.round(100*x)+"%";
const nowStamp = ()=>new Date().toISOString().replace('T',' ').replace('Z',' UTC');

function dl(name, text, mime="application/json"){
  const blob = new Blob([text], {type:mime});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 500);
}

/* ---------- PRNG for seeded MC ---------- */
function xmur3(str){ let h=1779033703^str.length; for(let i=0;i<str.length;i++){ h=Math.imul(h^str.charCodeAt(i),3432918353); h=(h<<13)|(h>>>19); } return function(){ h=Math.imul(h^(h>>>16),2246822507); h=Math.imul(h^(h>>>13),3266489909); return (h^=h>>>16)>>>0; }; }
function sfc32(a,b,c,d){ return function(){ a|=0;b|=0;c|=0;d|=0; let t=(a+b|0)+d|0; d=d+1|0; a=b^b>>>9; b=c+(c<<3)|0; c=(c<<21|c>>>11); c=c+t|0; return (t>>>0)/4294967296; }; }

/* ---------- model ---------- */
const SPECIES = [
  {id:"robin", name:"European Robin", base:{tau:260, lam:1.55, sig:0.32, em:0.22, wl:500, lint:0.70, rf:0.10, cal:0.82, map:0.70, mot:0.78, sts:0.18, exp:0.55, B:50, inc:60, anom:0.10}},
  {id:"pigeon", name:"Racing Pigeon", base:{tau:220, lam:1.45, sig:0.36, em:0.28, wl:510, lint:0.75, rf:0.12, cal:0.78, map:0.88, mot:0.72, sts:0.22, exp:0.70, B:50, inc:60, anom:0.10}},
  {id:"albatross", name:"Wandering Albatross", base:{tau:300, lam:1.65, sig:0.30, em:0.18, wl:520, lint:0.80, rf:0.08, cal:0.86, map:0.92, mot:0.80, sts:0.12, exp:0.75, B:45, inc:55, anom:0.08}},
  {id:"blackcap", name:"Blackcap Warbler", base:{tau:240, lam:1.50, sig:0.34, em:0.24, wl:490, lint:0.70, rf:0.11, cal:0.80, map:0.68, mot:0.82, sts:0.20, exp:0.50, B:50, inc:60, anom:0.10}},
  {id:"tern", name:"Arctic Tern", base:{tau:320, lam:1.70, sig:0.28, em:0.20, wl:520, lint:0.85, rf:0.09, cal:0.88, map:0.90, mot:0.86, sts:0.14, exp:0.65, B:48, inc:58, anom:0.08}},
];

function applyPreset(name){
  let em=+$("em").value, rf=+$("rf").value, an=+$("anom").value, lint=+$("lint").value;
  if(name==="quiet"){ em=0.15; rf=0.06; an=0.05; lint=Math.max(lint,0.60); }
  if(name==="urban"){ em=0.55; rf=0.18; an=0.12; lint=Math.max(lint,0.55); }
  if(name==="storm"){ em=0.40; rf=0.15; an=0.65; lint=Math.max(lint,0.40); }
  if(name==="flare"){ em=0.48; rf=0.22; an=0.80; lint=Math.max(lint,0.35); }
  if(name==="lab"){ em=0.02; rf=0.00; an=0.00; lint=Math.max(lint,0.75); }
  if(name==="rfjam"){ em=Math.max(em,0.22); rf=0.85; an=Math.max(an,0.10); lint=Math.max(lint,0.55); }
  $("em").value=em; $("rf").value=rf; $("anom").value=an; $("lint").value=lint;
}

function lightMultiplier(wl, lint){
  const mu=505, s=55;
  const g = Math.exp(-0.5*Math.pow((wl-mu)/s,2));
  const inten = 1 - Math.exp(-3.0*lint);
  return clamp(g*inten, 0, 1);
}
function rfMultiplier(rf){ return clamp(Math.exp(-3.2*rf), 0, 1); }
function calMultiplier(cal){ return clamp(0.15 + 0.85*cal, 0, 1); }
function mapMultiplier(map){ return clamp(0.20 + 0.80*map, 0, 1); }
function behaviourMultiplier(mot, sts, exp){
  const drive = 0.35 + 0.65*mot;
  const stress = Math.exp(-2.4*sts);
  const learn = 0.55 + 0.45*exp;
  return clamp(drive*stress*learn, 0, 1);
}
function geomFactor(B, inc, anom){
  const Bref=50, sB=12, incRef=60, sI=18;
  const gB = Math.exp(-0.5*Math.pow((B-Bref)/sB,2));
  const gI = Math.exp(-0.5*Math.pow((inc-incRef)/sI,2));
  const dist = Math.exp(-1.8*anom);
  return clamp(gB*gI*dist, 0, 1);
}

function readState(){
  return {
    species:$("species").value,
    preset:$("preset").value,
    tau:+$("tau").value, lam:+$("lam").value, sig:+$("sig").value, em:+$("em").value,
    wl:+$("wl").value, lint:+$("lint").value, rf:+$("rf").value, cal:+$("cal").value,
    map:+$("map").value, mot:+$("mot").value, sts:+$("sts").value, exp:+$("exp").value,
    B:+$("B").value, inc:+$("inc").value, anom:+$("anom").value
  };
}

function compute(p){
  const tauRef=250, lamRef=1.6;
  const coh = Math.pow(p.tau/tauRef, 0.62) * Math.pow(p.lam/lamRef, 0.38);
  const noise = Math.exp(-1.55*p.em) / (0.18 + p.sig);
  const g = geomFactor(p.B, p.inc, p.anom);
  let K_raw = 1.25 * coh * noise * (0.35 + 0.65*g);
  K_raw = clamp(K_raw, 0, 6);
  const compass = clamp(1 - Math.exp(-K_raw), 0, 1);

  const L = lightMultiplier(p.wl, p.lint);
  const R = rfMultiplier(p.rf);
  const C = calMultiplier(p.cal);
  const M = mapMultiplier(p.map);
  const Bh = behaviourMultiplier(p.mot, p.sts, p.exp);
  const G = clamp(0.35 + 0.65*g, 0, 1);

  const nav = clamp(compass * L * R * C * M * Bh * G, 0, 1);
  const fnr = clamp((compass) * (1 - nav) * (nav < 0.45 ? 1.15 : 0.75), 0, 1);

  const factors = [
    {k:"Light", v:L, hint:"Wavelength/intensity window."},
    {k:"RF", v:R, hint:"MHz-band disruption survival."},
    {k:"Calibration", v:C, hint:"Celestial‚Üîmagnetic coherence."},
    {k:"Map", v:M, hint:"Map channel contribution."},
    {k:"Behaviour", v:Bh, hint:"Drive√óstress√óexperience."},
    {k:"Geom", v:G, hint:"Field suitability + disturbance."},
  ];
  const limiters = [...factors].sort((a,b)=>a.v-b.v).slice(0,3);

  const trail = {
    stamp: nowStamp(),
    species: p.species,
    preset: p.preset,
    inputs: p,
    outputs: {
      K_raw:+fmt(K_raw,6),
      compass_confidence:+fmt(compass,6),
      navigation_reliability:+fmt(nav,6),
      false_negative_risk:+fmt(fnr,6)
    },
    factors: Object.fromEntries(factors.map(x=>[x.k.toLowerCase(), +fmt(x.v,6)]))
  };

  return {p, K_raw, compass, nav, fnr, factors, limiters, trail};
}

/* ---------- UI ---------- */
function dotFor(nav){
  if(nav>=0.75) return ["good","Stable Navigation ‚Äî corridor likely coherent."];
  if(nav>=0.45) return ["warn","Mixed Navigation ‚Äî borderline / context-sensitive."];
  return ["bad","Unstable Navigation ‚Äî confounds dominate or signal weak."];
}
function render(res){
  const {p, K_raw, compass, nav, fnr, factors, limiters, trail} = res;
  $("stamp").textContent = trail.stamp;

  $("v_tau").textContent = fmt(p.tau,0)+" ¬µs";
  $("v_lam").textContent = fmt(p.lam,2)+" nm";
  $("v_sig").textContent = fmt(p.sig,2);
  $("v_em").textContent  = fmt(p.em,2);
  $("v_wl").textContent  = fmt(p.wl,0)+" nm";
  $("v_int").textContent = fmt(p.lint,2);
  $("v_rf").textContent  = fmt(p.rf,2);
  $("v_cal").textContent = fmt(p.cal,2);
  $("v_map").textContent = fmt(p.map,2);
  $("v_mot").textContent = fmt(p.mot,2);
  $("v_sts").textContent = fmt(p.sts,2);
  $("v_exp").textContent = fmt(p.exp,2);
  $("v_B").textContent   = fmt(p.B,0)+" ¬µT";
  $("v_inc").textContent = fmt(p.inc,0)+"¬∞";
  $("v_anom").textContent= fmt(p.anom,2);

  $("kraw").textContent = fmt(K_raw,3);
  $("conf").textContent = pct(compass);
  $("nav").textContent  = pct(nav);
  $("fnr").textContent  = pct(fnr);
  $("bar_conf").style.width = (100*compass).toFixed(1)+"%";
  $("bar_nav").style.width  = (100*nav).toFixed(1)+"%";

  const [cls, msg] = dotFor(nav);
  $("dot").className = "dot "+cls;
  $("status").textContent = msg;

  $("factors").innerHTML = factors
    .map(f=>`<li><b>${f.k}</b> = ${pct(f.v)} <span class="small">‚Äî ${f.hint}</span></li>`).join("");

  $("limiters").innerHTML = limiters
    .map(w=>`<li><b>${w.k}</b> = ${pct(w.v)} ‚Äî ${w.hint}</li>`).join("");

  $("trail").textContent = JSON.stringify(trail, null, 2);

  window.__LAST = res;
}

function setState(p){
  $("species").value=p.species; $("preset").value=p.preset;
  $("tau").value=p.tau; $("lam").value=p.lam; $("sig").value=p.sig; $("em").value=p.em;
  $("wl").value=p.wl; $("lint").value=p.lint; $("rf").value=p.rf; $("cal").value=p.cal;
  $("map").value=p.map; $("mot").value=p.mot; $("sts").value=p.sts; $("exp").value=p.exp;
  $("B").value=p.B; $("inc").value=p.inc; $("anom").value=p.anom;
}

/* ---------- A/B compare ---------- */
function brief(res){
  if(!res) return "Empty";
  const f = res.trail.factors;
  return [
    `stamp: ${res.trail.stamp}`,
    `species: ${res.p.species}  preset: ${res.p.preset}`,
    `K_raw: ${fmt(res.K_raw,3)}`,
    `compass: ${pct(res.compass)}  nav: ${pct(res.nav)}  fnr: ${pct(res.fnr)}`,
    `factors: L=${pct(f.light)} RF=${pct(f.rf)} Cal=${pct(f.calibration)} Map=${pct(f.map)} Beh=${pct(f.behaviour)} Geom=${pct(f.geom)}`
  ].join("\n");
}
function delta(A,B){
  if(!A||!B) return "Save A and B‚Ä¶";
  const d = (x,y)=> (y-x);
  const fa=A.trail.factors, fb=B.trail.factors;
  const lines = [
    `nav: ${pct(A.nav)} ‚Üí ${pct(B.nav)}   (Œî ${pct(d(A.nav,B.nav))})`,
    `compass: ${pct(A.compass)} ‚Üí ${pct(B.compass)} (Œî ${pct(d(A.compass,B.compass))})`,
    `K_raw: ${fmt(A.K_raw,3)} ‚Üí ${fmt(B.K_raw,3)} (Œî ${fmt(d(A.K_raw,B.K_raw),3)})`,
    "",
    `Light: ${pct(fa.light)} ‚Üí ${pct(fb.light)} (Œî ${pct(d(fa.light,fb.light))})`,
    `RF: ${pct(fa.rf)} ‚Üí ${pct(fb.rf)} (Œî ${pct(d(fa.rf,fb.rf))})`,
    `Cal: ${pct(fa.calibration)} ‚Üí ${pct(fb.calibration)} (Œî ${pct(d(fa.calibration,fb.calibration))})`,
    `Map: ${pct(fa.map)} ‚Üí ${pct(fb.map)} (Œî ${pct(d(fa.map,fb.map))})`,
    `Beh: ${pct(fa.behaviour)} ‚Üí ${pct(fb.behaviour)} (Œî ${pct(d(fa.behaviour,fb.behaviour))})`,
    `Geom: ${pct(fa.geom)} ‚Üí ${pct(fb.geom)} (Œî ${pct(d(fa.geom,fb.geom))})`,
  ];
  return lines.join("\n");
}

/* ---------- Sensitivity ---------- */
function runSensitivity(){
  const base = window.__LAST;
  if(!base) return;
  const p0 = JSON.parse(JSON.stringify(base.p));
  const probes = [
    {k:"rf", step:0.06, min:0, max:1},
    {k:"em", step:0.10, min:0, max:1},
    {k:"lint", step:0.12, min:0, max:1},
    {k:"cal", step:0.12, min:0, max:1},
    {k:"map", step:0.12, min:0, max:1},
    {k:"sts", step:0.10, min:0, max:1},
    {k:"exp", step:0.20, min:0, max:1},
    {k:"mot", step:0.15, min:0, max:1},
    {k:"anom", step:0.12, min:0, max:1},
    {k:"wl", step:25, min:360, max:680},
    {k:"tau", step:80, min:5, max:6000},
    {k:"sig", step:0.06, min:0.05, max:1.2},
    {k:"lam", step:0.20, min:0.2, max:3.5},
  ];

  const out = [];
  for(const pr of probes){
    const pA = JSON.parse(JSON.stringify(p0));
    const pB = JSON.parse(JSON.stringify(p0));
    pA[pr.k] = clamp(pA[pr.k] - pr.step, pr.min, pr.max);
    pB[pr.k] = clamp(pB[pr.k] + pr.step, pr.min, pr.max);
    const A = compute(pA).nav, B = compute(pB).nav;
    const leverage = Math.abs(B - A);
    out.push({k:pr.k, A, B, leverage});
  }
  out.sort((a,b)=>b.leverage-a.leverage);

  const lines = [
    `baseline nav = ${pct(base.nav)}`,
    `Top levers (bigger = more impact):`,
    ...out.slice(0,10).map(o=>`- ${o.k.padEnd(5)}  Œî‚âà${pct(o.leverage)}   (down ${pct(o.A)} / up ${pct(o.B)})`)
  ];
  $("sensOut").textContent = lines.join("\n");
}

/* ---------- MC+ ---------- */
function drawHist(vals){
  const c = $("plot"), ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(160,190,255,.35)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(40, 20); ctx.lineTo(40, c.height-30); ctx.lineTo(c.width-20, c.height-30);
  ctx.stroke();

  const bins = 24;
  const hist = Array.from({length:bins}, ()=>0);
  for(const v of vals){
    const b = clamp(Math.floor(v*bins), 0, bins-1);
    hist[b]++;
  }
  const maxH = Math.max(...hist, 1);
  const W = c.width-60, H = c.height-60;
  const x0 = 40, y0 = c.height-30;
  const bw = W/bins;

  for(let i=0;i<bins;i++){
    const h = hist[i]/maxH;
    const x = x0 + i*bw + 1;
    const y = y0 - h*H;
    const w = bw - 2;
    const hh = h*H;
    ctx.fillStyle = "rgba(124,247,255,.35)";
    ctx.fillRect(x, y, w, hh);
    ctx.strokeStyle = "rgba(119,255,154,.25)";
    ctx.strokeRect(x, y, w, hh);
  }

  ctx.fillStyle = "rgba(232,236,255,.75)";
  ctx.font = "12px ui-monospace, Menlo, Consolas, monospace";
  ctx.fillText("0%", 38, c.height-10);
  ctx.fillText("100%", c.width-52, c.height-10);
  ctx.fillText("MC+ nav reliability histogram", 40, 14);
}

function mcPlusRun(){
  const base = window.__LAST;
  if(!base) return;
  const N = +$("mcn").value;
  const jit = +$("jit").value;
  $("v_mcn").textContent = N;
  $("v_jit").textContent = fmt(jit,2);

  // seed
  let rnd = Math.random;
  const seedStr = ($("seed").value||"").trim();
  if(seedStr){
    const seed = xmur3(seedStr);
    rnd = sfc32(seed(), seed(), seed(), seed());
  }

  const sims = [];
  const p0 = base.p;
  const j01 = (x, s)=>clamp(x + (rnd()*2-1)*s, 0, 1);

  for(let i=0;i<N;i++){
    const p = JSON.parse(JSON.stringify(p0));
    // nuisance channels jitter scaled by jit
    p.em   = j01(p.em,   0.10*jit);
    p.rf   = j01(p.rf,   0.14*jit);
    p.cal  = j01(p.cal,  0.14*jit);
    p.anom = j01(p.anom, 0.20*jit);
    p.lint = j01(p.lint, 0.12*jit);
    // mild kernel jitter
    p.sig  = clamp(p.sig + (rnd()*2-1)*0.06*jit, 0.05, 1.2);
    p.tau  = clamp(p.tau + (rnd()*2-1)*90*jit, 5, 6000);
    const nav = compute(p).nav;
    sims.push(nav);
  }
  sims.sort((a,b)=>a-b);
  const mean = sims.reduce((a,b)=>a+b,0)/sims.length;
  const p10 = sims[Math.floor(0.10*(sims.length-1))];
  const p50 = sims[Math.floor(0.50*(sims.length-1))];
  const p90 = sims[Math.floor(0.90*(sims.length-1))];
  drawHist(sims);

  window.__MC = {stamp: nowStamp(), N, jit, seed: seedStr||null, baseline: base.trail, stats:{mean,p10,p50,p90}, sims};
  $("mcstats").textContent = `MC+(${N}) mean=${pct(mean)} p10=${pct(p10)} median=${pct(p50)} p90=${pct(p90)} spread=${pct(p90-p10)}`;
}

/* ---------- Labbook ---------- */
const BOOK_KEY="QDS_AVIAN_LABBOOK_V6";
function getBook(){
  try{ return JSON.parse(localStorage.getItem(BOOK_KEY)||"[]"); }catch{ return []; }
}
function setBook(arr){ localStorage.setItem(BOOK_KEY, JSON.stringify(arr)); }
function dedupKey(e){ return (e.stamp||"")+"|"+(e.species||"")+"|"+(e.preset||""); }
function renderBook(){
  const b = getBook();
  if(!b.length){ $("bookOut").textContent="No entries yet."; return; }
  const lines = b.slice().reverse().slice(0,80).map(e=>{
    return [
      `- ${e.stamp}  ${e.species}/${e.preset}`,
      `  nav=${pct(e.outputs.navigation_reliability)}  compass=${pct(e.outputs.compass_confidence)}  fnr=${pct(e.outputs.false_negative_risk)}`,
      e.note ? `  note: ${e.note}` : ""
    ].filter(Boolean).join("\n");
  });
  $("bookOut").textContent = lines.join("\n\n");
}
function logRun(note){
  const base = window.__LAST;
  if(!base) return;
  const entry = JSON.parse(JSON.stringify(base.trail));
  entry.note = (note||"").trim() || null;

  const book = getBook();
  const seen = new Set(book.map(dedupKey));
  const k = dedupKey(entry);
  if(!seen.has(k)) book.push(entry);
  setBook(book);
  renderBook();
}

/* ---------- Œ© Sweep ---------- */
function omegaSweep(){
  const base = window.__LAST;
  if(!base) return;
  const presets = ["quiet","urban","storm","flare","lab","rfjam"];
  const rows = [];
  for(const pr of presets){
    const p = JSON.parse(JSON.stringify(base.p));
    p.preset = pr;
    // apply preset ‚Äúas if‚Äù (without moving UI): reuse preset logic in a tiny sandbox
    const tmp = sandboxApplyPreset(p, pr);
    const r = compute(tmp);
    rows.push({preset: pr, nav:r.nav, compass:r.compass, fnr:r.fnr, K:r.K_raw, factors:r.trail.factors});
  }
  rows.sort((a,b)=>b.nav-a.nav);

  const names = {quiet:"Quiet", urban:"Urban", storm:"Storm", flare:"Flare", lab:"Lab", rfjam:"RF Jam"};
  const lines = rows.map((r,i)=>{
    const f=r.factors;
    return `${String(i+1).padStart(2,"0")}. ${names[r.preset].padEnd(6)}  nav=${pct(r.nav)}  compass=${pct(r.compass)}  fnr=${pct(r.fnr)}  (L ${pct(f.light)} RF ${pct(f.rf)} Beh ${pct(f.behaviour)})`;
  });
  window.__SWEEP = {stamp: nowStamp(), baseline: base.trail, rows};
  $("sweepOut").textContent = lines.join("\n");
}
function sandboxApplyPreset(p, name){
  let em=p.em, rf=p.rf, an=p.anom, lint=p.lint;
  if(name==="quiet"){ em=0.15; rf=0.06; an=0.05; lint=Math.max(lint,0.60); }
  if(name==="urban"){ em=0.55; rf=0.18; an=0.12; lint=Math.max(lint,0.55); }
  if(name==="storm"){ em=0.40; rf=0.15; an=0.65; lint=Math.max(lint,0.40); }
  if(name==="flare"){ em=0.48; rf=0.22; an=0.80; lint=Math.max(lint,0.35); }
  if(name==="lab"){ em=0.02; rf=0.00; an=0.00; lint=Math.max(lint,0.75); }
  if(name==="rfjam"){ em=Math.max(em,0.22); rf=0.85; an=Math.max(an,0.10); lint=Math.max(lint,0.55); }
  p.em=em; p.rf=rf; p.anom=an; p.lint=lint;
  return p;
}

/* ---------- wiring ---------- */
function fillSpecies(){
  $("species").innerHTML = SPECIES.map(s=>`<option value="${s.id}">${s.name}</option>`).join("");
  $("species").value="robin";
}
function applySpecies(id){
  const s = SPECIES.find(x=>x.id===id) || SPECIES[0];
  setState({species:s.id, preset:$("preset").value, ...s.base});
}
function recompute(){
  const p = readState();
  const res = compute(p);
  render(res);
  updateComparePanels();
}
function updateComparePanels(){
  $("Abox").textContent = brief(window.__A);
  $("Bbox").textContent = brief(window.__B);
  $("Delta").textContent = delta(window.__A, window.__B);
}

function bindTabs(){
  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=>{
      document.querySelectorAll(".tab").forEach(x=>x.classList.remove("on"));
      document.querySelectorAll(".pane").forEach(x=>x.classList.remove("on"));
      t.classList.add("on");
      $("pane_"+t.dataset.tab).classList.add("on");
    });
  });
}

function bind(){
  const ids = ["tau","lam","sig","em","wl","lint","rf","cal","map","mot","sts","exp","B","inc","anom"];
  ids.forEach(id=>$(id).addEventListener("input", recompute));
  $("species").addEventListener("change", e=>{ applySpecies(e.target.value); recompute(); });
  $("preset").addEventListener("change", e=>{ applyPreset(e.target.value); recompute(); });
  $("run").addEventListener("click", recompute);

  $("saveA").addEventListener("click", ()=>{ window.__A = JSON.parse(JSON.stringify(window.__LAST)); updateComparePanels(); });
  $("saveB").addEventListener("click", ()=>{ window.__B = JSON.parse(JSON.stringify(window.__LAST)); updateComparePanels(); });
  $("applyA").addEventListener("click", ()=>{ if(window.__A){ setState(window.__A.p); recompute(); }});
  $("applyB").addEventListener("click", ()=>{ if(window.__B){ setState(window.__B.p); recompute(); }});
  $("exportA").addEventListener("click", ()=>{ if(window.__A) dl("qds_avian_v6_A.json", JSON.stringify(window.__A.trail,null,2)); });
  $("exportB").addEventListener("click", ()=>{ if(window.__B) dl("qds_avian_v6_B.json", JSON.stringify(window.__B.trail,null,2)); });

  $("runSens").addEventListener("click", runSensitivity);

  $("mcn").addEventListener("input", ()=>$("v_mcn").textContent = +$("mcn").value);
  $("jit").addEventListener("input", ()=>$("v_jit").textContent = fmt(+$("jit").value,2));
  $("mc").addEventListener("click", ()=>{ document.querySelector('[data-tab="mcplus"]').click(); mcPlusRun(); });
  $("mcRun").addEventListener("click", mcPlusRun);
  $("mcExport").addEventListener("click", ()=>{ if(window.__MC) dl("qds_avian_v6_mcplus.json", JSON.stringify(window.__MC,null,2)); });

  $("logRun").addEventListener("click", ()=>{ document.querySelector('[data-tab="labbook"]').click(); });
  $("logNow").addEventListener("click", ()=>{ logRun($("note").value); $("note").value=""; });

  $("exportBook").addEventListener("click", ()=> dl("qds_avian_v6_labbook.json", JSON.stringify(getBook(),null,2)));
  $("clearBook").addEventListener("click", ()=>{ if(confirm("Clear labbook local storage?")){ setBook([]); renderBook(); }});
  $("doImport").addEventListener("click", async ()=>{
    const f = $("importFile").files?.[0];
    if(!f) return alert("Pick a JSON file first.");
    const txt = await f.text();
    let incoming=[];
    try{ incoming = JSON.parse(txt); }catch{ return alert("Invalid JSON."); }
    if(!Array.isArray(incoming)) return alert("Expected an array of entries.");
    const book = getBook();
    const seen = new Set(book.map(dedupKey));
    for(const e of incoming){
      const k = dedupKey(e);
      if(!seen.has(k)){ book.push(e); seen.add(k); }
    }
    setBook(book);
    renderBook();
    alert("Imported + merged.");
  });

  $("sweep").addEventListener("click", omegaSweep);
  $("sweepExport").addEventListener("click", ()=>{ if(window.__SWEEP) dl("qds_avian_v6_omega_sweep.json", JSON.stringify(window.__SWEEP,null,2)); });

  bindTabs();
}

/* ---------- boot ---------- */
fillSpecies();
applySpecies($("species").value);
applyPreset($("preset").value);
$("v_mcn").textContent = +$("mcn").value;
$("v_jit").textContent = fmt(+$("jit").value,2);
bind();
recompute();
renderBook();


// --- qds_megasuite_onebutton_MAX.html ---

/* ===== tiny utils (ASCII-safe) ===== */
const $ = (id)=>document.getElementById(id);
const nowISO = ()=> new Date().toISOString().replace('T',' ').replace('Z','');
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const isNum=(x)=>typeof x==="number" && isFinite(x);
function logln(s){ const el=$("log"); el.textContent += s + "\n"; el.scrollTop = el.scrollHeight; }
function setStatus(ok, title, sub){
  $("statusDot").className = "dot " + (ok===true?"ok": ok===false?"bad":"");
  $("statusTitle").textContent = title;
  $("statusSub").textContent = sub || "";
}
function dl(filename, text){
  const blob = new Blob([text], {type:"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
function safeJSONParse(s){
  try{ return {ok:true, v: JSON.parse(s)}; }catch(e){ return {ok:false, err:String(e)}; }
}

/* ===== simple canvas plotter (no libs) ===== */
function plotLines(canvas, series, opts){
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  // background grid
  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 1;
  for(let i=0;i<=10;i++){
    const x = Math.round(i*W/10);
    const y = Math.round(i*H/10);
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // compute bounds
  let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
  series.forEach(s=>{
    s.xy.forEach(p=>{
      xmin=Math.min(xmin,p[0]); xmax=Math.max(xmax,p[0]);
      ymin=Math.min(ymin,p[1]); ymax=Math.max(ymax,p[1]);
    });
  });
  if(!isFinite(xmin)||!isFinite(ymin)){ return; }
  if(xmin===xmax){ xmax=xmin+1; }
  if(ymin===ymax){ ymax=ymin+1; }

  const pad = 28;
  const x2px = x => pad + (x-xmin)*(W-2*pad)/(xmax-xmin);
  const y2py = y => H-pad - (y-ymin)*(H-2*pad)/(ymax-ymin);

  // axes
  ctx.strokeStyle = "rgba(255,255,255,.65)";
  ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.moveTo(pad,pad); ctx.lineTo(pad,H-pad); ctx.lineTo(W-pad,H-pad); ctx.stroke();

  // title
  if(opts && opts.title){
    ctx.fillStyle="rgba(255,255,255,.88)";
    ctx.font="bold 18px system-ui";
    ctx.fillText(opts.title, pad, 22);
  }

  // plot
  series.forEach((s, idx)=>{
    ctx.strokeStyle = s.color || `hsl(${(idx*70)%360} 80% 65%)`;
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    s.xy.forEach((p,i)=>{
      const x=x2px(p[0]), y=y2py(p[1]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
  });

  // legend (top-right)
  ctx.font="12px ui-monospace, Menlo, Consolas";
  let lx=W-pad-6, ly=pad+10;
  series.slice(0,6).forEach((s, idx)=>{
    const col = s.color || `hsl(${(idx*70)%360} 80% 65%)`;
    ctx.fillStyle=col;
    ctx.fillRect(lx-10, ly-8, 10, 10);
    ctx.fillStyle="rgba(255,255,255,.85)";
    const t = (s.name||`S${idx+1}`).slice(0,28);
    const w = ctx.measureText(t).width;
    ctx.fillText(t, lx-14-w, ly);
    ly += 16;
  });
}

/* ===== tests (plugins) ===== */
function test_microphysics(data){
  const k = data.kernel;
  const sig2 = k.sigma2, tc = k.tau_c, lc = k.lambda_c;
  const ok = isNum(sig2)&&sig2>0 && isNum(tc)&&tc>0 && isNum(lc)&&lc>0;
  if(!ok) return {name:"Microphysics Kernel", pass:false, note:"bad params", curves:{}};

  // K(t)/sig2 = exp(-|t|/tc)
  const tmax = tc*5;
  const txy = [];
  for(let i=0;i<=200;i++){
    const t = -tmax + 2*tmax*(i/200);
    txy.push([t, Math.exp(-Math.abs(t)/tc)]);
  }
  // K(r)/sig2 = exp(-r^2/(2 lc^2))
  const rmax = lc*4;
  const rxy = [];
  for(let i=0;i<=200;i++){
    const r = 0 + rmax*(i/200);
    rxy.push([r, Math.exp(-(r*r)/(2*lc*lc))]);
  }
  return {
    name:"Microphysics Kernel",
    pass:true,
    metrics:{sigma2:sig2, tau_c:tc, lambda_c:lc},
    curves:{Kt_over_sig2:txy, Kr_over_sig2:rxy}
  };
}

// UV finiteness sanity: P(k) ~ k^-3 exp(-k/kUV). check integral I = ‚à´_{kmin}^{kmax} k^2 P(k) dk converges
function test_uv(data){
  const u = data.uv;
  const kUV = u.k_uv;
  const kmin = u.k_min, kmax = u.k_max;
  if(!(isNum(kUV)&&kUV>0&&isNum(kmin)&&kmin>0&&isNum(kmax)&&kmax>kmin)) {
    return {name:"UV Finiteness", pass:false, note:"bad params", curves:{}};
  }
  function P(k){ return Math.pow(k,-3) * Math.exp(-k/kUV); }
  // numeric trapezoid
  const N=600;
  let I=0;
  const xy=[];
  let prevK=kmin, prevF = (prevK*prevK)*P(prevK);
  for(let i=1;i<=N;i++){
    const k = kmin + (kmax-kmin)*(i/N);
    const f = (k*k)*P(k);
    I += 0.5*(f+prevF)*(k-prevK);
    if(i%10===0) xy.push([k, I]);
    prevK=k; prevF=f;
  }
  // pass if tail contribution is small-ish
  const tailStart = kmax*0.8;
  let Itail=0;
  prevK=tailStart; prevF=(prevK*prevK)*P(prevK);
  for(let i=1;i<=N;i++){
    const k = tailStart + (kmax-tailStart)*(i/N);
    const f=(k*k)*P(k);
    Itail += 0.5*(f+prevF)*(k-prevK);
    prevK=k; prevF=f;
  }
  const fracTail = Itail / (I||1);
  const pass = fracTail < u.tail_frac_max;
  return {
    name:"UV Finiteness",
    pass,
    metrics:{k_uv:kUV, I:I, tailFrac:fracTail},
    curves:{I_of_k:xy},
    note: pass ? "convergent" : "tail too large (increase k_max or reduce tail_frac_max)"
  };
}

function test_h0(data){
  const h = data.h0;
  const A=h.A, p=h.p, tol=h.tol_frac;
  if(!(isNum(A)&&A>0&&isNum(p)&&p>0&&isNum(tol)&&tol>0)) return {name:"H0 Variance", pass:false, note:"bad params", curves:{}};

  const rows = h.samples || [];
  let passCount=0;
  const xyPred=[], xyObs=[];
  rows.forEach(r=>{
    const R=r.R_mpc, obs=r.sig_over_H;
    const pred = A*Math.pow(R,-p);
    xyPred.push([R, pred]);
    xyObs.push([R, obs]);
    const rel = Math.abs(obs-pred)/Math.max(pred,1e-12);
    if(rel <= tol) passCount++;
  });
  const pass = passCount === rows.length && rows.length>0;
  return {
    name:"H0 Variance",
    pass,
    metrics:{A:A, p:p, tolFrac:tol, passN:passCount, N:rows.length},
    curves:{pred:xyPred, obs:xyObs},
    note: pass ? "within tolerance" : "one or more points out of band"
  };
}

function test_rotation(data){
  const g = data.rotation;
  const a=g.alpha, lc=g.lambda_c_kpc, tol=g.tol_frac;
  const pts = g.points || [];
  if(!(isNum(a)&&isNum(lc)&&lc>0&&isNum(tol)&&tol>0) || pts.length===0) return {name:"Rotation Curves", pass:false, note:"bad params", curves:{}};

  const xyN=[], xyQ=[];
  let passN=0;
  pts.forEach(p=>{
    const r=p.r_kpc, vN=p.vN, vObs=p.vObs;
    const vQ = vN*Math.sqrt(1 + a*Math.exp(-r/lc));
    xyN.push([r, vN]);
    xyQ.push([r, vQ]);
    const rel = Math.abs(vQ - vObs)/Math.max(vObs,1e-12);
    if(rel <= tol) passN++;
  });
  const pass = passN === pts.length;
  return {
    name:"Rotation Curves",
    pass,
    metrics:{alpha:a, lambda_c_kpc:lc, tolFrac:tol, passN:passN, N:pts.length},
    curves:{newton:xyN, qds:xyQ},
    note: pass ? "fits within tol (sanity)" : "outside tol (tweak alpha/lambda or use real galaxy data)"
  };
}

// Pulsar constraint proxy: same idea as your one-button suite (amax vs lambda envelope)
// simplified f(r,lambda)= (1+r/lambda)e^{-r/lambda}, amax = band/|f|
function test_pulsar(data){
  const ps = data.pulsar;
  const lamGrid = ps.lambda_grid || {log10_min:-3, log10_max:3, points:140};
  const systems = ps.systems || [];
  const eps = ps.edge_eps || 2e-6;

  function f(r, lam){
    if(lam<=0 || r<0) return NaN;
    if(r===0) return 1;
    const x=r/lam;
    return (1+x)*Math.exp(-x);
  }
  function amaxAllowed(r, band, lam){
    const fv=f(r,lam);
    const denom=Math.max(Math.abs(fv), eps);
    return band/denom;
  }

  const curves={};
  const env=[];
  const lamList=[];
  for(let i=0;i<lamGrid.points;i++){
    const t = i/(lamGrid.points-1);
    const log10 = lamGrid.log10_min + (lamGrid.log10_max-lamGrid.log10_min)*t;
    const lam = Math.pow(10, log10);
    lamList.push({log10, lam});
    // envelope = min amax across systems
    let amin=Infinity;
    systems.forEach(s=>{
      const amax = amaxAllowed(s.r, s.band, lam);
      amin = Math.min(amin, amax);
    });
    env.push([log10, Math.log10(amin)]);
  }
  // per system curve
  systems.forEach((s,idx)=>{
    const xy=[];
    lamList.forEach(L=>{
      const amax=amaxAllowed(s.r, s.band, L.lam);
      xy.push([L.log10, Math.log10(amax)]);
    });
    curves["sys_"+idx]=xy;
  });

  // pass criterion here is only ‚Äúcomputed + sane monotonic-ish‚Äù
  let monotonicOK=true;
  for(let i=1;i<env.length;i++){
    if(env[i][1] > env[i-1][1] + 1e-6){ monotonicOK=false; break; } // should generally decrease with lambda
  }
  return {
    name:"Binary/Pulsar Constraint Proxy",
    pass: monotonicOK && systems.length>0,
    metrics:{systemsN:systems.length, gridN:lamGrid.points, edge_eps:eps},
    curves:{envelope:env, perSystem:curves},
    note: "sanity proxy (not full timing-model fit)"
  };
}

function test_bird(data){
  const b = data.bird;
  const cohorts = b.cohorts || [];
  if(cohorts.length===0) return {name:"Bird Migration Coherence", pass:false, note:"no cohorts", curves:{}};

  // coherence metric: compare time series of daily distance (or heading proxy) via correlation
  function corr(a,b){
    const n=Math.min(a.length,b.length);
    if(n<3) return NaN;
    let ma=0,mb=0;
    for(let i=0;i<n;i++){ ma+=a[i]; mb+=b[i]; }
    ma/=n; mb/=n;
    let num=0,da=0,db=0;
    for(let i=0;i<n;i++){
      const xa=a[i]-ma, xb=b[i]-mb;
      num += xa*xb; da += xa*xa; db += xb*xb;
    }
    return num/Math.sqrt((da*db)||1e-12);
  }

  // use first as reference
  const ref = cohorts[0];
  const xy=[];
  let passN=0;
  for(let i=0;i<cohorts.length;i++){
    const c = cohorts[i];
    const r = corr(ref.series, c.series);
    xy.push([i, r]);
    if(r >= b.min_corr) passN++;
  }
  const pass = passN === cohorts.length;
  return {
    name:"Bird Migration Coherence",
    pass,
    metrics:{minCorr:b.min_corr, passN:passN, N:cohorts.length},
    curves:{corrByCohort:xy},
    note: pass ? "coherent vs ref" : "drift/anomaly flagged"
  };
}

/* ===== self-tests ===== */
function runSelfTests(){
  const out=[];
  function ok(name, cond){ out.push({name, pass:!!cond}); }

  ok("exp(-0.1) approx", Math.abs(Math.exp(-0.1)-0.904837)<1e-6);
  // correlation sanity
  const a=[1,2,3,4], b=[1,2,3,4], c=[4,3,2,1];
  function corr(a,b){
    let n=Math.min(a.length,b.length), ma=0,mb=0;
    for(let i=0;i<n;i++){ma+=a[i];mb+=b[i];}
    ma/=n;mb/=n;
    let num=0,da=0,db=0;
    for(let i=0;i<n;i++){
      const xa=a[i]-ma, xb=b[i]-mb;
      num+=xa*xb; da+=xa*xa; db+=xb*xb;
    }
    return num/Math.sqrt((da*db)||1e-12);
  }
  ok("corr identical ~1", Math.abs(corr(a,b)-1)<1e-9);
  ok("corr reversed ~-1", Math.abs(corr(a,c)+1)<1e-9);

  // pulsar f(r,lam) boundary
  function f(r,lam){ if(lam<=0||r<0) return NaN; if(r===0) return 1; const x=r/lam; return (1+x)*Math.exp(-x); }
  ok("pulsar f(r=0)=1", f(0,1)===1);
  ok("pulsar negative lam -> NaN", Number.isNaN(f(1,-1)));

  return out;
}

/* ===== defaults ===== */
function defaults(){
  return {
    kernel:{ sigma2:0.27, tau_c:0.35, lambda_c:2.4 },
    uv:{ k_uv:40, k_min:1e-3, k_max:2e3, tail_frac_max:0.01 },
    h0:{
      A:0.017, p:0.35, tol_frac:0.35,
      samples:[
        {R_mpc:5,  sig_over_H:0.011},
        {R_mpc:10, sig_over_H:0.009},
        {R_mpc:20, sig_over_H:0.007},
        {R_mpc:50, sig_over_H:0.005},
        {R_mpc:100,sig_over_H:0.004}
      ]
    },
    rotation:{
      alpha:0.8, lambda_c_kpc:10, tol_frac:0.20,
      points:[
        {r_kpc:2,  vN:90,  vObs:130},
        {r_kpc:5,  vN:120, vObs:160},
        {r_kpc:10, vN:150, vObs:175},
        {r_kpc:15, vN:160, vObs:180},
        {r_kpc:25, vN:165, vObs:185}
      ]
    },
    pulsar:{
      edge_eps:2e-6,
      lambda_grid:{log10_min:-3, log10_max:3, points:140},
      systems:[
        {name:"PSR B1913+16 (demo)", r:1.0,  band:0.0020},
        {name:"Double Pulsar J0737-3039 (demo)", r:0.6, band:0.0015},
        {name:"PSR J0348+0432 (demo)", r:0.25, band:0.0010},
        {name:"PSR J1738+0333 (demo)", r:0.35, band:0.0012}
      ]
    },
    bird:{
      min_corr:0.88,
      cohorts:[
        {name:"Cohort A (ref)", series:[10,12,15,18,25,30,40,55,60,62]},
        {name:"Cohort B",       series:[9,11,16,19,24,31,39,54,61,63]},
        {name:"Cohort C",       series:[10,13,14,18,26,29,41,56,59,61]}
      ]
    }
  };
}

/* ===== main run ===== */
let LAST_REPORT = null;

function makeTable(results){
  const rows=[];
  rows.push("<tr><th>Test</th><th>Pass</th><th>Key metrics</th><th>Note</th></tr>");
  results.forEach(r=>{
    const p = r.pass ? "‚úÖ" : "‚ùå";
    const m = r.metrics ? Object.keys(r.metrics).slice(0,6).map(k=>`${k}=${fmt(r.metrics[k])}`).join(" ‚Ä¢ ") : "";
    rows.push(`<tr><td>${esc(r.name)}</td><td>${p}</td><td>${esc(m)}</td><td>${esc(r.note||"")}</td></tr>`);
  });
  $("tbl").innerHTML = rows.join("");
}
function esc(s){ return String(s).replace(/[&<>"]/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[c])); }
function fmt(x){
  if(typeof x==="number"){
    if(!isFinite(x)) return "NaN";
    if(Math.abs(x)>=1000 || Math.abs(x)<1e-3) return x.toExponential(3);
    return x.toFixed(6).replace(/\.?0+$/,"");
  }
  return String(x);
}

function exportCSV(report){
  // flatten curves to csv: test, curve, x, y
  let out="test,curve,x,y\n";
  report.results.forEach(r=>{
    if(!r.curves) return;
    Object.keys(r.curves).forEach(k=>{
      const v=r.curves[k];
      // nested map for pulsar perSystem
      if(k==="perSystem" && v && typeof v==="object"){
        Object.keys(v).forEach(sysKey=>{
          (v[sysKey]||[]).forEach(p=>{ out += `${csv(r.name)},${csv(sysKey)},${p[0]},${p[1]}\n`; });
        });
      } else if(Array.isArray(v)){
        v.forEach(p=>{ out += `${csv(r.name)},${csv(k)},${p[0]},${p[1]}\n`; });
      }
    });
  });
  return out;
}
function csv(s){ return `"${String(s).replace(/"/g,'""')}"`; }

function runMegaSuite(){
  $("log").textContent = "";
  setStatus(null, "Running‚Ä¶", "One button. No excuses.");
  logln("=== QDS MEGA SUITE ‚Ä¢ One-Button MAX ===");
  logln("Time: " + nowISO());

  const parsed = safeJSONParse($("dataBox").value);
  if(!parsed.ok){
    setStatus(false, "Bad JSON", parsed.err);
    logln("‚ùå JSON parse error: " + parsed.err);
    return;
  }
  const data = parsed.v;

  const results=[];
  const t0 = performance.now();

  // run tests
  const rMicro = test_microphysics(data); results.push(rMicro);
  const rUV    = test_uv(data);          results.push(rUV);
  const rH0    = test_h0(data);          results.push(rH0);
  const rRot   = test_rotation(data);    results.push(rRot);
  const rP     = test_pulsar(data);      results.push(rP);
  const rBird  = test_bird(data);        results.push(rBird);

  const passN = results.filter(x=>x.pass).length;
  const failN = results.length - passN;

  // plots
  if(rMicro.curves && rMicro.curves.Kt_over_sig2){
    plotLines($("cvKernelT"), [{name:"K(t)/sigma2", xy:rMicro.curves.Kt_over_sig2}], {title:"Kernel temporal factor"});
  }
  if(rMicro.curves && rMicro.curves.Kr_over_sig2){
    plotLines($("cvKernelR"), [{name:"K(r)/sigma2", xy:rMicro.curves.Kr_over_sig2}], {title:"Kernel spatial factor"});
  }
  if(rUV.curves && rUV.curves.I_of_k){
    plotLines($("cvUV"), [{name:"I(k) cumulative", xy:rUV.curves.I_of_k}], {title:"UV finiteness: cumulative integral"});
  }
  if(rH0.curves){
    plotLines($("cvH0"), [
      {name:"pred", xy:rH0.curves.pred},
      {name:"obs",  xy:rH0.curves.obs}
    ], {title:"H0 variance: pred vs obs"});
  }
  if(rRot.curves){
    plotLines($("cvRot"), [
      {name:"Newtonian vN", xy:rRot.curves.newton},
      {name:"QDS vQDS",     xy:rRot.curves.qds}
    ], {title:"Rotation: v(r) sanity"});
  }
  if(rP.curves){
    const series=[];
    // show 3 sys max to avoid clutter
    if(rP.curves.perSystem){
      const keys = Object.keys(rP.curves.perSystem).slice(0,3);
      keys.forEach((k,idx)=>{
        series.push({name:"sys "+(idx+1), xy:rP.curves.perSystem[k]});
      });
    }
    series.push({name:"envelope", xy:rP.curves.envelope});
    plotLines($("cvPulsar"), series, {title:"Pulsar proxy: log10(amax) vs log10(lambda)"});
  }
  if(rBird.curves && rBird.curves.corrByCohort){
    plotLines($("cvBird"), [{name:"corr vs cohort index", xy:rBird.curves.corrByCohort}], {title:"Bird coherence: correlation to ref"});
  }

  makeTable(results);

  const dt = performance.now()-t0;
  logln("");
  logln("Results: PASS " + passN + " / " + results.length + " ‚Ä¢ FAIL " + failN);
  logln("Runtime: " + dt.toFixed(1) + " ms");

  LAST_REPORT = {
    title:"QDS MEGA SUITE ‚Ä¢ One-Button MAX",
    time: nowISO(),
    pass: passN, fail: failN,
    results: results,
    data: data
  };

  if(failN===0) setStatus(true, "MEGA SUITE PASS ‚úÖ", "All tests passed (sanity-grade).");
  else setStatus(false, "MEGA SUITE FAIL ‚ùå", failN + " test(s) failed. Fix params or data.");
}

/* ===== wire buttons ===== */
$("btnDefaults").onclick = ()=>{ $("dataBox").value = JSON.stringify(defaults(), null, 2); logln("Loaded defaults."); };
$("btnSave").onclick = ()=>{ localStorage.setItem("QDS_MEGA_DATA", $("dataBox").value); logln("Saved dataset to localStorage."); };
$("btnLoad").onclick = ()=>{
  const s=localStorage.getItem("QDS_MEGA_DATA");
  if(s){ $("dataBox").value=s; logln("Loaded dataset from localStorage."); }
  else logln("No saved dataset found.");
};
$("btnClear").onclick = ()=>{ $("log").textContent=""; $("tbl").innerHTML=""; setStatus(null,"Ready","Cleared."); };

$("btnRun").onclick = runMegaSuite;

$("btnSelf").onclick = ()=>{
  const tests = runSelfTests();
  $("log").textContent="";
  logln("=== SELF-TEST SUITE ===");
  let pass=0;
  tests.forEach(t=>{
    logln((t.pass?"‚úÖ ":"‚ùå ") + t.name);
    if(t.pass) pass++;
  });
  const fail = tests.length-pass;
  logln("");
  logln("Self-tests: " + pass + " pass, " + fail + " fail");
  setStatus(fail===0, fail===0 ? "Self-tests PASS ‚úÖ" : "Self-tests FAIL ‚ùå", "");
};

$("btnExportJSON").onclick = ()=>{
  if(!LAST_REPORT){ logln("Nothing to export yet. Run the suite first."); return; }
  dl("qds_megasuite_report_"+new Date().toISOString().slice(0,10)+".json", JSON.stringify(LAST_REPORT, null, 2));
};

$("btnExportCSV").onclick = ()=>{
  if(!LAST_REPORT){ logln("Nothing to export yet. Run the suite first."); return; }
  dl("qds_megasuite_curves_"+new Date().toISOString().slice(0,10)+".csv", exportCSV(LAST_REPORT));
};

// boot
$("dataBox").value = JSON.stringify(defaults(), null, 2);
setStatus(null,"Ready","Defaults loaded. Push RUN.");


// --- physorg_news_dashboard.html ---

const $ = (id)=>document.getElementById(id);

const BASE = "/news_rips/physorg/";
const DEFAULT_DATE = new URLSearchParams(location.search).get("date") || new Date().toISOString().slice(0,10);

const state = {
  manifest: null,
  dateA: DEFAULT_DATE,
  dateB: DEFAULT_DATE,
  mode: "single",
  cat: "",
  q: "",
  sort: "new",
  itemsA: [],
  itemsB: []
};

// Quick bias heuristic by category keywords (adjust as you like)
function biasTag(categoriesText){
  const t = (categoriesText||"").toLowerCase();
  if (/(business|economics|finance|policy|social|education|psychology|politics)/.test(t)) return "bad";
  if (/(archaeology|history|culture|society)/.test(t)) return "mid";
  return "good";
}

function safeText(s){ return (s||"").replace(/\s+/g," ").trim(); }

function parseDate(d){
  // RSS pubDate is a string; keep as string for display, but also try Date parse for sorting
  const dt = new Date(d);
  return isNaN(dt.getTime()) ? null : dt;
}

async function fetchJSON(url){
  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  return await res.json();
}

async function loadManifest(){
  // We generate this with a bash script below; if missing, we fall back to just DEFAULT_DATE.
  try{
    const m = await fetchJSON(BASE + "manifest.json?x=" + Date.now());
    state.manifest = m;
    $("pillStatus").textContent = "online";
    $("pillStatus").style.borderColor = "rgba(99,255,182,.35)";
    $("pillStatus").style.color = "#bfffe2";
    $("subHint").textContent = `Last refresh: ${m.last_run || "unknown"} ¬∑ Dates: ${m.dates?.length || 0}`;
  }catch(e){
    state.manifest = null;
    $("pillStatus").textContent = "manifest missing";
    $("pillStatus").style.borderColor = "rgba(255,204,102,.35)";
    $("pillStatus").style.color = "#ffe1a6";
    $("subHint").textContent = `Tip: create manifest.json via Termux refresh script. Using date=${state.dateA}.`;
  }
}

function fillDateSelect(sel, dates, selected){
  sel.innerHTML = "";
  for(const d of dates){
    const opt = document.createElement("option");
    opt.value = d;
    opt.textContent = d;
    if(d === selected) opt.selected = true;
    sel.appendChild(opt);
  }
}

async function loadDate(dateStr){
  const url = `${BASE}${dateStr}/MASTER.json?x=${Date.now()}`;
  return await fetchJSON(url);
}

function unionCategories(items){
  const set = new Set();
  for(const it of items){
    (it.categories||[]).forEach(c=> set.add(c));
  }
  return Array.from(set).sort((a,b)=>a.localeCompare(b));
}

function getCatKey(it){
  const cats = (it.categories||[]);
  return cats.length ? cats[0] : "Uncategorised";
}

function applyFilters(items){
  const q = state.q.trim().toLowerCase();
  const cat = state.cat;
  let out = items;

  if(cat){
    out = out.filter(it => (it.categories||[]).includes(cat));
  }
  if(q){
    out = out.filter(it => {
      const t = (it.title||"").toLowerCase();
      const d = (it.description||"").toLowerCase();
      const c = (it.categories||[]).join(" ").toLowerCase();
      return t.includes(q) || d.includes(q) || c.includes(q);
    });
  }

  // sort
  const sort = state.sort;
  out = out.slice();
  if(sort==="az"){
    out.sort((a,b)=> (a.title||"").localeCompare(b.title||""));
  }else{
    out.sort((a,b)=>{
      const da = parseDate(a.pubDate) || new Date(0);
      const db = parseDate(b.pubDate) || new Date(0);
      return (sort==="new") ? (db-da) : (da-db);
    });
  }
  return out;
}

function renderList(items, itemsB=null){
  const list = $("list");
  list.innerHTML = "";

  // Compare mode: mark items new in A vs B (by link)
  const bLinks = new Set((itemsB||[]).map(x=>x.link).filter(Boolean));

  for(const it of items){
    const cats = (it.categories||[]);
    const catsText = cats.join(", ");
    const tag = biasTag(catsText);
    const isNew = itemsB ? !bLinks.has(it.link) : false;

    const card = document.createElement("div");
    card.className = "card";

    const h = safeText(it.title);
    const link = it.link || "#";
    const pub = safeText(it.pubDate);

    const badge = document.createElement("span");
    badge.className = `tag ${tag}`;
    badge.textContent = tag==="good" ? "low framing" : tag==="mid" ? "mid framing" : "high framing";

    const newb = document.createElement("span");
    newb.className = "tag";
    newb.style.borderColor = "rgba(102,227,255,.35)";
    newb.style.color = "#c8f4ff";
    newb.textContent = "new vs B";

    card.innerHTML = `
      <div class="row">
        <div style="min-width:0">
          <p class="headline"><a href="${link}" target="_blank" rel="noopener">${h}</a></p>
          <div class="meta">
            <span class="tag">${pub || "‚Äî"}</span>
            ${(cats||[]).slice(0,4).map(c=>`<span class="tag">${c}</span>`).join("")}
          </div>
        </div>
        <div style="display:flex; flex-direction:column; gap:8px; align-items:flex-end">
        </div>
      </div>
      <p class="desc">${safeText(it.description) || ""}</p>
    `;

    const right = card.querySelector(".row > div:last-child");
    right.appendChild(badge);
    if(isNew) right.appendChild(newb);

    list.appendChild(card);
  }
}

function renderBars(items){
  const bars = $("bars");
  bars.innerHTML = "";

  const counts = new Map();
  for(const it of items){
    const k = getCatKey(it);
    counts.set(k, (counts.get(k)||0)+1);
  }
  const arr = Array.from(counts.entries()).sort((a,b)=>b[1]-a[1]);
  const top = arr[0] ? `${arr[0][0]} (${arr[0][1]})` : "‚Äî";
  $("kTop").textContent = top;

  const max = arr[0] ? arr[0][1] : 1;
  for(const [name, n] of arr.slice(0,14)){
    const row = document.createElement("div");
    row.className = "bar";
    const pct = Math.round((n/max)*100);
    row.innerHTML = `
      <div>
        <div class="barname">${name}</div>
        <div class="small">${n} item(s)</div>
        <div class="barline"><div class="fill" style="width:${pct}%; background: linear-gradient(90deg, rgba(102,227,255,.9), rgba(99,255,182,.9));"></div></div>
      </div>
      <div style="text-align:right; font-weight:900; color:#cfe0ff">${pct}%</div>
    `;
    bars.appendChild(row);
  }
}

function renderCategorySelect(cats){
  const sel = $("selCat");
  const current = state.cat;
  sel.innerHTML = `<option value="">All</option>` + cats.map(c=>`<option value="${c}">${c}</option>`).join("");
  if(current) sel.value = current;
}

async function refreshData(){
  $("pillStatus").textContent = "loading‚Ä¶";
  $("pillStatus").style.borderColor = "rgba(102,227,255,.35)";
  $("pillStatus").style.color = "#c8f4ff";

  const dateA = $("selDate").value;
  const mode = $("selMode").value;
  const dateB = $("selDateB").value;

  state.dateA = dateA;
  state.mode = mode;
  state.dateB = dateB;

  // load A always
  state.itemsA = await loadDate(state.dateA);

  // load B if compare
  state.itemsB = (state.mode==="compare") ? await loadDate(state.dateB) : [];

  const cats = unionCategories(state.itemsA.concat(state.itemsB));
  renderCategorySelect(cats);

  // Apply filters on A
  state.cat = $("selCat").value;
  state.q = $("q").value || "";
  state.sort = $("selSort").value;

  const filteredA = applyFilters(state.itemsA);
  const compareItemsB = (state.mode==="compare") ? state.itemsB : null;

  $("hMain").textContent = state.mode==="compare"
    ? `Compare: ${state.dateA} (A) vs ${state.dateB} (B)`
    : `Feed: ${state.dateA}`;

  $("kItems").textContent = filteredA.length;
  $("kCats").textContent = cats.length;
  $("kQuery").textContent = (state.cat || state.q) ? `${state.cat || "All"} ¬∑ ${state.q || "‚Äî"}` : "‚Äî";

  renderList(filteredA, compareItemsB);
  renderBars(filteredA);

  $("pillStatus").textContent = "ready";
  $("pillStatus").style.borderColor = "rgba(99,255,182,.35)";
  $("pillStatus").style.color = "#bfffe2";

  // Update URL date param
  const u = new URL(location.href);
  u.searchParams.set("date", state.dateA);
  history.replaceState({}, "", u.toString());
}

function setupUI(){
  $("selMode").addEventListener("change", ()=>{
    const mode = $("selMode").value;
    $("ctrlCompare").style.display = (mode==="compare") ? "" : "none";
    refreshData().catch(err=>alert(err.message));
  });

  $("selDate").addEventListener("change", ()=>refreshData().catch(err=>alert(err.message)));
  $("selDateB").addEventListener("change", ()=>refreshData().catch(err=>alert(err.message)));
  $("selCat").addEventListener("change", ()=>refreshData().catch(err=>alert(err.message)));
  $("selSort").addEventListener("change", ()=>refreshData().catch(err=>alert(err.message)));

  let t=null;
  $("q").addEventListener("input", ()=>{
    clearTimeout(t);
    t = setTimeout(()=>refreshData().catch(err=>alert(err.message)), 180);
  });

  $("btnReload").addEventListener("click", ()=>refreshData().catch(err=>alert(err.message)));

  $("btnOpenFolder").addEventListener("click", ()=>{
    // open the folder listing for the date (python http.server directory listing)
    const url = `${location.origin}${BASE}${$("selDate").value}/`;
    window.open(url, "_blank");
  });
}

(async function main(){
  setupUI();
  await loadManifest();

  const dates = (state.manifest && Array.isArray(state.manifest.dates) && state.manifest.dates.length)
    ? state.manifest.dates
    : [DEFAULT_DATE];

  // Prefer latest date from manifest
  const latest = dates[0] || DEFAULT_DATE;

  state.dateA = dates.includes(DEFAULT_DATE) ? DEFAULT_DATE : latest;
  state.dateB = latest;

  fillDateSelect($("selDate"), dates, state.dateA);
  fillDateSelect($("selDateB"), dates, state.dateB);

  await refreshData();
})();


// --- physorg_qds_triage.html ---

/* ===========================
   QDS ‚Ä¢ News Triage Vault
   v2 Backtest + Graph
   =========================== */

const ROOT = "/news_rips/physorg";
const MASTER = "MASTER.json";

const LS_TRIAGE = "QDS_TRIAGE_MAP_v2";
const LS_BT     = "QDS_TRIAGE_BACKTEST_v2";

const $ = (id)=>document.getElementById(id);
const nowIso = ()=> new Date().toISOString();

function setStatus(t){ $("status").textContent = t; }

function safeJSON(x, fallback){
  try{ return JSON.parse(x); }catch{ return fallback; }
}

function loadTriage(){
  return safeJSON(localStorage.getItem(LS_TRIAGE)||"{}", {});
}
function saveTriage(map){
  localStorage.setItem(LS_TRIAGE, JSON.stringify(map));
}
function loadBT(){
  return safeJSON(localStorage.getItem(LS_BT)||"[]", []);
}
function saveBT(arr){
  localStorage.setItem(LS_BT, JSON.stringify(arr));
}

function itemId(it){
  return it.id || it.guid || it.link || (it.title||"")+"|"+(it.pubDate||it.date||"");
}

async function fetchJSON(url){
  const r = await fetch(url, {cache:"no-store"});
  if(!r.ok) throw new Error("HTTP "+r.status);
  return await r.json();
}

async function headOK(url){
  try{
    const r = await fetch(url, {method:"HEAD", cache:"no-store"});
    return r.ok;
  }catch(e){ return false; }
}

function parseDateFoldersFromDirListing(html){
  // python http.server directory listing contains href="2025-12-14/"
  const re = /href="(\d{4}-\d{2}-\d{2})\/"/g;
  const out = [];
  let m;
  while((m = re.exec(html))){ out.push(m[1]); }
  // unique, sorted desc
  return Array.from(new Set(out)).sort((a,b)=> b.localeCompare(a));
}

async function discoverDates(maxDays){
  // Try directory listing first (fast)
  try{
    const r = await fetch(ROOT + "/", {cache:"no-store"});
    if(r.ok){
      const html = await r.text();
      const got = parseDateFoldersFromDirListing(html);
      if(got.length) return got.slice(0, maxDays);
    }
  }catch(e){}
  // Fallback: probe backwards day-by-day
  const out = [];
  const today = new Date();
  for(let i=0;i<maxDays;i++){
    const dt = new Date(today.getTime() - i*86400000);
    const y = dt.getFullYear();
    const m = String(dt.getMonth()+1).padStart(2,"0");
    const d = String(dt.getDate()).padStart(2,"0");
    const key = `${y}-${m}-${d}`;
    const ok = await headOK(`${ROOT}/${key}/${MASTER}`);
    if(ok) out.push(key);
  }
  return out;
}

function normalizeItems(master){
  // Be forgiving: different rippers name arrays differently
  return master.items || master.articles || master.news || master.feed || [];
}

/* ---------- triage logic (manual) ---------- */
function setBucket(triageMap, id, bucket){
  if(!triageMap[id]) triageMap[id] = {bucket:"", notes:"", ts:Date.now()};
  triageMap[id].bucket = bucket;
  triageMap[id].ts = Date.now();
}
function setNotes(triageMap, id, notes){
  if(!triageMap[id]) triageMap[id] = {bucket:"", notes:"", ts:Date.now()};
  triageMap[id].notes = notes;
  triageMap[id].ts = Date.now();
}

/* ---------- backtest scoring ---------- */
function scoreStory(it, mode, harsh){
  // You can tune this battery anytime. This aims to be useful + stable.
  const t = (it.title||"").toLowerCase();
  const d = (it.description||"").toLowerCase();
  const c = (it.category||"").toLowerCase();
  const s = (t+" "+d+" "+c);

  // base signals (QDS-adjacent themes)
  const sig = [
    {re:/correlat|coheren|kernel|memory|lindblad|decoher|stochastic|noise|variance|entropy|information|mutual information/, w:2.0},
    {re:/gravity|cosmolog|hubble|galaxy|rotation|lens|dark (matter|energy)|vacuum|spacetime|metric/, w:1.8},
    {re:/quantum|superconduct|spin|magnet|phonon|topolog|metamaterial|nanopore|ion|electrolyte|battery/, w:1.6},
    {re:/turbulence|plasma|mhd|fusion|instabil|feedback|control|spectrum|psd|noise floor/, w:1.4},
    {re:/compress|codec|signal processing|error[- ]correction|bandwidth|fisher|likelihood/, w:1.3},
  ];

  // mode bias: keep it gentle, not brittle
  let modeBoost = 0.0;
  const mm = (mode||"All").toLowerCase();
  if(mm !== "all"){
    if(c.includes(mm) || t.includes(mm)) modeBoost += 0.4;
  }

  let score = modeBoost;
  for(const k of sig){
    if(k.re.test(s)) score += k.w;
  }

  // Harshness ‚Üí thresholds (loose=low threshold; strict=high)
  // map harsh 0..100 to thresholds roughly 1.8..4.4
  const vsTh   = 1.8 + (harsh/100)*2.6;
  const compTh = vsTh - 0.9; // complement if medium signal

  if(score >= vsTh) return {label:"vs", score};
  if(score >= compTh) return {label:"complement", score};
  return {label:"", score};
}

/* ---------- rendering ---------- */
let triageMap = loadTriage();
let btHistory = loadBT();

let dates = [];
let currentMaster = null;
let currentDate = null;

function renderCounts(items){
  const total = items.length;
  let vs=0, comp=0, broken=0, untri=0;
  for(const it of items){
    const id = itemId(it);
    const tr = triageMap[id];
    const b = tr?.bucket || (it.triage||it.bucket||"");
    if(b==="vs") vs++;
    else if(b==="complement") comp++;
    else if(b==="broken") broken++;
    else untri++;
  }
  $("counts").innerHTML = `
    <span class="count">Items: <b>${total}</b></span>
    <span class="count">vs: <b>${vs}</b></span>
    <span class="count">complements: <b>${comp}</b></span>
    <span class="count">broken?: <b>${broken}</b></span>
    <span class="count">untriaged: <b>${untri}</b></span>
  `;
}

function pickBucketTag(it){
  const id = itemId(it);
  const tr = triageMap[id];
  const b = tr?.bucket || it.triage || it.bucket || "";
  if(b==="vs") return {text:"QDS vs MAINSTREAM", color:"var(--glow2)"};
  if(b==="complement") return {text:"Complements", color:"var(--good)"};
  if(b==="broken") return {text:"Broken?", color:"var(--bad)"};
  return {text:"", color:"rgba(255,255,255,.25)"};
}

function renderList(){
  if(!currentMaster){ $("list").innerHTML = ""; return; }
  const mode = $("modeSel").value;
  const bucket = $("bucketSel").value;
  const q = ($("q").value||"").trim().toLowerCase();
  const sort = $("sortSel").value;
  const limit = Number($("limitSel").value || 500);

  let items = normalizeItems(currentMaster).slice();

  // mode filter (light)
  if(mode !== "All"){
    items = items.filter(it=>{
      const cat = (it.category||"").toLowerCase();
      const title = (it.title||"").toLowerCase();
      return cat.includes(mode.toLowerCase()) || title.includes(mode.toLowerCase());
    });
  }

  // bucket filter
  if(bucket !== "All"){
    items = items.filter(it=>{
      const id = itemId(it);
      const b = (triageMap[id]?.bucket || it.triage || it.bucket || "");
      if(bucket === "untriaged") return !b;
      return b === bucket;
    });
  }

  // search filter (title/category/description/notes)
  if(q){
    items = items.filter(it=>{
      const id = itemId(it);
      const note = (triageMap[id]?.notes||"").toLowerCase();
      const s = ((it.title||"")+" "+(it.category||"")+" "+(it.description||"")+" "+note).toLowerCase();
      return s.includes(q);
    });
  }

  // sort by date where possible
  function toTime(it){
    const raw = it.pubDate || it.date || it.published || it.updated || "";
    const t = Date.parse(raw);
    return isNaN(t) ? 0 : t;
  }
  items.sort((a,b)=>{
    const ta=toTime(a), tb=toTime(b);
    return sort==="newest" ? (tb-ta) : (ta-tb);
  });

  // limit
  items = items.slice(0, limit);

  renderCounts(items);
  $("queryEcho").textContent = q ? q : "‚Äî";
  $("loadedEcho").textContent = `${currentDate} ‚Ä¢ mode=${mode} ‚Ä¢ bucket=${bucket} ‚Ä¢ showing=${items.length}`;

  const html = items.map(it=>{
    const id = itemId(it);
    const title = it.title || "(untitled)";
    const desc = it.description || "";
    const link = it.link || it.url || "";
    const cat = it.category || "";
    const date = it.pubDate || it.date || it.published || "";
    const tag = pickBucketTag(it);
    const note = triageMap[id]?.notes || "";

    const tagHTML = tag.text ? `<span class="tag" style="border-color:${tag.color};color:${tag.color};background:rgba(255,179,0,.08)">${tag.text}</span>` : "";

    return `
      <div class="card" data-id="${escapeAttr(id)}">
        <div class="cardTop">
          <div style="flex:1;min-width:240px">
            <p class="title">${escapeHTML(title)}</p>
          </div>
          ${tagHTML}
        </div>

        <div class="meta">
          ${date ? `<span class="pill">${escapeHTML(date)}</span>` : ``}
          ${cat ? `<span class="pill">${escapeHTML(cat)}</span>` : ``}
          ${link ? `<span class="pill">phys.org</span>` : ``}
        </div>

        ${desc ? `<p class="desc">${escapeHTML(desc)}</p>` : ``}

        <div class="actions">
          <button class="btn primary" data-act="vs">QDS vs</button>
          <button class="btn good" data-act="complement">Complements</button>
          <button class="btn danger" data-act="broken">Broken?</button>
          <button class="btn ghost" data-act="clear">Clear</button>
          ${link ? `<button class="btn" data-act="open">Open</button>` : ``}
        </div>

        <textarea data-act="notes" placeholder="Notes / why you filed it here (saved locally)...">${escapeHTML(note)}</textarea>
      </div>
    `;
  }).join("");

  $("list").innerHTML = html || `<div class="mut">No items match your filters.</div>`;
}

function escapeHTML(s){
  return String(s||"").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
}
function escapeAttr(s){
  return escapeHTML(s).replace(/"/g,"&quot;");
}

/* ---------- interactions ---------- */
$("list").addEventListener("click", (e)=>{
  const btn = e.target.closest("button");
  if(!btn) return;
  const card = e.target.closest(".card");
  if(!card) return;
  const id = card.getAttribute("data-id");
  const act = btn.getAttribute("data-act");

  if(act==="vs"){ setBucket(triageMap, id, "vs"); saveTriage(triageMap); renderList(); }
  if(act==="complement"){ setBucket(triageMap, id, "complement"); saveTriage(triageMap); renderList(); }
  if(act==="broken"){ setBucket(triageMap, id, "broken"); saveTriage(triageMap); renderList(); }
  if(act==="clear"){ setBucket(triageMap, id, ""); saveTriage(triageMap); renderList(); }
  if(act==="open"){
    // get link from current item
    const it = (normalizeItems(currentMaster)||[]).find(x=> itemId(x)===id);
    const link = it?.link || it?.url || "";
    if(link) window.open(link, "_blank");
  }
});

$("list").addEventListener("input", (e)=>{
  const ta = e.target.closest("textarea");
  if(!ta) return;
  const card = e.target.closest(".card");
  if(!card) return;
  const id = card.getAttribute("data-id");
  setNotes(triageMap, id, ta.value);
  saveTriage(triageMap);
});

/* ---------- load / reload ---------- */
async function loadDay(date){
  currentDate = date;
  setStatus("loading "+date);
  try{
    const url = `${ROOT}/${date}/${MASTER}`;
    currentMaster = await fetchJSON(url);
    $("lastRefresh").textContent = nowIso();
    setStatus("ok");
  }catch(e){
    currentMaster = {items:[]};
    setStatus("missing");
  }
  renderList();
}

async function boot(){
  setStatus("discovering dates‚Ä¶");
  const maxDays = Number($("maxDays").value||120);
  dates = await discoverDates(maxDays);
  $("dateSel").innerHTML = dates.map(d=>`<option value="${d}">${d}</option>`).join("");
  $("dateCount").textContent = String(dates.length);
  $("lastRefresh").textContent = nowIso();

  const first = dates[0] || new Date().toISOString().slice(0,10);
  $("dateSel").value = first;
  await loadDay(first);

  // render backtest history graph
  updateBTUI();
  drawBTGraph();
  setStatus("ready");
}

/* ---------- filter refresh hooks ---------- */
["dateSel","modeSel","bucketSel","sortSel","limitSel","q"].forEach(id=>{
  $(id).addEventListener(id==="q" ? "input" : "change", ()=>{
    if(id==="dateSel") loadDay($("dateSel").value);
    else renderList();
  });
});

$("btnReload").addEventListener("click", ()=> loadDay($("dateSel").value));
$("btnOpenFolder").addEventListener("click", ()=>{
  const d = $("dateSel").value;
  window.open(`${ROOT}/${d}/`, "_blank");
});

/* ---------- export / import ---------- */
$("btnExport").addEventListener("click", ()=>{
  const payload = {
    exported_at: nowIso(),
    root: ROOT,
    triage_map: triageMap,
    note: "QDS News Triage Vault export"
  };
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `qds_triage_export_${new Date().toISOString().replace(/[:.]/g,"_")}.json`;
  a.click();
});

$("btnImport").addEventListener("click", ()=>{
  const inp = document.createElement("input");
  inp.type = "file";
  inp.accept = "application/json";
  inp.onchange = async ()=>{
    const f = inp.files?.[0];
    if(!f) return;
    const txt = await f.text();
    const j = safeJSON(txt, null);
    if(!j || !j.triage_map){ alert("No triage_map found in JSON"); return; }
    triageMap = j.triage_map;
    saveTriage(triageMap);
    renderList();
  };
  inp.click();
});

$("btnClear").addEventListener("click", ()=>{
  if(!confirm("Clear ALL triage + notes saved locally?")) return;
  triageMap = {};
  saveTriage(triageMap);
  renderList();
});

/* ---------- backtest / graph ---------- */
function updateBTUI(){
  $("harshLbl").textContent = $("harsh").value;
  $("maxDaysLbl").textContent = $("maxDays").value;
  $("btPts").textContent = String(btHistory.length);
}
$("harsh").addEventListener("input", ()=>{ updateBTUI(); });
$("maxDays").addEventListener("input", ()=>{ updateBTUI(); });

function btKey(date, mode, harsh){
  return `${date}|${mode}|${harsh}`;
}

async function testDay(date, mode, harsh){
  const url = `${ROOT}/${date}/${MASTER}`;
  try{
    const master = await fetchJSON(url);
    const items = normalizeItems(master);
    let itemsN=0, vs=0, comp=0, broken=0;
    for(const it of items){
      // apply mode filter lightly
      if(mode !== "All"){
        const cat = (it.category||"").toLowerCase();
        const title = (it.title||"").toLowerCase();
        if(!cat.includes(mode.toLowerCase()) && !title.includes(mode.toLowerCase())) continue;
      }
      itemsN++;
      const res = scoreStory(it, mode, harsh);
      if(res.label==="vs") vs++;
      else if(res.label==="complement") comp++;
    }
    return {date, mode, harsh, items:itemsN, vs_pred:vs, comp_pred:comp, broken:0, ts:Date.now()};
  }catch(e){
    return {date, mode, harsh, items:0, vs_pred:0, comp_pred:0, broken:1, ts:Date.now()};
  }
}

function drawBTGraph(){
  const cv = $("btCanvas");
  const g = cv.getContext("2d");
  g.clearRect(0,0,cv.width,cv.height);

  const pad = 34, w = cv.width - pad*2, h = cv.height - pad*2;

  // axes
  g.strokeStyle = "rgba(255,255,255,.14)";
  g.lineWidth = 2;
  g.beginPath();
  g.moveTo(pad, pad);
  g.lineTo(pad, pad+h);
  g.lineTo(pad+w, pad+h);
  g.stroke();

  if(!btHistory.length){
    $("btMeta").textContent = "No backtest history yet ‚Äî run a test.";
    return;
  }

  // show latest run series (same mode+harsh) for readability
  const last = btHistory[btHistory.length-1];
  const series = btHistory
    .filter(p=> p.mode===last.mode && p.harsh===last.harsh)
    .sort((a,b)=> a.date.localeCompare(b.date))
    .slice(-180);

  $("btMeta").textContent = `Series: mode=${last.mode} ‚Ä¢ harsh=${last.harsh} ‚Ä¢ points=${series.length} ‚Ä¢ range=${series[0].date} ‚Üí ${series[series.length-1].date}`;

  const maxY = Math.max(1, ...series.map(p=>Math.max(p.items,p.vs_pred,p.comp_pred,p.broken)));

  const sx = (i)=> pad + (series.length===1?0:(i/(series.length-1))*w);
  const sy = (v)=> pad + h - (v/maxY)*h;

  function plot(key, color, alpha, lw){
    g.strokeStyle = color;
    g.globalAlpha = alpha;
    g.lineWidth = lw;
    g.beginPath();
    series.forEach((p,i)=>{
      const x = sx(i), y = sy(p[key]);
      if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
    });
    g.stroke();
  }

  // Use your scheme colors
  plot("items",   "rgba(255,179,0,1)", 0.70, 3);
  plot("vs_pred", "rgba(57,255,136,1)", 0.95, 3.2);
  plot("comp_pred","rgba(255,204,51,1)", 0.70, 2.6);
  plot("broken",  "rgba(255,59,92,1)", 0.60, 2.4);

  // labels
  g.globalAlpha = 0.9;
  g.fillStyle = "rgba(255,255,255,.65)";
  g.font = "16px system-ui";
  g.fillText("0", 8, pad+h+6);
  g.fillText(String(maxY), 8, pad+14);
}

$("btnTestDay").addEventListener("click", async ()=>{
  const date = $("dateSel").value;
  const mode = $("modeSel").value;
  const harsh = Number($("harsh").value||35);

  $("btState").textContent = "testing day‚Ä¶";
  const p = await testDay(date, mode, harsh);
  const key = btKey(p.date, p.mode, p.harsh);

  // replace if exists, else append
  const idx = btHistory.findIndex(x=> btKey(x.date,x.mode,x.harsh)===key);
  if(idx>=0) btHistory[idx] = p; else btHistory.push(p);

  saveBT(btHistory);
  $("btState").textContent = "ok";
  updateBTUI();
  drawBTGraph();
});

$("btnBacktest").addEventListener("click", async ()=>{
  const mode = $("modeSel").value;
  const harsh = Number($("harsh").value||35);
  const maxDays = Number($("maxDays").value||120);

  $("btState").textContent = "discovering‚Ä¶";
  const sweepDates = await discoverDates(maxDays);

  // newest->older already
  const seen = new Set(btHistory.map(x=> btKey(x.date,x.mode,x.harsh)));
  let added = 0;

  $("btState").textContent = `backtesting ${sweepDates.length}‚Ä¶`;

  for(let i=0;i<sweepDates.length;i++){
    const date = sweepDates[i];
    const key = btKey(date, mode, harsh);
    if(seen.has(key)) continue;

    const p = await testDay(date, mode, harsh);
    btHistory.push(p);
    added++;

    if(added % 8 === 0){
      saveBT(btHistory);
      drawBTGraph();
    }
  }

  saveBT(btHistory);
  $("btState").textContent = `done (+${added})`;
  updateBTUI();
  drawBTGraph();
});

$("btnClearBT").addEventListener("click", ()=>{
  if(!confirm("Clear backtest history stored locally?")) return;
  btHistory = [];
  saveBT(btHistory);
  $("btState").textContent = "cleared";
  updateBTUI();
  drawBTGraph();
});

/* ---------- start ---------- */
updateBTUI();
boot();


// --- battery_whisperer_index.html ---



// --- qds_news_backtest_v2.html ---

(() => {
  const $ = (id)=>document.getElementById(id);
  const logEl = $("log");
  const chart = $("chart");
  const ctx = chart.getContext("2d");
  const KEY = "QDS_NEWS_BACKTEST_V2";
  const TRIAGE_KEY = "QDS_NEWS_TRIAGE_EXPORTS_V1";

  const state = {
    dates: [],
    results: load(KEY, []),
    triageExports: load(TRIAGE_KEY, {}), // date -> {triage:{id:label}}
  };

  function nowISO(){
    const d = new Date();
    const z = (n)=>String(n).padStart(2,"0");
    return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}T${z(d.getHours())}:${z(d.getMinutes())}:${z(d.getSeconds())}`;
  }
  function save(k,v){ localStorage.setItem(k, JSON.stringify(v)); }
  function load(k, fallback){
    try{ const v = localStorage.getItem(k); return v?JSON.parse(v):fallback; }
    catch(e){ return fallback; }
  }
  function log(line){
    const t = new Date().toLocaleTimeString();
    logEl.textContent += `[${t}] ${line}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

  // --- Auto-test scoring (harshness tunes the threshold) ---
  // This is intentionally heuristic (fast + explainable).
  const QDS_TERMS = [
    ["correlated", 2], ["correlation",2], ["coherence",3], ["stochastic",3],
    ["fluctuation",2], ["noise",2], ["turbulence",2], ["kernel",3],
    ["decoherence",3], ["nonlocal",2], ["memory",2], ["hysteresis",2],
    ["phonon",2], ["hot phonon",3], ["nanopore",3], ["vortex",2],
    ["magnetic landscape",2], ["metamaterial",2], ["Josephson",2],
    ["NV center",2], ["SQUID",2], ["quantum sensor",2], ["ion transport",2],
    ["edge localized mode",3], ["plasma turbulence",3]
  ];
  const MAINSTREAM_TERMS = [
    ["dark matter",3], ["lambda",2], ["ŒõCDM",3], ["inflation",2],
    ["standard model",2], ["general relativity",2], ["Hubble tension",3]
  ];

  function scoreItem(item){
    const text = `${item.title||""} ${item.description||item.summary||""} ${item.category||item.mode||""}`.toLowerCase();
    let q=0, m=0;

    for (const [t,w] of QDS_TERMS){
      if (text.includes(t)) q += w;
    }
    for (const [t,w] of MAINSTREAM_TERMS){
      if (text.includes(t.toLowerCase())) m += w;
    }
    // bonus: multi-hit density
    const len = Math.max(80, text.length);
    const density = (q + m) / Math.sqrt(len);
    return {q, m, density};
  }

  function classify(item, harsh){
    const {q, m, density} = scoreItem(item);

    // harshness scales threshold 0..100 -> 0.8..3.2 approx
    const th = 0.8 + (harsh/100)*2.4;

    // interpret:
    // - QDS vs MAINST if strong "QDS-ish signal" OR high density with some mainstream tension
    // - Complement if strongly mainstream but low QDS-ish
    // - Neutral otherwise
    const qsig = (q/3) + density;
    const msig = (m/3) + density*0.6;

    if (qsig >= th && (q >= 3 || density >= 1.2)) return "vs";
    if (msig >= th && q < 3) return "complements";
    return "neutral";
  }

  // --- Data loading ---
  async function fetchText(url){
    const r = await fetch(url, {cache:"no-store"});
    if(!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.text();
  }
  async function fetchJson(url){
    const r = await fetch(url, {cache:"no-store"});
    if(!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  }

  function parseDatesFromDirHtml(html){
    // python http.server directory listing -> <a href="2025-12-14/">2025-12-14/</a>
    const re = /href="(\d{4}-\d{2}-\d{2})\/"/g;
    const out = [];
    let m;
    while((m = re.exec(html))) out.push(m[1]);
    return [...new Set(out)].sort();
  }

  async function refreshDates(){
    const base = $("basePath").value.trim().replace(/\/$/,"");
    try{
      const html = await fetchText(base + "/");
      state.dates = parseDatesFromDirHtml(html);
      $("datesCount").textContent = String(state.dates.length);

      // fill dropdowns
      fillDateSelectors();
      log(`Found ${state.dates.length} date folders under ${base}/`);
    }catch(e){
      log(`Could not list dates at ${base}/ (needs dir listing or symlink). Error: ${e.message}`);
      // fallback: keep whatever is already in selects
    }
  }

  function fillDateSelectors(){
    const s = $("startDate"), e = $("endDate");
    const prevS = s.value, prevE = e.value;

    s.innerHTML = "";
    e.innerHTML = "";
    for(const d of state.dates){
      s.appendChild(new Option(d, d));
      e.appendChild(new Option(d, d));
    }
    // default: last 7 days range if possible
    if(state.dates.length){
      const end = state.dates[state.dates.length-1];
      const start = state.dates[Math.max(0, state.dates.length-7)];
      s.value = prevS || start;
      e.value = prevE || end;
    }
  }

  function dateRange(start, end){
    const out = [];
    const s = new Date(start+"T00:00:00");
    const t = new Date(end+"T00:00:00");
    if (isNaN(s) || isNaN(t)) return out;
    const step = s <= t ? 1 : -1;
    const cur = new Date(s);
    const z = (n)=>String(n).padStart(2,"0");
    while((step===1 && cur<=t) || (step===-1 && cur>=t)){
      out.push(`${cur.getFullYear()}-${z(cur.getMonth()+1)}-${z(cur.getDate())}`);
      cur.setDate(cur.getDate()+step);
    }
    return out;
  }

  // --- Charting (simple canvas line chart) ---
  function draw(){
    const W = chart.width, H = chart.height;
    ctx.clearRect(0,0,W,H);

    const rows = state.results.slice().sort((a,b)=>a.date.localeCompare(b.date));
    if(!rows.length){
      ctx.fillStyle = "rgba(233,238,252,.65)";
      ctx.font = "16px system-ui";
      ctx.fillText("No backtest history yet. Hit Run backtest.", 18, 38);
      return;
    }

    const padL=48, padR=18, padT=14, padB=32;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;

    const maxY = Math.max(10, ...rows.map(r=>r.total||0));
    const x = (i)=> padL + (rows.length===1 ? plotW/2 : (i/(rows.length-1))*plotW);
    const y = (v)=> padT + (1 - (v/maxY))*plotH;

    // grid
    ctx.strokeStyle = "rgba(255,179,0,.10)";
    ctx.lineWidth = 1;
    for(let k=0;k<=4;k++){
      const yy = padT + (k/4)*plotH;
      ctx.beginPath(); ctx.moveTo(padL,yy); ctx.lineTo(W-padR,yy); ctx.stroke();
      const val = Math.round(maxY*(1-k/4));
      ctx.fillStyle = "rgba(154,167,196,.8)";
      ctx.font = "11px system-ui";
      ctx.fillText(String(val), 8, yy+4);
    }

    function line(getter, alpha){
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      rows.forEach((r,i)=>{
        const xx=x(i), yy=y(getter(r));
        if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      });
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // total
    ctx.strokeStyle = "rgba(255,179,0,.85)";
    ctx.lineWidth = 2.5;
    line(r=>r.total||0, 0.9);

    // vs
    ctx.strokeStyle = "rgba(255,59,0,.85)";
    ctx.lineWidth = 2.2;
    line(r=>r.vs||0, 0.95);

    // complements
    ctx.strokeStyle = "rgba(57,255,136,.85)";
    ctx.lineWidth = 2.0;
    line(r=>r.complements||0, 0.85);

    // neutral
    ctx.strokeStyle = "rgba(233,238,252,.55)";
    ctx.lineWidth = 1.8;
    line(r=>r.neutral||0, 0.75);

    // x labels (sparse)
    ctx.fillStyle = "rgba(154,167,196,.85)";
    ctx.font = "11px system-ui";
    const step = Math.max(1, Math.floor(rows.length/6));
    rows.forEach((r,i)=>{
      if(i%step!==0 && i!==rows.length-1) return;
      const xx=x(i);
      ctx.fillText(r.date.slice(5), xx-14, H-12);
    });

    // legend
    ctx.fillStyle = "rgba(233,238,252,.85)";
    ctx.font = "12px system-ui";
    ctx.fillText("total", padL+0, 16);
    ctx.fillStyle = "rgba(255,59,0,.9)"; ctx.fillText("vs", padL+52, 16);
    ctx.fillStyle = "rgba(57,255,136,.9)"; ctx.fillText("complements", padL+80, 16);
    ctx.fillStyle = "rgba(233,238,252,.65)"; ctx.fillText("neutral", padL+178, 16);
  }

  // --- Backtest run ---
  async function run(){
    const base = $("basePath").value.trim().replace(/\/$/,"");
    const mode = $("modeSel").value;
    const harsh = parseInt($("harsh").value,10);
    const limit = parseInt($("limitSel").value,10);
    $("harshVal").textContent = String(harsh);

    const start = $("startDate").value || (state.dates[0]||"");
    const end   = $("endDate").value   || (state.dates[state.dates.length-1]||"");
    if(!start || !end){
      log("No dates selected (and date listing failed). Try refreshing dates, or set basePath correctly.");
      return;
    }

    const days = dateRange(start, end);
    log(`Backtest: ${days.length} day(s), mode=${mode}, harsh=${harsh}, limit=${limit}`);
    let totalAll = 0;

    for(const d of days){
      const url = `${base}/${d}/MASTER.json`;
      let master;
      try{
        master = await fetchJson(url);
      }catch(e){
        log(`MISS ${d}: ${url} (${e.message})`);
        continue;
      }

      const items = (master.items || master || []).slice(0, limit);
      const filtered = items.filter(it=>{
        if(mode==="ALL") return true;
        const c = (it.category || it.mode || it.section || "").toString();
        return c.toLowerCase().includes(mode.toLowerCase());
      });

      let vs=0, comps=0, neu=0;
      for(const it of filtered){
        const c = classify(it, harsh);
        if(c==="vs") vs++;
        else if(c==="complements") comps++;
        else neu++;
      }

      totalAll += filtered.length;

      // merge triage export tallies if we have them
      const tri = state.triageExports[d]?.triage || null;
      let manual_vs=0, manual_comps=0, manual_broken=0;
      if(tri){
        for(const k in tri){
          if(tri[k]==="vs") manual_vs++;
          else if(tri[k]==="complements") manual_comps++;
          else if(tri[k]==="broken") manual_broken++;
        }
      }

      upsertResult({
        date:d,
        mode,
        harsh,
        total: filtered.length,
        vs, complements: comps, neutral: neu,
        manual_vs, manual_complements: manual_comps, manual_broken
      });

      log(`OK ${d}: total=${filtered.length}  vs=${vs}  comps=${comps}  neutral=${neu}` + (tri ? `  | manual(vs=${manual_vs}, comps=${manual_comps}, broken=${manual_broken})` : ""));
      await sleep(40);
    }

    $("lastRun").textContent = nowISO();
    $("totalProc").textContent = String(totalAll);
    save(KEY, state.results);
    draw();
  }

  function upsertResult(row){
    const i = state.results.findIndex(r => r.date===row.date && r.mode===row.mode && r.harsh===row.harsh);
    if(i>=0) state.results[i] = {...state.results[i], ...row};
    else state.results.push(row);
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // --- Import / export backtest + triage exports ---
  function download(name, obj){
    const blob = new Blob([JSON.stringify(obj,null,2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = name;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  }

  function guessDateFromFilename(fn){
    const m = (fn||"").match(/(\d{4}-\d{2}-\d{2})/);
    return m ? m[1] : null;
  }

  async function importFiles(files){
    for(const f of files){
      try{
        const text = await f.text();
        const j = JSON.parse(text);

        // expected export shape:
        // { version, exported_at, triage: {id: label, ...}, notes: {...} }
        const tri = j.triage || j || {};
        const dt = guessDateFromFilename(f.name) || (j.exported_at ? String(j.exported_at).slice(0,10) : null);
        if(!dt){
          log(`Import skipped (no date found): ${f.name}`);
          continue;
        }
        state.triageExports[dt] = { triage: tri, meta: {file:f.name, exported_at:j.exported_at||null} };
        log(`Imported triage: ${f.name} -> date ${dt} (${Object.keys(tri).length} marks)`);
      }catch(e){
        log(`Import failed: ${f.name} (${e.message})`);
      }
    }
    save(TRIAGE_KEY, state.triageExports);
  }

  // --- UI wiring ---
  $("btnMode").onclick = ()=>toggle("modeBox");
  $("btnDates").onclick = ()=>toggle("datesBox");
  $("btnRun").onclick = run;
  $("btnClear").onclick = ()=>{
    if(!confirm("Clear stored backtest history?")) return;
    state.results = [];
    save(KEY, state.results);
    $("totalProc").textContent = "0";
    $("lastRun").textContent = "‚Äî";
    logEl.textContent = "";
    log("Cleared backtest history.");
    draw();
  };
  $("btnExport").onclick = ()=>{
    download(`qds_news_backtest_${new Date().toISOString().slice(0,10)}.json`, {
      version:"backtest_v2",
      exported_at: nowISO(),
      results: state.results,
      triage_exports_index: Object.keys(state.triageExports)
    });
  };
  $("btnImport").onclick = ()=> $("filePick").click();
  $("filePick").addEventListener("change", async (e)=>{
    const files = Array.from(e.target.files||[]);
    if(files.length) await importFiles(files);
    e.target.value = "";
    draw();
  });

  $("harsh").addEventListener("input", ()=> $("harshVal").textContent = $("harsh").value);

  function toggle(id){
    const el = $(id);
    el.classList.toggle("hidden");
  }

  async function init(){
    log("Booting‚Ä¶");
    $("harshVal").textContent = $("harsh").value;
    await refreshDates();

    // build mode list from newest day (best-effort)
    if(state.dates.length){
      const base = $("basePath").value.trim().replace(/\/$/,"");
      const newest = state.dates[state.dates.length-1];
      try{
        const master = await fetchJson(`${base}/${newest}/MASTER.json`);
        const items = (master.items || master || []);
        const modes = new Set(["ALL"]);
        for(const it of items){
          const c = (it.category || it.mode || it.section || "").toString().trim();
          if(c) modes.add(c);
        }
        const sel = $("modeSel");
        sel.innerHTML = "";
        [...modes].slice(0,80).forEach(m=> sel.appendChild(new Option(m, m==="ALL"?"ALL":m)));
        log(`Mode list loaded from ${newest} (${modes.size-1} category(s))`);
      }catch(e){
        log(`Mode list load failed (ok): ${e.message}`);
      }
    }

    $("datesCount").textContent = String(state.dates.length);
    if(state.results.length) $("lastRun").textContent = "stored";
    draw();
  }

  init();
})();


// --- physorg_qds_triage_backup_20251214_011604.html ---

(() => {
  const $ = (id)=>document.getElementById(id);

  const STORAGE_KEY = "qds_news_triage_v1";
  const NOTES_KEY   = "qds_news_notes_v1";
  const state = {
    dates: [],
    items: [],
    triage: loadJson(STORAGE_KEY, {}),
    notes: loadJson(NOTES_KEY, {}),
    lastRefresh: null,
  };

  function loadJson(k, fallback){
    try { return JSON.parse(localStorage.getItem(k) || "") || fallback; }
    catch { return fallback; }
  }
  function save(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state.triage));
    localStorage.setItem(NOTES_KEY, JSON.stringify(state.notes));
  }

  function nowISO(){
    return new Date().toISOString().slice(0,19);
  }

  function bucketLabel(b){
    if(b==="vs") return "QDS vs MAINSTREAM";
    if(b==="comp") return "QDS complements MAINSTREAM";
    if(b==="broken") return "QDS broken by data?";
    return "untriaged";
  }

  function bucketClass(b){
    if(b==="vs") return "b-vs";
    if(b==="comp") return "b-comp";
    if(b==="broken") return "b-broken";
    return "b-none";
  }

  function itemKey(it){
    // Prefer stable GUID/link; fall back to title+date
    return (it.guid || it.link || (it.title+"|"+(it.pubDate||it.date||""))).slice(0,512);
  }

  async function listDates(){
    // Your rip folder layout: /news_rips/physorg/YYYY-MM-DD/MASTER.json
    // We'll probe the last ~21 days and only keep ones that exist.
    const days = 21;
    const out = [];
    const today = new Date();
    for(let i=0;i<days;i++){
      const d = new Date(today.getTime() - i*86400e3);
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      const s = `${yyyy}-${mm}-${dd}`;
      const url = `news_rips/physorg/${s}/MASTER.json`;
      try{
        const r = await fetch(url, {cache:"no-store"});
        if(r.ok){
          out.push(s);
        }
      }catch(e){}
    }
    return out;
  }

  async function loadDate(dateStr){
    const url = `news_rips/physorg/${dateStr}/MASTER.json`;
    const r = await fetch(url, {cache:"no-store"});
    if(!r.ok) throw new Error(`Fetch failed: ${r.status}`);
    const j = await r.json();
    // Expecting either {items:[...]} or [...]
    const items = Array.isArray(j) ? j : (j.items || j.ITEMS || j.master || []);
    return items.map(x => normalizeItem(x));
  }

  function normalizeItem(x){
    // your rip script likely uses common RSS fields; normalize gently
    const it = {...x};
    it.title = it.title || it.TITLE || "Untitled";
    it.link  = it.link  || it.LINK  || it.url || "";
    it.pubDate = it.pubDate || it.date || it.published || it.pub || "";
    it.category = it.category || it.cat || it.section || it.feed || "";
    it.summary  = it.summary  || it.description || it.desc || it.contentSnippet || "";
    it.source   = it.source   || it.site || "phys.org";
    return it;
  }

  function toTimeValue(pubDate){
    // Works if pubDate is ISO-ish; otherwise fallback 0
    const t = Date.parse(pubDate);
    return isNaN(t) ? 0 : t;
  }

  function render(){
    const dateStr = $("dateSel").value;
    const mode = $("modeSel").value;
    const bucket = $("bucketSel").value;
    const q = $("q").value.trim().toLowerCase();
    const sort = $("sortSel").value;
    const limit = parseInt($("limitSel").value,10) || 500;

    $("lastRefresh").textContent = state.lastRefresh || "‚Äî";
    $("dateCount").textContent = state.dates.length;

    let items = state.items.slice();

    // MODE filter
    items = items.filter(it => {
      const b = state.triage[itemKey(it)] || "none";
      if(mode==="triage") return b!=="none";
      if(mode==="untriaged") return b==="none";
      return true;
    });

    // BUCKET filter
    items = items.filter(it => {
      const b = state.triage[itemKey(it)] || "none";
      if(bucket==="any") return true;
      if(bucket==="none") return b==="none";
      return b===bucket;
    });

    // SEARCH filter
    if(q){
      items = items.filter(it => {
        const k = itemKey(it);
        const note = (state.notes[k] || "");
        const hay = `${it.title} ${it.category} ${it.summary} ${note}`.toLowerCase();
        return hay.includes(q);
      });
    }

    // SORT
    items.sort((a,b)=>{
      const ba = state.triage[itemKey(a)] || "none";
      const bb = state.triage[itemKey(b)] || "none";
      if(sort==="time_desc") return toTimeValue(b.pubDate)-toTimeValue(a.pubDate);
      if(sort==="time_asc") return toTimeValue(a.pubDate)-toTimeValue(b.pubDate);
      if(sort==="title_asc") return (a.title||"").localeCompare(b.title||"");
      if(sort==="bucket") return (ba+ (a.title||"")).localeCompare(bb+(b.title||""));
      return 0;
    });

    // STATS (from full state.items for this date, not filtered)
    const counts = {vs:0,comp:0,broken:0,none:0};
    for(const it of state.items){
      const b = state.triage[itemKey(it)] || "none";
      counts[b] = (counts[b]||0)+1;
    }
    $("nItems").textContent = state.items.length;
    $("nVs").textContent = counts.vs||0;
    $("nComp").textContent = counts.comp||0;
    $("nBroken").textContent = counts.broken||0;
    $("nNone").textContent = counts.none||0;
    $("qChip").textContent = q ? q : "‚Äî";

    // limit
    items = items.slice(0, limit);

    // render list
    const list = $("list");
    list.innerHTML = "";
    for(const it of items){
      list.appendChild(renderCard(it));
    }
  }

  function renderCard(it){
    const k = itemKey(it);
    const b = state.triage[k] || "none";
    const note = state.notes[k] || "";

    const card = document.createElement("div");
    card.className = "card";

    const top = document.createElement("div");
    top.className = "topRow";

    const left = document.createElement("div");
    left.style.flex = "1";

    const h = document.createElement("div");
    h.className = "t";
    h.textContent = it.title || "Untitled";

    const meta = document.createElement("div");
    meta.className = "meta";
    const t1 = document.createElement("span"); t1.className="tag"; t1.textContent = it.pubDate ? it.pubDate : "‚Äî";
    const t2 = document.createElement("span"); t2.className="tag"; t2.textContent = it.category ? it.category : "‚Äî";
    const t3 = document.createElement("span"); t3.className="tag"; t3.textContent = it.source || "phys.org";
    meta.append(t1,t2,t3);

    left.append(h, meta);

    const right = document.createElement("div");
    const buck = document.createElement("span");
    buck.className = `bucket ${bucketClass(b)}`;
    buck.textContent = bucketLabel(b);
    right.appendChild(buck);

    top.append(left,right);

    const desc = document.createElement("div");
    desc.className = "desc";
    desc.textContent = (it.summary || "").trim() || "‚Äî";

    const actions = document.createElement("div");
    actions.className = "actions";

    const mkBtn = (label, cls, val) => {
      const btn = document.createElement("button");
      btn.className = `aBtn ${cls}`;
      btn.textContent = label;
      btn.onclick = () => {
        if(val==="none") delete state.triage[k];
        else state.triage[k] = val;
        save();
        render();
      };
      return btn;
    };

    actions.append(
      mkBtn("QDS vs", "a-vs", "vs"),
      mkBtn("Complements", "a-comp", "comp"),
      mkBtn("Broken?", "a-broken", "broken"),
      mkBtn("Clear", "a-clear", "none")
    );

    const open = document.createElement("button");
    open.className = "aBtn a-open";
    open.textContent = "Open";
    open.onclick = ()=>{ if(it.link) window.open(it.link, "_blank"); };
    actions.appendChild(open);

    const ta = document.createElement("textarea");
    ta.placeholder = "Notes / why you filed it here (saved locally)‚Ä¶";
    ta.value = note;
    ta.onchange = () => {
      const v = ta.value.trim();
      if(v) state.notes[k] = v;
      else delete state.notes[k];
      save();
    };

    card.append(top, desc, actions, ta);
    return card;
  }

  async function reloadAll(){
    $("statusText").textContent = "loading‚Ä¶";
    try{
      state.dates = await listDates();
      if(state.dates.length===0){
        $("statusText").textContent = "no dates found";
        $("dateSel").innerHTML = `<option value="">‚Äî</option>`;
        state.items = [];
        state.lastRefresh = nowISO();
        render();
        return;
      }
      // fill date selector (newest first)
      $("dateSel").innerHTML = state.dates.map(d=>`<option value="${d}">${d}</option>`).join("");
      const chosen = $("dateSel").value || state.dates[0];
      $("dateSel").value = chosen;

      state.items = await loadDate(chosen);
      state.lastRefresh = nowISO();
      $("statusText").textContent = "ready";
      render();
    }catch(e){
      console.error(e);
      $("statusText").textContent = "error";
      state.items = [];
      state.lastRefresh = nowISO();
      render();
      alert("Failed to load MASTER.json. Check: symlink exists and you're serving /www on 8011.");
    }
  }

  // Hook up controls
  $("reloadBtn").onclick = reloadAll;
  $("openFolderBtn").onclick = ()=>{
    const d = $("dateSel").value;
    if(!d) return;
    // opens directory listing if python http.server allows it
    window.open(`news_rips/physorg/${d}/`, "_blank");
  };

  $("dateSel").onchange = async ()=>{
    const d = $("dateSel").value;
    if(!d) return;
    $("statusText").textContent = "loading‚Ä¶";
    try{
      state.items = await loadDate(d);
      state.lastRefresh = nowISO();
      $("statusText").textContent = "ready";
      render();
    }catch(e){
      console.error(e);
      $("statusText").textContent = "error";
      alert("Failed loading that date. Is the folder there?");
    }
  };

  for(const id of ["modeSel","bucketSel","sortSel","limitSel"]){
    $(id).onchange = render;
  }
  $("q").addEventListener("input", ()=>{ window.clearTimeout(window.__qt); window.__qt=setTimeout(render,120); });

  // Export/Import triage map + notes
  $("exportBtn").onclick = ()=>{
    const payload = {
      version: 1,
      exported_at: new Date().toISOString(),
      triage: state.triage,
      notes: state.notes
    };
    const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `qds_news_triage_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  };

  $("importBtn").onclick = ()=> $("importFile").click();
  $("importFile").onchange = async (ev)=>{
    const f = ev.target.files && ev.target.files[0];
    if(!f) return;
    try{
      const text = await f.text();
      const j = JSON.parse(text);
      if(j && j.triage) state.triage = j.triage;
      if(j && j.notes) state.notes = j.notes;
      save();
      render();
      alert("Imported triage OK.");
    }catch(e){
      alert("Import failed: not valid JSON?");
    } finally {
      ev.target.value = "";
    }
  };

  $("clearAllBtn").onclick = ()=>{
    if(!confirm("Clear ALL triage + notes (local only)?")) return;
    state.triage = {};
    state.notes = {};
    save();
    render();
  };

  // boot
  reloadAll();
})();


// --- qds_battery_news_lab_v1.html ---

(function() {
  const dateInput = document.getElementById('dateInput');
  const btnLoad = document.getElementById('btnLoad');
  const btnToday = document.getElementById('btnToday');
  const statusEl = document.getElementById('status');
  const statusDot = statusEl.querySelector('.status-dot');
  const statusText = statusEl.querySelector('span');

  const mTotal = document.getElementById('mTotal');
  const mBattery = document.getElementById('mBattery');
  const mBatteryPct = document.getElementById('mBatteryPct');
  const barTotal = document.getElementById('barTotal');
  const barBattery = document.getElementById('barBattery');

  const mChem = document.getElementById('mChem');
  const mChemNote = document.getElementById('mChemNote');
  const mDiag = document.getElementById('mDiag');
  const mDiagNote = document.getElementById('mDiagNote');
  const mArch = document.getElementById('mArch');
  const mArchNote = document.getElementById('mArchNote');

  const insightText = document.getElementById('insightText');
  const listCount = document.getElementById('listCount');
  const sortSelect = document.getElementById('sortSelect');
  const articlesEl = document.getElementById('articles');

  let currentBatteryItems = [];
  let currentDate = null;

  function setStatus(text, isError=false) {
    statusText.textContent = text;
    if (isError) {
      statusEl.classList.add('error');
    } else {
      statusEl.classList.remove('error');
    }
  }

  function setBars(total, battery) {
    const maxForBar = Math.max(total, 50); // just for visual scaling
    const totalPct = Math.min(100, (total / maxForBar) * 100);
    const battPct = total > 0 ? Math.min(100, (battery / total) * 100) : 0;
    barTotal.style.width = totalPct.toFixed(1) + '%';
    barBattery.style.width = battPct.toFixed(1) + '%';
  }

  function getTitle(item) {
    return item.title || item.headline || item.name || '(no title)';
  }

  function getSummary(item) {
    return item.summary || item.description || item.teaser || '';
  }

  function getLink(item) {
    return item.link || item.url || '#';
  }

  function getDate(item) {
    return item.pubDate || item.date || item.published || '';
  }

  const batteryKeywords = [
    'battery','batteries','li-ion','li ion','lithium','solid-state','solid state',
    'sodium-ion','sodium ion','na-ion','na ion','cathode','anode','electrolyte',
    'lithium-ion','li metal','lithium metal','lithium-sulfur','lithium sulfur',
    'silicon anode','graphite anode','separator','intercalation'
  ];

  function isBatteryStory(item) {
    const t = (getTitle(item) + ' ' + getSummary(item)).toLowerCase();
    return batteryKeywords.some(k => t.includes(k));
  }

  function classifyItem(item) {
    const t = (getTitle(item) + ' ' + getSummary(item)).toLowerCase();
    let chem = false, diag = false, arch = false, app = false;

    if (t.match(/cathode|anode|electrolyte|solid-state|solid state|lithium|sodium|intercalation|crystal|phase|nanoparticle|nanostructure/)) {
      chem = true;
    }
    if (t.match(/degradation|cycle life|aging|ageing|diagnostic|health estimation|state of health|impedance|fault|random walk/)) {
      diag = true;
    }
    if (t.match(/cell design|pouch cell|prismatic|manufactur|scale-up|gigafactory|production|fabrication|printing|electrode thickness/)) {
      arch = true;
    }
    if (t.match(/grid|ev |electric vehicle|drone|storage system|microgrid|satellite|spacecraft|wearable/)) {
      app = true;
    }

    let primary = 'general';
    if (chem) primary = 'chem';
    else if (diag) primary = 'diag';
    else if (arch) primary = 'arch';
    else if (app) primary = 'app';

    return { chem, diag, arch, app, primary };
  }

  function makeInsight(total, battCount, cats) {
    if (!total) return 'No MASTER.json items for this day yet. Run ripphys, then reload.';
    if (!battCount) return 'No battery-related hits found for this rip. Either a quiet day or the keywords need tuning.';
    const pct = (battCount/total*100).toFixed(1);
    const top = Object.entries(cats).sort((a,b)=>b[1]-a[1])[0];
    let theme = 'mixed';
    if (top) {
      if (top[0]==='chem') theme = 'chemistry / materials';
      else if (top[0]==='diag') theme = 'diagnostics / ageing';
      else if (top[0]==='arch') theme = 'architecture / manufacturing';
      else if (top[0]==='app') theme = 'applications / systems';
    }
    return `Day summary: ${battCount} battery-related stories out of ${total} total (${pct}%). Dominant theme: ${theme}. Use these as seeds for QDS battery habitat parameters, degradation modes, and RW stress profiles.`;
  }

  function renderArticles(items) {
    articlesEl.innerHTML = '';
    listCount.textContent = items.length;

    items.forEach(obj => {
      const item = obj.item;
      const cls = obj.cls;
      const card = document.createElement('div');
      card.className = 'article';

      const titleDiv = document.createElement('div');
      titleDiv.className = 'article-title';
      const a = document.createElement('a');
      a.href = getLink(item);
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      a.textContent = getTitle(item);
      titleDiv.appendChild(a);

      const meta = document.createElement('div');
      meta.className = 'article-meta';
      const dateSpan = document.createElement('span');
      const d = getDate(item);
      dateSpan.textContent = d ? `üìÖ ${d}` : 'üìÖ (no date)';
      meta.appendChild(dateSpan);

      const tagsSpan = document.createElement('span');
      let tagText = 'Tags: battery';
      if (cls.chem) tagText += ' ‚Ä¢ chemistry/materials';
      if (cls.diag) tagText += ' ‚Ä¢ diagnostics/ageing';
      if (cls.arch) tagText += ' ‚Ä¢ architecture/scale-up';
      if (cls.app) tagText += ' ‚Ä¢ applications';
      tagsSpan.textContent = tagText;
      meta.appendChild(tagsSpan);

      const summary = document.createElement('div');
      summary.className = 'article-summary';
      let s = getSummary(item);
      if (s.length > 260) s = s.slice(0, 257) + '‚Ä¶';
      // light highlight: try to emphasise "battery"
      s = s.replace(/(battery|batteries)/gi, '<span class="highlight">$1</span>');
      summary.innerHTML = s || '<span class="highlight">No summary available.</span>';

      card.appendChild(titleDiv);
      card.appendChild(meta);
      card.appendChild(summary);
      articlesEl.appendChild(card);
    });
  }

  function sortItems(mode) {
    if (!currentBatteryItems.length) return;
    let arr = [...currentBatteryItems];
    if (mode === 'title') {
      arr.sort((a,b) => getTitle(a.item).localeCompare(getTitle(b.item)));
    } else if (mode === 'chem') {
      arr.sort((a,b) => {
        const aScore = (a.cls.chem?2:0) + (a.cls.diag?1:0);
        const bScore = (b.cls.chem?2:0) + (b.cls.diag?1:0);
        return bScore - aScore;
      });
    } else {
      // recent: we don't have reliable timestamps, so keep order as in MASTER
    }
    renderArticles(arr);
  }

  async function loadDay(dateStr) {
    currentDate = dateStr;
    setStatus(`Loading MASTER.json for ${dateStr}‚Ä¶`);
    statusDot.style.background = 'var(--accent)';
    try {
      const url = `/news_rips/physorg/${dateStr}/MASTER.json`;
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      const data = await res.json();
      const items = Array.isArray(data)
        ? data
        : (Array.isArray(data.items) ? data.items : []);
      const total = items.length;
      mTotal.textContent = total ? total : '0';

      const battItems = [];
      let cats = {chem:0, diag:0, arch:0, app:0};

      items.forEach(it => {
        if (isBatteryStory(it)) {
          const cls = classifyItem(it);
          battItems.push({item: it, cls});
          if (cls.chem) cats.chem++;
          if (cls.diag) cats.diag++;
          if (cls.arch) cats.arch++;
          if (cls.app) cats.app++;
        }
      });

      currentBatteryItems = battItems;
      const battCount = battItems.length;
      mBattery.textContent = battCount;
      const pct = total ? (battCount/total*100) : 0;
      mBatteryPct.textContent = pct.toFixed(1) + '%';
      setBars(total, battCount);

      mChem.textContent = cats.chem;
      mDiag.textContent = cats.diag;
      mArch.textContent = cats.arch;
      mChemNote.textContent = cats.chem ? 'New chemistries / materials focus' : '‚Äî';
      mDiagNote.textContent = cats.diag ? 'Ageing / diagnostics angle' : '‚Äî';
      mArchNote.textContent = cats.arch ? 'Design / manufacturing / scale-up' : '‚Äî';

      insightText.textContent = makeInsight(total, battCount, cats);
      setStatus(`Loaded ${total} items; found ${battCount} battery-related stories for ${dateStr}.`);

      sortItems(sortSelect.value);
    } catch (err) {
      console.error(err);
      currentBatteryItems = [];
      mTotal.textContent = '‚Äî';
      mBattery.textContent = '‚Äî';
      mBatteryPct.textContent = '0%';
      setBars(0,0);
      mChem.textContent = '‚Äî';
      mDiag.textContent = '‚Äî';
      mArch.textContent = '‚Äî';
      mChemNote.textContent = '‚Äî';
      mDiagNote.textContent = '‚Äî';
      mArchNote.textContent = '‚Äî';
      insightText.textContent = 'Error loading MASTER.json. Check the date and that ripphys has written a folder for that day.';
      setStatus(`Couldn‚Äôt load /news_rips/physorg/${dateStr}/MASTER.json`, true);
      articlesEl.innerHTML = '';
      listCount.textContent = '0';
    }
  }

  // Wire up events
  btnLoad.addEventListener('click', () => {
    const d = dateInput.value.trim();
    if (!d) {
      setStatus('Please enter a date like 2025-12-14.', true);
      return;
    }
    loadDay(d);
  });

  btnToday.addEventListener('click', () => {
    const now = new Date();
    const yyyy = now.getFullYear();
    const mm = String(now.getMonth()+1).padStart(2,'0');
    const dd = String(now.getDate()).padStart(2,'0');
    const d = `${yyyy}-${mm}-${dd}`;
    dateInput.value = d;
    loadDay(d);
  });

  sortSelect.addEventListener('change', () => {
    sortItems(sortSelect.value);
  });

  // Initialise date to today (doesn't auto-load; that‚Äôs up to you)
  (function seedDate() {
    const now = new Date();
    const yyyy = now.getFullYear();
    const mm = String(now.getMonth()+1).padStart(2,'0');
    const dd = String(now.getDate()).padStart(2,'0');
    dateInput.value = `${yyyy}-${mm}-${dd}`;
  })();

})();


// --- qds_growthhub_onepager_print.html ---

(function(){
  // === YOU MAY NEED TO TWEAK THESE SELECTORS ===
  // Goal: read the already-rendered live numbers off your page.
  const SEL = {
    rev_mo:   ['[data-kpi="rev_mo"]', '#rev_mo', '#kpiRevenueMonth', '.kpi-rev-month .value'],
    rev_yr:   ['[data-kpi="rev_yr"]', '#rev_yr', '#kpiRunRate', '.kpi-runrate .value'],
    new_mrr:  ['[data-kpi="new_mrr"]', '#new_mrr', '#kpiNewMRR', '.kpi-new-mrr .value'],
    mrr_h:    ['[data-kpi="mrr_h"]', '#mrr_h', '#kpiMRRHorizon', '.kpi-mrr-h .value'],

    qual:     ['#outQualified', '[data-out="qualified"]', '.out-qualified'],
    sprints:  ['#outSprints', '[data-out="sprints"]', '.out-sprints'],
    pilots:   ['#outPilots', '[data-out="pilots"]', '.out-pilots'],
    retain:   ['#outRetainers', '[data-out="retainers"]', '.out-retainers'],

    q:        ['#in_q', 'input[name="q"]', '[data-in="q"]'],
    s:        ['#in_s', 'input[name="s"]', '[data-in="s"]'],
    p:        ['#in_p', 'input[name="p"]', '[data-in="p"]'],
    r:        ['#in_r', 'input[name="r"]', '[data-in="r"]'],
    c:        ['#in_c', 'input[name="c"]', '[data-in="c"]'],

    currency: ['#currency', 'input[name="currency"]', '[data-in="currency"]']
  };

  function pick(selectors){
    for(const s of selectors){
      const el = document.querySelector(s);
      if(el) return el;
    }
    return null;
  }

  function readText(el){
    if(!el) return '‚Äî';
    if(el.tagName === 'INPUT' || el.tagName === 'SELECT' || el.tagName === 'TEXTAREA'){
      return (el.value ?? '').toString().trim() || '‚Äî';
    }
    return (el.textContent ?? '').toString().trim() || '‚Äî';
  }

  function moneyish(x, cur){
    if(!x || x==='‚Äî') return '‚Äî';
    // if it already has a currency symbol, keep it
    if(/[¬£$‚Ç¨]/.test(x)) return x;
    // otherwise prefix symbol
    return (cur && cur!=='‚Äî') ? (cur + x) : x;
  }

  function updateOnePager(){
    const cur = readText(pick(SEL.currency));

    const rev_mo  = readText(pick(SEL.rev_mo));
    const rev_yr  = readText(pick(SEL.rev_yr));
    const new_mrr = readText(pick(SEL.new_mrr));
    const mrr_h   = readText(pick(SEL.mrr_h));

    const qual    = readText(pick(SEL.qual));
    const sprints = readText(pick(SEL.sprints));
    const pilots  = readText(pick(SEL.pilots));
    const retain  = readText(pick(SEL.retain));

    const q = readText(pick(SEL.q));
    const s = readText(pick(SEL.s));
    const p = readText(pick(SEL.p));
    const r = readText(pick(SEL.r));
    const c = readText(pick(SEL.c));

    document.getElementById('op_rev_mo').textContent  = moneyish(rev_mo, cur);
    document.getElementById('op_rev_yr').textContent  = moneyish(rev_yr, cur);
    document.getElementById('op_new_mrr').textContent = moneyish(new_mrr, cur);
    document.getElementById('op_mrr_h').textContent   = moneyish(mrr_h, cur);

    document.getElementById('op_qual').textContent    = qual;
    document.getElementById('op_sprints').textContent = sprints;
    document.getElementById('op_pilots').textContent  = pilots;
    document.getElementById('op_retain').textContent  = retain;

    document.getElementById('op_q').textContent = q;
    document.getElementById('op_s').textContent = s;
    document.getElementById('op_p').textContent = p;
    document.getElementById('op_r').textContent = r;
    document.getElementById('op_c').textContent = c;

    const summary =
`Board summary (capacity-truth, not hype):
‚Ä¢ Revenue/month: ${moneyish(rev_mo,cur)}  | Run-rate/year: ${moneyish(rev_yr,cur)}
‚Ä¢ New MRR/month: ${moneyish(new_mrr,cur)} | MRR@horizon: ${moneyish(mrr_h,cur)}
‚Ä¢ Volumes/month: Qualified ${qual}, Sprints ${sprints}, Pilots ${pilots}, New retainers ${retain}
‚Ä¢ Rates: q=${q}, s=${s}, p=${p}, r=${r}, churn=${c}
Positioning: ‚Äúhonest planning with explicit caps + assumption audit.‚Äù`;

    document.getElementById('op_board').textContent = summary;
    document.getElementById('op_note').textContent =
      "Snapshot taken from current live page state. Print is designed to be clean and meeting-safe.";
  }

  // Wire up buttons if your page already has ones, great ‚Äî otherwise we add keyboard shortcut:
  // Press "P" to toggle the onepager.
  function showOnePager(on){
    const wrap = document.getElementById('qdsOnePagerWrap');
    wrap.style.display = on ? 'block' : 'none';

    // Hide main content while onepager is up (keeps it tidy)
    document.querySelectorAll('body > :not(#qdsOnePagerWrap)').forEach(el=>{
      if(el.id === 'qdsOnePagerWrap') return;
      el.style.display = on ? 'none' : '';
    });

    if(on) updateOnePager();
  }

  // Try to bind to an existing ‚ÄúToggle One-Pager View‚Äù button if you have one.
  // If not, use keyboard 'p'.
  document.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase()==='p' && !e.ctrlKey && !e.metaKey && !e.altKey){
      const visible = document.getElementById('qdsOnePagerWrap').style.display === 'block';
      showOnePager(!visible);
    }
  });

  document.getElementById('qdsOPPrint').onclick = ()=>{ updateOnePager(); window.print(); };
  document.getElementById('qdsOPClose').onclick = ()=>{ showOnePager(false); };
  document.getElementById('qdsOPCopy').onclick = async ()=>{
    updateOnePager();
    const txt = document.getElementById('op_board').textContent || '';
    try{ await navigator.clipboard.writeText(txt); alert('Board summary copied.'); }
    catch(e){ prompt('Copy board summary:', txt); }
  };

  // Optional: auto-detect your existing toggle button by text
  // (won‚Äôt break if not found)
  const btns = [...document.querySelectorAll('button, a')];
  const toggle = btns.find(b => (b.textContent||'').toLowerCase().includes('one-pager'));
  if(toggle){
    toggle.addEventListener('click', (e)=>{ e.preventDefault(); showOnePager(true); });
  }
})();


// --- qds_revenue_floor_v2_delta.html ---

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);

function num(id, def=0){
  const el = $(id);
  if(!el) return def;
  const v = parseFloat(String(el.value ?? "").trim());
  return Number.isFinite(v) ? v : def;
}
function clamp(x, a, b){
  if(!Number.isFinite(x)) return a;
  return Math.min(b, Math.max(a, x));
}
function fmtMoney(x){
  const cur = String($("currency").value || "¬£").trim() || "¬£";
  const n = Number.isFinite(x) ? x : 0;
  const rounded = Math.round(n);
  return cur + rounded.toLocaleString();
}

/* ---------- Core model ---------- */
function computeModel(){
  const L = Math.max(0, num("L"));
  const q = clamp(num("q"), 0, 1);
  const s = clamp(num("s"), 0, 1);
  const p = clamp(num("p"), 0, 1);
  const r = clamp(num("r"), 0, 1);

  const Sprice = Math.max(0, num("Sprice"));
  const Pprice = Math.max(0, num("Pprice"));
  const Rprice = Math.max(0, num("Rprice"));

  const Smax = Math.max(0, num("Smax"));
  const Pmax = Math.max(0, num("Pmax"));

  const M0 = Math.max(0, num("M0"));
  const churnPct = clamp(num("churn"), 0, 50);
  const churn = churnPct / 100;

  const months = clamp(Math.round(num("months", 12)), 1, 60);

  const qualified = L * q;
  const sprintsRaw = qualified * s;
  const sprints = Math.min(sprintsRaw, Smax);

  const pilotsRaw = sprints * p;
  const pilots = Math.min(pilotsRaw, Pmax);

  const newRetainers = pilots * r;

  const newMrr = newRetainers * Rprice;

  const revMonth = (sprints * Sprice) + (pilots * Pprice) + newMrr;
  const revYear = revMonth * 12;

  // MRR accumulation over horizon
  let mrr = M0;
  const mrrTimeline = [mrr];
  for(let i=1;i<=months;i++){
    mrr = (mrr + newMrr) * (1 - churn);
    mrrTimeline.push(mrr);
  }

  const at = (n)=>{
    const idx = clamp(n, 0, months);
    return mrrTimeline[idx];
  };

  return {
    L,q,s,p,r,Sprice,Pprice,Rprice,Smax,Pmax,M0,churnPct,churn,months,
    qualified,sprintsRaw,sprints,pilotsRaw,pilots,newRetainers,newMrr,
    revMonth,revYear,mrrTimeline,
    mrr3: at(3), mrr6: at(6), mrr12: at(12), mrrEnd: at(months)
  };
}

/* ---------- Presets ---------- */
const PRESETS = {
  conservative: {
    L:6, q:0.40, s:0.30, p:0.30, r:0.25,
    Sprice:2000, Pprice:5000, Rprice:1500,
    Smax:4, Pmax:2, M0:0, churn:4
  },
  base: {
    L:12, q:0.50, s:0.35, p:0.40, r:0.30,
    Sprice:2500, Pprice:6000, Rprice:2000,
    Smax:6, Pmax:3, M0:0, churn:3
  },
  optimistic: {
    L:20, q:0.60, s:0.45, p:0.45, r:0.40,
    Sprice:3000, Pprice:8000, Rprice:2500,
    Smax:8, Pmax:4, M0:0, churn:2
  }
};

function applyPreset(){
  const key = $("preset")?.value || "base";
  const p = PRESETS[key] || PRESETS.base;

  $("L").value = p.L;
  $("q").value = p.q;
  $("s").value = p.s;
  $("p").value = p.p;
  $("r").value = p.r;

  $("Sprice").value = p.Sprice;
  $("Pprice").value = p.Pprice;
  $("Rprice").value = p.Rprice;

  $("Smax").value = p.Smax;
  $("Pmax").value = p.Pmax;

  $("M0").value = p.M0;
  $("churn").value = p.churn;
}

/* ---------- Sensitivity ---------- */
function buildSensitivity(base){
  const rows = [];

  function calcWith(patch){
    // temporarily apply patch values, compute, then restore
    const ids = Object.keys(patch);
    const old = {};
    ids.forEach(id=>{
      old[id] = $(id).value;
      $(id).value = patch[id];
    });
    const m = computeModel();
    ids.forEach(id=>$(id).value = old[id]);
    return m.revYear;
  }

  const baseYear = base.revYear;

  // +1 lead
  rows.push({
    label: "+1 lead / month",
    delta: calcWith({L: num("L")+1}) - baseYear
  });

  // +0.10 sprint close
  rows.push({
    label: "+0.10 sprint close rate",
    delta: calcWith({s: clamp(num("s")+0.10, 0, 1)}) - baseYear
  });

  // +1 sprint capacity
  rows.push({
    label: "+1 sprint capacity",
    delta: calcWith({Smax: num("Smax")+1}) - baseYear
  });

  // +0.05 pilot-from-sprint
  rows.push({
    label: "+0.05 pilot-from-sprint",
    delta: calcWith({p: clamp(num("p")+0.05, 0, 1)}) - baseYear
  });

  // +0.05 retainer-from-pilot
  rows.push({
    label: "+0.05 retainer-from-pilot",
    delta: calcWith({r: clamp(num("r")+0.05, 0, 1)}) - baseYear
  });

  const body = $("sensBody");
  body.innerHTML = "";
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const td1 = document.createElement("td");
    const td2 = document.createElement("td");
    td1.textContent = r.label;
    td2.textContent = fmtMoney(r.delta);
    tr.appendChild(td1); tr.appendChild(td2);
    body.appendChild(tr);
  });
}

/* ---------- Board summary ---------- */
function buildBoardSummary(m){
  const capNote = String($("capNotes").value || "").trim();
  const cost = Math.max(0, num("cost"));

  const conf = {
    q: $("qConf")?.value || "Med",
    s: $("sConf")?.value || "Med",
    p: $("pConf")?.value || "Med",
    r: $("rConf")?.value || "Med",
    c: $("cConf")?.value || "Med",
  };

  const notes = {
    q: String($("qNote")?.value || "").trim(),
    s: String($("sNote")?.value || "").trim(),
    p: String($("pNote")?.value || "").trim(),
    r: String($("rNote")?.value || "").trim(),
    c: String($("cNote")?.value || "").trim(),
  };

  const parts = [];
  parts.push(
    `Revenue floor model (capacity-truthed): ` +
    `${m.L} leads/mo ‚Üí q ${m.q.toFixed(2)} ‚Üí s ${m.s.toFixed(2)} ‚Üí p ${m.p.toFixed(2)} ‚Üí r ${m.r.toFixed(2)}.`
  );
  parts.push(
    `Pricing: Sprint ${fmtMoney(m.Sprice)}, Pilot ${fmtMoney(m.Pprice)}, Retainer ${fmtMoney(m.Rprice)}/mo.`
  );
  parts.push(
    `Capacity: Smax ${m.Smax}, Pmax ${m.Pmax}` + (capNote ? ` (${capNote})` : "") + `.`
  );
  parts.push(
    `Expected/month: ${m.sprints.toFixed(2)} sprints, ${m.pilots.toFixed(2)} pilots, ${m.newRetainers.toFixed(2)} new retainers.`
  );
  parts.push(
    `Run-rate: ${fmtMoney(m.revMonth)}/mo (${fmtMoney(m.revYear)}/yr).`
  );
  parts.push(
    `MRR: M0 ${fmtMoney(m.M0)}, churn ${m.churnPct.toFixed(1)}%. New MRR ${fmtMoney(m.newMrr)}/mo ‚Üí projected MRR @ ${m.months} months ${fmtMoney(m.mrrEnd)}.`
  );
  if(cost>0){
    parts.push(`Cost base noted: ${fmtMoney(cost)}/mo (for margin context, not enforced in calc).`);
  }

  const confLine =
    `Assumption confidence: q ${conf.q}, s ${conf.s}, p ${conf.p}, r ${conf.r}, churn ${conf.c}.`;
  parts.push(confLine);

  const ev = [];
  if(notes.q) ev.push(`q: ${notes.q}`);
  if(notes.s) ev.push(`s: ${notes.s}`);
  if(notes.p) ev.push(`p: ${notes.p}`);
  if(notes.r) ev.push(`r: ${notes.r}`);
  if(notes.c) ev.push(`c: ${notes.c}`);
  if(ev.length) parts.push(`Evidence: ${ev.join(" | ")}`);

  parts.push(`This model is deliberately conservative: upside comes from more leads, better close rates, and capacity expansion ‚Äî not inflated assumptions.`);

  return parts.join(" ");
}

/* ---------- Render ---------- */
function render(){
  const m = computeModel();

  // update audit value cells
  $("qValCell").textContent = m.q.toFixed(2);
  $("sValCell").textContent = m.s.toFixed(2);
  $("pValCell").textContent = m.p.toFixed(2);
  $("rValCell").textContent = m.r.toFixed(2);
  $("cValCell").textContent = m.churnPct.toFixed(1) + "%";

  // KPIs
  $("revMonth").textContent = fmtMoney(m.revMonth);
  $("revYear").textContent = fmtMoney(m.revYear);
  $("newMrr").textContent = fmtMoney(m.newMrr);
  $("mrrEnd").textContent = fmtMoney(m.mrrEnd);
  $("mrrEndSub").textContent = `MRR after churn @ ${m.months} months`;

  // volumes
  $("volumesBox").innerHTML =
    `Qualified: ${m.qualified.toFixed(2)}<br/>` +
    `Sprints: ${m.sprints.toFixed(2)} (raw ${m.sprintsRaw.toFixed(2)})<br/>` +
    `Pilots: ${m.pilots.toFixed(2)} (raw ${m.pilotsRaw.toFixed(2)})<br/>` +
    `New retainers: ${m.newRetainers.toFixed(2)}`;

  // MRR accumulation snapshot
  $("mrrBox").innerHTML =
    `Starting: ${fmtMoney(m.M0)}<br/>` +
    `MRR @ 3 months: ${fmtMoney(m.mrr3)}<br/>` +
    `MRR @ 6 months: ${fmtMoney(m.mrr6)}<br/>` +
    `MRR @ 12 months: ${fmtMoney(m.mrr12)}`;

  // sensitivity
  buildSensitivity(m);

  // board summary
  const summary = buildBoardSummary(m);
  $("boardSummary").value = summary;

  // status pill
  $("statusPill").textContent = "Live";
}

/* ---------- One-pager + Print ---------- */
function toggleView(){
  document.body.classList.toggle("onepager");
}
function printOnePager(){
  // ensure onepager layout for print, but restore after
  const was = document.body.classList.contains("onepager");
  if(!was) document.body.classList.add("onepager");
  window.print();
  if(!was) document.body.classList.remove("onepager");
}

/* ---------- Copy summary ---------- */
async function copySummary(){
  const text = $("boardSummary").value || "";
  try{
    await navigator.clipboard.writeText(text);
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }catch(e){
    // fallback
    $("boardSummary").select();
    document.execCommand("copy");
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }
}

/* ---------- Reset ---------- */
function resetBase(){
  $("preset").value = "base";
  applyPreset();
  $("currency").value = "¬£";
  $("months").value = 12;
  $("Smax").value = 6;
  $("Pmax").value = 3;
  $("M0").value = 0;
  $("churn").value = 3;
  $("cost").value = 200;
  $("capNotes").value = "";

  // audit defaults
  ["qConf","sConf","pConf","rConf","cConf"].forEach(id=>{ if($(id)) $(id).value="Med"; });
  ["qNote","sNote","pNote","rNote","cNote"].forEach(id=>{ if($(id)) $(id).value=""; });

  render();
}

/* ---------- Bulletproof wiring ---------- */
function attachListeners(){
  document.querySelectorAll("input, select, textarea").forEach(el=>{
    const handler = ()=>{
      if(el.id === "preset"){ applyPreset(); }
      render();
    };
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  $("toggleViewBtn").addEventListener("click", toggleView);
  $("printBtn").addEventListener("click", printOnePager);
  $("copySummaryBtn").addEventListener("click", copySummary);
  $("resetBtn").addEventListener("click", resetBase);
}

applyPreset();
attachListeners();
render();


(function(){
  function parseMoney(s){
    if(!s) return NaN;
    // keep minus sign; remove everything else except digits and dot/comma
    let t = s.replace(/,/g,'').replace(/[^\d\.\-]/g,'').trim();
    return t ? Number(t) : NaN;
  }
  function fmtMoney(x, sym){
    if(!isFinite(x)) return "‚Äî";
    const sign = x >= 0 ? "+" : "‚àí";
    const v = Math.abs(x);
    // nice thousands
    const pretty = v.toLocaleString(undefined,{maximumFractionDigits:0});
    return sign + (sym||"") + pretty;
  }
  function findValueNearLabel(labelText){
    const all = Array.from(document.querySelectorAll("div,span,p,h1,h2,h3,h4,td,th,label,strong"));
    const lab = all.find(el => (el.textContent||"").trim() === labelText);
    if(!lab) return null;
    // try next elements for a money string
    let cur = lab;
    for(let i=0;i<12;i++){
      cur = cur.nextElementSibling || cur.parentElement?.nextElementSibling;
      if(!cur) break;
      const t = (cur.textContent||"").trim();
      if(/[¬£$‚Ç¨]\s*\d|\d/.test(t)) return cur;
    }
    return null;
  }
  function getBaseYear(){
    // try exact label first
    const vEl = findValueNearLabel("Revenue / Year (Run-Rate)");
    if(vEl){
      const t = (vEl.textContent||"").trim();
      const sym = (t.match(/[¬£$‚Ç¨]/)||[""])[0];
      const val = parseMoney(t);
      if(isFinite(val)) return {val, sym};
    }
    // fallback: find the first big money number on page near that phrase
    const blobs = Array.from(document.querySelectorAll("*"))
      .filter(el => (el.textContent||"").includes("Revenue / Year (Run-Rate)"));
    for(const b of blobs){
      const area = b.closest("section") || b.parentElement || b;
      const candidates = Array.from(area.querySelectorAll("*"))
        .map(x => (x.textContent||"").trim())
        .filter(t => /[¬£$‚Ç¨]\s*\d/.test(t));
      if(candidates.length){
        const t = candidates[0];
        const sym = (t.match(/[¬£$‚Ç¨]/)||[""])[0];
        const val = parseMoney(t);
        if(isFinite(val)) return {val, sym};
      }
    }
    return null;
  }

  function fixSensitivity(){
    const base = getBaseYear();
    if(!base) return;

    // find the Sensitivity block by heading text
    const heads = Array.from(document.querySelectorAll("h1,h2,h3,h4,div,span,strong"))
      .filter(el => /What Moves the Needle/i.test((el.textContent||"").trim()));
    if(!heads.length) return;

    const root = heads[0].closest("section") || heads[0].parentElement || document;
    const rows = Array.from(root.querySelectorAll("tr"));
    if(!rows.length) return;

    // also rename the column label if present
    const ths = Array.from(root.querySelectorAll("th"));
    ths.forEach(th=>{
      if(/Effect on yearly run-rate/i.test(th.textContent||"")){
        th.textContent = "Œî yearly run-rate";
      }
    });

    rows.forEach(tr=>{
      const tds = tr.querySelectorAll("td");
      if(tds.length < 2) return;
      const cell = tds[tds.length-1];
      const raw = (cell.textContent||"").trim();
      if(!raw) return;
      if(/^[\+\-‚àí]/.test(raw)) return; // already delta style

      const scen = parseMoney(raw);
      if(!isFinite(scen)) return;

      // only convert if it looks like a total (usually bigger than base/2)
      if(scen < base.val * 0.5) return;

      const delta = scen - base.val;
      cell.textContent = fmtMoney(delta, base.sym);
    });
  }

  // run now + keep it correct when sliders change
  fixSensitivity();
  const obs = new MutationObserver(()=>fixSensitivity());
  obs.observe(document.body, {subtree:true, childList:true, characterData:true});
})();


// --- qds_revenue_floor_v5.html ---

(function(){
  const $ = (id)=>document.getElementById(id);

  const KEY = "QDS_GrowthHub_RevenueFloor_v5";

  const presets = {
    conservative: {
      L:4, q:0.35, s:0.20, p:0.25, r:0.15,
      sprintPrice:2200, pilotPrice:3200, retainerMonth:650,
      Smax:1, Pmax:1, months:12, m0:0, c:3.5, cost:0
    },
    base: {
      /* Lower, more realistic starting point (no ‚Äú¬£15k/mo out the gate‚Äù) */
      L:6, q:0.40, s:0.25, p:0.30, r:0.20,
      sprintPrice:2500, pilotPrice:3500, retainerMonth:800,
      Smax:2, Pmax:1, months:12, m0:0, c:3.0, cost:0
    },
    optimistic: {
      L:10, q:0.50, s:0.30, p:0.35, r:0.25,
      sprintPrice:3000, pilotPrice:4200, retainerMonth:1000,
      Smax:3, Pmax:2, months:12, m0:0, c:2.5, cost:0
    }
  };

  function clamp01(x){ x = Number(x); if(!isFinite(x)) return 0; return Math.max(0, Math.min(1, x)); }
  function num(x, def=0){ x = Number(x); return isFinite(x) ? x : def; }

  function sym(){
    const s = String($("sym").value || "¬£").trim();
    return s.length ? s : "¬£";
  }

  function fmtMoney(x){
    const s = sym();
    if(!isFinite(x)) return "‚Äî";
    const v = Math.round(x);
    return s + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  function fmtMoneySigned(x){
    const s = sym();
    if(!isFinite(x)) return "‚Äî";
    const sign = x > 0 ? "+" : (x < 0 ? "‚àí" : "¬±");
    const v = Math.round(Math.abs(x));
    return sign + s + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  function readInputs(){
    return {
      L: num($("L").value),
      q: clamp01($("q").value),
      s: clamp01($("s").value),
      p: clamp01($("p").value),
      r: clamp01($("r").value),
      sprintPrice: num($("sprintPrice").value),
      pilotPrice: num($("pilotPrice").value),
      retainerMonth: num($("retainerMonth").value),
      Smax: num($("Smax").value),
      Pmax: num($("Pmax").value),
      months: Math.max(1, Math.floor(num($("months").value, 12))),
      m0: Math.max(0, num($("m0").value)),
      c: Math.max(0, num($("c").value)) / 100.0,
      cost: Math.max(0, num($("cost").value)),
      notes: String($("notes").value||"")
    };
  }

  // Core model (math kept clean and consistent)
  function model(inp){
    const qualified = inp.L * inp.q;

    const sprintsRaw = qualified * inp.s;
    const sprints = (isFinite(inp.Smax) && inp.Smax >= 0) ? Math.min(sprintsRaw, inp.Smax) : sprintsRaw;

    const pilotsRaw = sprints * inp.p;
    const pilots = (isFinite(inp.Pmax) && inp.Pmax >= 0) ? Math.min(pilotsRaw, inp.Pmax) : pilotsRaw;

    const newRetainers = pilots * inp.r;

    const revMonth =
      sprints * inp.sprintPrice +
      pilots  * inp.pilotPrice +
      newRetainers * inp.retainerMonth;

    const runRateYear = revMonth * 12;

    // MRR accumulation with churn
    const mrrTrack = [];
    let mrr = inp.m0;
    for(let t=1; t<=inp.months; t++){
      mrr = mrr * (1 - inp.c) + newRetainers * inp.retainerMonth;
      mrrTrack.push(mrr);
    }

    function mAt(month){
      if(month <= 0) return inp.m0;
      if(month > mrrTrack.length) return mrrTrack[mrrTrack.length-1] ?? inp.m0;
      return mrrTrack[month-1];
    }

    return {
      qualified,
      sprintsRaw, sprints,
      pilotsRaw, pilots,
      newRetainers,
      revMonth, runRateYear,
      mrrTrack,
      mrr3: mAt(3),
      mrr6: mAt(6),
      mrr12: mAt(12),
      mrrH: mAt(inp.months),
    };
  }

  function setAudit(inp){
    const tbody = $("auditBody");
    tbody.innerHTML = "";

    const rows = [
      {k:"Qualified rate (q)", v: inp.q.toFixed(2), conf:"Med", note:"How many leads are actually in-scope."},
      {k:"Sprint close (s)", v: inp.s.toFixed(2), conf:"Med", note:"Conversion from qualified to paid sprint."},
      {k:"Pilot-from-sprint (p)", v: inp.p.toFixed(2), conf:"Med", note:"Who extends from sprint into pilot."},
      {k:"Retainer-from-pilot (r)", v: inp.r.toFixed(2), conf:"Med", note:"Pilot ‚Üí ongoing retainer conversion."},
      {k:"Churn (c)", v: (inp.c*100).toFixed(1) + "%", conf:"Low", note:"Until you have 6‚Äì12 months data."},
      {k:"Capacity caps", v: `Smax=${inp.Smax}, Pmax=${inp.Pmax}`, conf:"High", note:"Your time/ops reality (non-negotiable)."},
    ];

    function confChip(level){
      let cls="chip cMed", dot="var(--teal)";
      if(level==="Low"){ cls="chip cLow"; dot="var(--warn)"; }
      if(level==="High"){ cls="chip cHigh"; dot="var(--lime)"; }
      return `<span class="${cls}"><span class="cDot" style="background:${dot}"></span>${level}</span>`;
    }

    for(const r of rows){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${r.k}</td>
        <td>${r.v}</td>
        <td>${confChip(r.conf)}</td>
        <td style="color:var(--muted)">${r.note}</td>
      `;
      tbody.appendChild(tr);
    }
  }

  function setSensitivity(inp, base){
    const scenarios = [
      { idy:"s_y1", idm:"s_m1", mod: x => ({...x, L: x.L + 1}) },
      { idy:"s_y2", idm:"s_m2", mod: x => ({...x, s: clamp01(x.s + 0.10)}) },
      { idy:"s_y3", idm:"s_m3", mod: x => ({...x, Smax: (isFinite(x.Smax) ? x.Smax + 1 : x.Smax)}) },
      { idy:"s_y4", idm:"s_m4", mod: x => ({...x, p: clamp01(x.p + 0.05)}) },
      { idy:"s_y5", idm:"s_m5", mod: x => ({...x, r: clamp01(x.r + 0.05)}) },
    ];

    for(const sc of scenarios){
      const m = model(sc.mod(inp));
      const dy = m.runRateYear - base.runRateYear;
      const dm = m.revMonth - base.revMonth;

      const yEl = $(sc.idy);
      const mEl = $(sc.idm);

      yEl.textContent = fmtMoneySigned(dy);
      mEl.textContent = fmtMoneySigned(dm);

      // colour by sign
      const cls = (dy > 1e-9) ? "good" : (dy < -1e-9) ? "bad" : "neutral";
      yEl.className = cls;
      mEl.className = cls;
    }
  }

  function render(){
    const inp = readInputs();

    // keep currency hints synced
    const s = sym();
    $("labSprint").textContent = `${s} / sprint`;
    $("labPilot").textContent  = `${s} / pilot`;
    $("labRet").textContent    = `${s} / mo`;

    const m = model(inp);

    $("revMonthOut").textContent = fmtMoney(m.revMonth);
    $("runRateOut").textContent  = fmtMoney(m.runRateYear);
    $("newMRROut").textContent   = fmtMoney(m.newRetainers * inp.retainerMonth);
    $("mrrHOut").textContent     = fmtMoney(m.mrrH);
    $("mrrHSub").textContent     = `MRR after churn @ ${inp.months} month${inp.months===1?"":"s"}`;

    $("volLine").innerHTML =
      `<b>Expected volumes / month</b><br/>
      Qualified: <b>${m.qualified.toFixed(2)}</b> ‚Ä¢
      Sprints: <b>${m.sprints.toFixed(2)}</b> <span style="opacity:.8">(raw ${m.sprintsRaw.toFixed(2)})</span> ‚Ä¢
      Pilots: <b>${m.pilots.toFixed(2)}</b> <span style="opacity:.8">(raw ${m.pilotsRaw.toFixed(2)})</span> ‚Ä¢
      New retainers: <b>${m.newRetainers.toFixed(2)}</b>`;

    // MRR keypoints
    const m3 = (inp.months >= 3) ? fmtMoney(m.mrr3) : "‚Äî";
    const m6 = (inp.months >= 6) ? fmtMoney(m.mrr6) : "‚Äî";
    const m12= (inp.months >= 12)? fmtMoney(m.mrr12): "‚Äî";

    $("mrrLine").innerHTML =
      `<b>MRR accumulation</b><br/>
      Starting: <b>${fmtMoney(inp.m0)}</b> ‚Ä¢
      MRR @ 3 mo: <b>${m3}</b> ‚Ä¢
      MRR @ 6 mo: <b>${m6}</b> ‚Ä¢
      MRR @ 12 mo: <b>${m12}</b> ‚Ä¢
      MRR @ horizon: <b>${fmtMoney(m.mrrH)}</b>`;

    const board = `Base plan: ${fmtMoney(m.revMonth)}/mo revenue ‚Üí ${fmtMoney(m.runRateYear)}/yr run-rate. Adds ${fmtMoney(m.newRetainers * inp.retainerMonth)}/mo new MRR; projected MRR @ ${inp.months} months: ${fmtMoney(m.mrrH)}.`;
    $("boardSummaryText").textContent = board;

    setAudit(inp);
    setSensitivity(inp, m);
  }

  function applyPreset(name){
    const p = presets[name] || presets.base;
    $("L").value = p.L;
    $("q").value = p.q;
    $("s").value = p.s;
    $("p").value = p.p;
    $("r").value = p.r;
    $("sprintPrice").value = p.sprintPrice;
    $("pilotPrice").value = p.pilotPrice;
    $("retainerMonth").value = p.retainerMonth;
    $("Smax").value = p.Smax;
    $("Pmax").value = p.Pmax;
    $("months").value = p.months;
    $("m0").value = p.m0;
    $("c").value = (p.c*100).toFixed(1);
    $("cost").value = p.cost;
    render();
  }

  function saveLS(){
    const inp = readInputs();
    localStorage.setItem(KEY, JSON.stringify(inp));
  }

  function loadLS(){
    const raw = localStorage.getItem(KEY);
    if(!raw) return;
    try{
      const x = JSON.parse(raw);
      for(const k of ["sym","months","m0","L","q","s","p","r","sprintPrice","pilotPrice","retainerMonth","Smax","Pmax","c","cost","notes"]){
        if($(k) && x[k] !== undefined) $(k).value = x[k];
      }
      render();
    }catch(e){}
  }

  // Wire events
  document.addEventListener("input", (e)=>{ if(e.target && (e.target.tagName==="INPUT"||e.target.tagName==="SELECT"||e.target.tagName==="TEXTAREA")) render(); }, true);
  document.addEventListener("change", (e)=>{ if(e.target && (e.target.tagName==="INPUT"||e.target.tagName==="SELECT"||e.target.tagName==="TEXTAREA")) render(); }, true);

  $("mode").addEventListener("change", ()=>applyPreset($("mode").value));

  $("btnToggleOnePager").addEventListener("click", ()=>{
    document.body.classList.toggle("onepager");
  });

  $("btnPrint").addEventListener("click", ()=>window.print());

  $("btnCopyBoard").addEventListener("click", async ()=>{
    const text = $("boardSummaryText").textContent || "";
    try{
      await navigator.clipboard.writeText(text);
      $("btnCopyBoard").textContent = "Copied ‚úì";
      setTimeout(()=> $("btnCopyBoard").textContent="Copy Board Summary", 900);
    }catch(e){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = text; document.body.appendChild(ta);
      ta.select(); document.execCommand("copy");
      ta.remove();
    }
  });

  $("btnReset").addEventListener("click", ()=>{
    $("mode").value = "base";
    $("sym").value = "¬£";
    $("notes").value = "";
    applyPreset("base");
  });

  $("btnSaveLS").addEventListener("click", ()=>{ saveLS(); });
  $("btnLoadLS").addEventListener("click", ()=>{ loadLS(); });
  $("btnDefaults").addEventListener("click", ()=>{ $("mode").value="base"; $("sym").value="¬£"; $("notes").value=""; applyPreset("base"); });

  // First paint
  applyPreset("base");
})();


// --- frontdoor_show_backup_20251210_225540.html ---


// --- qds_avian_lab_v4_pro.html ---

(function () {
  const speciesPresets = {
    "European Robin":   { tau: 1.4, lambda: 1.2, noise: 0.12 },
    "Racing Pigeon":    { tau: 2.0, lambda: 1.6, noise: 0.10 },
    "Wandering Albatross": { tau: 3.0, lambda: 2.0, noise: 0.06 },
    "Blackcap Warbler": { tau: 1.1, lambda: 1.0, noise: 0.15 },
    "Arctic Tern":      { tau: 2.4, lambda: 1.8, noise: 0.10 }
  };

  const envAdjust = {
    "Quiet Forest":   { tauFactor: 1.00, lambdaFactor: 1.00, noiseOffset: -0.05 },
    "Urban Corridor": { tauFactor: 0.85, lambdaFactor: 0.95, noiseOffset: 0.22 },
    "Magnetic Storm": { tauFactor: 0.70, lambdaFactor: 0.85, noiseOffset: 0.55 },
    "Solar Flare":    { tauFactor: 0.95, lambdaFactor: 1.05, noiseOffset: 0.30 },
    "Quantum Lab":    { tauFactor: 1.10, lambdaFactor: 1.10, noiseOffset: -0.10 }
  };

  const state = {
    species: "European Robin",
    env: "Quiet Forest",
    tau: 1.4,
    lambda: 1.2,
    noise: 0.12,
    K: 0,
    fiveG: false,
    night: false
  };

  const speciesSelect = document.getElementById("speciesSelect");
  const tauSlider = document.getElementById("tauSlider");
  const lambdaSlider = document.getElementById("lambdaSlider");
  const noiseSlider = document.getElementById("noiseSlider");
  const tauValue = document.getElementById("tauValue");
  const lambdaValue = document.getElementById("lambdaValue");
  const noiseValue = document.getElementById("noiseValue");
  const needle = document.getElementById("needle");
  const needleTail = document.getElementById("needleTail");
  const statusBanner = document.getElementById("statusBanner");
  const kIndicator = document.getElementById("kIndicator");
  const cryptoDot = document.getElementById("cryptoDot");
  const cryptoCaption = document.getElementById("cryptoCaption");
  const envButtons = Array.from(document.querySelectorAll(".env-btn"));
  const fivegToggle = document.getElementById("fivegToggle");
  const dayNightToggle = document.getElementById("dayNightToggle");
  const exportBtn = document.getElementById("exportBtn");
  const overlay = document.getElementById("exportOverlay");
  const exportText = document.getElementById("exportText");
  const copyBtn = document.getElementById("copyBtn");
  const closeOverlayBtn = document.getElementById("closeOverlayBtn");

  let compassMode = "stable";
  let lastAngle = -90; // degrees

  function clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  }

  function getPresetParams() {
    const base = speciesPresets[state.species] || speciesPresets["European Robin"];
    const adj = envAdjust[state.env] || envAdjust["Quiet Forest"];

    let tau = base.tau * adj.tauFactor;
    let lambda = base.lambda * adj.lambdaFactor;
    let noise = clamp(base.noise + adj.noiseOffset, 0, 1);

    if (state.night) {
      tau *= 1.18;
      noise = clamp(noise - 0.06, 0, 1);
    }

    if (state.fiveG) {
      noise = clamp(noise + 0.25, 0, 1);
    }

    return {
      tau: clamp(tau, 0.2, 6),
      lambda: clamp(lambda, 0.3, 2.5),
      noise
    };
  }

  function syncSlidersToState() {
    tauSlider.value = state.tau;
    lambdaSlider.value = state.lambda;
    noiseSlider.value = state.noise;
    tauValue.textContent = state.tau.toFixed(2) + " ms";
    lambdaValue.textContent = state.lambda.toFixed(2) + " nm";
    noiseValue.textContent = state.noise.toFixed(2);
  }

  function computeK() {
    const tauNorm = state.tau / 3.0;      // ~1 around mid-range
    const lambdaNorm = state.lambda / 1.5;
    const noiseTerm = 1 - state.noise;    // 1 = quiet, 0 = chaos

    let Kraw = tauNorm * lambdaNorm * noiseTerm * 2.6;
    state.K = clamp(Kraw, 0, 2.6);
    kIndicator.textContent =
      "Kernel Stability Index K ‚âà " + state.K.toFixed(3);
  }

  function updateStatusAndMode() {
    if (state.K >= 1.6) {
      compassMode = "stable";
      statusBanner.classList.remove("warn", "danger");
      statusBanner.textContent =
        "Stable Navigation ‚Äî Ideal migratory corridor locked.";
    } else if (state.K >= 0.7) {
      compassMode = "mild";
      statusBanner.classList.remove("danger");
      statusBanner.classList.add("warn");
      statusBanner.textContent =
        "Functional Navigation ‚Äî Mild noise, drift possible near cities.";
    } else {
      compassMode = "collapse";
      statusBanner.classList.remove("warn");
      statusBanner.classList.add("danger");
      statusBanner.textContent =
        "Compass Collapse ‚Äî Disorientation; substrate coherence broken.";
    }
  }

  function setNeedleAngle(deg) {
    lastAngle = deg;
    needle.style.transform = "translate(-50%, -10%) rotate(" + deg + "deg)";
    needleTail.style.transform =
      "translate(-50%, -10%) rotate(" + deg + "deg)";
  }

  function animateCompass() {
    let base = -90; // due north
    let jitter = 0;

    if (compassMode === "stable") {
      jitter = (Math.random() - 0.5) * 2.0; // ¬±1¬∞
    } else if (compassMode === "mild") {
      jitter = (Math.random() - 0.5) * 12; // ¬±6¬∞
    } else {
      jitter = (Math.random() - 0.5) * 220; // ¬±110¬∞
    }

    const newAngle = base + jitter;
    setNeedleAngle(newAngle);
  }

  function updateCryptochrome() {
    const K = state.K;
    const intensity = clamp(K / 1.6, 0, 1);
    const scale = 1 + 0.35 * intensity;

    let colorGrad, glowCol;

    if (K >= 1.6) {
      colorGrad =
        "radial-gradient(circle at 30% 20%, #7fffd4, #00c896 55%, #00463d)";
      glowCol = "rgba(0, 248, 180, 0.88)";
      cryptoCaption.textContent =
        "High K: cryptochrome pair strongly biased ‚Äî compass lines up cleanly with the geomagnetic field.";
    } else if (K >= 0.7) {
      colorGrad =
        "radial-gradient(circle at 30% 20%, #6a63ff, #3423a3 55%, #1b083f)";
      glowCol = "rgba(138, 127, 255, 0.88)";
      cryptoCaption.textContent =
        "Intermediate K: activation is noisy ‚Äî the bird can still orient but is prone to drift.";
    } else {
      colorGrad =
        "radial-gradient(circle at 30% 20%, #ff5b7c, #6b0320 55%, #250010)";
      glowCol = "rgba(255, 91, 124, 0.95)";
      cryptoCaption.textContent =
        "Low K: cryptochrome signal collapses into noise ‚Äî headings become effectively random.";
    }

    cryptoDot.style.transform = "scale(" + scale.toFixed(3) + ")";
    cryptoDot.style.background = colorGrad;
    cryptoDot.style.boxShadow =
      "0 0 " +
      (20 + 30 * intensity).toFixed(1) +
      "px " +
      glowCol +
      ", 0 0 50px rgba(0, 255, 209, 0.25)";
  }

  function fullUpdateFromState() {
    syncSlidersToState();
    computeK();
    updateStatusAndMode();
    updateCryptochrome();
  }

  function applyPresetsAndUpdate() {
    const p = getPresetParams();
    state.tau = p.tau;
    state.lambda = p.lambda;
    state.noise = p.noise;
    fullUpdateFromState();
  }

  // Event wiring
  speciesSelect.addEventListener("change", function () {
    state.species = this.value;
    applyPresetsAndUpdate();
  });

  tauSlider.addEventListener("input", function () {
    state.tau = parseFloat(this.value);
    fullUpdateFromState();
  });

  lambdaSlider.addEventListener("input", function () {
    state.lambda = parseFloat(this.value);
    fullUpdateFromState();
  });

  noiseSlider.addEventListener("input", function () {
    state.noise = parseFloat(this.value);
    fullUpdateFromState();
  });

  envButtons.forEach(function (btn) {
    btn.addEventListener("click", function () {
      const env = this.getAttribute("data-env");
      state.env = env;
      envButtons.forEach(function (b) {
        b.classList.toggle("active", b === btn);
      });
      applyPresetsAndUpdate();
    });
  });

  fivegToggle.addEventListener("click", function () {
    state.fiveG = !state.fiveG;
    this.classList.toggle("active", state.fiveG);
    this.textContent = state.fiveG ? "üì° 5G Tower: ON" : "üì° 5G Tower: OFF";
    applyPresetsAndUpdate();
  });

  dayNightToggle.addEventListener("click", function () {
    state.night = !state.night;
    this.classList.toggle("active", state.night);
    this.textContent = state.night ? "üåô Night Mode" : "üåû Day Mode";
    applyPresetsAndUpdate();
  });

  // Export snapshot
  function buildSnapshot() {
    const lines = [];
    lines.push("QDS Avian Magnetoreception Lab v4 PRO+");
    lines.push("Forge Road Build ‚Äî paper trail snapshot");
    lines.push("--------------------------------------");
    lines.push("Species: " + state.species);
    lines.push("Environment: " + state.env);
    lines.push("Night mode: " + (state.night ? "Night" : "Day"));
    lines.push("5G Tower: " + (state.fiveG ? "ON" : "OFF"));
    lines.push("");
    lines.push("œÑ_c (ms): " + state.tau.toFixed(3));
    lines.push("Œª_c (nm): " + state.lambda.toFixed(3));
    lines.push("EM Noise: " + state.noise.toFixed(3));
    lines.push("Kernel Stability K: " + state.K.toFixed(4));
    lines.push("");
    lines.push("Navigation status: " + statusBanner.textContent);
    lines.push("");
    lines.push(
      "Notes: Parameters are consistent with QDS avian kernel regimes ‚Äî " +
      "use this snapshot as a high-level log, not a strict biophysical fit."
    );
    lines.push("");
    lines.push(
      "Timestamp (browser): " +
      new Date().toLocaleString()
    );
    return lines.join("\n");
  }

  exportBtn.addEventListener("click", function () {
    exportText.value = buildSnapshot();
    overlay.style.display = "flex";
  });

  closeOverlayBtn.addEventListener("click", function () {
    overlay.style.display = "none";
  });

  copyBtn.addEventListener("click", function () {
    exportText.select();
    try {
      const ok = document.execCommand("copy");
      if (ok) {
        alert("Snapshot copied. Paste into notes or a paper draft.");
      } else {
        alert("Could not auto-copy ‚Äî long-press and copy manually.");
      }
    } catch (e) {
      alert("Could not auto-copy ‚Äî long-press and copy manually.");
    }
  });

  overlay.addEventListener("click", function (e) {
    if (e.target === overlay) {
      overlay.style.display = "none";
    }
  });

  // Compass animation loop
  setInterval(animateCompass, 420);

  // Initial state
  envButtons.forEach(function (b) {
    if (b.getAttribute("data-env") === state.env) {
      b.classList.add("active");
    }
  });

  applyPresetsAndUpdate();
})();


// --- qds_rc_lab_ultra.html ---

/* ===========================
   QDS RC Lab ‚Äî Ultra (no libs)
   =========================== */

const $ = sel => document.querySelector(sel);

const state = {
  summaryRows: [],
  bestfits: new Map(), // galaxy -> {rows:[...], cols:{...}}
  sel: null,
  // heuristics (tune here)
  v0_zero_eps: 1e-6,
  lam_min_eps: 1e-9,
  lam_max_guess: null,   // inferred from data if possible
  lam_min_guess: null
};

function num(x){
  const v = Number(x);
  return Number.isFinite(v) ? v : NaN;
}

function fmt(x, d=3){
  if(!Number.isFinite(x)) return "‚Äî";
  const abs = Math.abs(x);
  if(abs >= 1000) return x.toFixed(0);
  if(abs >= 100) return x.toFixed(1);
  if(abs >= 10) return x.toFixed(2);
  return x.toFixed(d);
}

function parseCSV(text){
  // simple robust CSV (handles quotes)
  const rows = [];
  let i=0, field="", row=[], inQ=false;
  while(i < text.length){
    const c = text[i];
    if(inQ){
      if(c === '"'){
        if(text[i+1] === '"'){ field+='"'; i+=2; continue; }
        inQ=false; i++; continue;
      }
      field += c; i++; continue;
    } else {
      if(c === '"'){ inQ=true; i++; continue; }
      if(c === ','){ row.push(field); field=""; i++; continue; }
      if(c === '\r'){ i++; continue; }
      if(c === '\n'){ row.push(field); rows.push(row); row=[]; field=""; i++; continue; }
      field += c; i++; continue;
    }
  }
  // flush
  if(field.length || row.length){ row.push(field); rows.push(row); }
  return rows;
}

function headerMap(hdr){
  const idx = {};
  const H = hdr.map(s => (s||"").trim().toLowerCase());
  function findAny(names){
    for(const n of names){
      const j = H.indexOf(n);
      if(j>=0) return j;
    }
    return -1;
  }
  idx.galaxy = findAny(["galaxy","name"]);
  idx.n      = findAny(["n","npts","n_points","npoints"]);
  idx.chi2_b = findAny(["chi2_bary","chi2_b","chi2_baryon","chi2_baryons","chi2_baryonic","chi2b"]);
  idx.red_b  = findAny(["redchi2_bary","redchi2_b","redchi2b","red_bary"]);
  idx.chi2_q = findAny(["chi2_qds","chi2_q","chi2q","chi2_model"]);
  idx.red_q  = findAny(["redchi2_qds","redchi2_q","redchi2q","red_qds"]);
  idx.impPct = findAny(["improve_pct","improve","improvement_pct","imp_pct"]);
  idx.v0     = findAny(["v0","v_0"]);
  idx.lam    = findAny(["lam","lambda","lambda_c","lambda_c_kpc","lambda_kpc"]);
  // fallback to your known layout if headers unknown
  return idx;
}

function readFileAsText(file){
  return new Promise((resolve,reject)=>{
    const fr = new FileReader();
    fr.onload = () => resolve(String(fr.result||""));
    fr.onerror = () => reject(fr.error||new Error("read error"));
    fr.readAsText(file);
  });
}

function inferLamBounds(rows){
  let lamMin = Infinity, lamMax = -Infinity;
  for(const r of rows){
    if(Number.isFinite(r.lam)){
      lamMin = Math.min(lamMin, r.lam);
      lamMax = Math.max(lamMax, r.lam);
    }
  }
  if(lamMin !== Infinity) state.lam_min_guess = lamMin;
  if(lamMax !== -Infinity) state.lam_max_guess = lamMax;
}

function computeRowDerived(r){
  // chi2 improvement (clipped at 0)
  const cb = r.chi2_b;
  const cq = r.chi2_q;
  let imp = (Number.isFinite(cb) && cb>0 && Number.isFinite(cq)) ? (100*(cb - cq)/cb) : NaN;
  if(Number.isFinite(imp) && imp < 0) imp = 0;

  // AICc + BIC
  // assume bary k=0, QDS k=2 (penalty for 2 params)
  const n = r.n;
  const kb = 0, kq = 2;
  let aicb = cb + 2*kb;
  let aicq = cq + 2*kq;
  let aiccb = aicb, aiccq = aicq;
  if(Number.isFinite(n) && n > (kb+1)) aiccb = aicb + (2*kb*(kb+1))/(n-kb-1);
  if(Number.isFinite(n) && n > (kq+1)) aiccq = aicq + (2*kq*(kq+1))/(n-kq-1);

  const bicb = cb + kb*Math.log(Math.max(n,2));
  const bicq = cq + kq*Math.log(Math.max(n,2));

  // deltas: negative favours QDS
  const dAICc = aiccq - aiccb;
  const dBIC  = bicq - bicb;

  // flags
  const flags = [];
  const v0 = r.v0;
  const lam = r.lam;
  const lamMin = state.lam_min_guess;
  const lamMax = state.lam_max_guess;

  if(Number.isFinite(v0) && Math.abs(v0) <= state.v0_zero_eps) flags.push("v0‚âà0");
  if(Number.isFinite(lamMin) && Number.isFinite(lam) && Math.abs(lam-lamMin) <= 1e-12) flags.push("lam=min");
  if(Number.isFinite(lamMax) && Number.isFinite(lam) && Math.abs(lam-lamMax) <= 1e-12) flags.push("lam=max");

  const chiWin = Number.isFinite(cb) && Number.isFinite(cq) ? (cq < cb) : false;
  const aicWin = Number.isFinite(dAICc) ? (dAICc < 0) : false;
  const bicWin = Number.isFinite(dBIC) ? (dBIC < 0) : false;

  return {imp, dAICc, dBIC, flags, chiWin, aicWin, bicWin};
}

function loadSummaryFromText(text, label){
  const raw = parseCSV(text);
  if(raw.length < 2) throw new Error("SUMMARY looks empty");

  const hdr = raw[0];
  const map = headerMap(hdr);

  // If header mapping fails, fallback to known indices (your pipeline):
  // galaxy(0), npts(1), chi2_b(2), red_b(3), chi2_q(4), red_q(5), improve_pct(6), v0(7), lam(8)
  const fallback = (map.galaxy<0 || map.n<0 || map.chi2_b<0 || map.chi2_q<0 || map.v0<0 || map.lam<0);

  const rows = [];
  for(let i=1;i<raw.length;i++){
    const line = raw[i];
    if(!line || !line.length) continue;
    const get = (j)=> (j>=0 && j<line.length) ? line[j] : "";
    const r = {};
    if(!fallback){
      r.galaxy = String(get(map.galaxy)).trim();
      r.n      = num(get(map.n));
      r.chi2_b = num(get(map.chi2_b));
      r.red_b  = num(get(map.red_b));
      r.chi2_q = num(get(map.chi2_q));
      r.red_q  = num(get(map.red_q));
      r.impPct_file = num(get(map.impPct));
      r.v0     = num(get(map.v0));
      r.lam    = num(get(map.lam));
    } else {
      r.galaxy = String(get(0)).trim();
      r.n      = num(get(1));
      r.chi2_b = num(get(2));
      r.red_b  = num(get(3));
      r.chi2_q = num(get(4));
      r.red_q  = num(get(5));
      r.impPct_file = num(get(6));
      r.v0     = num(get(7));
      r.lam    = num(get(8));
    }
    if(!r.galaxy) continue;
    rows.push(r);
  }

  state.summaryRows = rows;
  inferLamBounds(rows);

  $("#sumStatus").textContent = `${rows.length} rows`;
  renderAll();
}

function galaxyNameFromBestfitFile(fileName){
  // common: NGC4013_QDS_bestfit.csv
  let base = fileName.replace(/\.csv$/i,"");
  base = base.replace(/_QDS_bestfit$/i,"");
  base = base.replace(/_bestfit$/i,"");
  return base;
}

function mapBestfitColumns(hdr){
  const H = hdr.map(s => (s||"").trim().toLowerCase());
  const idx = {};
  function findAny(names){
    for(const n of names){
      const j = H.indexOf(n);
      if(j>=0) return j;
    }
    return -1;
  }
  idx.r     = findAny(["r","radius","rad","r_kpc","r_k"]);
  idx.vobs  = findAny(["v_obs","vobs","v_observed","v"]);
  idx.vbary = findAny(["v_bary","vbary","v_bar","v_b"]);
  idx.vqds  = findAny(["v_qds","vqds","v_model","vfit","v_q"]);
  idx.vgas  = findAny(["v_gas","vgas"]);
  idx.vdisk = findAny(["v_disk","vdisk"]);
  idx.vbul  = findAny(["v_bulge","vbul","vbulge"]);
  idx.err   = findAny(["dv","v_err","verr","sigma","err"]);
  return idx;
}

function loadBestfitFromText(text, fileName){
  const raw = parseCSV(text);
  if(raw.length < 2) return;
  const hdr = raw[0];
  const col = mapBestfitColumns(hdr);
  const galaxy = galaxyNameFromBestfitFile(fileName);

  const rows = [];
  for(let i=1;i<raw.length;i++){
    const line = raw[i]; if(!line || !line.length) continue;
    const get = (j)=> (j>=0 && j<line.length) ? line[j] : "";
    const r = {};
    r.r    = num(get(col.r));
    r.vobs = num(get(col.vobs));
    r.vqds = num(get(col.vqds));
    // bary: either explicit vbary or from components
    const vb = num(get(col.vbary));
    const vg = num(get(col.vgas));
    const vd = num(get(col.vdisk));
    const vbu= num(get(col.vbul));
    r.vbary = Number.isFinite(vb) ? vb :
              (Number.isFinite(vg)||Number.isFinite(vd)||Number.isFinite(vbu))
                ? Math.sqrt((vg||0)**2 + (vd||0)**2 + (vbu||0)**2)
                : NaN;
    r.err  = num(get(col.err));
    if(Number.isFinite(r.r)) rows.push(r);
  }

  if(rows.length){
    state.bestfits.set(galaxy.toUpperCase(), {galaxy, rows});
    $("#bfCount").textContent = String(state.bestfits.size);
  }
}

function renderAll(){
  const rows = state.summaryRows.slice();
  if(!rows.length){
    $("#kN").textContent = "‚Äî";
    $("#tb").innerHTML = "";
    drawEmptyPlot();
    return;
  }

  // derive + sort (default: best AICc then œá¬≤ imp)
  const enriched = rows.map(r=>{
    const d = computeRowDerived(r);
    return {...r, ...d};
  });

  // stats
  const N = enriched.length;
  let chiWins=0, aicWins=0, bicWins=0, sumImp=0, posImp=0;
  let b_v0=0, b_lmin=0, b_lmax=0;

  for(const r of enriched){
    if(r.chiWin) chiWins++;
    if(r.aicWin) aicWins++;
    if(r.bicWin) bicWins++;
    if(Number.isFinite(r.imp)){ sumImp += r.imp; posImp++; }
    if(r.flags.includes("v0‚âà0")) b_v0++;
    if(r.flags.includes("lam=min")) b_lmin++;
    if(r.flags.includes("lam=max")) b_lmax++;
  }

  $("#kN").textContent = `${N}`;
  $("#kChiWins").textContent = `${chiWins} / ${N} (${fmt(100*chiWins/N,2)}%)`;
  $("#kMeanImp").textContent = `${fmt((posImp?sumImp/N:0),3)}%`;
  $("#kAicWins").textContent = `${aicWins} / ${N} (${fmt(100*aicWins/N,2)}%)`;
  $("#kBicWins").textContent = `${bicWins} / ${N} (${fmt(100*bicWins/N,2)}%)`;
  $("#kBounds").textContent = `v0‚âà0: ${b_v0}  ‚Ä¢  lam=min: ${b_lmin}  ‚Ä¢  lam=max: ${b_lmax}`;

  // apply search
  const q = ($("#search").value || "").trim().toUpperCase();
  let view = enriched;
  if(q){
    view = enriched.filter(r => r.galaxy.toUpperCase().includes(q));
  }

  // sort: AICc delta ascending, then chi2 improvement descending
  view.sort((a,b)=>{
    const da = Number.isFinite(a.dAICc) ? a.dAICc : 1e99;
    const db = Number.isFinite(b.dAICc) ? b.dAICc : 1e99;
    if(da !== db) return da - db;
    const ia = Number.isFinite(a.imp) ? a.imp : -1;
    const ib = Number.isFinite(b.imp) ? b.imp : -1;
    return ib - ia;
  });

  // table
  const tb = $("#tb");
  tb.innerHTML = "";
  for(const r of view){
    const tr = document.createElement("tr");
    tr.className = "click";
    tr.addEventListener("click", ()=> selectGalaxy(r.galaxy));
    const impCls = (Number.isFinite(r.imp) && r.imp>0) ? "pos" : "mut";
    const dA = Number.isFinite(r.dAICc) ? r.dAICc : NaN;
    const dB = Number.isFinite(r.dBIC)  ? r.dBIC  : NaN;

    const flags = [];
    if(r.chiWin) flags.push("œá¬≤");
    if(r.aicWin) flags.push("AICc");
    if(r.bicWin) flags.push("BIC");
    if(r.flags.length) flags.push("bound");

    tr.innerHTML = `
      <td><b>${esc(r.galaxy)}</b><div class="small">${state.bestfits.has(r.galaxy.toUpperCase()) ? "bestfit: loaded" : "bestfit: ‚Äî"}</div></td>
      <td class="right">${fmt(r.n,0)}</td>
      <td class="right">${fmt(r.chi2_b,3)}</td>
      <td class="right">${fmt(r.chi2_q,3)}</td>
      <td class="right ${impCls}">${Number.isFinite(r.imp)?fmt(r.imp,3):"‚Äî"}</td>
      <td class="right ${Number.isFinite(dA) ? (dA<0?"pos":"neg") : "mut"}">${Number.isFinite(dA)?fmt(dA,3):"‚Äî"}</td>
      <td class="right ${Number.isFinite(dB) ? (dB<0?"pos":"neg") : "mut"}">${Number.isFinite(dB)?fmt(dB,3):"‚Äî"}</td>
      <td class="right">${fmt(r.v0,3)}</td>
      <td class="right">${fmt(r.lam,6)}</td>
      <td class="center"><span class="${r.flags.length?'warnTxt':'mut'}">${esc(flags.join(" "))}</span></td>
    `;
    tb.appendChild(tr);
  }

  // keep selection alive
  if(state.sel){
    const exists = state.summaryRows.some(x => x.galaxy.toUpperCase() === state.sel.toUpperCase());
    if(!exists) clearSelection();
  }

  if(!state.sel) drawEmptyPlot();
}

function esc(s){ return String(s).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m])); }

function selectGalaxy(name){
  state.sel = name;
  $("#selName").textContent = name;

  const r0 = state.summaryRows.find(x => x.galaxy.toUpperCase() === name.toUpperCase());
  if(!r0){ clearSelection(); return; }
  const r = {...r0, ...computeRowDerived(r0)};

  $("#dChi").textContent = `${fmt(r.chi2_b,3)} ‚Üí ${fmt(r.chi2_q,3)}   |   imp(clipped)= ${Number.isFinite(r.imp)?fmt(r.imp,3)+"%":"‚Äî"}`;
  $("#dInfo").textContent = `ŒîAICc=${Number.isFinite(r.dAICc)?fmt(r.dAICc,3):"‚Äî"}   ‚Ä¢   ŒîBIC=${Number.isFinite(r.dBIC)?fmt(r.dBIC,3):"‚Äî"}`;
  $("#dParams").textContent = `v0=${fmt(r.v0,3)}   lam=${fmt(r.lam,6)}   n=${fmt(r.n,0)}`;
  $("#dFlags").textContent = r.flags.length ? r.flags.join("  ‚Ä¢  ") : "‚Äî";

  // plot if bestfit loaded
  const bf = state.bestfits.get(name.toUpperCase());
  if(bf && bf.rows && bf.rows.length){
    $("#plotHint").textContent = `Plotting bestfit CSV for ${name}.`;
    drawPlot(bf.rows, name);
  } else {
    $("#plotHint").textContent = `No bestfit CSV loaded for ${name}. Load *_QDS_bestfit.csv to plot curves.`;
    drawEmptyPlot(name);
  }
}

function clearSelection(){
  state.sel = null;
  $("#selName").textContent = "none selected";
  $("#dChi").textContent = "‚Äî";
  $("#dInfo").textContent = "‚Äî";
  $("#dParams").textContent = "‚Äî";
  $("#dFlags").textContent = "‚Äî";
  drawEmptyPlot();
}

function drawEmptyPlot(title){
  const c = $("#plot");
  const g = c.getContext("2d");
  g.clearRect(0,0,c.width,c.height);
  g.fillStyle = "rgba(255,255,255,.06)";
  g.fillRect(0,0,c.width,c.height);

  g.strokeStyle = "rgba(255,255,255,.10)";
  g.lineWidth = 1;
  const pad=50;
  g.strokeRect(pad, pad, c.width-2*pad, c.height-2*pad);

  g.fillStyle = "rgba(234,240,255,.75)";
  g.font = "16px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');
  g.fillText("Load a SUMMARY + bestfit CSVs to view curves", pad, pad-16);

  g.fillStyle = "rgba(170,182,214,.85)";
  g.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue('--mono');
  g.fillText(title ? `Selected: ${title}` : "Selected: none", pad, pad+22);
  g.fillText("Expected bestfit cols: r, v_obs, v_bary (or v_gas/v_disk/v_bulge), v_qds/v_model", pad, pad+42);
}

function drawPlot(rows, name){
  const c = $("#plot");
  const g = c.getContext("2d");
  g.clearRect(0,0,c.width,c.height);

  const padL=70, padR=20, padT=35, padB=55;
  const W = c.width, H = c.height;
  const x0 = padL, x1 = W-padR, y0=padT, y1=H-padB;

  // ranges
  let rMin=Infinity, rMax=-Infinity, vMin=Infinity, vMax=-Infinity;
  for(const p of rows){
    if(Number.isFinite(p.r)){
      rMin = Math.min(rMin, p.r);
      rMax = Math.max(rMax, p.r);
    }
    for(const k of ["vobs","vbary","vqds"]){
      const v = p[k];
      if(Number.isFinite(v)){
        vMin = Math.min(vMin, v);
        vMax = Math.max(vMax, v);
      }
    }
  }
  if(!Number.isFinite(rMin) || !Number.isFinite(vMin)){ drawEmptyPlot(name); return; }
  // padding
  const vr = (vMax - vMin) || 1;
  vMin -= 0.08*vr;
  vMax += 0.10*vr;

  const xr = (rMax - rMin) || 1;
  function X(r){ return x0 + ((r - rMin)/xr) * (x1-x0); }
  function Y(v){ return y1 - ((v - vMin)/(vMax-vMin)) * (y1-y0); }

  // background
  g.fillStyle = "rgba(0,0,0,.14)";
  g.fillRect(0,0,W,H);

  // grid
  g.strokeStyle = "rgba(255,255,255,.10)";
  g.lineWidth = 1;
  for(let i=0;i<=5;i++){
    const yy = y0 + (i/5)*(y1-y0);
    g.beginPath(); g.moveTo(x0,yy); g.lineTo(x1,yy); g.stroke();
  }
  for(let i=0;i<=6;i++){
    const xx = x0 + (i/6)*(x1-x0);
    g.beginPath(); g.moveTo(xx,y0); g.lineTo(xx,y1); g.stroke();
  }

  // axes box
  g.strokeStyle = "rgba(255,255,255,.20)";
  g.lineWidth = 1;
  g.strokeRect(x0,y0,x1-x0,y1-y0);

  // labels
  g.fillStyle = "rgba(234,240,255,.85)";
  g.font = "16px " + getComputedStyle(document.documentElement).getPropertyValue('--sans');
  g.fillText(`${name}`, x0, 22);

  g.fillStyle = "rgba(170,182,214,.90)";
  g.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue('--mono');
  g.fillText(`r: ${fmt(rMin,3)} ‚Üí ${fmt(rMax,3)}   |   V: ${fmt(vMin,1)} ‚Üí ${fmt(vMax,1)} (km/s)`, x0, y0-10);

  // ticks
  g.fillStyle = "rgba(170,182,214,.85)";
  for(let i=0;i<=5;i++){
    const vv = vMax - (i/5)*(vMax-vMin);
    const yy = y0 + (i/5)*(y1-y0);
    g.fillText(fmt(vv,1), 10, yy+4);
  }
  for(let i=0;i<=6;i++){
    const rr = rMin + (i/6)*(rMax-rMin);
    const xx = x0 + (i/6)*(x1-x0);
    g.fillText(fmt(rr,2), xx-12, H-22);
  }
  g.fillText("r (kpc)", (x0+x1)/2 - 22, H-6);
  g.save();
  g.translate(16, (y0+y1)/2 + 30);
  g.rotate(-Math.PI/2);
  g.fillText("V (km/s)", 0, 0);
  g.restore();

  // color helpers (no libs, but crisp)
  function strokeSeries(key, color){
    // if you want *strictly* no fixed colours, you can remove these. But pro UI needs stable legend.
    g.strokeStyle = color;
    g.lineWidth = 2.2;
    g.beginPath();
    let started=false;
    for(const p of rows){
      const v = p[key];
      if(!Number.isFinite(p.r) || !Number.isFinite(v)) continue;
      const xx = X(p.r), yy=Y(v);
      if(!started){ g.moveTo(xx,yy); started=true; }
      else g.lineTo(xx,yy);
    }
    g.stroke();
  }
  function dotSeries(key, color){
    g.fillStyle = color;
    for(const p of rows){
      const v = p[key];
      if(!Number.isFinite(p.r) || !Number.isFinite(v)) continue;
      const xx=X(p.r), yy=Y(v);
      g.beginPath(); g.arc(xx,yy,3,0,Math.PI*2); g.fill();
    }
  }

  // series
  // vobs points
  dotSeries("vobs", "rgba(106,166,255,.95)");
  // vbary curve
  strokeSeries("vbary", "rgba(255,204,102,.95)");
  // vqds curve
  strokeSeries("vqds", "rgba(41,242,154,.95)");
}

function demoMode(){
  // tiny built-in demo summary (not physics, just UI sanity)
  const txt = [
    "galaxy,npts,chi2_bary,redchi2_bary,chi2_qds,redchi2_qds,improve_pct,v0,lam",
    "NGC4013,36,2146.48,59.6246,639.82,17.7728,70.19,250.16,40",
    "UGC02885,19,913.98,48.1042,27.75,1.4607,96.96,278.451,40",
    "NGC3521,41,1205.63,29.4057,1222.29,29.8118,-1.38,301.845,40",
    "CamB,21,198.94,9.47336,255.78,12.18,-28.57,0,0.2"
  ].join("\n");
  loadSummaryFromText(txt, "demo");
  // demo curve for NGC4013
  const bf = [
    "r,v_obs,v_bary,v_qds",
    "0.5,40,25,38",
    "1.0,70,45,68",
    "2.0,115,75,112",
    "3.5,145,98,143",
    "5.0,165,112,162",
    "7.0,175,120,173",
    "9.0,178,122,176"
  ].join("\n");
  loadBestfitFromText(bf, "NGC4013_QDS_bestfit.csv");
  $("#bfCount").textContent = String(state.bestfits.size);
  renderAll();
  selectGalaxy("NGC4013");
}

function setupDnD(){
  const area = document.body;
  area.addEventListener("dragover", (e)=>{ e.preventDefault(); });
  area.addEventListener("drop", async (e)=>{
    e.preventDefault();
    const files = Array.from(e.dataTransfer.files || []);
    if(!files.length) return;
    // auto route
    let gotSummary=false;
    for(const f of files){
      const name = f.name.toLowerCase();
      const txt = await readFileAsText(f);
      if(name.includes("summary") && name.endsWith(".csv") && !gotSummary){
        loadSummaryFromText(txt, f.name);
        gotSummary = true;
      } else if(name.endsWith(".csv")){
        loadBestfitFromText(txt, f.name);
      }
    }
    $("#bfCount").textContent = String(state.bestfits.size);
    renderAll();
  });
}

$("#fileSummary").addEventListener("change", async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  try{
    const txt = await readFileAsText(f);
    loadSummaryFromText(txt, f.name);
  }catch(err){
    alert("Failed to load SUMMARY: " + err.message);
  }
});

$("#fileBestfits").addEventListener("change", async (e)=>{
  const files = Array.from(e.target.files || []);
  if(!files.length) return;
  for(const f of files){
    try{
      const txt = await readFileAsText(f);
      loadBestfitFromText(txt, f.name);
    }catch(_){}
  }
  $("#bfCount").textContent = String(state.bestfits.size);
  renderAll();
});

$("#search").addEventListener("input", ()=> renderAll());
$("#btnDemo").addEventListener("click", ()=> demoMode());

setupDnD();
drawEmptyPlot();


// --- qds_learning_alphabet_lab_v2.html ---

    // ---- Data: phoneme kernel ----
    const PHONEMES = [
      // consonants
      {
        id: "m",
        label: "m",
        example: "m-at",
        type: "consonant",
        place: "lips",
        manner: "nasal",
        voiced: true,
        color: "#22c55e",
        emoji: "üêª",
        gesture: "tap chest once"
      },
      {
        id: "n",
        label: "n",
        example: "n-et",
        type: "consonant",
        place: "front",
        manner: "nasal",
        voiced: true,
        color: "#22c55e",
        emoji: "üëÉ",
        gesture: "touch nose"
      },
      {
        id: "p",
        label: "p",
        example: "p-at",
        type: "consonant",
        place: "lips",
        manner: "stop",
        voiced: false,
        color: "#38bdf8",
        emoji: "üéà",
        gesture: "small finger pop"
      },
      {
        id: "t",
        label: "t",
        example: "t-ap",
        type: "consonant",
        place: "front",
        manner: "stop",
        voiced: false,
        color: "#38bdf8",
        emoji: "ü™µ",
        gesture: "tap finger on table"
      },
      {
        id: "k",
        label: "k",
        example: "k-it",
        type: "consonant",
        place: "back",
        manner: "stop",
        voiced: false,
        color: "#38bdf8",
        emoji: "üéØ",
        gesture: "small head nod"
      },
      {
        id: "s",
        label: "s",
        example: "s-un",
        type: "consonant",
        place: "front",
        manner: "fricative",
        voiced: false,
        color: "#f97316",
        emoji: "üêç",
        gesture: "snake hand wiggle"
      },
      {
        id: "sh",
        label: "sh",
        example: "sh-ip",
        type: "consonant",
        place: "middle",
        manner: "fricative",
        voiced: false,
        color: "#a855f7",
        emoji: "ü§´",
        gesture: "finger to lips"
      },
      {
        id: "ch",
        label: "ch",
        example: "ch-ip",
        type: "consonant",
        place: "front",
        manner: "affricate",
        voiced: false,
        color: "#ec4899",
        emoji: "üß±",
        gesture: "two-finger tap"
      },
      {
        id: "th",
        label: "th",
        example: "th-in",
        type: "consonant",
        place: "front",
        manner: "fricative",
        voiced: "mixed",
        color: "#fb923c",
        emoji: "ü¶∑",
        gesture: "thumb on chin"
      },

      // vowels / chunks
      {
        id: "a",
        label: "a",
        example: "c-a-t",
        type: "vowel",
        place: "front",
        manner: "short",
        voiced: true,
        color: "#facc15",
        emoji: "‚≠ê",
        gesture: "open hand forward"
      },
      {
        id: "e",
        label: "e",
        example: "b-e-d",
        type: "vowel",
        place: "front",
        manner: "short",
        voiced: true,
        color: "#facc15",
        emoji: "üìè",
        gesture: "small step"
      },
      {
        id: "i",
        label: "i",
        example: "f-i-sh",
        type: "vowel",
        place: "front",
        manner: "short",
        voiced: true,
        color: "#facc15",
        emoji: "üìå",
        gesture: "point up"
      },
      {
        id: "o",
        label: "o",
        example: "h-o-t",
        type: "vowel",
        place: "back",
        manner: "short",
        voiced: true,
        color: "#facc15",
        emoji: "üî•",
        gesture: "small circle in air"
      },
      {
        id: "ai",
        label: "ai",
        example: "r-ai-n",
        type: "vowel",
        place: "front",
        manner: "long",
        voiced: true,
        color: "#fbbf24",
        emoji: "üåà",
        gesture: "two steps forward"
      },
      {
        id: "ee",
        label: "ee",
        example: "s-ee",
        type: "vowel",
        place: "front",
        manner: "long",
        voiced: true,
        color: "#fbbf24",
        emoji: "üòä",
        gesture: "big smile"
      },
      {
        id: "oo",
        label: "oo",
        example: "m-oo-n",
        type: "vowel",
        place: "back",
        manner: "long",
        voiced: true,
        color: "#fbbf24",
        emoji: "üåï",
        gesture: "hands make circle"
      }
    ];

    // Mini word bank
    const WORDS = [
      {
        text: "ship",
        spelling: "ship",
        phonemes: ["sh", "i", "p"],
        emoji: "üö¢",
        note: "Shows chunk [sh] instead of s+h."
      },
      {
        text: "math",
        spelling: "math",
        phonemes: ["m", "a", "th"],
        emoji: "üßÆ",
        note: "Simple front-mouth consonants + short vowel."
      },
      {
        text: "tree",
        spelling: "tree",
        phonemes: ["t", "r?", "ee"],
        emoji: "üå≥",
        note: "Prototype: r? could be a later-stage add-on."
      },
      {
        text: "book",
        spelling: "book",
        phonemes: ["b?", "oo", "k"],
        emoji: "üìö",
        note: "Focus on [oo] as a stable vowel chunk."
      },
      {
        text: "night",
        spelling: "night",
        phonemes: ["n", "ai", "t"],
        emoji: "üåô",
        note: "Classic tricky spelling, clean phoneme path."
      }
    ];

    const modeDescriptions = {
      classic: "Plain phonics view ‚Äì label, example, basic type.",
      visual: "Colour-coded chunks ‚Äì good for visual pattern brains.",
      logic: "Feature grid: place / manner / voice. For rule-brains.",
      movement: "Gestures & rhythm ‚Äì sound as motion."
    };

    const profiles = {
      "default": {
        mode: "visual",
        hint: "Mixed / general group ‚Äì start visual, then try other modes."
      },
      "visual": {
        mode: "visual",
        hint: "Leans on colour + shape. Keep the visual cards visible while reading."
      },
      "logic": {
        mode: "logic",
        hint: "Enjoys patterns & rules. Make columns: place / manner / voice."
      },
      "movement": {
        mode: "movement",
        hint: "Needs motion first. Say the sound + do the gesture together."
      },
      "nd_mix": {
        mode: "visual",
        hint: "ND mix: keep colour+gesture, avoid overload. Short bursts, lots of control."
      }
    };

    // ---- DOM hooks ----
    const modeSelect = document.getElementById("modeSelect");
    const modeHint = document.getElementById("modeHint");
    const profileSelect = document.getElementById("profileSelect");
    const profileHint = document.getElementById("profileHint");
    const phonemeGrid = document.getElementById("phonemeGrid");
    const phonemePanel = document.getElementById("phonemePanel");
    const phonemeSub = document.getElementById("phonemeSub");
    const wordsList = document.getElementById("wordsList");

    const buildPathDisplay = document.getElementById("buildPathDisplay");
    const buildSpelling = document.getElementById("buildSpelling");
    const btnClearBuild = document.getElementById("btnClearBuild");
    const btnUndoBuild = document.getElementById("btnUndoBuild");
    const padGrid = document.getElementById("padGrid");

    const quizWordText = document.getElementById("quizWordText");
    const quizNote = document.getElementById("quizNote");
    const quizPhonemes = document.getElementById("quizPhonemes");
    const quizStatus = document.getElementById("quizStatus");
    const btnRevealQuiz = document.getElementById("btnRevealQuiz");
    const btnNextQuiz = document.getElementById("btnNextQuiz");

    // ---- Helpers ----
    function getPhonemeById(id) {
      return PHONEMES.find(p => p.id === id) || null;
    }

    // ---- Render phonemes ----
    function renderPhonemes(mode) {
      phonemeGrid.innerHTML = "";
      phonemePanel.classList.remove("mode-classic", "mode-visual", "mode-logic", "mode-movement");
      phonemePanel.classList.add("mode-" + mode);

      phonemeSub.textContent = modeDescriptions[mode] || "Shared sound set for all learners.";

      PHONEMES.forEach(p => {
        const card = document.createElement("div");
        card.className = "phoneme-card";

        if (mode === "visual" && p.color) {
          card.style.borderColor = p.color;
          card.style.boxShadow = "0 0 0 1px rgba(15,23,42,0.7), 0 0 16px " + p.color + "55";
        }

        const labelRow = document.createElement("div");
        labelRow.className = "phoneme-label-row";

        const label = document.createElement("div");
        label.className = "phoneme-label";
        label.textContent = p.label;

        const emoji = document.createElement("div");
        emoji.className = "phoneme-emoji";
        emoji.textContent = p.emoji || "";

        labelRow.appendChild(label);
        labelRow.appendChild(emoji);
        card.appendChild(labelRow);

        const ex = document.createElement("div");
        ex.className = "phoneme-example";
        ex.textContent = p.example || "";
        card.appendChild(ex);

        if (mode === "classic") {
          const feature = document.createElement("div");
          feature.className = "phoneme-feature";
          feature.textContent = p.type + " sound";
          card.appendChild(feature);
        } else if (mode === "visual") {
          const feature = document.createElement("div");
          feature.className = "phoneme-feature";
          feature.textContent = p.type === "vowel" ? "vowel chunk" : "consonant chunk";
          card.appendChild(feature);
        } else if (mode === "logic") {
          const feature = document.createElement("div");
          feature.className = "phoneme-feature";
          feature.textContent = "place: " + p.place + ", manner: " + p.manner + ", voice: " + p.voiced;
          card.appendChild(feature);
        } else if (mode === "movement") {
          const feature = document.createElement("div");
          feature.className = "phoneme-feature";
          feature.textContent = p.type === "vowel" ? "voice / breath shape" : "mouth action";
          card.appendChild(feature);

          const gest = document.createElement("div");
          gest.className = "phoneme-gesture";
          gest.textContent = p.gesture || "";
          card.appendChild(gest);
        }

        phonemeGrid.appendChild(card);
      });
    }

    // ---- Render words ----
    function renderWords(mode) {
      wordsList.innerHTML = "";

      WORDS.forEach(w => {
        const card = document.createElement("div");
        card.className = "word-card";

        const head = document.createElement("div");
        head.className = "word-head";

        const left = document.createElement("div");
        const wordText = document.createElement("div");
        wordText.className = "word-text";

        const wEmoji = document.createElement("span");
        wEmoji.className = "word-emoji";
        wEmoji.textContent = w.emoji || "";

        const wLabel = document.createElement("span");
        wLabel.textContent = w.text;

        wordText.appendChild(wEmoji);
        wordText.appendChild(wLabel);

        const wordSpell = document.createElement("div");
        wordSpell.className = "word-spelling";
        wordSpell.textContent = "spelling: " + w.spelling;

        left.appendChild(wordText);
        left.appendChild(wordSpell);

        const right = document.createElement("div");
        right.className = "word-phon";
        right.textContent = w.phonemes.join(" ‚Ä¢ ");

        head.appendChild(left);
        head.appendChild(right);
        card.appendChild(head);

        const chips = document.createElement("div");
        chips.className = "chips";

        w.phonemes.forEach(pid => {
          const chip = document.createElement("div");
          chip.className = "chip";

          const p = getPhonemeById(pid.replace("?", ""));
          const dot = document.createElement("span");
          dot.className = "chip-dot";

          if (p && p.color && mode === "visual") {
            dot.style.background = p.color;
          } else if (mode === "logic") {
            dot.style.background = "#38bdf8";
          } else if (mode === "movement") {
            dot.style.background = "#facc15";
          }

          chip.appendChild(dot);

          const label = document.createElement("span");
          label.textContent = pid;
          chip.appendChild(label);

          if (p && p.emoji && (mode === "visual" || mode === "movement")) {
            const ce = document.createElement("span");
            ce.className = "chip-emoji";
            ce.textContent = p.emoji;
            chip.appendChild(ce);
          }

          chips.appendChild(chip);
        });

        card.appendChild(chips);

        if (w.note) {
          const note = document.createElement("div");
          note.className = "word-note";
          note.textContent = w.note;
          card.appendChild(note);
        }

        wordsList.appendChild(card);
      });
    }

    // ---- Build lab ----
    let buildPath = [];

    function updateBuildDisplays() {
      buildPathDisplay.innerHTML = "";
      if (!buildPath.length) {
        const span = document.createElement("span");
        span.className = "build-placeholder";
        span.textContent = "tap sounds below‚Ä¶";
        buildPathDisplay.appendChild(span);
      } else {
        buildPath.forEach(id => {
          const chip = document.createElement("span");
          chip.className = "chip";
          const p = getPhonemeById(id.replace("?", ""));
          const dot = document.createElement("span");
          dot.className = "chip-dot";
          if (p && p.color) dot.style.background = p.color;
          const label = document.createElement("span");
          label.textContent = id;
          chip.appendChild(dot);
          chip.appendChild(label);
          if (p && p.emoji) {
            const ce = document.createElement("span");
            ce.className = "chip-emoji";
            ce.textContent = p.emoji;
            chip.appendChild(ce);
          }
          buildPathDisplay.appendChild(chip);
        });
      }

      if (!buildPath.length) {
        buildSpelling.textContent = "‚Äî";
      } else {
        // naive spelling: just join labels, but keep digraphs intact
        const guess = buildPath.join("");
        buildSpelling.textContent = guess;
      }
    }

    function renderPadGrid() {
      padGrid.innerHTML = "";

      PHONEMES.forEach(p => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "pad-btn";
        const emoji = document.createElement("span");
        emoji.textContent = p.emoji || "";
        const label = document.createElement("span");
        label.textContent = p.label;
        btn.appendChild(emoji);
        btn.appendChild(label);
        btn.addEventListener("click", () => {
          buildPath.push(p.id);
          updateBuildDisplays();
        });
        padGrid.appendChild(btn);
      });
    }

    // ---- Quiz ----
    let currentQuiz = null;
    let quizRevealed = false;

    function pickRandomWord() {
      const idx = Math.floor(Math.random() * WORDS.length);
      return WORDS[idx];
    }

    function startNewQuiz() {
      currentQuiz = pickRandomWord();
      quizRevealed = false;

      quizWordText.textContent = currentQuiz.text;
      quizNote.textContent = "Predict the kernel path. Then tap ‚ÄúShow kernel path‚Äù.";
      quizPhonemes.style.display = "none";
      quizPhonemes.textContent = "";
      quizStatus.textContent = "";
    }

    function revealQuiz() {
      if (!currentQuiz) return;
      quizPhonemes.style.display = "block";
      quizPhonemes.textContent = "kernel path: " + currentQuiz.phonemes.join(" ‚Ä¢ ");
      quizStatus.textContent = "Nice. Compare this path with what you guessed ‚Äì chunks first, letters later.";
      quizRevealed = true;
    }

    // ---- Mode & profile wiring ----
    function setMode(mode) {
      modeHint.textContent = modeDescriptions[mode] || "";
      renderPhonemes(mode);
      renderWords(mode);
    }

    function setProfile(profileKey) {
      const profile = profiles[profileKey] || profiles["default"];
      profileHint.textContent = profile.hint || "";
      // update mode but don't re-trigger profile change
      modeSelect.value = profile.mode;
      setMode(profile.mode);
    }

    modeSelect.addEventListener("change", function () {
      setMode(this.value);
    });

    profileSelect.addEventListener("change", function () {
      setProfile(this.value);
    });

    // ---- Buttons & events ----
    btnClearBuild.addEventListener("click", function () {
      buildPath = [];
      updateBuildDisplays();
    });
    btnUndoBuild.addEventListener("click", function () {
      buildPath.pop();
      updateBuildDisplays();
    });

    btnRevealQuiz.addEventListener("click", function () {
      revealQuiz();
    });
    btnNextQuiz.addEventListener("click", function () {
      startNewQuiz();
    });

    // ---- Boot ----
    (function boot() {
      // default profile -> visual mode
      profileSelect.value = "default";
      setProfile("default");
      renderPadGrid();
      buildPath = [];
      updateBuildDisplays();
      startNewQuiz();
    })();
  

// --- qds_revenue_floor_v2_sensitivity_fix.html ---

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);

function num(id, def=0){
  const el = $(id);
  if(!el) return def;
  const v = parseFloat(String(el.value ?? "").trim());
  return Number.isFinite(v) ? v : def;
}
function clamp(x, a, b){
  if(!Number.isFinite(x)) return a;
  return Math.min(b, Math.max(a, x));
}
function fmtMoney(x){
  const cur = String($("currency").value || "¬£").trim() || "¬£";
  const n = Number.isFinite(x) ? x : 0;
  const rounded = Math.round(n);
  return cur + rounded.toLocaleString();
}

/* ---------- Core model ---------- */
function computeModel(){
  const L = Math.max(0, num("L"));
  const q = clamp(num("q"), 0, 1);
  const s = clamp(num("s"), 0, 1);
  const p = clamp(num("p"), 0, 1);
  const r = clamp(num("r"), 0, 1);

  const Sprice = Math.max(0, num("Sprice"));
  const Pprice = Math.max(0, num("Pprice"));
  const Rprice = Math.max(0, num("Rprice"));

  const Smax = Math.max(0, num("Smax"));
  const Pmax = Math.max(0, num("Pmax"));

  const M0 = Math.max(0, num("M0"));
  const churnPct = clamp(num("churn"), 0, 50);
  const churn = churnPct / 100;

  const months = clamp(Math.round(num("months", 12)), 1, 60);

  const qualified = L * q;
  const sprintsRaw = qualified * s;
  const sprints = Math.min(sprintsRaw, Smax);

  const pilotsRaw = sprints * p;
  const pilots = Math.min(pilotsRaw, Pmax);

  const newRetainers = pilots * r;

  const newMrr = newRetainers * Rprice;

  const revMonth = (sprints * Sprice) + (pilots * Pprice) + newMrr;
  const revYear = revMonth * 12;

  // MRR accumulation over horizon
  let mrr = M0;
  const mrrTimeline = [mrr];
  for(let i=1;i<=months;i++){
    mrr = (mrr + newMrr) * (1 - churn);
    mrrTimeline.push(mrr);
  }

  const at = (n)=>{
    const idx = clamp(n, 0, months);
    return mrrTimeline[idx];
  };

  return {
    L,q,s,p,r,Sprice,Pprice,Rprice,Smax,Pmax,M0,churnPct,churn,months,
    qualified,sprintsRaw,sprints,pilotsRaw,pilots,newRetainers,newMrr,
    revMonth,revYear,mrrTimeline,
    mrr3: at(3), mrr6: at(6), mrr12: at(12), mrrEnd: at(months)
  };
}

/* ---------- Presets ---------- */
const PRESETS = {
  conservative: {
    L:6, q:0.40, s:0.30, p:0.30, r:0.25,
    Sprice:2000, Pprice:5000, Rprice:1500,
    Smax:4, Pmax:2, M0:0, churn:4
  },
  base: {
    L:12, q:0.50, s:0.35, p:0.40, r:0.30,
    Sprice:2500, Pprice:6000, Rprice:2000,
    Smax:6, Pmax:3, M0:0, churn:3
  },
  optimistic: {
    L:20, q:0.60, s:0.45, p:0.45, r:0.40,
    Sprice:3000, Pprice:8000, Rprice:2500,
    Smax:8, Pmax:4, M0:0, churn:2
  }
};

function applyPreset(){
  const key = $("preset")?.value || "base";
  const p = PRESETS[key] || PRESETS.base;

  $("L").value = p.L;
  $("q").value = p.q;
  $("s").value = p.s;
  $("p").value = p.p;
  $("r").value = p.r;

  $("Sprice").value = p.Sprice;
  $("Pprice").value = p.Pprice;
  $("Rprice").value = p.Rprice;

  $("Smax").value = p.Smax;
  $("Pmax").value = p.Pmax;

  $("M0").value = p.M0;
  $("churn").value = p.churn;
}

/* ---------- Sensitivity ---------- */
function buildSensitivity(base){
  const rows = [];

  function calcWith(patch){
    // temporarily apply patch values, compute, then restore
    const ids = Object.keys(patch);
    const old = {};
    ids.forEach(id=>{
      old[id] = $(id).value;
      $(id).value = patch[id];
    });
    const m = computeModel();
    ids.forEach(id=>$(id).value = old[id]);
    return m.revYear;
  }

  const baseYear = base.revYear;

  // +1 lead
  rows.push({
    label: "+1 lead / month",
    delta: calcWith({L: num("L")+1}) - baseYear
  });

  // +0.10 sprint close
  rows.push({
    label: "+0.10 sprint close rate",
    delta: calcWith({s: clamp(num("s")+0.10, 0, 1)}) - baseYear
  });

  // +1 sprint capacity
  rows.push({
    label: "+1 sprint capacity",
    delta: calcWith({Smax: num("Smax")+1}) - baseYear
  });

  // +0.05 pilot-from-sprint
  rows.push({
    label: "+0.05 pilot-from-sprint",
    delta: calcWith({p: clamp(num("p")+0.05, 0, 1)}) - baseYear
  });

  // +0.05 retainer-from-pilot
  rows.push({
    label: "+0.05 retainer-from-pilot",
    delta: calcWith({r: clamp(num("r")+0.05, 0, 1)}) - baseYear
  });

  const body = $("sensBody");
  body.innerHTML = "";
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const td1 = document.createElement("td");
    const td2 = document.createElement("td");
    td1.textContent = r.label;
    td2.textContent = fmtMoney(r.delta);
    tr.appendChild(td1); tr.appendChild(td2);
    body.appendChild(tr);
  });
}

/* ---------- Board summary ---------- */
function buildBoardSummary(m){
  const capNote = String($("capNotes").value || "").trim();
  const cost = Math.max(0, num("cost"));

  const conf = {
    q: $("qConf")?.value || "Med",
    s: $("sConf")?.value || "Med",
    p: $("pConf")?.value || "Med",
    r: $("rConf")?.value || "Med",
    c: $("cConf")?.value || "Med",
  };

  const notes = {
    q: String($("qNote")?.value || "").trim(),
    s: String($("sNote")?.value || "").trim(),
    p: String($("pNote")?.value || "").trim(),
    r: String($("rNote")?.value || "").trim(),
    c: String($("cNote")?.value || "").trim(),
  };

  const parts = [];
  parts.push(
    `Revenue floor model (capacity-truthed): ` +
    `${m.L} leads/mo ‚Üí q ${m.q.toFixed(2)} ‚Üí s ${m.s.toFixed(2)} ‚Üí p ${m.p.toFixed(2)} ‚Üí r ${m.r.toFixed(2)}.`
  );
  parts.push(
    `Pricing: Sprint ${fmtMoney(m.Sprice)}, Pilot ${fmtMoney(m.Pprice)}, Retainer ${fmtMoney(m.Rprice)}/mo.`
  );
  parts.push(
    `Capacity: Smax ${m.Smax}, Pmax ${m.Pmax}` + (capNote ? ` (${capNote})` : "") + `.`
  );
  parts.push(
    `Expected/month: ${m.sprints.toFixed(2)} sprints, ${m.pilots.toFixed(2)} pilots, ${m.newRetainers.toFixed(2)} new retainers.`
  );
  parts.push(
    `Run-rate: ${fmtMoney(m.revMonth)}/mo (${fmtMoney(m.revYear)}/yr).`
  );
  parts.push(
    `MRR: M0 ${fmtMoney(m.M0)}, churn ${m.churnPct.toFixed(1)}%. New MRR ${fmtMoney(m.newMrr)}/mo ‚Üí projected MRR @ ${m.months} months ${fmtMoney(m.mrrEnd)}.`
  );
  if(cost>0){
    parts.push(`Cost base noted: ${fmtMoney(cost)}/mo (for margin context, not enforced in calc).`);
  }

  const confLine =
    `Assumption confidence: q ${conf.q}, s ${conf.s}, p ${conf.p}, r ${conf.r}, churn ${conf.c}.`;
  parts.push(confLine);

  const ev = [];
  if(notes.q) ev.push(`q: ${notes.q}`);
  if(notes.s) ev.push(`s: ${notes.s}`);
  if(notes.p) ev.push(`p: ${notes.p}`);
  if(notes.r) ev.push(`r: ${notes.r}`);
  if(notes.c) ev.push(`c: ${notes.c}`);
  if(ev.length) parts.push(`Evidence: ${ev.join(" | ")}`);

  parts.push(`This model is deliberately conservative: upside comes from more leads, better close rates, and capacity expansion ‚Äî not inflated assumptions.`);

  return parts.join(" ");
}

/* ---------- Render ---------- */
function render(){
  const m = computeModel();

  // update audit value cells
  $("qValCell").textContent = m.q.toFixed(2);
  $("sValCell").textContent = m.s.toFixed(2);
  $("pValCell").textContent = m.p.toFixed(2);
  $("rValCell").textContent = m.r.toFixed(2);
  $("cValCell").textContent = m.churnPct.toFixed(1) + "%";

  // KPIs
  $("revMonth").textContent = fmtMoney(m.revMonth);
  $("revYear").textContent = fmtMoney(m.revYear);
  $("newMrr").textContent = fmtMoney(m.newMrr);
  $("mrrEnd").textContent = fmtMoney(m.mrrEnd);
  $("mrrEndSub").textContent = `MRR after churn @ ${m.months} months`;

  // volumes
  $("volumesBox").innerHTML =
    `Qualified: ${m.qualified.toFixed(2)}<br/>` +
    `Sprints: ${m.sprints.toFixed(2)} (raw ${m.sprintsRaw.toFixed(2)})<br/>` +
    `Pilots: ${m.pilots.toFixed(2)} (raw ${m.pilotsRaw.toFixed(2)})<br/>` +
    `New retainers: ${m.newRetainers.toFixed(2)}`;

  // MRR accumulation snapshot
  $("mrrBox").innerHTML =
    `Starting: ${fmtMoney(m.M0)}<br/>` +
    `MRR @ 3 months: ${fmtMoney(m.mrr3)}<br/>` +
    `MRR @ 6 months: ${fmtMoney(m.mrr6)}<br/>` +
    `MRR @ 12 months: ${fmtMoney(m.mrr12)}`;

  // sensitivity
  buildSensitivity(m);

  // board summary
  const summary = buildBoardSummary(m);
  $("boardSummary").value = summary;

  // status pill
  $("statusPill").textContent = "Live";
}

/* ---------- One-pager + Print ---------- */
function toggleView(){
  document.body.classList.toggle("onepager");
}
function printOnePager(){
  // ensure onepager layout for print, but restore after
  const was = document.body.classList.contains("onepager");
  if(!was) document.body.classList.add("onepager");
  window.print();
  if(!was) document.body.classList.remove("onepager");
}

/* ---------- Copy summary ---------- */
async function copySummary(){
  const text = $("boardSummary").value || "";
  try{
    await navigator.clipboard.writeText(text);
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }catch(e){
    // fallback
    $("boardSummary").select();
    document.execCommand("copy");
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }
}

/* ---------- Reset ---------- */
function resetBase(){
  $("preset").value = "base";
  applyPreset();
  $("currency").value = "¬£";
  $("months").value = 12;
  $("Smax").value = 6;
  $("Pmax").value = 3;
  $("M0").value = 0;
  $("churn").value = 3;
  $("cost").value = 200;
  $("capNotes").value = "";

  // audit defaults
  ["qConf","sConf","pConf","rConf","cConf"].forEach(id=>{ if($(id)) $(id).value="Med"; });
  ["qNote","sNote","pNote","rNote","cNote"].forEach(id=>{ if($(id)) $(id).value=""; });

  render();
}

/* ---------- Bulletproof wiring ---------- */
function attachListeners(){
  document.querySelectorAll("input, select, textarea").forEach(el=>{
    const handler = ()=>{
      if(el.id === "preset"){ applyPreset(); }
      render();
    };
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  $("toggleViewBtn").addEventListener("click", toggleView);
  $("printBtn").addEventListener("click", printOnePager);
  $("copySummaryBtn").addEventListener("click", copySummary);
  $("resetBtn").addEventListener("click", resetBase);
}

applyPreset();
attachListeners();
render();


(function(){
  function parseNum(x){
    if(x==null) return NaN;
    const s = String(x).replace(/,/g,'').replace(/[^\d.\-]/g,'').trim();
    return s ? Number(s) : NaN;
  }
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function moneySym(){
    // try to infer symbol from any visible money figure
    const t = document.body.innerText.match(/[¬£$‚Ç¨]/);
    return t ? t[0] : "¬£";
  }
  function fmtMoney(x, sym){
    if(!isFinite(x)) return "‚Äî";
    const sign = x >= 0 ? "+" : "‚àí";
    const v = Math.abs(x);
    return sign + (sym||"¬£") + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  // Find an input/select by nearby label text (works even if IDs differ)
  function getFieldByLabel(re){
    const nodes = Array.from(document.querySelectorAll("label,div,span,p,strong,h4,h3,h2,th,td"));
    const lab = nodes.find(n => re.test((n.textContent||"").trim()));
    if(!lab) return null;

    // search nearby for input/select
    const scope = lab.closest("div,section,article,td,th") || lab.parentElement || document;
    const cand = scope.querySelector("input,select,textarea");
    if(cand) return cand;

    // fallback: next siblings
    let cur = lab;
    for(let i=0;i<12;i++){
      cur = cur.nextElementSibling || cur.parentElement?.nextElementSibling;
      if(!cur) break;
      const f = cur.querySelector?.("input,select,textarea") || (cur.matches?.("input,select,textarea") ? cur : null);
      if(f) return f;
    }
    return null;
  }

  function readInputs(){
    const L    = parseNum(getFieldByLabel(/Leads\s*\/\s*month/i)?.value);
    const q    = parseNum(getFieldByLabel(/Qualified\s*rate/i)?.value);
    const s    = parseNum(getFieldByLabel(/Sprint\s*close/i)?.value);
    const p    = parseNum(getFieldByLabel(/Pilot-from-sprint/i)?.value);
    const r    = parseNum(getFieldByLabel(/Retainer-from-pilot/i)?.value);

    const sprintPrice   = parseNum(getFieldByLabel(/Sprint\s*price/i)?.value);
    const pilotPrice    = parseNum(getFieldByLabel(/Pilot\s*price/i)?.value);
    const retainerMonth = parseNum(getFieldByLabel(/Retainer\s*\/\s*month/i)?.value);

    const Smax = parseNum(getFieldByLabel(/Max\s*sprints\s*\/\s*month/i)?.value);
    const Pmax = parseNum(getFieldByLabel(/Max\s*pilots\s*\/\s*month/i)?.value);

    return {
      L, q:clamp01(q), s:clamp01(s), p:clamp01(p), r:clamp01(r),
      sprintPrice, pilotPrice, retainerMonth,
      Smax, Pmax
    };
  }

  function model(inp){
    // demand funnel + caps
    const qualified = inp.L * inp.q;
    const sprintsRaw = qualified * inp.s;
    const sprints = isFinite(inp.Smax) ? Math.min(sprintsRaw, inp.Smax) : sprintsRaw;

    const pilotsRaw = sprints * inp.p;
    const pilots = isFinite(inp.Pmax) ? Math.min(pilotsRaw, inp.Pmax) : pilotsRaw;

    const newRetainers = pilots * inp.r;

    const revMonth =
      sprints * inp.sprintPrice +
      pilots * inp.pilotPrice +
      newRetainers * inp.retainerMonth;

    const runRateYear = revMonth * 12;

    return {qualified, sprintsRaw, sprints, pilotsRaw, pilots, newRetainers, revMonth, runRateYear};
  }

  function ensureSensTable(){
    // locate the "What Moves the Needle (Sensitivity)" block
    const heads = Array.from(document.querySelectorAll("*"))
      .filter(el => /What Moves the Needle/i.test((el.textContent||"").trim()));
    if(!heads.length) return null;

    const root = heads[0].closest("section") || heads[0].parentElement || document;

    // find a table inside it
    let table = root.querySelector("table");
    if(!table){
      // sometimes it‚Äôs not a <table>; just bail politely
      return null;
    }
    return table;
  }

  function setRow(table, labelRe, valueText){
    const rows = Array.from(table.querySelectorAll("tr"));
    for(const tr of rows){
      const tds = tr.querySelectorAll("td,th");
      if(tds.length < 2) continue;
      const left = (tds[0].textContent||"").trim();
      if(labelRe.test(left)){
        tds[tds.length-1].textContent = valueText;
        return true;
      }
    }
    return false;
  }

  function fix(){
    const inp = readInputs();
    const sym = moneySym();
    if(!isFinite(inp.L) || !isFinite(inp.sprintPrice) || !isFinite(inp.pilotPrice) || !isFinite(inp.retainerMonth)) return;

    const base = model(inp);

    // sensitivity scenarios
    const sc = [];
    sc.push({re:/\+1\s*lead/i,     inp:{...inp, L: inp.L + 1}});
    sc.push({re:/\+0\.10\s*sprint\s*close/i, inp:{...inp, s: clamp01(inp.s + 0.10)}});
    sc.push({re:/\+1\s*sprint\s*capacity/i,  inp:{...inp, Smax: isFinite(inp.Smax) ? inp.Smax + 1 : inp.Smax}});
    sc.push({re:/\+0\.05\s*pilot-from-sprint/i, inp:{...inp, p: clamp01(inp.p + 0.05)}});
    sc.push({re:/\+0\.05\s*retainer-from-pilot/i, inp:{...inp, r: clamp01(inp.r + 0.05)}});

    const table = ensureSensTable();
    if(!table) return;

    // header rename (if present)
    Array.from(table.querySelectorAll("th")).forEach(th=>{
      if(/Effect on yearly run-rate/i.test(th.textContent||"")) th.textContent = "Œî yearly run-rate";
    });

    for(const item of sc){
      const m = model(item.inp);
      const delta = m.runRateYear - base.runRateYear;
      setRow(table, item.re, fmtMoney(delta, sym));
    }
  }

  // run now + whenever user tweaks sliders/inputs
  fix();
  const obs = new MutationObserver(()=>fix());
  obs.observe(document.body, {subtree:true, childList:true, characterData:true});
  document.addEventListener("input", fix, true);
  document.addEventListener("change", fix, true);
})();


// --- qds_revenue_floor_v2_sensfix_v4.html ---

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);

function num(id, def=0){
  const el = $(id);
  if(!el) return def;
  const v = parseFloat(String(el.value ?? "").trim());
  return Number.isFinite(v) ? v : def;
}
function clamp(x, a, b){
  if(!Number.isFinite(x)) return a;
  return Math.min(b, Math.max(a, x));
}
function fmtMoney(x){
  const cur = String($("currency").value || "¬£").trim() || "¬£";
  const n = Number.isFinite(x) ? x : 0;
  const rounded = Math.round(n);
  return cur + rounded.toLocaleString();
}

/* ---------- Core model ---------- */
function computeModel(){
  const L = Math.max(0, num("L"));
  const q = clamp(num("q"), 0, 1);
  const s = clamp(num("s"), 0, 1);
  const p = clamp(num("p"), 0, 1);
  const r = clamp(num("r"), 0, 1);

  const Sprice = Math.max(0, num("Sprice"));
  const Pprice = Math.max(0, num("Pprice"));
  const Rprice = Math.max(0, num("Rprice"));

  const Smax = Math.max(0, num("Smax"));
  const Pmax = Math.max(0, num("Pmax"));

  const M0 = Math.max(0, num("M0"));
  const churnPct = clamp(num("churn"), 0, 50);
  const churn = churnPct / 100;

  const months = clamp(Math.round(num("months", 12)), 1, 60);

  const qualified = L * q;
  const sprintsRaw = qualified * s;
  const sprints = Math.min(sprintsRaw, Smax);

  const pilotsRaw = sprints * p;
  const pilots = Math.min(pilotsRaw, Pmax);

  const newRetainers = pilots * r;

  const newMrr = newRetainers * Rprice;

  const revMonth = (sprints * Sprice) + (pilots * Pprice) + newMrr;
  const revYear = revMonth * 12;

  // MRR accumulation over horizon
  let mrr = M0;
  const mrrTimeline = [mrr];
  for(let i=1;i<=months;i++){
    mrr = (mrr + newMrr) * (1 - churn);
    mrrTimeline.push(mrr);
  }

  const at = (n)=>{
    const idx = clamp(n, 0, months);
    return mrrTimeline[idx];
  };

  return {
    L,q,s,p,r,Sprice,Pprice,Rprice,Smax,Pmax,M0,churnPct,churn,months,
    qualified,sprintsRaw,sprints,pilotsRaw,pilots,newRetainers,newMrr,
    revMonth,revYear,mrrTimeline,
    mrr3: at(3), mrr6: at(6), mrr12: at(12), mrrEnd: at(months)
  };
}

/* ---------- Presets ---------- */
const PRESETS = {
  conservative: {
    L:6, q:0.40, s:0.30, p:0.30, r:0.25,
    Sprice:2000, Pprice:5000, Rprice:1500,
    Smax:4, Pmax:2, M0:0, churn:4
  },
  base: {
    L:12, q:0.50, s:0.35, p:0.40, r:0.30,
    Sprice:2500, Pprice:6000, Rprice:2000,
    Smax:6, Pmax:3, M0:0, churn:3
  },
  optimistic: {
    L:20, q:0.60, s:0.45, p:0.45, r:0.40,
    Sprice:3000, Pprice:8000, Rprice:2500,
    Smax:8, Pmax:4, M0:0, churn:2
  }
};

function applyPreset(){
  const key = $("preset")?.value || "base";
  const p = PRESETS[key] || PRESETS.base;

  $("L").value = p.L;
  $("q").value = p.q;
  $("s").value = p.s;
  $("p").value = p.p;
  $("r").value = p.r;

  $("Sprice").value = p.Sprice;
  $("Pprice").value = p.Pprice;
  $("Rprice").value = p.Rprice;

  $("Smax").value = p.Smax;
  $("Pmax").value = p.Pmax;

  $("M0").value = p.M0;
  $("churn").value = p.churn;
}

/* ---------- Sensitivity ---------- */
function buildSensitivity(base){
  const rows = [];

  function calcWith(patch){
    // temporarily apply patch values, compute, then restore
    const ids = Object.keys(patch);
    const old = {};
    ids.forEach(id=>{
      old[id] = $(id).value;
      $(id).value = patch[id];
    });
    const m = computeModel();
    ids.forEach(id=>$(id).value = old[id]);
    return m.revYear;
  }

  const baseYear = base.revYear;

  // +1 lead
  rows.push({
    label: "+1 lead / month",
    delta: calcWith({L: num("L")+1}) - baseYear
  });

  // +0.10 sprint close
  rows.push({
    label: "+0.10 sprint close rate",
    delta: calcWith({s: clamp(num("s")+0.10, 0, 1)}) - baseYear
  });

  // +1 sprint capacity
  rows.push({
    label: "+1 sprint capacity",
    delta: calcWith({Smax: num("Smax")+1}) - baseYear
  });

  // +0.05 pilot-from-sprint
  rows.push({
    label: "+0.05 pilot-from-sprint",
    delta: calcWith({p: clamp(num("p")+0.05, 0, 1)}) - baseYear
  });

  // +0.05 retainer-from-pilot
  rows.push({
    label: "+0.05 retainer-from-pilot",
    delta: calcWith({r: clamp(num("r")+0.05, 0, 1)}) - baseYear
  });

  const body = $("sensBody");
  body.innerHTML = "";
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const td1 = document.createElement("td");
    const td2 = document.createElement("td");
    td1.textContent = r.label;
    td2.textContent = fmtMoney(r.delta);
    tr.appendChild(td1); tr.appendChild(td2);
    body.appendChild(tr);
  });
}

/* ---------- Board summary ---------- */
function buildBoardSummary(m){
  const capNote = String($("capNotes").value || "").trim();
  const cost = Math.max(0, num("cost"));

  const conf = {
    q: $("qConf")?.value || "Med",
    s: $("sConf")?.value || "Med",
    p: $("pConf")?.value || "Med",
    r: $("rConf")?.value || "Med",
    c: $("cConf")?.value || "Med",
  };

  const notes = {
    q: String($("qNote")?.value || "").trim(),
    s: String($("sNote")?.value || "").trim(),
    p: String($("pNote")?.value || "").trim(),
    r: String($("rNote")?.value || "").trim(),
    c: String($("cNote")?.value || "").trim(),
  };

  const parts = [];
  parts.push(
    `Revenue floor model (capacity-truthed): ` +
    `${m.L} leads/mo ‚Üí q ${m.q.toFixed(2)} ‚Üí s ${m.s.toFixed(2)} ‚Üí p ${m.p.toFixed(2)} ‚Üí r ${m.r.toFixed(2)}.`
  );
  parts.push(
    `Pricing: Sprint ${fmtMoney(m.Sprice)}, Pilot ${fmtMoney(m.Pprice)}, Retainer ${fmtMoney(m.Rprice)}/mo.`
  );
  parts.push(
    `Capacity: Smax ${m.Smax}, Pmax ${m.Pmax}` + (capNote ? ` (${capNote})` : "") + `.`
  );
  parts.push(
    `Expected/month: ${m.sprints.toFixed(2)} sprints, ${m.pilots.toFixed(2)} pilots, ${m.newRetainers.toFixed(2)} new retainers.`
  );
  parts.push(
    `Run-rate: ${fmtMoney(m.revMonth)}/mo (${fmtMoney(m.revYear)}/yr).`
  );
  parts.push(
    `MRR: M0 ${fmtMoney(m.M0)}, churn ${m.churnPct.toFixed(1)}%. New MRR ${fmtMoney(m.newMrr)}/mo ‚Üí projected MRR @ ${m.months} months ${fmtMoney(m.mrrEnd)}.`
  );
  if(cost>0){
    parts.push(`Cost base noted: ${fmtMoney(cost)}/mo (for margin context, not enforced in calc).`);
  }

  const confLine =
    `Assumption confidence: q ${conf.q}, s ${conf.s}, p ${conf.p}, r ${conf.r}, churn ${conf.c}.`;
  parts.push(confLine);

  const ev = [];
  if(notes.q) ev.push(`q: ${notes.q}`);
  if(notes.s) ev.push(`s: ${notes.s}`);
  if(notes.p) ev.push(`p: ${notes.p}`);
  if(notes.r) ev.push(`r: ${notes.r}`);
  if(notes.c) ev.push(`c: ${notes.c}`);
  if(ev.length) parts.push(`Evidence: ${ev.join(" | ")}`);

  parts.push(`This model is deliberately conservative: upside comes from more leads, better close rates, and capacity expansion ‚Äî not inflated assumptions.`);

  return parts.join(" ");
}

/* ---------- Render ---------- */
function render(){
  const m = computeModel();

  // update audit value cells
  $("qValCell").textContent = m.q.toFixed(2);
  $("sValCell").textContent = m.s.toFixed(2);
  $("pValCell").textContent = m.p.toFixed(2);
  $("rValCell").textContent = m.r.toFixed(2);
  $("cValCell").textContent = m.churnPct.toFixed(1) + "%";

  // KPIs
  $("revMonth").textContent = fmtMoney(m.revMonth);
  $("revYear").textContent = fmtMoney(m.revYear);
  $("newMrr").textContent = fmtMoney(m.newMrr);
  $("mrrEnd").textContent = fmtMoney(m.mrrEnd);
  $("mrrEndSub").textContent = `MRR after churn @ ${m.months} months`;

  // volumes
  $("volumesBox").innerHTML =
    `Qualified: ${m.qualified.toFixed(2)}<br/>` +
    `Sprints: ${m.sprints.toFixed(2)} (raw ${m.sprintsRaw.toFixed(2)})<br/>` +
    `Pilots: ${m.pilots.toFixed(2)} (raw ${m.pilotsRaw.toFixed(2)})<br/>` +
    `New retainers: ${m.newRetainers.toFixed(2)}`;

  // MRR accumulation snapshot
  $("mrrBox").innerHTML =
    `Starting: ${fmtMoney(m.M0)}<br/>` +
    `MRR @ 3 months: ${fmtMoney(m.mrr3)}<br/>` +
    `MRR @ 6 months: ${fmtMoney(m.mrr6)}<br/>` +
    `MRR @ 12 months: ${fmtMoney(m.mrr12)}`;

  // sensitivity
  buildSensitivity(m);

  // board summary
  const summary = buildBoardSummary(m);
  $("boardSummary").value = summary;

  // status pill
  $("statusPill").textContent = "Live";
}

/* ---------- One-pager + Print ---------- */
function toggleView(){
  document.body.classList.toggle("onepager");
}
function printOnePager(){
  // ensure onepager layout for print, but restore after
  const was = document.body.classList.contains("onepager");
  if(!was) document.body.classList.add("onepager");
  window.print();
  if(!was) document.body.classList.remove("onepager");
}

/* ---------- Copy summary ---------- */
async function copySummary(){
  const text = $("boardSummary").value || "";
  try{
    await navigator.clipboard.writeText(text);
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }catch(e){
    // fallback
    $("boardSummary").select();
    document.execCommand("copy");
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }
}

/* ---------- Reset ---------- */
function resetBase(){
  $("preset").value = "base";
  applyPreset();
  $("currency").value = "¬£";
  $("months").value = 12;
  $("Smax").value = 6;
  $("Pmax").value = 3;
  $("M0").value = 0;
  $("churn").value = 3;
  $("cost").value = 200;
  $("capNotes").value = "";

  // audit defaults
  ["qConf","sConf","pConf","rConf","cConf"].forEach(id=>{ if($(id)) $(id).value="Med"; });
  ["qNote","sNote","pNote","rNote","cNote"].forEach(id=>{ if($(id)) $(id).value=""; });

  render();
}

/* ---------- Bulletproof wiring ---------- */
function attachListeners(){
  document.querySelectorAll("input, select, textarea").forEach(el=>{
    const handler = ()=>{
      if(el.id === "preset"){ applyPreset(); }
      render();
    };
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  $("toggleViewBtn").addEventListener("click", toggleView);
  $("printBtn").addEventListener("click", printOnePager);
  $("copySummaryBtn").addEventListener("click", copySummary);
  $("resetBtn").addEventListener("click", resetBase);
}

applyPreset();
attachListeners();
render();


(function(){
  const TAG = "[QDS sensfix v3]";
  function parseNum(x){
    if(x==null) return NaN;
    const s = String(x).replace(/,/g,'').replace(/[^\d.\-]/g,'').trim();
    return s ? Number(s) : NaN;
  }
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function moneySym(){
    // try: explicit currency input, else any symbol on page
    const sym = (document.body.innerText.match(/[¬£$‚Ç¨]/)||[])[0];
    return sym || "¬£";
  }
  function fmtMoneySigned(x, sym){
    if(!isFinite(x)) return "‚Äî";
    const sign = x >= 0 ? "+" : "‚àí";
    const v = Math.abs(x);
    return sign + (sym||"¬£") + v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  // Find section containing some text
  function findSection(re){
    const all = Array.from(document.querySelectorAll("h1,h2,h3,h4,div,section,p,span,strong"));
    const el = all.find(n => re.test((n.textContent||"").trim()));
    return el ? (el.closest("section,article,div") || el.parentElement || document.body) : null;
  }

  // Try to find numeric inputs in the Inputs area by order (fallback-safe)
  function readInputs(){
    // 1) narrow to Inputs block if possible
    const inputsBlock = findSection(/^Inputs$/i) || findSection(/Revenue Floor|Capacity Truth/i) || document.body;

    // 2) collect inputs
    const ins = Array.from(inputsBlock.querySelectorAll("input,select,textarea"))
      .filter(el => el && (el.tagName==="SELECT" || (el.tagName==="INPUT" && (el.type==="number" || el.type==="text" || el.type==="range"))));

    // helper: pick numeric value from element
    const v = (i)=> (i>=0 && i<ins.length) ? parseNum(ins[i].value) : NaN;

    // Heuristic order (matches your page layout 99% of the time):
    // Demand: L,q,s,p,r
    // Pricing: sprint, pilot, retainer
    // Capacity: Smax, Pmax
    const L  = v(0);
    const q  = v(1);
    const s  = v(2);
    const p  = v(3);
    const r  = v(4);

    const sprintPrice   = v(5);
    const pilotPrice    = v(6);
    const retainerMonth = v(7);

    const Smax = v(8);
    const Pmax = v(9);

    return {
      L, q:clamp01(q), s:clamp01(s), p:clamp01(p), r:clamp01(r),
      sprintPrice, pilotPrice, retainerMonth,
      Smax, Pmax
    };
  }

  function model(inp){
    const qualified = inp.L * inp.q;
    const sprintsRaw = qualified * inp.s;
    const sprints = isFinite(inp.Smax) ? Math.min(sprintsRaw, inp.Smax) : sprintsRaw;

    const pilotsRaw = sprints * inp.p;
    const pilots = isFinite(inp.Pmax) ? Math.min(pilotsRaw, inp.Pmax) : pilotsRaw;

    const newRetainers = pilots * inp.r;

    const revMonth =
      sprints * inp.sprintPrice +
      pilots * inp.pilotPrice +
      newRetainers * inp.retainerMonth;

    const runRateYear = revMonth * 12;
    return {qualified, sprintsRaw, sprints, pilotsRaw, pilots, newRetainers, revMonth, runRateYear};
  }

  function findSensitivityRoot(){
    const root = findSection(/What Moves the Needle/i) || findSection(/Sensitivity/i);
    return root || document.body;
  }

  // Works for table rows OR grid/div rows
  function setRowValue(root, labelText, valueText){
    // try exact text match element
    const all = Array.from(root.querySelectorAll("*"))
      .filter(el => (el.children?.length||0) < 6) // avoid huge containers
      .filter(el => ((el.textContent||"").trim() === labelText));

    for(const labEl of all){
      // TABLE: if inside tr
      const tr = labEl.closest("tr");
      if(tr){
        const cells = tr.querySelectorAll("td,th");
        if(cells.length >= 2){
          cells[cells.length-1].textContent = valueText;
          return true;
        }
      }
      // DIV GRID: assume label + value are siblings
      const parent = labEl.parentElement;
      if(parent){
        const kids = Array.from(parent.children);
        const idx = kids.indexOf(labEl);
        if(idx !== -1 && idx+1 < kids.length){
          kids[idx+1].textContent = valueText;
          return true;
        }
      }
      // LAST RESORT: nextElementSibling
      if(labEl.nextElementSibling){
        labEl.nextElementSibling.textContent = valueText;
        return true;
      }
    }
    return false;
  }

  function renameHeader(root){
    const targets = Array.from(root.querySelectorAll("*"))
      .filter(el => /Effect on yearly run-rate/i.test((el.textContent||"").trim()));
    targets.forEach(el => {
      el.textContent = el.textContent.replace(/Effect on yearly run-rate/i, "Œî yearly run-rate");
    });
  }

  function fix(){
    const inp = readInputs();
    const sym = moneySym();

    // sanity: must have core numbers
    if(!isFinite(inp.L) || !isFinite(inp.sprintPrice) || !isFinite(inp.pilotPrice) || !isFinite(inp.retainerMonth)){
      // don't spam
      return;
    }

    const base = model(inp);
    const scenarios = [
      {label:"+1 lead / month",            mod: x => ({...x, L: x.L + 1})},
      {label:"+0.10 sprint close rate",    mod: x => ({...x, s: clamp01(x.s + 0.10)})},
      {label:"+1 sprint capacity",         mod: x => ({...x, Smax: isFinite(x.Smax) ? x.Smax + 1 : x.Smax})},
      {label:"+0.05 pilot-from-sprint",    mod: x => ({...x, p: clamp01(x.p + 0.05)})},
      {label:"+0.05 retainer-from-pilot",  mod: x => ({...x, r: clamp01(x.r + 0.05)})},
    ];

    const root = findSensitivityRoot();
    renameHeader(root);

    let ok = 0;
    for(const sc of scenarios){
      const m = model(sc.mod(inp));
      const delta = m.runRateYear - base.runRateYear;
      if(setRowValue(root, sc.label, fmtMoneySigned(delta, sym))) ok++;
    }

    // one-time debug ping
    if(!window.__QDS_SENS_V3_LOGGED){
      window.__QDS_SENS_V3_LOGGED = true;
      console.log(TAG, "running. Updated rows:", ok, "Base rev/mo:", base.revMonth.toFixed(2), "Base run-rate/yr:", base.runRateYear.toFixed(2));
    }
  }

  fix();
  document.addEventListener("input", fix, true);
  document.addEventListener("change", fix, true);
})();


(function(){
  const TAG="[QDS sens v4]";
  function parseNum(x){
    if(x==null) return NaN;
    const s=String(x).replace(/,/g,'').replace(/[^\d.\-]/g,'').trim();
    return s?Number(s):NaN;
  }
  function clamp01(x){ return Math.max(0,Math.min(1,x)); }
  function moneySym(){
    const sym=(document.body.innerText.match(/[¬£$‚Ç¨]/)||[])[0];
    return sym||"¬£";
  }
  function fmtMoneySigned(x,sym){
    if(!isFinite(x)) return "‚Äî";
    const sign = x>=0?"+":"‚àí";
    const v=Math.abs(x);
    return sign+(sym||"¬£")+v.toLocaleString(undefined,{maximumFractionDigits:0});
  }

  function findSection(re){
    const all=[...document.querySelectorAll("h1,h2,h3,h4,div,section,p,span,strong")];
    const el=all.find(n=>re.test((n.textContent||"").trim()));
    return el?(el.closest("section,article,div")||el.parentElement||document.body):null;
  }

  function readInputs(){
    const inputsBlock = findSection(/^Inputs$/i) || findSection(/Revenue Floor|Capacity Truth/i) || document.body;
    const ins=[...inputsBlock.querySelectorAll("input,select,textarea")]
      .filter(el => el && (el.tagName==="SELECT" || (el.tagName==="INPUT" && (el.type==="number"||el.type==="text"||el.type==="range"))));
    const v=i => (i>=0 && i<ins.length) ? parseNum(ins[i].value) : NaN;

    const L=v(0), q=clamp01(v(1)), s=clamp01(v(2)), p=clamp01(v(3)), r=clamp01(v(4));
    const sprintPrice=v(5), pilotPrice=v(6), retainerMonth=v(7);
    const Smax=v(8), Pmax=v(9);
    return {L,q,s,p,r,sprintPrice,pilotPrice,retainerMonth,Smax,Pmax};
  }

  function model(inp){
    const qualified = inp.L * inp.q;
    const sprintsRaw = qualified * inp.s;
    const sprints = isFinite(inp.Smax) ? Math.min(sprintsRaw, inp.Smax) : sprintsRaw;
    const pilotsRaw = sprints * inp.p;
    const pilots = isFinite(inp.Pmax) ? Math.min(pilotsRaw, inp.Pmax) : pilotsRaw;
    const newRetainers = pilots * inp.r;
    const revMonth = sprints*inp.sprintPrice + pilots*inp.pilotPrice + newRetainers*inp.retainerMonth;
    const runRateYear = revMonth * 12;
    return {qualified,sprints,pilots,newRetainers,revMonth,runRateYear};
  }

  function ensurePanel(root){
    let box = root.querySelector(".qds-sens-v4");
    if(!box){
      box=document.createElement("div");
      box.className="qds-sens-v4";
      box.innerHTML = `
        <h4>Œî Sensitivity (verified)</h4>
        <div class="sub">Shows <b>change in yearly run-rate</b> vs current inputs. (This panel is rendered by engine v4, independent of the legacy block.)</div>
        <table>
          <thead><tr><th>Change</th><th>Œî yearly run-rate</th></tr></thead>
          <tbody></tbody>
        </table>
      `;
      root.appendChild(box);
    }
    return box;
  }

  function render(){
    const inp=readInputs();
    if(!isFinite(inp.L) || !isFinite(inp.sprintPrice) || !isFinite(inp.pilotPrice) || !isFinite(inp.retainerMonth)) return;

    const base=model(inp);
    const sym=moneySym();

    const rows = [
      {label:"+1 lead / month",           inp:{...inp, L: inp.L + 1}},
      {label:"+0.10 sprint close rate",   inp:{...inp, s: clamp01(inp.s + 0.10)}},
      {label:"+1 sprint capacity",        inp:{...inp, Smax: isFinite(inp.Smax)? inp.Smax + 1 : inp.Smax}},
      {label:"+0.05 pilot-from-sprint",   inp:{...inp, p: clamp01(inp.p + 0.05)}},
      {label:"+0.05 retainer-from-pilot", inp:{...inp, r: clamp01(inp.r + 0.05)}},
    ];

    const root = findSection(/What Moves the Needle/i) || findSection(/Sensitivity/i) || document.body;
    const panel = ensurePanel(root);
    const tbody = panel.querySelector("tbody");
    tbody.innerHTML = "";

    for(const row of rows){
      const m=model(row.inp);
      const delta=m.runRateYear - base.runRateYear;
      const tr=document.createElement("tr");
      tr.innerHTML = `<td class="ok">${row.label}</td><td>${fmtMoneySigned(delta, sym)}</td>`;
      tbody.appendChild(tr);
    }

    if(!window.__QDS_SENS_V4_LOGGED){
      window.__QDS_SENS_V4_LOGGED=true;
      console.log(TAG,"rendered. Base run-rate/yr:", base.runRateYear.toFixed(2));
    }
  }

  render();
  document.addEventListener("input", render, true);
  document.addEventListener("change", render, true);
})();


// --- QDS_Battery_Lab/index.html ---



// --- _clean_masters/qds_revenue_floor_v2.html ---

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);

function num(id, def=0){
  const el = $(id);
  if(!el) return def;
  const v = parseFloat(String(el.value ?? "").trim());
  return Number.isFinite(v) ? v : def;
}
function clamp(x, a, b){
  if(!Number.isFinite(x)) return a;
  return Math.min(b, Math.max(a, x));
}
function fmtMoney(x){
  const cur = String($("currency").value || "¬£").trim() || "¬£";
  const n = Number.isFinite(x) ? x : 0;
  const rounded = Math.round(n);
  return cur + rounded.toLocaleString();
}

/* ---------- Core model ---------- */
function computeModel(){
  const L = Math.max(0, num("L"));
  const q = clamp(num("q"), 0, 1);
  const s = clamp(num("s"), 0, 1);
  const p = clamp(num("p"), 0, 1);
  const r = clamp(num("r"), 0, 1);

  const Sprice = Math.max(0, num("Sprice"));
  const Pprice = Math.max(0, num("Pprice"));
  const Rprice = Math.max(0, num("Rprice"));

  const Smax = Math.max(0, num("Smax"));
  const Pmax = Math.max(0, num("Pmax"));

  const M0 = Math.max(0, num("M0"));
  const churnPct = clamp(num("churn"), 0, 50);
  const churn = churnPct / 100;

  const months = clamp(Math.round(num("months", 12)), 1, 60);

  const qualified = L * q;
  const sprintsRaw = qualified * s;
  const sprints = Math.min(sprintsRaw, Smax);

  const pilotsRaw = sprints * p;
  const pilots = Math.min(pilotsRaw, Pmax);

  const newRetainers = pilots * r;

  const newMrr = newRetainers * Rprice;

  const revMonth = (sprints * Sprice) + (pilots * Pprice) + newMrr;
  const revYear = revMonth * 12;

  // MRR accumulation over horizon
  let mrr = M0;
  const mrrTimeline = [mrr];
  for(let i=1;i<=months;i++){
    mrr = (mrr + newMrr) * (1 - churn);
    mrrTimeline.push(mrr);
  }

  const at = (n)=>{
    const idx = clamp(n, 0, months);
    return mrrTimeline[idx];
  };

  return {
    L,q,s,p,r,Sprice,Pprice,Rprice,Smax,Pmax,M0,churnPct,churn,months,
    qualified,sprintsRaw,sprints,pilotsRaw,pilots,newRetainers,newMrr,
    revMonth,revYear,mrrTimeline,
    mrr3: at(3), mrr6: at(6), mrr12: at(12), mrrEnd: at(months)
  };
}

/* ---------- Presets ---------- */
const PRESETS = {
  conservative: {
    L:6, q:0.40, s:0.30, p:0.30, r:0.25,
    Sprice:2000, Pprice:5000, Rprice:1500,
    Smax:4, Pmax:2, M0:0, churn:4
  },
  base: {
    L:12, q:0.50, s:0.35, p:0.40, r:0.30,
    Sprice:2500, Pprice:6000, Rprice:2000,
    Smax:6, Pmax:3, M0:0, churn:3
  },
  optimistic: {
    L:20, q:0.60, s:0.45, p:0.45, r:0.40,
    Sprice:3000, Pprice:8000, Rprice:2500,
    Smax:8, Pmax:4, M0:0, churn:2
  }
};

function applyPreset(){
  const key = $("preset")?.value || "base";
  const p = PRESETS[key] || PRESETS.base;

  $("L").value = p.L;
  $("q").value = p.q;
  $("s").value = p.s;
  $("p").value = p.p;
  $("r").value = p.r;

  $("Sprice").value = p.Sprice;
  $("Pprice").value = p.Pprice;
  $("Rprice").value = p.Rprice;

  $("Smax").value = p.Smax;
  $("Pmax").value = p.Pmax;

  $("M0").value = p.M0;
  $("churn").value = p.churn;
}

/* ---------- Sensitivity ---------- */
function buildSensitivity(base){
  const rows = [];

  function calcWith(patch){
    // temporarily apply patch values, compute, then restore
    const ids = Object.keys(patch);
    const old = {};
    ids.forEach(id=>{
      old[id] = $(id).value;
      $(id).value = patch[id];
    });
    const m = computeModel();
    ids.forEach(id=>$(id).value = old[id]);
    return m.revYear;
  }

  const baseYear = base.revYear;

  // +1 lead
  rows.push({
    label: "+1 lead / month",
    delta: calcWith({L: num("L")+1}) - baseYear
  });

  // +0.10 sprint close
  rows.push({
    label: "+0.10 sprint close rate",
    delta: calcWith({s: clamp(num("s")+0.10, 0, 1)}) - baseYear
  });

  // +1 sprint capacity
  rows.push({
    label: "+1 sprint capacity",
    delta: calcWith({Smax: num("Smax")+1}) - baseYear
  });

  // +0.05 pilot-from-sprint
  rows.push({
    label: "+0.05 pilot-from-sprint",
    delta: calcWith({p: clamp(num("p")+0.05, 0, 1)}) - baseYear
  });

  // +0.05 retainer-from-pilot
  rows.push({
    label: "+0.05 retainer-from-pilot",
    delta: calcWith({r: clamp(num("r")+0.05, 0, 1)}) - baseYear
  });

  const body = $("sensBody");
  body.innerHTML = "";
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const td1 = document.createElement("td");
    const td2 = document.createElement("td");
    td1.textContent = r.label;
    td2.textContent = fmtMoney(r.delta);
    tr.appendChild(td1); tr.appendChild(td2);
    body.appendChild(tr);
  });
}

/* ---------- Board summary ---------- */
function buildBoardSummary(m){
  const capNote = String($("capNotes").value || "").trim();
  const cost = Math.max(0, num("cost"));

  const conf = {
    q: $("qConf")?.value || "Med",
    s: $("sConf")?.value || "Med",
    p: $("pConf")?.value || "Med",
    r: $("rConf")?.value || "Med",
    c: $("cConf")?.value || "Med",
  };

  const notes = {
    q: String($("qNote")?.value || "").trim(),
    s: String($("sNote")?.value || "").trim(),
    p: String($("pNote")?.value || "").trim(),
    r: String($("rNote")?.value || "").trim(),
    c: String($("cNote")?.value || "").trim(),
  };

  const parts = [];
  parts.push(
    `Revenue floor model (capacity-truthed): ` +
    `${m.L} leads/mo ‚Üí q ${m.q.toFixed(2)} ‚Üí s ${m.s.toFixed(2)} ‚Üí p ${m.p.toFixed(2)} ‚Üí r ${m.r.toFixed(2)}.`
  );
  parts.push(
    `Pricing: Sprint ${fmtMoney(m.Sprice)}, Pilot ${fmtMoney(m.Pprice)}, Retainer ${fmtMoney(m.Rprice)}/mo.`
  );
  parts.push(
    `Capacity: Smax ${m.Smax}, Pmax ${m.Pmax}` + (capNote ? ` (${capNote})` : "") + `.`
  );
  parts.push(
    `Expected/month: ${m.sprints.toFixed(2)} sprints, ${m.pilots.toFixed(2)} pilots, ${m.newRetainers.toFixed(2)} new retainers.`
  );
  parts.push(
    `Run-rate: ${fmtMoney(m.revMonth)}/mo (${fmtMoney(m.revYear)}/yr).`
  );
  parts.push(
    `MRR: M0 ${fmtMoney(m.M0)}, churn ${m.churnPct.toFixed(1)}%. New MRR ${fmtMoney(m.newMrr)}/mo ‚Üí projected MRR @ ${m.months} months ${fmtMoney(m.mrrEnd)}.`
  );
  if(cost>0){
    parts.push(`Cost base noted: ${fmtMoney(cost)}/mo (for margin context, not enforced in calc).`);
  }

  const confLine =
    `Assumption confidence: q ${conf.q}, s ${conf.s}, p ${conf.p}, r ${conf.r}, churn ${conf.c}.`;
  parts.push(confLine);

  const ev = [];
  if(notes.q) ev.push(`q: ${notes.q}`);
  if(notes.s) ev.push(`s: ${notes.s}`);
  if(notes.p) ev.push(`p: ${notes.p}`);
  if(notes.r) ev.push(`r: ${notes.r}`);
  if(notes.c) ev.push(`c: ${notes.c}`);
  if(ev.length) parts.push(`Evidence: ${ev.join(" | ")}`);

  parts.push(`This model is deliberately conservative: upside comes from more leads, better close rates, and capacity expansion ‚Äî not inflated assumptions.`);

  return parts.join(" ");
}

/* ---------- Render ---------- */
function render(){
  const m = computeModel();

  // update audit value cells
  $("qValCell").textContent = m.q.toFixed(2);
  $("sValCell").textContent = m.s.toFixed(2);
  $("pValCell").textContent = m.p.toFixed(2);
  $("rValCell").textContent = m.r.toFixed(2);
  $("cValCell").textContent = m.churnPct.toFixed(1) + "%";

  // KPIs
  $("revMonth").textContent = fmtMoney(m.revMonth);
  $("revYear").textContent = fmtMoney(m.revYear);
  $("newMrr").textContent = fmtMoney(m.newMrr);
  $("mrrEnd").textContent = fmtMoney(m.mrrEnd);
  $("mrrEndSub").textContent = `MRR after churn @ ${m.months} months`;

  // volumes
  $("volumesBox").innerHTML =
    `Qualified: ${m.qualified.toFixed(2)}<br/>` +
    `Sprints: ${m.sprints.toFixed(2)} (raw ${m.sprintsRaw.toFixed(2)})<br/>` +
    `Pilots: ${m.pilots.toFixed(2)} (raw ${m.pilotsRaw.toFixed(2)})<br/>` +
    `New retainers: ${m.newRetainers.toFixed(2)}`;

  // MRR accumulation snapshot
  $("mrrBox").innerHTML =
    `Starting: ${fmtMoney(m.M0)}<br/>` +
    `MRR @ 3 months: ${fmtMoney(m.mrr3)}<br/>` +
    `MRR @ 6 months: ${fmtMoney(m.mrr6)}<br/>` +
    `MRR @ 12 months: ${fmtMoney(m.mrr12)}`;

  // sensitivity
  buildSensitivity(m);

  // board summary
  const summary = buildBoardSummary(m);
  $("boardSummary").value = summary;

  // status pill
  $("statusPill").textContent = "Live";
}

/* ---------- One-pager + Print ---------- */
function toggleView(){
  document.body.classList.toggle("onepager");
}
function printOnePager(){
  // ensure onepager layout for print, but restore after
  const was = document.body.classList.contains("onepager");
  if(!was) document.body.classList.add("onepager");
  window.print();
  if(!was) document.body.classList.remove("onepager");
}

/* ---------- Copy summary ---------- */
async function copySummary(){
  const text = $("boardSummary").value || "";
  try{
    await navigator.clipboard.writeText(text);
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }catch(e){
    // fallback
    $("boardSummary").select();
    document.execCommand("copy");
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }
}

/* ---------- Reset ---------- */
function resetBase(){
  $("preset").value = "base";
  applyPreset();
  $("currency").value = "¬£";
  $("months").value = 12;
  $("Smax").value = 6;
  $("Pmax").value = 3;
  $("M0").value = 0;
  $("churn").value = 3;
  $("cost").value = 200;
  $("capNotes").value = "";

  // audit defaults
  ["qConf","sConf","pConf","rConf","cConf"].forEach(id=>{ if($(id)) $(id).value="Med"; });
  ["qNote","sNote","pNote","rNote","cNote"].forEach(id=>{ if($(id)) $(id).value=""; });

  render();
}

/* ---------- Bulletproof wiring ---------- */
function attachListeners(){
  document.querySelectorAll("input, select, textarea").forEach(el=>{
    const handler = ()=>{
      if(el.id === "preset"){ applyPreset(); }
      render();
    };
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  $("toggleViewBtn").addEventListener("click", toggleView);
  $("printBtn").addEventListener("click", printOnePager);
  $("copySummaryBtn").addEventListener("click", copySummary);
  $("resetBtn").addEventListener("click", resetBase);
}

applyPreset();
attachListeners();
render();


// --- _clean_masters/qds_revenue_floor_BASE.html ---

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);

function num(id, def=0){
  const el = $(id);
  if(!el) return def;
  const v = parseFloat(String(el.value ?? "").trim());
  return Number.isFinite(v) ? v : def;
}
function clamp(x, a, b){
  if(!Number.isFinite(x)) return a;
  return Math.min(b, Math.max(a, x));
}
function fmtMoney(x){
  const cur = String($("currency").value || "¬£").trim() || "¬£";
  const n = Number.isFinite(x) ? x : 0;
  const rounded = Math.round(n);
  return cur + rounded.toLocaleString();
}

/* ---------- Core model ---------- */
function computeModel(){
  const L = Math.max(0, num("L"));
  const q = clamp(num("q"), 0, 1);
  const s = clamp(num("s"), 0, 1);
  const p = clamp(num("p"), 0, 1);
  const r = clamp(num("r"), 0, 1);

  const Sprice = Math.max(0, num("Sprice"));
  const Pprice = Math.max(0, num("Pprice"));
  const Rprice = Math.max(0, num("Rprice"));

  const Smax = Math.max(0, num("Smax"));
  const Pmax = Math.max(0, num("Pmax"));

  const M0 = Math.max(0, num("M0"));
  const churnPct = clamp(num("churn"), 0, 50);
  const churn = churnPct / 100;

  const months = clamp(Math.round(num("months", 12)), 1, 60);

  const qualified = L * q;
  const sprintsRaw = qualified * s;
  const sprints = Math.min(sprintsRaw, Smax);

  const pilotsRaw = sprints * p;
  const pilots = Math.min(pilotsRaw, Pmax);

  const newRetainers = pilots * r;

  const newMrr = newRetainers * Rprice;

  const revMonth = (sprints * Sprice) + (pilots * Pprice) + newMrr;
  const revYear = revMonth * 12;

  // MRR accumulation over horizon
  let mrr = M0;
  const mrrTimeline = [mrr];
  for(let i=1;i<=months;i++){
    mrr = (mrr + newMrr) * (1 - churn);
    mrrTimeline.push(mrr);
  }

  const at = (n)=>{
    const idx = clamp(n, 0, months);
    return mrrTimeline[idx];
  };

  return {
    L,q,s,p,r,Sprice,Pprice,Rprice,Smax,Pmax,M0,churnPct,churn,months,
    qualified,sprintsRaw,sprints,pilotsRaw,pilots,newRetainers,newMrr,
    revMonth,revYear,mrrTimeline,
    mrr3: at(3), mrr6: at(6), mrr12: at(12), mrrEnd: at(months)
  };
}

/* ---------- Presets ---------- */
const PRESETS = {
  conservative: {
    L:6, q:0.40, s:0.30, p:0.30, r:0.25,
    Sprice:2000, Pprice:5000, Rprice:1500,
    Smax:4, Pmax:2, M0:0, churn:4
  },
  base: {
    L:12, q:0.50, s:0.35, p:0.40, r:0.30,
    Sprice:2500, Pprice:6000, Rprice:2000,
    Smax:6, Pmax:3, M0:0, churn:3
  },
  optimistic: {
    L:20, q:0.60, s:0.45, p:0.45, r:0.40,
    Sprice:3000, Pprice:8000, Rprice:2500,
    Smax:8, Pmax:4, M0:0, churn:2
  }
};

function applyPreset(){
  const key = $("preset")?.value || "base";
  const p = PRESETS[key] || PRESETS.base;

  $("L").value = p.L;
  $("q").value = p.q;
  $("s").value = p.s;
  $("p").value = p.p;
  $("r").value = p.r;

  $("Sprice").value = p.Sprice;
  $("Pprice").value = p.Pprice;
  $("Rprice").value = p.Rprice;

  $("Smax").value = p.Smax;
  $("Pmax").value = p.Pmax;

  $("M0").value = p.M0;
  $("churn").value = p.churn;
}

/* ---------- Sensitivity ---------- */
function buildSensitivity(base){
  const rows = [];

  function calcWith(patch){
    // temporarily apply patch values, compute, then restore
    const ids = Object.keys(patch);
    const old = {};
    ids.forEach(id=>{
      old[id] = $(id).value;
      $(id).value = patch[id];
    });
    const m = computeModel();
    ids.forEach(id=>$(id).value = old[id]);
    return m.revYear;
  }

  const baseYear = base.revYear;

  // +1 lead
  rows.push({
    label: "+1 lead / month",
    delta: calcWith({L: num("L")+1}) - baseYear
  });

  // +0.10 sprint close
  rows.push({
    label: "+0.10 sprint close rate",
    delta: calcWith({s: clamp(num("s")+0.10, 0, 1)}) - baseYear
  });

  // +1 sprint capacity
  rows.push({
    label: "+1 sprint capacity",
    delta: calcWith({Smax: num("Smax")+1}) - baseYear
  });

  // +0.05 pilot-from-sprint
  rows.push({
    label: "+0.05 pilot-from-sprint",
    delta: calcWith({p: clamp(num("p")+0.05, 0, 1)}) - baseYear
  });

  // +0.05 retainer-from-pilot
  rows.push({
    label: "+0.05 retainer-from-pilot",
    delta: calcWith({r: clamp(num("r")+0.05, 0, 1)}) - baseYear
  });

  const body = $("sensBody");
  body.innerHTML = "";
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const td1 = document.createElement("td");
    const td2 = document.createElement("td");
    td1.textContent = r.label;
    td2.textContent = fmtMoney(r.delta);
    tr.appendChild(td1); tr.appendChild(td2);
    body.appendChild(tr);
  });
}

/* ---------- Board summary ---------- */
function buildBoardSummary(m){
  const capNote = String($("capNotes").value || "").trim();
  const cost = Math.max(0, num("cost"));

  const conf = {
    q: $("qConf")?.value || "Med",
    s: $("sConf")?.value || "Med",
    p: $("pConf")?.value || "Med",
    r: $("rConf")?.value || "Med",
    c: $("cConf")?.value || "Med",
  };

  const notes = {
    q: String($("qNote")?.value || "").trim(),
    s: String($("sNote")?.value || "").trim(),
    p: String($("pNote")?.value || "").trim(),
    r: String($("rNote")?.value || "").trim(),
    c: String($("cNote")?.value || "").trim(),
  };

  const parts = [];
  parts.push(
    `Revenue floor model (capacity-truthed): ` +
    `${m.L} leads/mo ‚Üí q ${m.q.toFixed(2)} ‚Üí s ${m.s.toFixed(2)} ‚Üí p ${m.p.toFixed(2)} ‚Üí r ${m.r.toFixed(2)}.`
  );
  parts.push(
    `Pricing: Sprint ${fmtMoney(m.Sprice)}, Pilot ${fmtMoney(m.Pprice)}, Retainer ${fmtMoney(m.Rprice)}/mo.`
  );
  parts.push(
    `Capacity: Smax ${m.Smax}, Pmax ${m.Pmax}` + (capNote ? ` (${capNote})` : "") + `.`
  );
  parts.push(
    `Expected/month: ${m.sprints.toFixed(2)} sprints, ${m.pilots.toFixed(2)} pilots, ${m.newRetainers.toFixed(2)} new retainers.`
  );
  parts.push(
    `Run-rate: ${fmtMoney(m.revMonth)}/mo (${fmtMoney(m.revYear)}/yr).`
  );
  parts.push(
    `MRR: M0 ${fmtMoney(m.M0)}, churn ${m.churnPct.toFixed(1)}%. New MRR ${fmtMoney(m.newMrr)}/mo ‚Üí projected MRR @ ${m.months} months ${fmtMoney(m.mrrEnd)}.`
  );
  if(cost>0){
    parts.push(`Cost base noted: ${fmtMoney(cost)}/mo (for margin context, not enforced in calc).`);
  }

  const confLine =
    `Assumption confidence: q ${conf.q}, s ${conf.s}, p ${conf.p}, r ${conf.r}, churn ${conf.c}.`;
  parts.push(confLine);

  const ev = [];
  if(notes.q) ev.push(`q: ${notes.q}`);
  if(notes.s) ev.push(`s: ${notes.s}`);
  if(notes.p) ev.push(`p: ${notes.p}`);
  if(notes.r) ev.push(`r: ${notes.r}`);
  if(notes.c) ev.push(`c: ${notes.c}`);
  if(ev.length) parts.push(`Evidence: ${ev.join(" | ")}`);

  parts.push(`This model is deliberately conservative: upside comes from more leads, better close rates, and capacity expansion ‚Äî not inflated assumptions.`);

  return parts.join(" ");
}

/* ---------- Render ---------- */
function render(){
  const m = computeModel();

  // update audit value cells
  $("qValCell").textContent = m.q.toFixed(2);
  $("sValCell").textContent = m.s.toFixed(2);
  $("pValCell").textContent = m.p.toFixed(2);
  $("rValCell").textContent = m.r.toFixed(2);
  $("cValCell").textContent = m.churnPct.toFixed(1) + "%";

  // KPIs
  $("revMonth").textContent = fmtMoney(m.revMonth);
  $("revYear").textContent = fmtMoney(m.revYear);
  $("newMrr").textContent = fmtMoney(m.newMrr);
  $("mrrEnd").textContent = fmtMoney(m.mrrEnd);
  $("mrrEndSub").textContent = `MRR after churn @ ${m.months} months`;

  // volumes
  $("volumesBox").innerHTML =
    `Qualified: ${m.qualified.toFixed(2)}<br/>` +
    `Sprints: ${m.sprints.toFixed(2)} (raw ${m.sprintsRaw.toFixed(2)})<br/>` +
    `Pilots: ${m.pilots.toFixed(2)} (raw ${m.pilotsRaw.toFixed(2)})<br/>` +
    `New retainers: ${m.newRetainers.toFixed(2)}`;

  // MRR accumulation snapshot
  $("mrrBox").innerHTML =
    `Starting: ${fmtMoney(m.M0)}<br/>` +
    `MRR @ 3 months: ${fmtMoney(m.mrr3)}<br/>` +
    `MRR @ 6 months: ${fmtMoney(m.mrr6)}<br/>` +
    `MRR @ 12 months: ${fmtMoney(m.mrr12)}`;

  // sensitivity
  buildSensitivity(m);

  // board summary
  const summary = buildBoardSummary(m);
  $("boardSummary").value = summary;

  // status pill
  $("statusPill").textContent = "Live";
}

/* ---------- One-pager + Print ---------- */
function toggleView(){
  document.body.classList.toggle("onepager");
}
function printOnePager(){
  // ensure onepager layout for print, but restore after
  const was = document.body.classList.contains("onepager");
  if(!was) document.body.classList.add("onepager");
  window.print();
  if(!was) document.body.classList.remove("onepager");
}

/* ---------- Copy summary ---------- */
async function copySummary(){
  const text = $("boardSummary").value || "";
  try{
    await navigator.clipboard.writeText(text);
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }catch(e){
    // fallback
    $("boardSummary").select();
    document.execCommand("copy");
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }
}

/* ---------- Reset ---------- */
function resetBase(){
  $("preset").value = "base";
  applyPreset();
  $("currency").value = "¬£";
  $("months").value = 12;
  $("Smax").value = 6;
  $("Pmax").value = 3;
  $("M0").value = 0;
  $("churn").value = 3;
  $("cost").value = 200;
  $("capNotes").value = "";

  // audit defaults
  ["qConf","sConf","pConf","rConf","cConf"].forEach(id=>{ if($(id)) $(id).value="Med"; });
  ["qNote","sNote","pNote","rNote","cNote"].forEach(id=>{ if($(id)) $(id).value=""; });

  render();
}

/* ---------- Bulletproof wiring ---------- */
function attachListeners(){
  document.querySelectorAll("input, select, textarea").forEach(el=>{
    const handler = ()=>{
      if(el.id === "preset"){ applyPreset(); }
      render();
    };
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  $("toggleViewBtn").addEventListener("click", toggleView);
  $("printBtn").addEventListener("click", printOnePager);
  $("copySummaryBtn").addEventListener("click", copySummary);
  $("resetBtn").addEventListener("click", resetBase);
}

applyPreset();
attachListeners();
render();


// --- _clean_masters/qds_revenue_floor_STRETCH.html ---

/* ---------- Helpers ---------- */
const $ = (id)=>document.getElementById(id);

function num(id, def=0){
  const el = $(id);
  if(!el) return def;
  const v = parseFloat(String(el.value ?? "").trim());
  return Number.isFinite(v) ? v : def;
}
function clamp(x, a, b){
  if(!Number.isFinite(x)) return a;
  return Math.min(b, Math.max(a, x));
}
function fmtMoney(x){
  const cur = String($("currency").value || "¬£").trim() || "¬£";
  const n = Number.isFinite(x) ? x : 0;
  const rounded = Math.round(n);
  return cur + rounded.toLocaleString();
}

/* ---------- Core model ---------- */
function computeModel(){
  const L = Math.max(0, num("L"));
  const q = clamp(num("q"), 0, 1);
  const s = clamp(num("s"), 0, 1);
  const p = clamp(num("p"), 0, 1);
  const r = clamp(num("r"), 0, 1);

  const Sprice = Math.max(0, num("Sprice"));
  const Pprice = Math.max(0, num("Pprice"));
  const Rprice = Math.max(0, num("Rprice"));

  const Smax = Math.max(0, num("Smax"));
  const Pmax = Math.max(0, num("Pmax"));

  const M0 = Math.max(0, num("M0"));
  const churnPct = clamp(num("churn"), 0, 50);
  const churn = churnPct / 100;

  const months = clamp(Math.round(num("months", 12)), 1, 60);

  const qualified = L * q;
  const sprintsRaw = qualified * s;
  const sprints = Math.min(sprintsRaw, Smax);

  const pilotsRaw = sprints * p;
  const pilots = Math.min(pilotsRaw, Pmax);

  const newRetainers = pilots * r;

  const newMrr = newRetainers * Rprice;

  const revMonth = (sprints * Sprice) + (pilots * Pprice) + newMrr;
  const revYear = revMonth * 12;

  // MRR accumulation over horizon
  let mrr = M0;
  const mrrTimeline = [mrr];
  for(let i=1;i<=months;i++){
    mrr = (mrr + newMrr) * (1 - churn);
    mrrTimeline.push(mrr);
  }

  const at = (n)=>{
    const idx = clamp(n, 0, months);
    return mrrTimeline[idx];
  };

  return {
    L,q,s,p,r,Sprice,Pprice,Rprice,Smax,Pmax,M0,churnPct,churn,months,
    qualified,sprintsRaw,sprints,pilotsRaw,pilots,newRetainers,newMrr,
    revMonth,revYear,mrrTimeline,
    mrr3: at(3), mrr6: at(6), mrr12: at(12), mrrEnd: at(months)
  };
}

/* ---------- Presets ---------- */
const PRESETS = {
  conservative: {
    L:6, q:0.40, s:0.30, p:0.30, r:0.25,
    Sprice:2000, Pprice:5000, Rprice:1500,
    Smax:4, Pmax:2, M0:0, churn:4
  },
  base: {
    L:12, q:0.50, s:0.35, p:0.40, r:0.30,
    Sprice:2500, Pprice:6000, Rprice:2000,
    Smax:6, Pmax:3, M0:0, churn:3
  },
  optimistic: {
    L:20, q:0.60, s:0.45, p:0.45, r:0.40,
    Sprice:3000, Pprice:8000, Rprice:2500,
    Smax:8, Pmax:4, M0:0, churn:2
  }
};

function applyPreset(){
  const key = $("preset")?.value || "base";
  const p = PRESETS[key] || PRESETS.base;

  $("L").value = p.L;
  $("q").value = p.q;
  $("s").value = p.s;
  $("p").value = p.p;
  $("r").value = p.r;

  $("Sprice").value = p.Sprice;
  $("Pprice").value = p.Pprice;
  $("Rprice").value = p.Rprice;

  $("Smax").value = p.Smax;
  $("Pmax").value = p.Pmax;

  $("M0").value = p.M0;
  $("churn").value = p.churn;
}

/* ---------- Sensitivity ---------- */
function buildSensitivity(base){
  const rows = [];

  function calcWith(patch){
    // temporarily apply patch values, compute, then restore
    const ids = Object.keys(patch);
    const old = {};
    ids.forEach(id=>{
      old[id] = $(id).value;
      $(id).value = patch[id];
    });
    const m = computeModel();
    ids.forEach(id=>$(id).value = old[id]);
    return m.revYear;
  }

  const baseYear = base.revYear;

  // +1 lead
  rows.push({
    label: "+1 lead / month",
    delta: calcWith({L: num("L")+1}) - baseYear
  });

  // +0.10 sprint close
  rows.push({
    label: "+0.10 sprint close rate",
    delta: calcWith({s: clamp(num("s")+0.10, 0, 1)}) - baseYear
  });

  // +1 sprint capacity
  rows.push({
    label: "+1 sprint capacity",
    delta: calcWith({Smax: num("Smax")+1}) - baseYear
  });

  // +0.05 pilot-from-sprint
  rows.push({
    label: "+0.05 pilot-from-sprint",
    delta: calcWith({p: clamp(num("p")+0.05, 0, 1)}) - baseYear
  });

  // +0.05 retainer-from-pilot
  rows.push({
    label: "+0.05 retainer-from-pilot",
    delta: calcWith({r: clamp(num("r")+0.05, 0, 1)}) - baseYear
  });

  const body = $("sensBody");
  body.innerHTML = "";
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const td1 = document.createElement("td");
    const td2 = document.createElement("td");
    td1.textContent = r.label;
    td2.textContent = fmtMoney(r.delta);
    tr.appendChild(td1); tr.appendChild(td2);
    body.appendChild(tr);
  });
}

/* ---------- Board summary ---------- */
function buildBoardSummary(m){
  const capNote = String($("capNotes").value || "").trim();
  const cost = Math.max(0, num("cost"));

  const conf = {
    q: $("qConf")?.value || "Med",
    s: $("sConf")?.value || "Med",
    p: $("pConf")?.value || "Med",
    r: $("rConf")?.value || "Med",
    c: $("cConf")?.value || "Med",
  };

  const notes = {
    q: String($("qNote")?.value || "").trim(),
    s: String($("sNote")?.value || "").trim(),
    p: String($("pNote")?.value || "").trim(),
    r: String($("rNote")?.value || "").trim(),
    c: String($("cNote")?.value || "").trim(),
  };

  const parts = [];
  parts.push(
    `Revenue floor model (capacity-truthed): ` +
    `${m.L} leads/mo ‚Üí q ${m.q.toFixed(2)} ‚Üí s ${m.s.toFixed(2)} ‚Üí p ${m.p.toFixed(2)} ‚Üí r ${m.r.toFixed(2)}.`
  );
  parts.push(
    `Pricing: Sprint ${fmtMoney(m.Sprice)}, Pilot ${fmtMoney(m.Pprice)}, Retainer ${fmtMoney(m.Rprice)}/mo.`
  );
  parts.push(
    `Capacity: Smax ${m.Smax}, Pmax ${m.Pmax}` + (capNote ? ` (${capNote})` : "") + `.`
  );
  parts.push(
    `Expected/month: ${m.sprints.toFixed(2)} sprints, ${m.pilots.toFixed(2)} pilots, ${m.newRetainers.toFixed(2)} new retainers.`
  );
  parts.push(
    `Run-rate: ${fmtMoney(m.revMonth)}/mo (${fmtMoney(m.revYear)}/yr).`
  );
  parts.push(
    `MRR: M0 ${fmtMoney(m.M0)}, churn ${m.churnPct.toFixed(1)}%. New MRR ${fmtMoney(m.newMrr)}/mo ‚Üí projected MRR @ ${m.months} months ${fmtMoney(m.mrrEnd)}.`
  );
  if(cost>0){
    parts.push(`Cost base noted: ${fmtMoney(cost)}/mo (for margin context, not enforced in calc).`);
  }

  const confLine =
    `Assumption confidence: q ${conf.q}, s ${conf.s}, p ${conf.p}, r ${conf.r}, churn ${conf.c}.`;
  parts.push(confLine);

  const ev = [];
  if(notes.q) ev.push(`q: ${notes.q}`);
  if(notes.s) ev.push(`s: ${notes.s}`);
  if(notes.p) ev.push(`p: ${notes.p}`);
  if(notes.r) ev.push(`r: ${notes.r}`);
  if(notes.c) ev.push(`c: ${notes.c}`);
  if(ev.length) parts.push(`Evidence: ${ev.join(" | ")}`);

  parts.push(`This model is deliberately conservative: upside comes from more leads, better close rates, and capacity expansion ‚Äî not inflated assumptions.`);

  return parts.join(" ");
}

/* ---------- Render ---------- */
function render(){
  const m = computeModel();

  // update audit value cells
  $("qValCell").textContent = m.q.toFixed(2);
  $("sValCell").textContent = m.s.toFixed(2);
  $("pValCell").textContent = m.p.toFixed(2);
  $("rValCell").textContent = m.r.toFixed(2);
  $("cValCell").textContent = m.churnPct.toFixed(1) + "%";

  // KPIs
  $("revMonth").textContent = fmtMoney(m.revMonth);
  $("revYear").textContent = fmtMoney(m.revYear);
  $("newMrr").textContent = fmtMoney(m.newMrr);
  $("mrrEnd").textContent = fmtMoney(m.mrrEnd);
  $("mrrEndSub").textContent = `MRR after churn @ ${m.months} months`;

  // volumes
  $("volumesBox").innerHTML =
    `Qualified: ${m.qualified.toFixed(2)}<br/>` +
    `Sprints: ${m.sprints.toFixed(2)} (raw ${m.sprintsRaw.toFixed(2)})<br/>` +
    `Pilots: ${m.pilots.toFixed(2)} (raw ${m.pilotsRaw.toFixed(2)})<br/>` +
    `New retainers: ${m.newRetainers.toFixed(2)}`;

  // MRR accumulation snapshot
  $("mrrBox").innerHTML =
    `Starting: ${fmtMoney(m.M0)}<br/>` +
    `MRR @ 3 months: ${fmtMoney(m.mrr3)}<br/>` +
    `MRR @ 6 months: ${fmtMoney(m.mrr6)}<br/>` +
    `MRR @ 12 months: ${fmtMoney(m.mrr12)}`;

  // sensitivity
  buildSensitivity(m);

  // board summary
  const summary = buildBoardSummary(m);
  $("boardSummary").value = summary;

  // status pill
  $("statusPill").textContent = "Live";
}

/* ---------- One-pager + Print ---------- */
function toggleView(){
  document.body.classList.toggle("onepager");
}
function printOnePager(){
  // ensure onepager layout for print, but restore after
  const was = document.body.classList.contains("onepager");
  if(!was) document.body.classList.add("onepager");
  window.print();
  if(!was) document.body.classList.remove("onepager");
}

/* ---------- Copy summary ---------- */
async function copySummary(){
  const text = $("boardSummary").value || "";
  try{
    await navigator.clipboard.writeText(text);
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }catch(e){
    // fallback
    $("boardSummary").select();
    document.execCommand("copy");
    $("statusPill").textContent = "Copied";
    setTimeout(()=>$("statusPill").textContent = "Live", 800);
  }
}

/* ---------- Reset ---------- */
function resetBase(){
  $("preset").value = "base";
  applyPreset();
  $("currency").value = "¬£";
  $("months").value = 12;
  $("Smax").value = 6;
  $("Pmax").value = 3;
  $("M0").value = 0;
  $("churn").value = 3;
  $("cost").value = 200;
  $("capNotes").value = "";

  // audit defaults
  ["qConf","sConf","pConf","rConf","cConf"].forEach(id=>{ if($(id)) $(id).value="Med"; });
  ["qNote","sNote","pNote","rNote","cNote"].forEach(id=>{ if($(id)) $(id).value=""; });

  render();
}

/* ---------- Bulletproof wiring ---------- */
function attachListeners(){
  document.querySelectorAll("input, select, textarea").forEach(el=>{
    const handler = ()=>{
      if(el.id === "preset"){ applyPreset(); }
      render();
    };
    el.addEventListener("input", handler);
    el.addEventListener("change", handler);
  });

  $("toggleViewBtn").addEventListener("click", toggleView);
  $("printBtn").addEventListener("click", printOnePager);
  $("copySummaryBtn").addEventListener("click", copySummary);
  $("resetBtn").addEventListener("click", resetBase);
}

applyPreset();
attachListeners();
render();


// --- nasa_rw3/NASA_RW3_report.html ---

function parseCSV(text){
  const lines = text.trim().split(/\r?\n/);
  const hdr = lines[0].split(",");
  const rows = [];
  for(let i=1;i<lines.length;i++){
    const parts = lines[i].split(",");
    const obj = {};
    for(let j=0;j<hdr.length;j++) obj[hdr[j]] = parts[j];
    rows.push(obj);
  }
  return rows;
}

function drawLineChart(canvas, seriesByName){
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;

  ctx.clearRect(0,0,w,h);

  // gather bounds
  let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
  for(const name in seriesByName){
    for(const p of seriesByName[name]){
      xmin=Math.min(xmin,p.x); xmax=Math.max(xmax,p.x);
      ymin=Math.min(ymin,p.y); ymax=Math.max(ymax,p.y);
    }
  }
  if(!isFinite(xmin)) return;
  const pad = 28*devicePixelRatio;
  const X = x => pad + (x-xmin) * (w-2*pad) / ((xmax-xmin)||1);
  const Y = y => h-pad - (y-ymin) * (h-2*pad) / ((ymax-ymin)||1);

  // grid
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = "rgba(0,140,255,.35)";
  ctx.lineWidth = 1*devicePixelRatio;
  for(let i=0;i<5;i++){
    const gx = pad + i*(w-2*pad)/4;
    const gy = pad + i*(h-2*pad)/4;
    ctx.beginPath(); ctx.moveTo(gx,pad); ctx.lineTo(gx,h-pad); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(pad,gy); ctx.lineTo(w-pad,gy); ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // axes labels
  ctx.fillStyle = "rgba(233,247,255,.7)";
  ctx.font = `${12*devicePixelRatio}px system-ui`;
  ctx.fillText(`x: checkpoint`, pad, h-10*devicePixelRatio);
  ctx.save();
  ctx.translate(10*devicePixelRatio, h/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(`y: Ah`, 0, 0);
  ctx.restore();

  // lines
  const colors = {
    RW1:"rgba(0,255,200,.95)",
    RW2:"rgba(0,180,255,.95)",
    RW7:"rgba(170,120,255,.95)",
    RW8:"rgba(255,120,180,.95)"
  };

  for(const name in seriesByName){
    const pts = seriesByName[name].slice().sort((a,b)=>a.x-b.x);
    ctx.strokeStyle = colors[name] || "rgba(120,255,220,.9)";
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.beginPath();
    pts.forEach((p,idx)=>{
      const x=X(p.x), y=Y(p.y);
      if(idx===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();

    // dots
    ctx.fillStyle = ctx.strokeStyle;
    for(const p of pts){
      const x=X(p.x), y=Y(p.y);
      ctx.beginPath(); ctx.arc(x,y,2.5*devicePixelRatio,0,Math.PI*2); ctx.fill();
    }
  }
}

function drawScatter(canvas, pts){
  const ctx = canvas.getContext("2d");
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
  for(const p of pts){
    xmin=Math.min(xmin,p.x); xmax=Math.max(xmax,p.x);
    ymin=Math.min(ymin,p.y); ymax=Math.max(ymax,p.y);
  }
  const pad=28*devicePixelRatio;
  const X = x => pad + (x-xmin) * (w-2*pad) / ((xmax-xmin)||1);
  const Y = y => h-pad - (y-ymin) * (h-2*pad) / ((ymax-ymin)||1);

  // grid
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = "rgba(0,140,255,.35)";
  ctx.lineWidth = 1*devicePixelRatio;
  for(let i=0;i<5;i++){
    const gx = pad + i*(w-2*pad)/4;
    const gy = pad + i*(h-2*pad)/4;
    ctx.beginPath(); ctx.moveTo(gx,pad); ctx.lineTo(gx,h-pad); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(pad,gy); ctx.lineTo(w-pad,gy); ctx.stroke();
  }
  ctx.globalAlpha = 1;

  ctx.fillStyle = "rgba(233,247,255,.7)";
  ctx.font = `${12*devicePixelRatio}px system-ui`;
  ctx.fillText(`x: rw_Ah`, pad, h-10*devicePixelRatio);
  ctx.save();
  ctx.translate(10*devicePixelRatio, h/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(`y: Ah_drop`, 0, 0);
  ctx.restore();

  ctx.fillStyle = "rgba(0,255,200,.65)";
  for(const p of pts){
    const x=X(p.x), y=Y(p.y);
    ctx.beginPath(); ctx.arc(x,y,2.2*devicePixelRatio,0,Math.PI*2); ctx.fill();
  }
}

async function main(){
  const [modelTxt, anchTxt] = await Promise.all([
    fetch("NASA_RW3_model_table_cidx.csv").then(r=>r.text()),
    fetch("NASA_RW3_anchors_plot.csv").then(r=>r.text())
  ]);

  const model = parseCSV(modelTxt);
  const anchors = parseCSV(anchTxt);

  // pills (quick stats)
  const n = model.length;
  const sumDrop = model.reduce((a,r)=>a + (+r.Ah_drop||0), 0);
  const sumAh = model.reduce((a,r)=>a + (+r.rw_Ah||0), 0);
  const sumHi = model.reduce((a,r)=>a + (+r.highA_s||0), 0);

  const pills = document.getElementById("pills");
  const mk = (t)=>{const s=document.createElement("div"); s.className="pill"; s.textContent=t; return s;};
  pills.appendChild(mk(`blocks: ${n}`));
  pills.appendChild(mk(`Œ£ Ah_drop: ${sumDrop.toFixed(3)}`));
  pills.appendChild(mk(`Œ£ rw_Ah: ${sumAh.toFixed(1)}`));
  pills.appendChild(mk(`Œ£ highA_s: ${sumHi.toFixed(0)} s`));

  // anchor chart
  const series = {};
  for(const r of anchors){
    const cell=r.cell;
    if(!series[cell]) series[cell]=[];
    series[cell].push({x:+r.cidx, y:+r.Ah});
  }
  drawLineChart(document.getElementById("cAnch"), series);

  // scatter
  const scat = model.map(r=>({x:+r.rw_Ah, y:+r.Ah_drop}));
  drawScatter(document.getElementById("cScat"), scat);

  // top table by rw_Ah
  const top = model.slice().sort((a,b)=>(+b.rw_Ah)-(+a.rw_Ah)).slice(0,12);
  const tb = document.querySelector("#topTable tbody");
  tb.innerHTML="";
  for(const r of top){
    const tr=document.createElement("tr");
    tr.innerHTML = `<td>${r.cell}</td><td>${r.block_id}</td><td>${(+r.rw_Ah).toFixed(3)}</td><td>${(+r.rw_Wh).toFixed(3)}</td><td>${r.rw_D_steps}</td><td>${(+r.highA_s).toFixed(0)}</td>`;
    tb.appendChild(tr);
  }

  window.addEventListener("resize", ()=>{
    drawLineChart(document.getElementById("cAnch"), series);
    drawScatter(document.getElementById("cScat"), scat);
  });
}

main().catch(e=>alert(e));
