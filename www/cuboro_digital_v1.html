<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Î© Cuboro-Style Marble Run v1</title>
<style>
  :root{
    --bg1:#05060b;
    --bg2:#0b0f1e;
    --panel: rgba(255,255,255,0.06);
    --panel-2: rgba(255,255,255,0.09);
    --stroke: rgba(255,255,255,0.08);
    --glow: rgba(120,180,255,0.25);
    --accent:#8fd3ff;
    --accent2:#d6a8ff;
    --wood1:#c8b28a;
    --wood2:#b4986d;
    --wood3:#9c7b52;
    --track:#1b2238;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background: radial-gradient(1200px 800px at 70% 10%, #10152e 0%, transparent 45%),
                radial-gradient(900px 900px at 20% 80%, #0b1a2e 0%, transparent 40%),
                linear-gradient(160deg, var(--bg1), var(--bg2));
    color:#eaf2ff;
    height:100vh;
    overflow:hidden;
  }

  .hud{
    position:fixed;
    top:10px; left:10px; right:10px;
    display:flex;
    gap:10px;
    align-items:stretch;
    z-index:5;
  }
  .card{
    background: linear-gradient(180deg, var(--panel), transparent 120%),
                var(--panel-2);
    border:1px solid var(--stroke);
    border-radius:16px;
    padding:10px 12px;
    backdrop-filter: blur(10px);
    box-shadow: 0 8px 24px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.02);
    min-width:0;
  }
  .card h3{
    margin:0 0 4px 0;
    font-size:12px;
    font-weight:600;
    opacity:0.8;
    letter-spacing:0.4px;
  }
  .big{
    font-size:20px;
    font-weight:700;
    line-height:1.1;
  }
  .sub{
    font-size:11px;
    opacity:0.7;
  }

  .spacer{flex:1;}

  .btn{
    appearance:none;
    border:1px solid rgba(255,255,255,0.10);
    background: linear-gradient(135deg, rgba(143,211,255,0.12), rgba(214,168,255,0.10));
    color:#ecf6ff;
    padding:10px 12px;
    border-radius:12px;
    font-weight:650;
    font-size:12px;
    letter-spacing:0.3px;
    cursor:pointer;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
  }
  .btn:active{transform: translateY(1px) scale(0.99);}
  .btn.primary{
    border-color: rgba(143,211,255,0.35);
    background: linear-gradient(135deg, rgba(143,211,255,0.22), rgba(214,168,255,0.18));
  }
  .btn.warn{
    border-color: rgba(255,120,120,0.35);
    background: linear-gradient(135deg, rgba(255,120,120,0.18), rgba(255,180,120,0.12));
  }

  .palette{
    display:flex;
    gap:6px;
    flex-wrap:wrap;
  }
  .chip{
    border:1px solid rgba(255,255,255,0.10);
    background: rgba(255,255,255,0.05);
    padding:6px 8px;
    border-radius:10px;
    font-size:11px;
    font-weight:600;
    opacity:0.9;
  }
  .chip.active{
    border-color: rgba(143,211,255,0.45);
    background: rgba(143,211,255,0.12);
    box-shadow: 0 0 0 1px rgba(143,211,255,0.12);
  }

  .bottom{
    position:fixed;
    left:10px; right:10px; bottom:10px;
    display:flex;
    gap:10px;
    z-index:5;
  }

  .hint{
    font-size:11px;
    opacity:0.7;
  }

  canvas{
    position:fixed;
    inset:0;
    width:100vw;
    height:100vh;
    z-index:1;
  }

  .badge{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    font-size:10px;
    font-weight:700;
    border:1px solid rgba(255,255,255,0.10);
    background: rgba(255,255,255,0.05);
  }

</style>
</head>
<body>

<canvas id="cv"></canvas>

<div class="hud" id="hud">
  <div class="card" style="width:32%;">
    <h3>SCORE</h3>
    <div class="big" id="score">0</div>
    <div class="sub">Best: <span id="best">0</span></div>
  </div>

  <div class="card" style="width:36%;">
    <h3>MODE</h3>
    <div class="big">Cuboro-ish</div>
    <div class="sub"><span class="badge">Tap place</span> <span class="badge">Tap rotate</span></div>
  </div>

  <div class="card" style="width:32%; display:flex; flex-direction:column; gap:8px;">
    <button class="btn primary" id="runBtn">RUN</button>
    <button class="btn" id="stopBtn">PAUSE</button>
  </div>
</div>

<div class="bottom" id="bottom">
  <div class="card" style="flex:1;">
    <h3>PALETTE</h3>
    <div class="palette" id="palette"></div>
    <div class="hint">Selected piece is placed on tap. Tapping an existing piece rotates it. ðŸ¥ƒ</div>
  </div>

  <div class="card" style="width:35%;">
    <h3>CONTROL</h3>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button class="btn" id="clearBtn">CLEAR GRID</button>
      <button class="btn" id="randomBtn">RANDOM BUILD</button>
      <button class="btn warn" id="resetScoreBtn">RESET SCORE</button>
      <button class="btn" id="hudToggleBtn">HUD: ON</button>
    </div>
    <div class="hint" style="margin-top:6px;">
      v1 uses stable path logic (not heavy physics).  
      Next upgrade: multi-level + tunnels + gates.
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  // ---------------------------
  // Canvas + resize
  // ---------------------------
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  let W=0,H=0,DPR=1;

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    cv.width = Math.floor(W * DPR);
    cv.height = Math.floor(H * DPR);
    cv.style.width = W+"px";
    cv.style.height = H+"px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener("resize", resize, {passive:true});
  resize();

  // ---------------------------
  // Grid + pieces
  // ---------------------------
  // Directions: 0=Up, 1=Right, 2=Down, 3=Left
  const DIRS = [
    {x:0,y:-1},
    {x:1,y:0},
    {x:0,y:1},
    {x:-1,y:0},
  ];

  // Piece types
  const PIECES = {
    empty: {name:"Empty", rot:1, color:"#ffffff00"},
    start: {name:"Start", rot:4, color:"#a8ffda"},
    straight: {name:"Straight", rot:2, color:"#8fd3ff"},
    turn: {name:"Turn", rot:4, color:"#d6a8ff"},
    bowl: {name:"Bowl", rot:1, color:"#ffe1a8"},
    block: {name:"Block", rot:1, color:"#aaaaaa"},
  };

  const paletteOrder = ["start","straight","turn","bowl","block","empty"];
  let selected = "straight";

  // Grid size chosen for phones
  const COLS = 8;
  const ROWS = 12;

  // cell sizing based on safe vertical area
  function cellSize(){
    const topPad = 120;   // approx HUD height
    const botPad = 170;   // approx bottom controls
    const usableH = Math.max(260, H - topPad - botPad);
    const sizeByH = Math.floor(usableH / ROWS);
    const sizeByW = Math.floor((W - 20) / COLS);
    return Math.max(34, Math.min(64, Math.min(sizeByH, sizeByW)));
  }

  let CELL = cellSize();
  function recalcCell(){
    CELL = cellSize();
  }
  window.addEventListener("resize", recalcCell, {passive:true});

  function gridOrigin(){
    // center grid between HUD and bottom panel
    const topPad = 110;
    const botPad = 160;
    const gridW = COLS * CELL;
    const gridH = ROWS * CELL;
    const x = Math.floor((W - gridW) / 2);
    const y = Math.floor(topPad + (Math.max(0, (H - topPad - botPad - gridH)/2)));
    return {x,y,gridW,gridH};
  }

  // Each cell: {type, rot}
  let grid = [];
  function makeEmptyGrid(){
    grid = new Array(ROWS).fill(0).map(()=>(
      new Array(COLS).fill(0).map(()=>({type:"empty", rot:0}))
    ));
  }
  makeEmptyGrid();

  // ---------------------------
  // Path logic
  // ---------------------------
  // For each piece type + rotation:
  // given an incoming dir, return outgoing dir or null.
  // We also allow "start" to emit in its facing direction (no incoming needed).
  function straightMap(rot, incoming){
    // rot 0/2 => vertical; rot 1/3 => horizontal
    const vertical = (rot % 2 === 0);
    if(vertical){
      if(incoming === 0) return 2;
      if(incoming === 2) return 0;
    }else{
      if(incoming === 1) return 3;
      if(incoming === 3) return 1;
    }
    return null;
  }

  function turnMap(rot, incoming){
    // rot defines which corner is open:
    // rot 0: connects Up<->Right
    // rot 1: Right<->Down
    // rot 2: Down<->Left
    // rot 3: Left<->Up
    if(rot===0){
      if(incoming===0) return 1;
      if(incoming===1) return 0;
    }else if(rot===1){
      if(incoming===1) return 2;
      if(incoming===2) return 1;
    }else if(rot===2){
      if(incoming===2) return 3;
      if(incoming===3) return 2;
    }else if(rot===3){
      if(incoming===3) return 0;
      if(incoming===0) return 3;
    }
    return null;
  }

  function pieceExit(type, rot, incoming){
    switch(type){
      case "straight": return straightMap(rot, incoming);
      case "turn": return turnMap(rot, incoming);
      case "bowl":
        // bowl accepts any incoming and "consumes" marble
        return "BOWL";
      case "block":
      case "empty":
      case "start":
      default:
        return null;
    }
  }

  function startDir(rot){
    // rot 0=Up,1=Right,2=Down,3=Left
    return rot % 4;
  }

  // ---------------------------
  // Marbles
  // ---------------------------
  let marbles = [];
  let running = false;
  let score = 0;
  let best = 0;

  try{
    best = parseInt(localStorage.getItem("CUBORO_BEST")||"0",10) || 0;
  }catch(e){}

  const scoreEl = document.getElementById("score");
  const bestEl = document.getElementById("best");
  bestEl.textContent = best;

  function setScore(v){
    score = v;
    scoreEl.textContent = score;
    if(score > best){
      best = score;
      bestEl.textContent = best;
      try{ localStorage.setItem("CUBORO_BEST", String(best)); }catch(e){}
    }
  }

  function resetScore(){
    setScore(0);
  }

  function spawnFromStarts(){
    marbles.length = 0;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = grid[r][c];
        if(cell.type==="start"){
          const dir = startDir(cell.rot);
          const {x,y} = cellCenterPx(r,c);
          marbles.push({
            r, c,
            x, y,
            dir,
            t:0,
            speed: 1.0 + Math.random()*0.2,
            alive:true,
            hue: 180 + Math.random()*120,
            radius: Math.max(6, Math.floor(CELL*0.18))
          });
        }
      }
    }
  }

  function cellCenterPx(r,c){
    const {x:ox,y:oy} = gridOrigin();
    return {
      x: ox + c*CELL + CELL/2,
      y: oy + r*CELL + CELL/2
    };
  }

  function nextCell(r,c,dir){
    const d = DIRS[dir];
    return {nr: r + d.y, nc: c + d.x};
  }

  function inBounds(r,c){
    return r>=0 && r<ROWS && c>=0 && c<COLS;
  }

  // Step marble along graph from cell to cell with interpolation
  function updateMarbles(dt){
    if(!running) return;

    const stepSpeed = 2.6; // cells per second-ish
    for(const m of marbles){
      if(!m.alive) continue;

      m.t += dt * stepSpeed * m.speed;

      // When t>=1, attempt to move to next cell
      while(m.t >= 1 && m.alive){
        m.t -= 1;

        const cell = grid[m.r][m.c];

        // Determine outgoing dir depending on piece type
        if(cell.type === "start"){
          // start just pushes marble forward
          const out = startDir(cell.rot);
          m.dir = out;
        }else{
          const out = pieceExit(cell.type, cell.rot, m.dir);
          if(out === "BOWL"){
            // scored!
            m.alive = false;
            setScore(score + 10);
            continue;
          }
          if(out === null){
            // dead end
            m.alive = false;
            continue;
          }
          m.dir = out;
        }

        const {nr,nc} = nextCell(m.r, m.c, m.dir);
        if(!inBounds(nr,nc)){
          m.alive = false;
          continue;
        }

        // If next cell is empty or block, the marble will still enter it,
        // but likely die on next step unless it's a start/track/bowl
        m.r = nr; m.c = nc;
      }

      // Interpolate position within current cell towards next
      const cur = cellCenterPx(m.r,m.c);
      let nx = cur.x, ny = cur.y;

      if(m.alive){
        const {nr,nc} = nextCell(m.r,m.c, m.dir);
        if(inBounds(nr,nc)){
          const nxt = cellCenterPx(nr,nc);
          nx = cur.x + (nxt.x-cur.x)*m.t;
          ny = cur.y + (nxt.y-cur.y)*m.t;
        }
      }
      m.x = nx; m.y = ny;
    }
  }

  // ---------------------------
  // Drawing (wood block look)
  // ---------------------------
  function drawBackground(){
    ctx.clearRect(0,0,W,H);

    // subtle starfield
    const n = 60;
    for(let i=0;i<n;i++){
      const x = (i*97 % 1000)/1000 * W;
      const y = (i*151 % 1000)/1000 * H;
      const a = 0.06 + ((i*13)%10)/200;
      ctx.fillStyle = `rgba(180,210,255,${a})`;
      ctx.fillRect(x,y,1.2,1.2);
    }
  }

  function woodFill(x,y,w,h){
    // layered gradients to fake wood
    const g = ctx.createLinearGradient(x,y,x+w,y+h);
    g.addColorStop(0, "rgba(200,178,138,0.95)");
    g.addColorStop(0.5, "rgba(180,155,106,0.95)");
    g.addColorStop(1, "rgba(156,123,82,0.95)");
    ctx.fillStyle = g;
    ctx.fillRect(x,y,w,h);

    // soft grain lines
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = "#3b2a18";
    ctx.lineWidth = 1;
    for(let i=0;i<4;i++){
      const yy = y + (i+1)*h/5;
      ctx.beginPath();
      ctx.moveTo(x+4, yy);
      ctx.quadraticCurveTo(x+w*0.45, yy-2, x+w-4, yy+1);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawCell(r,c){
    const {x:ox,y:oy} = gridOrigin();
    const x = ox + c*CELL;
    const y = oy + r*CELL;
    const cell = grid[r][c];

    // base block
    ctx.save();
    ctx.shadowColor = "rgba(0,0,0,0.35)";
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 3;
    woodFill(x+1,y+1,CELL-2,CELL-2);
    ctx.restore();

    // bevel
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    ctx.strokeRect(x+1.5,y+1.5,CELL-3,CELL-3);

    // track overlay depending on type
    if(cell.type==="empty") return;

    // Track bed
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(10,14,30,0.28)";
    ctx.fillRect(x+6,y+6,CELL-12,CELL-12);
    ctx.restore();

    // draw path
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    const thick = Math.max(6, Math.floor(CELL*0.16));
    const inner = Math.max(3, Math.floor(thick*0.45));

    function strokePath(drawFn, glowCol){
      ctx.save();
      ctx.shadowColor = glowCol;
      ctx.shadowBlur = 12;
      ctx.strokeStyle = "rgba(120,180,255,0.25)";
      ctx.lineWidth = thick + 4;
      ctx.beginPath(); drawFn(); ctx.stroke();
      ctx.restore();

      ctx.strokeStyle = "rgba(20,30,60,0.9)";
      ctx.lineWidth = thick;
      ctx.beginPath(); drawFn(); ctx.stroke();

      ctx.strokeStyle = "rgba(200,230,255,0.25)";
      ctx.lineWidth = inner;
      ctx.beginPath(); drawFn(); ctx.stroke();
    }

    const cx = x + CELL/2;
    const cy = y + CELL/2;
    const pad = CELL*0.28;

    const rot = cell.rot % (PIECES[cell.type]?.rot || 1);

    if(cell.type==="straight"){
      const vertical = (rot % 2 === 0);
      strokePath(() => {
        if(vertical){
          ctx.moveTo(cx, y+pad);
          ctx.lineTo(cx, y+CELL-pad);
        }else{
          ctx.moveTo(x+pad, cy);
          ctx.lineTo(x+CELL-pad, cy);
        }
      }, "rgba(143,211,255,0.25)");

    }else if(cell.type==="turn"){
      strokePath(() => {
        // corners based on rot mapping used in turnMap
        if(rot===0){
          ctx.moveTo(cx, y+pad);
          ctx.lineTo(cx, cy);
          ctx.lineTo(x+CELL-pad, cy);
        }else if(rot===1){
          ctx.moveTo(x+CELL-pad, cy);
          ctx.lineTo(cx, cy);
          ctx.lineTo(cx, y+CELL-pad);
        }else if(rot===2){
          ctx.moveTo(cx, y+CELL-pad);
          ctx.lineTo(cx, cy);
          ctx.lineTo(x+pad, cy);
        }else{
          ctx.moveTo(x+pad, cy);
          ctx.lineTo(cx, cy);
          ctx.lineTo(cx, y+pad);
        }
      }, "rgba(214,168,255,0.25)");

    }else if(cell.type==="start"){
      // arrow-like emitter groove
      const dir = startDir(rot);
      strokePath(() => {
        ctx.moveTo(cx, cy);
        const dx = DIRS[dir].x, dy = DIRS[dir].y;
        ctx.lineTo(cx + dx*(CELL*0.28), cy + dy*(CELL*0.28));
      }, "rgba(168,255,218,0.28)");

      // small "source hole"
      ctx.save();
      ctx.fillStyle = "rgba(10,14,30,0.65)";
      ctx.beginPath();
      ctx.arc(cx, cy, CELL*0.12, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

    }else if(cell.type==="bowl"){
      // circular pocket/goal
      ctx.save();
      ctx.shadowColor = "rgba(255,225,168,0.25)";
      ctx.shadowBlur = 16;
      ctx.fillStyle = "rgba(10,14,30,0.75)";
      ctx.beginPath();
      ctx.arc(cx, cy, CELL*0.22, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      ctx.strokeStyle = "rgba(255,225,168,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, CELL*0.24, 0, Math.PI*2);
      ctx.stroke();

    }else if(cell.type==="block"){
      // a "nope" mark
      ctx.save();
      ctx.strokeStyle = "rgba(255,120,120,0.45)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x+CELL*0.25,y+CELL*0.25);
      ctx.lineTo(x+CELL*0.75,y+CELL*0.75);
      ctx.moveTo(x+CELL*0.75,y+CELL*0.25);
      ctx.lineTo(x+CELL*0.25,y+CELL*0.75);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawGrid(){
    const {x:ox,y:oy,gridW,gridH} = gridOrigin();

    // subtle outer glow
    ctx.save();
    ctx.strokeStyle = "rgba(143,211,255,0.08)";
    ctx.lineWidth = 2;
    ctx.strokeRect(ox-2, oy-2, gridW+4, gridH+4);
    ctx.restore();

    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        drawCell(r,c);
      }
    }

    // grid lines faint
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = "#b9d7ff";
    ctx.lineWidth = 1;
    for(let i=1;i<COLS;i++){
      const x = ox + i*CELL;
      ctx.beginPath(); ctx.moveTo(x, oy); ctx.lineTo(x, oy+gridH); ctx.stroke();
    }
    for(let i=1;i<ROWS;i++){
      const y = oy + i*CELL;
      ctx.beginPath(); ctx.moveTo(ox, y); ctx.lineTo(ox+gridW, y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawMarbles(){
    for(const m of marbles){
      if(!m.alive) continue;
      ctx.save();
      const r = m.radius;

      const g = ctx.createRadialGradient(m.x-r*0.4, m.y-r*0.4, r*0.2, m.x, m.y, r*1.2);
      g.addColorStop(0, `hsla(${m.hue}, 90%, 75%, 0.95)`);
      g.addColorStop(1, `hsla(${m.hue}, 70%, 45%, 0.95)`);

      ctx.shadowColor = `hsla(${m.hue}, 90%, 70%, 0.25)`;
      ctx.shadowBlur = 14;
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(m.x, m.y, r, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(m.x - r*0.25, m.y - r*0.25, r*0.35, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }
  }

  function render(){
    drawBackground();
    drawGrid();
    drawMarbles();
  }

  // ---------------------------
  // Input handling
  // ---------------------------
  function screenToCell(px,py){
    const {x:ox,y:oy} = gridOrigin();
    const gx = px - ox;
    const gy = py - oy;
    if(gx<0 || gy<0) return null;
    const c = Math.floor(gx / CELL);
    const r = Math.floor(gy / CELL);
    if(r<0 || r>=ROWS || c<0 || c>=COLS) return null;
    return {r,c};
  }

  function placeOrRotate(r,c){
    const cell = grid[r][c];
    if(cell.type === selected){
      // rotate
      const maxRot = PIECES[cell.type]?.rot || 1;
      if(maxRot>1) cell.rot = (cell.rot + 1) % maxRot;
    }else{
      // place new
      cell.type = selected;
      cell.rot = 0;
    }
  }

  let lastTapTime = 0;

  function handleTap(x,y){
    const hit = screenToCell(x,y);
    if(!hit) return;

    // basic tap debounce
    const now = performance.now();
    if(now - lastTapTime < 40) return;
    lastTapTime = now;

    placeOrRotate(hit.r, hit.c);
    render();
  }

  function pointerXY(ev){
    if(ev.touches && ev.touches.length){
      return {x: ev.touches[0].clientX, y: ev.touches[0].clientY};
    }
    return {x: ev.clientX, y: ev.clientY};
  }

  function onPointerDown(ev){
    ev.preventDefault();
    const {x,y} = pointerXY(ev);
    handleTap(x,y);
  }

  cv.addEventListener("pointerdown", onPointerDown);
  cv.addEventListener("touchstart", onPointerDown, {passive:false});

  // ---------------------------
  // UI
  // ---------------------------
  const paletteEl = document.getElementById("palette");
  function rebuildPalette(){
    paletteEl.innerHTML = "";
    for(const key of paletteOrder){
      const btn = document.createElement("button");
      btn.className = "chip" + (key===selected ? " active":"");
      btn.textContent = PIECES[key].name;
      btn.addEventListener("click", () => {
        selected = key;
        rebuildPalette();
      });
      paletteEl.appendChild(btn);
    }
  }
  rebuildPalette();

  const runBtn = document.getElementById("runBtn");
  const stopBtn = document.getElementById("stopBtn");
  const clearBtn = document.getElementById("clearBtn");
  const randomBtn = document.getElementById("randomBtn");
  const resetScoreBtn = document.getElementById("resetScoreBtn");
  const hudToggleBtn = document.getElementById("hudToggleBtn");
  const hud = document.getElementById("hud");
  const bottom = document.getElementById("bottom");

  runBtn.addEventListener("click", () => {
    spawnFromStarts();
    running = true;
  });
  stopBtn.addEventListener("click", () => {
    running = !running;
    stopBtn.textContent = running ? "PAUSE" : "RESUME";
  });

  clearBtn.addEventListener("click", () => {
    makeEmptyGrid();
    marbles.length = 0;
    running = false;
    stopBtn.textContent = "PAUSE";
    render();
  });

  function randomBuild(){
    makeEmptyGrid();
    // sprinkle tracks
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const roll = Math.random();
        if(roll < 0.12){
          grid[r][c].type = "turn";
          grid[r][c].rot = Math.floor(Math.random()*4);
        }else if(roll < 0.26){
          grid[r][c].type = "straight";
          grid[r][c].rot = Math.floor(Math.random()*2);
        }
      }
    }
    // add a couple starts near top
    for(let i=0;i<2;i++){
      const c = Math.floor(Math.random()*COLS);
      grid[0][c].type = "start";
      grid[0][c].rot = 2; // down
    }
    // add a bowl near bottom
    const bc = Math.floor(Math.random()*COLS);
    grid[ROWS-1][bc].type = "bowl";
    grid[ROWS-1][bc].rot = 0;

    marbles.length = 0;
    running = false;
    stopBtn.textContent = "PAUSE";
  }

  randomBtn.addEventListener("click", () => {
    randomBuild();
    render();
  });

  resetScoreBtn.addEventListener("click", () => resetScore());

  let hudOn = true;
  function setHud(on){
    hudOn = on;
    hud.style.display = on ? "flex" : "none";
    bottom.style.display = on ? "flex" : "none";
    hudToggleBtn.textContent = on ? "HUD: ON" : "HUD: OFF";
  }
  hudToggleBtn.addEventListener("click", () => setHud(!hudOn));

  // ---------------------------
  // Main loop
  // ---------------------------
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    updateMarbles(dt);
    render();

    requestAnimationFrame(loop);
  }

  // initial scene
  randomBuild();
  render();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
