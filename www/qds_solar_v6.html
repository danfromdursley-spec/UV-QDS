<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Solar System V6 â€” QDS Gravity Mesh + Full Planet Physics</title>
<style>
  html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #000; }
  #renderCanvas { width: 100%; height: 100%; }
  #toolbar {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px;
      color: #fff; font-family: Arial; font-size: 14px;
  }
</style>
</head>
<body>

<div id="toolbar">
  <b>Solar System V6</b><br>
  <button onclick="fireCME()">ðŸ’¥ Fire CME</button>
  <button onclick="museumMode()">ðŸŽ¨ Museum Mode</button><br>
  QDS Î»c: <input id="lc" type="range" min="0" max="2" step="0.01" value="0.28"><br>
  QDS Ï„c: <input id="tc" type="range" min="0" max="2" step="0.01" value="0.35"><br>
</div>

<canvas id="renderCanvas"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
<script>

// ------------------------------------------------------------
// INITIAL SETUP
// ------------------------------------------------------------
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer: true, stencil: true});
let scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

// Camera
const camera = new BABYLON.ArcRotateCamera("cam", Math.PI/2, 1.0, 300, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 80;
camera.upperRadiusLimit = 500;

// Lights
const light = new BABYLON.PointLight("sunlight", new BABYLON.Vector3(0,0,0), scene);
light.intensity = 2;

// ------------------------------------------------------------
// SUN
// ------------------------------------------------------------
const sun = BABYLON.MeshBuilder.CreateSphere("sun", {diameter: 20}, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveColor = new BABYLON.Color3(1,0.7,0.2);
sun.material = sunMat;

// ------------------------------------------------------------
// PLANETS (positions simplified for demo; tilts added)
// ------------------------------------------------------------
const planets = [
  { name:"Mercury", r: 40, size: 2, speed: 0.018 },
  { name:"Venus",   r: 55, size: 4, speed: 0.013, tilt:177 },
  { name:"Earth",   r: 70, size: 4.5, speed: 0.010, tilt:23.4, moon:true },
  { name:"Mars",    r: 85, size: 3.2, speed: 0.008 },
  { name:"Jupiter", r:120, size:12, speed: 0.004 },
  { name:"Saturn",  r:155, size:10, speed: 0.0035 },
  { name:"Uranus",  r:190, size:8, speed: 0.0025, tilt:97 },
  { name:"Neptune", r:230, size:8, speed: 0.002 }
];

planets.forEach(p => {
  p.mesh = BABYLON.MeshBuilder.CreateSphere(p.name, {diameter:p.size}, scene);
  p.mesh.position.x = p.r;
  let m = new BABYLON.StandardMaterial(p.name+"Mat", scene);
  m.diffuseColor = new BABYLON.Color3(0.3+Math.random()*0.7, Math.random()*0.8, Math.random()*0.8);
  p.mesh.material = m;

  if (p.tilt) p.mesh.rotation.z = p.tilt * Math.PI/180;
});

// Earthâ€“Moon system
let moon = BABYLON.MeshBuilder.CreateSphere("Moon", {diameter:1.5}, scene);
moon.material = new BABYLON.StandardMaterial("moonMat", scene);
moon.material.diffuseColor = new BABYLON.Color3(0.8,0.8,0.8);

// ------------------------------------------------------------
// ULTRA GRAVITY MESH (120Ã—120 grid) â€” Mode 1
// ------------------------------------------------------------
const GRID = 120;
const SIZE = 450;

let gravityMesh = BABYLON.MeshBuilder.CreateGround("gravityMesh", {
    width: SIZE, height: SIZE, subdivisions: GRID
}, scene);

let gmMat = new BABYLON.StandardMaterial("gmMat", scene);
gmMat.wireframe = true;
gmMat.emissiveColor = new BABYLON.Color3(0.1, 0.5, 1);
gravityMesh.material = gmMat;
gravityMesh.position.y = -40;

// Cache vertex data
let vdata = gravityMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
let positions = vdata.slice();
let originalPositions = vdata.slice();

// ------------------------------------------------------------
// CME + QDS fields
// ------------------------------------------------------------
let cmeWave = {r:0, active:false};
function fireCME(){
  cmeWave.r = 0;
  cmeWave.active = true;
}

// Museum Mode
function museumMode(){
  document.getElementById("toolbar").style.display = "none";
  camera.lowerRadiusLimit = 150;
  camera.upperRadiusLimit = 250;
  camera.alpha = 1.2;
  camera.beta = 1.1;
  camera.radius = 200;
}

// ------------------------------------------------------------
// MAIN LOOP
// ------------------------------------------------------------
scene.registerBeforeRender(() => {

  let t = performance.now() * 0.001;

  // Update planets
  planets.forEach((p,i)=>{
    let a = t * p.speed * 60;
    p.mesh.position.x = Math.cos(a) * p.r;
    p.mesh.position.z = Math.sin(a) * p.r;

    // Earthâ€“Moon
    if(p.name==="Earth"){
      let am = t * 0.04 * 60;
      moon.position.x = p.mesh.position.x + Math.cos(am) * 7;
      moon.position.z = p.mesh.position.z + Math.sin(am) * 7;
      moon.position.y = p.mesh.position.y;
    }
  });

  // CME expansion
  if(cmeWave.active){
    cmeWave.r += 2.5;
    if(cmeWave.r > SIZE*1.3) cmeWave.active = false;
  }

  // Gravity mesh deformation -------------------------------------------------
  for(let i=0;i<positions.length;i+=3){
    let x = positions[i];
    let z = positions[i+2];

    // Start from base plane
    let y = originalPositions[i+1];

    // Add planet gravity wells
    planets.forEach(p=>{
      let dx = x - p.mesh.position.x;
      let dz = z - p.mesh.position.z;
      let dist = Math.sqrt(dx*dx + dz*dz);

      if(dist < 60){
        y -= (50 / (dist + 5));   // gravity well
      }
    });

    // Earthâ€“Moon effect
    let dxm = x - moon.position.x;
    let dzm = z - moon.position.z;
    let distm = Math.sqrt(dxm*dxm + dzm*dzm);
    if(distm < 25){
      y -= (8 / (distm + 3));
    }

    // CME ripple
    if(cmeWave.active){
       let d = Math.sqrt(x*x + z*z);
       let wave = Math.sin((d - cmeWave.r)*0.15) * 3;
       if(Math.abs(d - cmeWave.r) < 30) y += wave;
    }

    // QDS stochastic wobble
    let q = Math.sin((x*0.05)+(t*2)) + Math.cos((z*0.05)-(t*1.7));
    let lc = parseFloat(document.getElementById("lc").value);
    let tc = parseFloat(document.getElementById("tc").value);
    y += q * lc * 0.8 * Math.exp(-tc * 2);

    positions[i+1] = y;
  }

  gravityMesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
});

// Render loop
engine.runRenderLoop(()=>scene.render());
window.addEventListener("resize", ()=>engine.resize());

</script>
</body>
</html>
