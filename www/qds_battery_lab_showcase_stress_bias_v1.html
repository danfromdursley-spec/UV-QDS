<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QDS Battery Lab â€” Showcase Stress + Bias v1</title>
<style>
:root{
  --bg:#070b14; --panel:#0d1424; --panel2:#0b1120;
  --text:#e7edf7; --muted:#9aa7bd; --accent:#5ad1c0; --danger:#d06b86;
  --outline:rgba(255,255,255,0.06);
  --radius:18px;
}
*{box-sizing:border-box}
body{
  margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--text); background:radial-gradient(1200px 800px at 20% 10%, #101a34 0%, var(--bg) 55%, #05070f 100%);
}
.wrap{max-width:980px; margin:0 auto; padding:16px 14px 60px}
.hero{
  background:linear-gradient(135deg, rgba(90,209,192,.08), rgba(208,107,134,.08));
  border:1px solid var(--outline); border-radius:24px; padding:20px 18px 18px;
  box-shadow:0 10px 30px rgba(0,0,0,.35);
}
.hero h1{margin:0 0 6px; font-size:28px; letter-spacing:.2px}
.hero p{margin:0; color:var(--muted); line-height:1.35}
.badges{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
.badge{
  padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.04);
  border:1px solid var(--outline); font-size:12px; color:var(--muted)
}

.grid{display:grid; gap:12px; margin-top:14px}
@media(min-width:860px){ .grid{grid-template-columns: 1fr 1.1fr} }

.panel{
  background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
  border:1px solid var(--outline); border-radius:var(--radius); padding:14px 14px 12px;
}
.panel-title{font-weight:650; font-size:16px; margin-bottom:10px}
.subtle{color:var(--muted); font-size:12px}

.control{
  background:var(--panel); border:1px solid var(--outline);
  border-radius:14px; padding:10px 10px 8px; margin-bottom:10px;
}
.control label{display:flex; justify-content:space-between; font-size:12px; color:var(--muted)}
.control input[type="range"]{width:100%}

.row{display:flex; gap:8px; flex-wrap:wrap}
.btn{
  background:rgba(255,255,255,.05); color:var(--text);
  border:1px solid var(--outline); padding:10px 12px; border-radius:14px;
  font-weight:600; font-size:12px; letter-spacing:.2px; cursor:pointer;
}
.btn:hover{border-color:rgba(255,255,255,.14)}
.btn.primary{background:linear-gradient(135deg, rgba(90,209,192,.18), rgba(90,209,192,.06)); border-color:rgba(90,209,192,.25)}
.btn.danger{background:linear-gradient(135deg, rgba(208,107,134,.18), rgba(208,107,134,.06)); border-color:rgba(208,107,134,.25)}

.checkbox-row{display:flex; align-items:center; gap:8px; font-size:12px; color:var(--muted); margin:6px 0}
hr.sep{border:none; border-top:1px solid var(--outline); margin:10px 0}

.results-grid{display:grid; grid-template-columns:1fr 1fr; gap:10px}
.card{
  background:var(--panel2); border:1px solid var(--outline); border-radius:14px;
  padding:12px 12px 10px;
}
.card .k{color:var(--muted); font-size:11px}
.card .v{font-size:26px; font-weight:750; margin-top:2px}

.flag{
  border:1px solid rgba(208,107,134,.35);
  background:rgba(208,107,134,.08);
  color:#ffd9e3; border-radius:12px; padding:10px; font-size:12px; line-height:1.35;
}

canvas{
  width:100%; height:220px; background:rgba(255,255,255,.02);
  border:1px solid var(--outline); border-radius:14px;
}

.history{
  max-height:210px; overflow:auto; padding-right:4px;
}
.hist-item{
  background:rgba(255,255,255,.035); border:1px solid var(--outline);
  border-radius:12px; padding:10px; margin-bottom:8px; font-size:11px; color:var(--muted);
  white-space:pre-wrap;
}
.small-note{font-size:11px; color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">

  <div class="hero">
    <h1>QDS Battery Lab â€” Showcase Stress + Bias ðŸ§ªðŸ”‹</h1>
    <p>
      Offline, phone-safe simulator comparing uncorrelated (white) vs QDS-style AR(1) correlated noise.
      Includes Stress Hammers and Bias Integrity controls to keep the demo honest.
    </p>
    <div class="badges">
      <span class="badge">No dependencies</span>
      <span class="badge">Canvas charts</span>
      <span class="badge">Local run history</span>
      <span class="badge">Stress Hammers v1</span>
      <span class="badge">Bias Integrity v1</span>
      <span class="badge">Shed Edition stable ðŸŽ©</span>
    </div>
  </div>

  <div class="grid">

    <!-- LEFT: CONTROLS -->
    <div class="panel">
      <div class="panel-title">Controls</div>

      <div class="control">
        <label><span>Base drain per cycle (%)</span><span id="v_base">2.0</span></label>
        <input id="base" type="range" min="0.1" max="12" step="0.1" value="2.0"/>
        <div class="subtle">Deterministic degradation per cycle.</div>
      </div>

      <div class="control">
        <label><span>Noise amplitude (%)</span><span id="v_amp">3.0</span></label>
        <input id="amp" type="range" min="0.1" max="20" step="0.1" value="3.0"/>
        <div class="subtle">Stochastic variability applied each cycle.</div>
      </div>

      <div class="control">
        <label><span>Correlation p (0â€“0.99)</span><span id="v_p">0.90</span></label>
        <input id="p" type="range" min="0" max="0.99" step="0.01" value="0.90"/>
        <div class="subtle">AR(1) correlation strength for QDS-style noise.</div>
      </div>

      <div class="control">
        <label><span>Number of cells (runs)</span><span id="v_n">500</span></label>
        <input id="n" type="range" min="50" max="3000" step="50" value="500"/>
        <div class="subtle">Monte Carlo population per model.</div>
      </div>

      <div class="control">
        <label><span>Max cycles simulated</span><span id="v_max">1200</span></label>
        <input id="maxCycles" type="range" min="100" max="8000" step="50" value="1200"/>
        <div class="subtle">Upper bound to avoid infinite sims.</div>
      </div>

      <div class="control">
        <label><span>Failure threshold (%)</span><span id="v_thr">80</span></label>
        <input id="thr" type="range" min="30" max="99" step="1" value="80"/>
        <div class="subtle">Cell fails when health â‰¤ threshold.</div>
      </div>

      <div class="row">
        <button class="btn primary" id="btnRun">Run simulation</button>
        <button class="btn" id="btnReset">Reset defaults</button>
      </div>

      <hr class="sep"/>

      <div class="panel-title">Presets</div>
      <div class="row">
        <button class="btn" id="preReal">Preset: Realistic phone</button>
        <button class="btn" id="preContrast">Preset: QDS contrast</button>
        <button class="btn danger" id="preChaos">Preset: Chaos</button>
      </div>

      <hr class="sep"/>

      <div class="panel-title">Stress Hammers</div>
      <label class="checkbox-row">
        <input type="checkbox" id="hamNonlin" checked/>
        <span>Nonlinear wear (accelerates when health is low)</span>
      </label>
      <label class="checkbox-row">
        <input type="checkbox" id="hamHeat" checked/>
        <span>Heat epochs (periodic harsh cycles)</span>
      </label>
      <label class="checkbox-row">
        <input type="checkbox" id="hamOutlier" checked/>
        <span>Rare outliers (shock events)</span>
      </label>

      <div class="row" style="margin-top:6px">
        <button class="btn danger" id="hamPath">
          Hammer: Pathological regime
        </button>
      </div>

      <hr class="sep"/>

      <div class="panel-title">Bias Integrity</div>
      <div class="row">
        <button class="btn" id="btnHardNull">Hammer: Hard null (p=0)</button>
        <button class="btn" id="btnMatched">Hammer: Matched marginal noise</button>
      </div>
      <label class="checkbox-row">
        <input type="checkbox" id="chkBlind"/>
        <span>Blind labels (randomly swap White/QDS display)</span>
      </label>
      <div class="small-note">
        Goal: if QDS benefit only shows up when we let narrative creep in, we catch it here.
      </div>

    </div>

    <!-- RIGHT: RESULTS -->
    <div class="panel">
      <div class="panel-title">Results</div>

      <div id="flags" class="flag" style="display:none"></div>

      <div class="results-grid" style="margin-top:10px">
        <div class="card">
          <div class="k" id="labWhite">White noise mean lifetime</div>
          <div class="v" id="r_white_mu">â€”</div>
        </div>
        <div class="card">
          <div class="k">White noise Ïƒ</div>
          <div class="v" id="r_white_sd">â€”</div>
        </div>
        <div class="card">
          <div class="k" id="labQDS">QDS-style mean lifetime</div>
          <div class="v" id="r_qds_mu">â€”</div>
        </div>
        <div class="card">
          <div class="k">QDS-style Ïƒ</div>
          <div class="v" id="r_qds_sd">â€”</div>
        </div>
        <div class="card">
          <div class="k">Relative change (QDS vs white)</div>
          <div class="v" id="r_delta">â€”</div>
        </div>
        <div class="card">
          <div class="k">Runs simulated per model</div>
          <div class="v" id="r_n">â€”</div>
        </div>
      </div>

      <hr class="sep"/>

      <div class="panel-title">Sample health profile (1 representative cell each)</div>
      <canvas id="profileChart" width="900" height="240"></canvas>
      <div class="small-note" id="profileNote"></div>

      <hr class="sep"/>

      <div class="panel-title">Cycles to failure (distribution)</div>
      <canvas id="histChart" width="900" height="240"></canvas>

      <hr class="sep"/>

      <div class="panel-title">Recent run history (local)</div>
      <div class="history" id="historyBox"></div>
      <div class="row">
        <button class="btn" id="btnClearHist">Clear history</button>
      </div>
    </div>

  </div>
</div>

<script>
// ======================================================
// QDS Battery Lab â€” Showcase Stress + Bias v1
// single-file, android-safe, no deps
// ======================================================

const $ = id => document.getElementById(id);

const DEFAULTS = {
  base: 2.0, amp: 3.0, p: 0.90, n: 500, maxCycles: 1200, thr: 80,
  hamNonlin: true, hamHeat: true, hamOutlier: true
};

let BIAS = { matchedMarginal:false, blindLabels:false };

// ----------------- UI wiring -----------------
function bindSlider(id, outId, fmt=1){
  const el = $(id), out = $(outId);
  const upd = () => out.textContent = Number(el.value).toFixed(fmt);
  el.addEventListener("input", upd); upd();
}
bindSlider("base","v_base",1);
bindSlider("amp","v_amp",1);
bindSlider("p","v_p",2);
bindSlider("n","v_n",0);
bindSlider("maxCycles","v_max",0);
bindSlider("thr","v_thr",0);

$("btnRun").onclick = () => runSimulation();
$("btnReset").onclick = () => resetDefaults();

$("preReal").onclick = () => applyPreset("real");
$("preContrast").onclick = () => applyPreset("contrast");
$("preChaos").onclick = () => applyPreset("chaos");

$("hamPath").onclick = () => pathologicalHammer();

$("btnHardNull").onclick = () => { setSlider("p",0); BIAS.matchedMarginal=false; softToast("Hard null: p=0."); runSimulation(); };
$("btnMatched").onclick = () => { BIAS.matchedMarginal = !BIAS.matchedMarginal; softToast("Matched marginal " + (BIAS.matchedMarginal?"ON":"OFF")); runSimulation(); };
$("chkBlind").onchange = e => { BIAS.blindLabels = !!e.target.checked; softToast("Blind labels " + (BIAS.blindLabels?"ON":"OFF")); runSimulation(); };

$("btnClearHist").onclick = () => { localStorage.removeItem("QDS_BATT_HIST_V1"); renderHistory(); };

function setSlider(id, v){
  const el = $(id); if(!el) return;
  el.value = v; el.dispatchEvent(new Event("input"));
}
function setCheck(id, v){
  const el = $(id); if(!el) return;
  el.checked = !!v;
}

function resetDefaults(){
  setSlider("base", DEFAULTS.base);
  setSlider("amp", DEFAULTS.amp);
  setSlider("p", DEFAULTS.p);
  setSlider("n", DEFAULTS.n);
  setSlider("maxCycles", DEFAULTS.maxCycles);
  setSlider("thr", DEFAULTS.thr);
  setCheck("hamNonlin", DEFAULTS.hamNonlin);
  setCheck("hamHeat", DEFAULTS.hamHeat);
  setCheck("hamOutlier", DEFAULTS.hamOutlier);
  BIAS.matchedMarginal = false;
  $("chkBlind").checked = false; BIAS.blindLabels = false;
  runSimulation();
}

function applyPreset(kind){
  if(kind==="real"){
    setSlider("base",2.0); setSlider("amp",3.0); setSlider("p",0.90);
    setSlider("n",500); setSlider("maxCycles",1200); setSlider("thr",80);
  }
  if(kind==="contrast"){
    setSlider("base",3.0); setSlider("amp",2.2); setSlider("p",0.75);
    setSlider("n",1200); setSlider("maxCycles",2400); setSlider("thr",60);
  }
  if(kind==="chaos"){
    setSlider("base",8.0); setSlider("amp",12.0); setSlider("p",0.99);
    setSlider("n",2000); setSlider("maxCycles",3000); setSlider("thr",95);
  }
  runSimulation();
}

function pathologicalHammer(){
  setSlider("base",7.5);
  setSlider("amp",10.0);
  setSlider("p",0.95);
  setSlider("n",1600);
  setSlider("maxCycles",2600);
  setSlider("thr",90);
  setCheck("hamNonlin", true);
  setCheck("hamHeat", true);
  setCheck("hamOutlier", true);
  runSimulation();
}

// ----------------- RNG helpers -----------------
function randn(){
  // Box-Muller
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

// ----------------- Model core -----------------
function simulateOneCell(model, cfg){
  let health = 100.0;
  let prevQ = 0.0;
  let cycles = 0;

  const base = cfg.base;
  const amp = cfg.amp;
  const phi = cfg.p;
  const thr = cfg.thr;

  const hamNonlin = cfg.hamNonlin;
  const hamHeat = cfg.hamHeat;
  const hamOutlier = cfg.hamOutlier;

  // heat epochs: every ~40 cycles, 6-cycle harsh band
  function heatMultiplier(c){
    if(!hamHeat) return 1.0;
    const period = 40;
    const band = 6;
    const m = c % period;
    return (m < band) ? 1.6 : 1.0;
  }

  while(cycles < cfg.maxCycles && health > thr){
    cycles++;

    // shared draw for matched marginal option
    const eps = randn();

    let step;
    if(model==="white"){
      step = eps;
    }else{
      if(BIAS.matchedMarginal){
        step = phi*prevQ + Math.sqrt(1 - phi*phi)*eps;
      }else{
        step = phi*prevQ + Math.sqrt(1 - phi*phi)*randn();
      }
      prevQ = step;
    }

    // base + scaled noise
    let drain = base + amp * step;

    // outlier shocks
    if(hamOutlier && Math.random() < 0.012){
      drain += 6 + Math.random()*10;
    }

    // nonlinear wear when low
    if(hamNonlin){
      const frag = Math.max(0, (40 - health) / 40); // 0..1 as health drops under 40
      drain *= (1 + 0.9*frag);
    }

    // heat epochs
    drain *= heatMultiplier(cycles);

    // clamp drain to avoid insane reversals
    if(drain < -3) drain = -3;

    health -= drain;

    // mild clamp for display realism
    if(health > 110) health = 110;
  }

  return cycles;
}

function simulateProfile(model, cfg){
  let health = 100.0;
  let prevQ = 0.0;
  const arr = [health];

  const epsTiny = () => randn();

  function heatMultiplier(c){
    if(!cfg.hamHeat) return 1.0;
    const period = 40, band = 6;
    const m = c % period;
    return (m < band) ? 1.6 : 1.0;
  }

  for(let c=1; c<=Math.min(cfg.maxCycles, 260); c++){
    const eps = epsTiny();

    let step;
    if(model==="white"){
      step = eps;
    }else{
      if(BIAS.matchedMarginal){
        step = cfg.p*prevQ + Math.sqrt(1 - cfg.p*cfg.p)*eps;
      }else{
        step = cfg.p*prevQ + Math.sqrt(1 - cfg.p*cfg.p)*epsTiny();
      }
      prevQ = step;
    }

    let drain = cfg.base + cfg.amp * step;

    if(cfg.hamOutlier && Math.random() < 0.02){
      drain += 4 + Math.random()*8;
    }
    if(cfg.hamNonlin){
      const frag = Math.max(0, (40 - health) / 40);
      drain *= (1 + 0.9*frag);
    }
    drain *= heatMultiplier(c);
    if(drain < -3) drain = -3;

    health -= drain;
    arr.push(health);
    if(health <= cfg.thr) break;
  }
  return arr;
}

// ----------------- Stats -----------------
function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }
function sd(a){
  const m = mean(a);
  const v = a.reduce((s,x)=>s+(x-m)*(x-m),0)/Math.max(1,(a.length-1));
  return Math.sqrt(v);
}

// ----------------- Charts -----------------
function drawProfile(canvas, whiteArr, qdsArr, labels){
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  // grid
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y = (h*i)/6;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }
  for(let i=1;i<8;i++){
    const x = (w*i)/8;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }

  function plot(arr, color){
    const n = arr.length;
    const maxX = Math.max(10, n-1);
    const minY = 0, maxY = 110;

    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const x = (i/maxX)*w;
      const y = h - ((arr[i]-minY)/(maxY-minY))*h;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  plot(whiteArr, "rgba(120,170,255,0.95)");
  plot(qdsArr, "rgba(255,110,150,0.9)");

  // labels
  ctx.fillStyle = "rgba(230,240,255,0.9)";
  ctx.font = "bold 12px system-ui";
  ctx.fillText(labels.whiteLabel, 14, 18);
  ctx.fillStyle = "rgba(255,170,200,0.9)";
  ctx.fillText(labels.qdsLabel, 120, 18);
}

function drawHistogram(canvas, white, qds, labels){
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  const all = white.concat(qds);
  const maxV = Math.max(...all);
  const minV = Math.min(...all);

  const bins = 14;
  const binW = (maxV - minV + 1) / bins;

  function binCounts(arr){
    const c = new Array(bins).fill(0);
    for(const x of arr){
      let b = Math.floor((x - minV)/binW);
      if(b<0) b=0; if(b>=bins) b=bins-1;
      c[b]++;
    }
    return c;
  }

  const cw = binCounts(white);
  const cq = binCounts(qds);
  const top = Math.max(...cw, ...cq, 1);

  // grid
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  for(let i=1;i<6;i++){
    const y = (h*i)/6;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
  }

  const pad = 16;
  const plotW = w - pad*2;
  const plotH = h - pad*2;
  const barGroup = plotW / bins;

  for(let i=0;i<bins;i++){
    const x0 = pad + i*barGroup;

    const bw = barGroup*0.36;
    const gap = barGroup*0.08;

    const hw = (cw[i]/top)*plotH;
    const hq = (cq[i]/top)*plotH;

    // white bars
    ctx.fillStyle = "rgba(120,170,255,0.75)";
    ctx.fillRect(x0, pad + (plotH-hw), bw, hw);

    // qds bars
    ctx.fillStyle = "rgba(255,110,150,0.7)";
    ctx.fillRect(x0+bw+gap, pad + (plotH-hq), bw, hq);
  }

  // legend text
  ctx.fillStyle = "rgba(230,240,255,0.85)";
  ctx.font="bold 12px system-ui";
  ctx.fillText(labels.whiteLabel, 14, 18);
  ctx.fillStyle = "rgba(255,170,200,0.9)";
  ctx.fillText(labels.qdsLabel, 120, 18);
}

// ----------------- Bias-safe label swap -----------------
function applyBlindDisplay(res){
  let labels = { whiteLabel:"White noise", qdsLabel:"QDS-style" };
  if(!BIAS.blindLabels) return { res, labels };

  if(Math.random() < 0.5) return { res, labels };

  // swap display only
  const swapped = {
    whiteMu: res.qdsMu, whiteSd: res.qdsSd,
    qdsMu: res.whiteMu, qdsSd: res.whiteSd,
    whiteArr: res.qdsArr, qdsArr: res.whiteArr,
    whiteHist: res.qdsHist, qdsHist: res.whiteHist,
    delta: -res.delta // display trick, not physics
  };
  labels = { whiteLabel:"QDS-style", qdsLabel:"White noise" };
  return { res: swapped, labels };
}

// ----------------- Run simulation -----------------
function runSimulation(){
  const cfg = readCfg();

  const white = [];
  const qds = [];

  for(let i=0;i<cfg.n;i++){
    white.push(simulateOneCell("white", cfg));
    qds.push(simulateOneCell("qds", cfg));
  }

  const whiteMu = mean(white), whiteSd = sd(white);
  const qdsMu = mean(qds), qdsSd = sd(qds);
  const delta = ((qdsMu - whiteMu) / Math.max(1e-9, whiteMu)) * 100;

  const whiteArr = simulateProfile("white", cfg);
  const qdsArr = simulateProfile("qds", cfg);

  const resCore = {
    whiteMu, whiteSd, qdsMu, qdsSd, delta,
    whiteArr, qdsArr,
    whiteHist: white, qdsHist: qds
  };

  const blindPack = applyBlindDisplay(resCore);
  const res = blindPack.res;
  const labels = blindPack.labels;

  renderFlags(cfg, whiteMu, qdsMu);
  renderNumbers(res, cfg, labels);
  renderCharts(res, labels, cfg);
  pushHistory(cfg, whiteMu, whiteSd, qdsMu, qdsSd, delta);
  renderHistory();
}

function readCfg(){
  return {
    base: Number($("base").value),
    amp: Number($("amp").value),
    p: Number($("p").value),
    n: Number($("n").value),
    maxCycles: Number($("maxCycles").value),
    thr: Number($("thr").value),
    hamNonlin: $("hamNonlin").checked,
    hamHeat: $("hamHeat").checked,
    hamOutlier: $("hamOutlier").checked
  };
}

// ----------------- Render -----------------
function renderFlags(cfg, whiteMu, qdsMu){
  const flags = [];

  if(cfg.thr < 60) flags.push("Low failure threshold â†’ easier survival by definition.");
  if(cfg.base > 7) flags.push("Very high base drain â†’ likely demo-only.");
  if(cfg.amp > 10) flags.push("Very high noise amplitude â†’ exaggerated conditions.");
  if(cfg.p > 0.95) flags.push("Extremely high p â†’ strong long-memory noise.");
  if(cfg.n * cfg.maxCycles > 5_000_000) flags.push("Heavy compute combo â†’ may be slow on some phones.");
  if(BIAS.matchedMarginal) flags.push("Matched marginal ON â†’ correlation-only comparison.");
  if(BIAS.blindLabels) flags.push("Blind labels ON â†’ display swap may occur.");

  const box = $("flags");
  if(flags.length){
    box.style.display="block";
    box.innerHTML = "<b>Sanity flags:</b><br>â€¢ " + flags.join("<br>â€¢ ");
  }else{
    box.style.display="none";
    box.textContent="";
  }
}

function renderNumbers(res, cfg, labels){
  $("labWhite").textContent = labels.whiteLabel + " mean lifetime";
  $("labQDS").textContent = labels.qdsLabel + " mean lifetime";

  $("r_white_mu").textContent = res.whiteMu.toFixed(1);
  $("r_white_sd").textContent = res.whiteSd.toFixed(1);
  $("r_qds_mu").textContent = res.qdsMu.toFixed(1);
  $("r_qds_sd").textContent = res.qdsSd.toFixed(1);

  const sign = res.delta >= 0 ? "+" : "";
  $("r_delta").textContent = sign + res.delta.toFixed(1) + "%";
  $("r_n").textContent = cfg.n + " per model";
}

function renderCharts(res, labels, cfg){
  drawProfile($("profileChart"), res.whiteArr, res.qdsArr, labels);
  drawHistogram($("histChart"), res.whiteHist, res.qdsHist, labels);

  const wFail = res.whiteArr.length-1;
  const qFail = res.qdsArr.length-1;
  $("profileNote").textContent =
    `${labels.whiteLabel}: failed at cycle ${wFail} (profile may clamp afterwards). ` +
    `${labels.qdsLabel}: failed at cycle ${qFail} (profile may clamp afterwards).`;
}

// ----------------- History -----------------
function pushHistory(cfg, wMu, wSd, qMu, qSd, delta){
  const key = "QDS_BATT_HIST_V1";
  const arr = JSON.parse(localStorage.getItem(key) || "[]");

  const stamp = new Date().toLocaleString();
  const line =
`${stamp}
base=${cfg.base.toFixed(1)}% Â· amp=${cfg.amp.toFixed(1)}% Â· p=${cfg.p.toFixed(2)} Â· thr=${cfg.thr}%
n=${cfg.n} Â· max=${cfg.maxCycles}
white Î¼=${wMu.toFixed(1)} Ïƒ=${wSd.toFixed(1)} Â· QDS Î¼=${qMu.toFixed(1)} Ïƒ=${qSd.toFixed(1)}
Î”=${delta>=0?"+":""}${delta.toFixed(1)}%
stress: nonlin=${cfg.hamNonlin} heat=${cfg.hamHeat} outlier=${cfg.hamOutlier}
bias: matched=${BIAS.matchedMarginal} blind=${BIAS.blindLabels}`;

  arr.unshift(line);
  if(arr.length > 30) arr.length = 30;
  localStorage.setItem(key, JSON.stringify(arr));
}

function renderHistory(){
  const key = "QDS_BATT_HIST_V1";
  const arr = JSON.parse(localStorage.getItem(key) || "[]");
  const box = $("historyBox");
  box.innerHTML = arr.length ? "" : `<div class="hist-item">No history yet.</div>`;
  for(const item of arr){
    const d = document.createElement("div");
    d.className="hist-item";
    d.textContent = item;
    box.appendChild(d);
  }
}

// ----------------- Toast (console only) -----------------
function softToast(msg){
  console.log("[QDS Battery Lab]", msg);
}

// boot
resetDefaults();
renderHistory();
</script>
</body>
</html>
