<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>QDS Solar System V4 â€“ CME & QDS kernel</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #05060a;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }
    #ui-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(5, 6, 10, 0.92);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 0 18px rgba(0,0,0,0.7);
      font-size: 11px;
      max-width: 280px;
      z-index: 10;
      border: 1px solid rgba(255,255,255,0.08);
    }
    #ui-panel h1 {
      font-size: 13px;
      margin: 0 0 6px 0;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #ui-panel h1 span {
      font-size: 15px;
    }
    .slider-row {
      margin: 4px 0;
    }
    .slider-row label {
      display: block;
      margin-bottom: 2px;
    }
    .slider-row input[type="range"] {
      width: 100%;
    }
    .small-text {
      font-size: 10px;
      opacity: 0.8;
      margin-top: 3px;
    }
    .toggle-row {
      margin-top: 5px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .toggle-row label {
      font-size: 10px;
    }
    select {
      background: #141622;
      color: #f5f5f5;
      border-radius: 6px;
      border: 1px solid #33374a;
      padding: 2px 4px;
      font-size: 10px;
    }
    button {
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 6px;
      border: 1px solid #3a3f5a;
      background: #181b2a;
      color: #f5f5f5;
      cursor: pointer;
    }
    button:hover {
      background: #232740;
    }
  </style>
</head>
<body>
<div id="ui-panel">
  <h1>QDS Solar System V4 <span>ðŸŽ©</span></h1>
  <div class="small-text">
    Keplerian orbits + QDS vacuum kernel + CME shock rings from the Sun.<br>
    Watch planets wobble when the star sneezes.
  </div>

  <div class="slider-row">
    <label for="lambdaSlider">Spatial correlation Î»<sub>c</sub></label>
    <input id="lambdaSlider" type="range" min="0.5" max="3.0" step="0.1" value="2.5">
  </div>

  <div class="slider-row">
    <label for="tauSlider">Temporal correlation Ï„<sub>c</sub></label>
    <input id="tauSlider" type="range" min="0.5" max="3.0" step="0.1" value="2.5">
  </div>

  <div class="slider-row">
    <label for="ampSlider">Field amplitude A</label>
    <input id="ampSlider" type="range" min="0.0" max="1.5" step="0.05" value="0.4">
  </div>

  <div class="slider-row">
    <label for="speedSlider">Orbit speed (sim time)</label>
    <input id="speedSlider" type="range" min="0.3" max="6.0" step="0.1" value="2.0">
  </div>

  <div class="toggle-row">
    <label for="modeSelect">Mode:</label>
    <select id="modeSelect">
      <option value="gr">GR only (clean Kepler)</option>
      <option value="qds" selected>Kepler + QDS kernel</option>
    </select>
  </div>

  <div class="toggle-row">
    <label>
      <input type="checkbox" id="showTrails" checked>
      Show orbit lines
    </label>
    <label>
      <input type="checkbox" id="showBelt" checked>
      Show asteroid belt
    </label>
  </div>

  <hr style="border-color: rgba(255,255,255,0.08); margin: 6px 0;">

  <div class="slider-row">
    <label for="cmeIntensity">CME intensity</label>
    <input id="cmeIntensity" type="range" min="0.1" max="1.0" step="0.05" value="0.4">
  </div>

  <div class="toggle-row">
    <button id="fireCme">Fire CME</button>
    <label>
      <input type="checkbox" id="autoCme">
      Auto CME
    </label>
  </div>

  <div class="small-text">
    CME waves are expanding rings from the Sun.<br>
    When they pass a planet, they kick its orbit radius a bit, then it settles again.
  </div>
</div>

<canvas id="renderCanvas"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, {
    preserveDrawingBuffer: true,
    stencil: true,
  });

  function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.02, 0.03, 0.07, 1.0);

    // Camera
    const camera = new BABYLON.ArcRotateCamera(
      "camera",
      -Math.PI / 2.2,
      Math.PI / 3,
      120,
      BABYLON.Vector3.Zero(),
      scene
    );
    camera.attachControl(canvas, true);
    camera.lowerRadiusLimit = 40;
    camera.upperRadiusLimit = 260;

    // Lights
    const light = new BABYLON.HemisphericLight(
      "hemi",
      new BABYLON.Vector3(0, 1, 0),
      scene
    );
    light.intensity = 0.8;

    const sunLight = new BABYLON.PointLight(
      "sunLight",
      new BABYLON.Vector3(0, 0, 0),
      scene
    );
    sunLight.intensity = 1.6;
    sunLight.range = 400;

    // Substrate dots (vacuum grid)
    const fieldDots = [];
    const baseDot = BABYLON.MeshBuilder.CreateSphere("fdot", {
      diameter: 0.7,
      segments: 4,
    }, scene);
    baseDot.material = new BABYLON.StandardMaterial("fdotMat", scene);
    baseDot.material.emissiveColor = new BABYLON.Color3(0.1, 0.6, 1.0);
    baseDot.material.specularColor = new BABYLON.Color3(0, 0, 0);
    baseDot.isPickable = false;

    const gridRadius = 140;
    const spacing = 10;
    for (let x = -gridRadius; x <= gridRadius; x += spacing) {
      for (let z = -gridRadius; z <= gridRadius; z += spacing) {
        const d = Math.sqrt(x * x + z * z);
        if (d > gridRadius) continue;
        const dot = baseDot.clone("fdot_" + x + "_" + z);
        dot.position.set(x, -0.4, z);
        fieldDots.push(dot);
      }
    }
    baseDot.setEnabled(false);

    // Sun
    const sun = BABYLON.MeshBuilder.CreateSphere("sun", {
      diameter: 16,
      segments: 24,
    }, scene);
    const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
    sunMat.emissiveColor = new BABYLON.Color3(1.0, 0.9, 0.4);
    sunMat.diffuseColor = new BABYLON.Color3(0.9, 0.75, 0.3);
    sunMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
    sun.material = sunMat;

    // CME base material + template torus
    const cmeMat = new BABYLON.StandardMaterial("cmeMat", scene);
    cmeMat.emissiveColor = new BABYLON.Color3(1.0, 0.5, 0.1);
    cmeMat.diffuseColor = new BABYLON.Color3(0.8, 0.4, 0.1);
    cmeMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
    cmeMat.alpha = 0.6;

    const cmeTemplate = BABYLON.MeshBuilder.CreateTorus("cmeTemplate", {
      thickness: 1,
      diameter: 10,
      tessellation: 64
    }, scene);
    cmeTemplate.rotation.x = Math.PI / 2;
    cmeTemplate.material = cmeMat;
    cmeTemplate.isVisible = false;
    cmeTemplate.isPickable = false;

    const cmeWaves = [];
    let lastAutoCmeTime = 0;

    function spawnCME(intensity, currentTime) {
      const cmeMesh = cmeTemplate.clone("cme_" + currentTime);
      cmeMesh.isVisible = true;
      cmeMesh.scaling.set(1, 1, 1);
      cmeMesh.material = cmeMat.clone("cmeMat_" + currentTime);

      cmeWaves.push({
        radius: 0,
        speed: 40 + intensity * 40,   // outward speed
        maxRadius: 200,
        strength: intensity * 1.2,
        mesh: cmeMesh
      });
    }

    // Planet factory
    function makePlanet(name, radius, orbitRadius, orbitPeriodYears, color, label) {
      const mesh = BABYLON.MeshBuilder.CreateSphere(name, {
        diameter: radius * 2,
        segments: 16,
      }, scene);
      const mat = new BABYLON.StandardMaterial(name + "_mat", scene);
      mat.diffuseColor = color.clone();
      mat.emissiveColor = color.scale(0.4);
      mat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
      mesh.material = mat;

      const orbitPoints = [];
      const steps = 160;
      for (let i = 0; i <= steps; i++) {
        const a = (i / steps) * Math.PI * 2;
        orbitPoints.push(new BABYLON.Vector3(
          Math.cos(a) * orbitRadius,
          0,
          Math.sin(a) * orbitRadius
        ));
      }
      const orbitLine = BABYLON.MeshBuilder.CreateLines(
        name + "_orbit",
        { points: orbitPoints },
        scene
      );
      orbitLine.color = new BABYLON.Color3(0.3, 0.5, 0.9);
      orbitLine.alpha = 0.7;

      return {
        name,
        label,
        mesh,
        orbitRadius,
        orbitPeriodYears,
        orbitLine,
        moons: [],
        phi0: Math.random() * Math.PI * 2,
        cmeOffset: 0   // CME radial kick term
      };
    }

    // Moon factory
    function makeMoon(planet, name, radius, distance, periodDays, color) {
      const mesh = BABYLON.MeshBuilder.CreateSphere(name, {
        diameter: radius * 2,
        segments: 10,
      }, scene);
      const mat = new BABYLON.StandardMaterial(name + "_mat", scene);
      mat.diffuseColor = color.clone();
      mat.emissiveColor = color.scale(0.5);
      mat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
      mesh.material = mat;

      const moon = {
        name,
        mesh,
        distance,
        periodDays,
        phi0: Math.random() * Math.PI * 2
      };
      planet.moons.push(moon);
      return moon;
    }

    // Planets
    const AU = 12;
    const planets = [];
    planets.push(makePlanet("mercury", 0.8, 0.39 * AU, 0.24,
      new BABYLON.Color3(0.7, 0.7, 0.7), "Mercury"));
    planets.push(makePlanet("venus", 1.2, 0.72 * AU, 0.62,
      new BABYLON.Color3(0.9, 0.75, 0.45), "Venus"));
    const earth = makePlanet("earth", 1.3, 1.0 * AU, 1.0,
      new BABYLON.Color3(0.2, 0.5, 1.0), "Earth");
    planets.push(earth);
    planets.push(makePlanet("mars", 1.0, 1.52 * AU, 1.88,
      new BABYLON.Color3(0.9, 0.4, 0.25), "Mars"));
    const jupiter = makePlanet("jupiter", 3.5, 5.2 * AU, 11.86,
      new BABYLON.Color3(0.9, 0.7, 0.55), "Jupiter");
    planets.push(jupiter);
    const saturn = makePlanet("saturn", 3.0, 9.5 * AU, 29.5,
      new BABYLON.Color3(0.9, 0.8, 0.6), "Saturn");
    planets.push(saturn);
    planets.push(makePlanet("uranus", 2.3, 19 * AU, 84,
      new BABYLON.Color3(0.6, 0.85, 0.95), "Uranus"));
    planets.push(makePlanet("neptune", 2.2, 30 * AU, 165,
      new BABYLON.Color3(0.3, 0.55, 0.95), "Neptune"));
    planets.push(makePlanet("pluto", 0.6, 39.5 * AU, 248,
      new BABYLON.Color3(0.8, 0.8, 0.9), "Pluto"));

    // Saturn ring
    const saturnRing = BABYLON.MeshBuilder.CreateDisc("saturnRing", {
      radius: saturn.orbitRadius * 0.09,
      tessellation: 64,
      sideOrientation: BABYLON.Mesh.DOUBLESIDE
    }, scene);
    saturnRing.parent = saturn.mesh;
    saturnRing.rotation.x = Math.PI / 2;
    const ringMat = new BABYLON.StandardMaterial("ringMat", scene);
    ringMat.diffuseColor = new BABYLON.Color3(0.8, 0.75, 0.6);
    ringMat.emissiveColor = new BABYLON.Color3(0.4, 0.35, 0.25);
    ringMat.alpha = 0.7;
    ringMat.backFaceCulling = false;
    saturnRing.material = ringMat;

    // Moons
    makeMoon(earth, "moon", 0.4, 2.5, 27.3, new BABYLON.Color3(0.85, 0.85, 0.9));
    makeMoon(jupiter, "io", 0.4, 5, 1.77, new BABYLON.Color3(0.9, 0.75, 0.35));
    makeMoon(jupiter, "europa", 0.35, 6.5, 3.55, new BABYLON.Color3(0.8, 0.85, 0.95));
    makeMoon(jupiter, "ganymede", 0.5, 8, 7.15, new BABYLON.Color3(0.7, 0.75, 0.8));
    makeMoon(jupiter, "callisto", 0.45, 10, 16.7, new BABYLON.Color3(0.6, 0.6, 0.65));

    // Asteroid belt
    const beltDots = [];
    (function createBelt() {
      const beltCount = 350;
      const innerR = 2.2 * AU;
      const outerR = 3.2 * AU;
      for (let i = 0; i < beltCount; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = innerR + (outerR - innerR) * Math.random();
        const y = (Math.random() - 0.5) * 1.5;
        const dot = baseDot.clone("belt_" + i);
        dot.scaling.scaleInPlace(0.7);
        dot.position.set(Math.cos(a) * r, y, Math.sin(a) * r);
        beltDots.push(dot);
      }
    })();

    // UI controls
    const lambdaSlider = document.getElementById("lambdaSlider");
    const tauSlider = document.getElementById("tauSlider");
    const ampSlider = document.getElementById("ampSlider");
    const speedSlider = document.getElementById("speedSlider");
    const modeSelect = document.getElementById("modeSelect");
    const showTrails = document.getElementById("showTrails");
    const showBelt = document.getElementById("showBelt");
    const cmeIntensitySlider = document.getElementById("cmeIntensity");
    const fireCmeBtn = document.getElementById("fireCme");
    const autoCmeChk = document.getElementById("autoCme");

    fireCmeBtn.addEventListener("click", () => {
      const intensity = parseFloat(cmeIntensitySlider.value);
      const t = performance.now() / 1000.0;
      spawnCME(intensity, t);
    });

    const t0 = performance.now();

    scene.onBeforeRenderObservable.add(() => {
      const nowMs = performance.now();
      const dtSec = (nowMs - t0) / 1000.0;
      const simTime = dtSec;

      const lambda_c = parseFloat(lambdaSlider.value);
      const tau_c = parseFloat(tauSlider.value);
      const amp = parseFloat(ampSlider.value);
      const speed = parseFloat(speedSlider.value);
      const mode = modeSelect.value;
      const cmeIntensity = parseFloat(cmeIntensitySlider.value);
      const autoCme = autoCmeChk.checked;

      const qdsOn = (mode === "qds");
      const tau_eff = 0.2 + tau_c;

      // Auto CME: every ~20â€“40 sim seconds
      if (autoCme) {
        const interval = 20 + (1 - cmeIntensity) * 20; // lower intensity -> slightly less frequent
        if (simTime - lastAutoCmeTime > interval) {
          spawnCME(cmeIntensity, simTime);
          lastAutoCmeTime = simTime;
        }
      }

      // Update CME waves (radius + visual)
      for (let i = cmeWaves.length - 1; i >= 0; i--) {
        const wave = cmeWaves[i];
        wave.radius += wave.speed * engine.getDeltaTime() / 1000.0;

        const s = wave.radius / 5;
        wave.mesh.scaling.x = s;
        wave.mesh.scaling.z = s;

        const alpha = Math.max(0, 0.7 * (1 - wave.radius / wave.maxRadius));
        wave.mesh.material.alpha = alpha;

        // Apply CME kicks to planets when wave crosses their orbital radius
        planets.forEach(p => {
          const rBase = p.orbitRadius;
          const dist = Math.abs(wave.radius - rBase);
          if (dist < 2.0 && wave.radius > 0) {
            // radial kick â€“ small, decays later
            const sign = (Math.random() < 0.5) ? -1 : 1;
            const falloff = Math.max(0.2, 1 - dist / 2.0);
            p.cmeOffset += sign * wave.strength * 0.8 * falloff;
          }
        });

        if (wave.radius > wave.maxRadius) {
          wave.mesh.dispose();
          cmeWaves.splice(i, 1);
        }
      }

      // Update planets
      planets.forEach((p, index) => {
        // Decay CME offset
        p.cmeOffset *= 0.96;

        const baseAngularSpeed = (Math.PI * 2) / (p.orbitPeriodYears * 20.0);
        const angle = simTime * baseAngularSpeed * speed + p.phi0;

        let r = p.orbitRadius + p.cmeOffset;
        let y = 0;

        if (qdsOn) {
          const decay = Math.exp(-p.orbitRadius / (lambda_c * 40.0));
          const radialWobble = amp * 1.2 * decay * Math.sin(angle * lambda_c * 0.8 + index);
          const verticalWobble = amp * 0.8 * decay * Math.sin(simTime / tau_eff + p.orbitRadius * 0.05);
          r += radialWobble;
          y = verticalWobble;
        }

        const x = Math.cos(angle) * r;
        const z = Math.sin(angle) * r;
        p.mesh.position.set(x, y, z);

        p.orbitLine.isVisible = showTrails.checked;

        if (p.moons && p.moons.length > 0) {
          p.moons.forEach(m => {
            const moonAngle = simTime * (Math.PI * 2) / (m.periodDays * 1.8) * speed + m.phi0;
            const mx = p.mesh.position.x + Math.cos(moonAngle) * m.distance;
            const mz = p.mesh.position.z + Math.sin(moonAngle) * m.distance;
            const my = p.mesh.position.y + Math.sin(moonAngle * 1.2) * 0.3;
            m.mesh.position.set(mx, my, mz);
          });
        }
      });

      // Asteroid belt visibility
      const beltVisible = showBelt.checked;
      beltDots.forEach(d => d.setEnabled(beltVisible));

      // Substrate shimmer (+ slight CME pulse coupling)
      const shimmer = amp * 0.15;
      if (shimmer > 0.001) {
        const lval = parseFloat(lambdaSlider.value);
        const tval = parseFloat(tauSlider.value);
        const w = 0.15 + lval * 0.05;
        const f = 0.3 + tval * 0.1;
        const cmeBoost = cmeWaves.length > 0 ? 0.05 : 0.0;

        fieldDots.forEach(d => {
          const baseY = -0.4;
          const phase = (d.position.x + d.position.z) * 0.03;
          d.position.y = baseY + (shimmer + cmeBoost) * Math.sin(simTime * f + phase);
        });
      }
    });

    return scene;
  }

  const scene = createScene();

  engine.runRenderLoop(function () {
    scene.render();
  });

  window.addEventListener("resize", function () {
    engine.resize();
  });
</script>
</body>
</html>
