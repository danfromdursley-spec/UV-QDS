<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QDS Dark Substrate Realtime Map v1</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  :root {
    color-scheme: dark;
    --bg: #02030b;
    --panel-bg: rgba(5, 8, 30, 0.9);
    --accent: #36d5ff;
    --accent-soft: #4df2b8;
    --text: #e7f7ff;
    --muted: #6b7c9e;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: radial-gradient(circle at top, #05081a 0%, #02030b 55%, #000 100%);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: var(--text);
    overflow: hidden;
  }

  #container {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
  }

  #canvasWrap {
    position: relative;
    flex: 1;
  }

  #qdsCanvas {
    width: 100%;
    height: 100%;
    display: block;
    background: radial-gradient(circle at center, #05051a 0%, #02030b 60%, #000 100%);
  }

  #hudOverlay {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 8px 10px;
    border-radius: 10px;
    background: rgba(3, 8, 28, 0.78);
    border: 1px solid rgba(72, 222, 255, 0.4);
    backdrop-filter: blur(6px);
    font-size: 10px;
    line-height: 1.35;
    max-width: 70vw;
  }

  #hudTitle {
    font-size: 11px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: var(--accent);
    margin-bottom: 2px;
  }

  #hudSubtitle {
    color: var(--muted);
  }

  #hudStats {
    margin-top: 4px;
    color: var(--accent-soft);
  }

  #controls {
    padding: 8px 10px 10px;
    background: linear-gradient(to top, rgba(0,0,0,0.95), rgba(0,0,20,0.92));
    border-top: 1px solid rgba(72, 222, 255, 0.2);
    display: flex;
    flex-wrap: wrap;
    gap: 6px 10px;
    align-items: center;
    justify-content: space-between;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    min-width: 110px;
    flex: 1 1 110px;
  }

  .control-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--muted);
    margin-bottom: 2px;
  }

  .control-label span {
    color: var(--accent-soft);
  }

  input[type="range"] {
    width: 100%;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    border-radius: 999px;
    background: rgba(90, 120, 180, 0.35);
    outline: none;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    border: 2px solid #ffffff;
    box-shadow: 0 0 4px rgba(54, 213, 255, 0.9);
  }

  input[type="range"]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    border: 2px solid #ffffff;
    box-shadow: 0 0 4px rgba(54, 213, 255, 0.9);
  }

  #buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    justify-content: flex-end;
    min-width: 170px;
  }

  button {
    border: 1px solid rgba(90, 160, 255, 0.6);
    background: radial-gradient(circle at top, #122040 0%, #060916 60%, #020308 100%);
    border-radius: 999px;
    color: var(--text);
    font-size: 10px;
    padding: 4px 8px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  button span.dot {
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
  }

  button#btnPause span.dot {
    background: #ffcc44;
  }

  button#btnReset span.dot {
    background: #ff4d89;
  }

  button.preset span.dot {
    background: #4df2b8;
  }

  button:active {
    transform: translateY(1px) scale(0.99);
    box-shadow: 0 0 4px rgba(72, 222, 255, 0.6);
  }

  @media (max-width: 640px) {
    #hudOverlay {
      max-width: 80vw;
      font-size: 9px;
    }
    #buttons {
      justify-content: flex-start;
    }
  }
</style>
</head>
<body>
<div id="container">
  <div id="canvasWrap">
    <canvas id="qdsCanvas"></canvas>
    <div id="hudOverlay">
      <div id="hudTitle">QDS DARK SUBSTRATE MAP — v1</div>
      <div id="hudSubtitle">Simulated finite-correlation field (not live cosmological data)</div>
      <div id="hudStats"></div>
    </div>
  </div>

  <div id="controls">
    <div class="control-group">
      <label class="control-label" for="lambdaSlider">
        Spatial Coherence <span>λ<sub>c</sub></span>
      </label>
      <input id="lambdaSlider" type="range" min="1" max="20" value="7">
    </div>

    <div class="control-group">
      <label class="control-label" for="tauSlider">
        Temporal Persistence <span>τ<sub>c</sub></span>
      </label>
      <input id="tauSlider" type="range" min="10" max="200" value="90">
    </div>

    <div class="control-group">
      <label class="control-label" for="noiseSlider">
        Noise Injection <span>σ</span>
      </label>
      <input id="noiseSlider" type="range" min="1" max="100" value="28">
    </div>

    <div id="buttons">
      <button id="btnPause"><span class="dot"></span> Pause</button>
      <button id="btnReset"><span class="dot"></span> Reset</button>
      <button class="preset" id="btnCalm"><span class="dot"></span> Calm</button>
      <button class="preset" id="btnStorm"><span class="dot"></span> Storm</button>
    </div>
  </div>
</div>

<script>
(function() {
  const canvas = document.getElementById('qdsCanvas');
  const hudStats = document.getElementById('hudStats');
  const lambdaSlider = document.getElementById('lambdaSlider');
  const tauSlider = document.getElementById('tauSlider');
  const noiseSlider = document.getElementById('noiseSlider');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');
  const btnCalm = document.getElementById('btnCalm');
  const btnStorm = document.getElementById('btnStorm');
  const ctx = canvas.getContext('2d');

  // Internal "substrate resolution" (coarse grid → upscaled to canvas)
  let gridW = 120;
  let gridH = 70;

  let field = [];
  let fieldNext = [];
  let lastTime = performance.now();
  let running = true;
  let frameCount = 0;
  let lastStatUpdate = performance.now();
  let lastLambda = 0, lastTau = 0, lastSigma = 0;

  function initField() {
    field = new Array(gridW * gridH);
    fieldNext = new Array(gridW * gridH);
    for (let i = 0; i < field.length; i++) {
      field[i] = (Math.random() * 2 - 1) * 0.2;
      fieldNext[i] = 0;
    }
  }

  function resizeCanvas() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  window.addEventListener('resize', resizeCanvas);

  function updateField(dt) {
    // Slider → model parameters
    const lambdaUi = parseFloat(lambdaSlider.value);   // 1..20
    const tauUi = parseFloat(tauSlider.value);         // 10..200
    const sigmaUi = parseFloat(noiseSlider.value);     // 1..100

    // Map UI to "physics-y" ranges
    const spatialMix = 0.04 + (lambdaUi / 20) * 0.22;      // 0.04 .. ~0.26
    const tauNorm = tauUi / 200;                            // 0.05 .. 1
    const temporalPersistence = 0.80 + tauNorm * 0.19;      // 0.80 .. 0.99
    const noiseAmp = 0.003 + (sigmaUi / 100) * 0.03;        // 0.003 .. 0.033

    const w = gridW, h = gridH;

    for (let y = 0; y < h; y++) {
      const ym1 = (y === 0 ? 0 : y - 1);
      const yp1 = (y === h - 1 ? h - 1 : y + 1);
      for (let x = 0; x < w; x++) {
        const xm1 = (x === 0 ? 0 : x - 1);
        const xp1 = (x === w - 1 ? w - 1 : x + 1);

        const idx = y * w + x;

        const self = field[idx];
        const n1 = field[y * w + xm1];
        const n2 = field[y * w + xp1];
        const n3 = field[ym1 * w + x];
        const n4 = field[yp1 * w + x];

        const neighbourAvg = (n1 + n2 + n3 + n4) * 0.25;
        const spatiallySmoothed = self * (1 - spatialMix) + neighbourAvg * spatialMix;

        // Temporal persistence + fresh noise → rough QDS-style OU process
        const target = spatiallySmoothed + (Math.random() * 2 - 1) * noiseAmp;
        fieldNext[idx] = self * temporalPersistence + target * (1 - temporalPersistence);
      }
    }

    // Swap
    const tmp = field;
    field = fieldNext;
    fieldNext = tmp;

    // Update HUD occasionally
    const now = performance.now();
    if (now - lastStatUpdate > 300) {
      lastStatUpdate = now;
      lastLambda = lambdaUi.toFixed(1);
      lastTau = tauUi.toFixed(1);
      lastSigma = sigmaUi.toFixed(1);
      const mean = computeMean(field);
      const varr = computeVariance(field, mean);
      hudStats.textContent =
        `λc ≈ ${lastLambda}  |  τc (ui) ≈ ${lastTau}  |  σ (ui) ≈ ${lastSigma}  ` +
        `|  ⟨χ⟩ ≈ ${mean.toFixed(3)}  |  Var[χ] ≈ ${varr.toFixed(3)}`;
    }
  }

  function computeMean(arr) {
    let s = 0;
    for (let i = 0; i < arr.length; i++) s += arr[i];
    return s / arr.length;
  }

  function computeVariance(arr, mean) {
    let s = 0;
    for (let i = 0; i < arr.length; i++) {
      const d = arr[i] - mean;
      s += d * d;
    }
    return s / arr.length;
  }

  function renderField() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const cellW = w / gridW;
    const cellH = h / gridH;

    // For a neon look: map field value to hue + brightness
    for (let y = 0; y < gridH; y++) {
      for (let x = 0; x < gridW; x++) {
        const v = field[y * gridW + x]; // typically ~ -1 .. 1
        // Compress to 0..1
        const nv = Math.max(0, Math.min(1, 0.5 + v * 1.4));
        const hue = 190 + nv * 80;      // cyan → purple
        const light = 12 + nv * 55;     // darker → bright
        const sat = 70 + nv * 25;       // saturated neon
        ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
        ctx.fillRect(x * cellW, y * cellH, cellW + 1, cellH + 1);
      }
    }
  }

  function loop(now) {
    const dt = now - lastTime;
    lastTime = now;
    if (running) {
      updateField(dt);
      renderField();
      frameCount++;
    }
    requestAnimationFrame(loop);
  }

  btnPause.addEventListener('click', () => {
    running = !running;
    btnPause.innerHTML = running
      ? '<span class="dot"></span> Pause'
      : '<span class="dot"></span> Run';
  });

  btnReset.addEventListener('click', () => {
    initField();
  });

  btnCalm.addEventListener('click', () => {
    lambdaSlider.value = 14;
    tauSlider.value = 170;
    noiseSlider.value = 8;
  });

  btnStorm.addEventListener('click', () => {
    lambdaSlider.value = 4;
    tauSlider.value = 40;
    noiseSlider.value = 70;
  });

  // Init
  initField();
  resizeCanvas();
  lastTime = performance.now();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
