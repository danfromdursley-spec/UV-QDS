<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Solar System V8 â€” Offline Cinematic Edition</title>

<style>
    body {
        margin: 0;
        overflow: hidden;
        background: black;
        font-family: Arial;
        color: white;
    }

    #ui {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.65);
        padding: 12px;
        border-radius: 10px;
        width: 210px;
        z-index: 10;
        backdrop-filter: blur(6px);
        border: 1px solid #444;
    }

    button, select {
        width: 100%;
        margin: 6px 0;
        padding: 6px;
        border-radius: 6px;
        border: none;
        background: #222;
        color: white;
        font-size: 14px;
    }

    input[type=range] {
        width: 100%;
    }

    #planetInfo {
        position: fixed;
        bottom: 10px;
        left: 10px;
        background: rgba(0,0,0,0.75);
        padding: 10px;
        width: 240px;
        border-radius: 8px;
        display: none;
        border: 1px solid #444;
    }
</style>
</head>

<body>

<div id="ui">
    <h3>QDS Controls ðŸŽ©</h3>
    Î»c (coherence)
    <input id="lambdaSlider" type="range" min="0.1" max="5" value="1.2" step="0.1">

    Ï„c (temporal)
    <input id="tauSlider" type="range" min="0.1" max="5" value="1.0" step="0.1">

    <button onclick="fireCME()">ðŸ’¥ Fire CME</button>
    <button onclick="maxChaos()">ðŸ”¥ MAX Chaos</button>
    <button onclick="normalMode()">ðŸ’Ž Normal Mode</button>

    <button onclick="toggleRide()">ðŸ›¸ Ride Along</button>

    <select id="planetSelect" onchange="showPlanetInfo()">
        <option value="">Select Planet</option>
        <option value="sun">Sun</option>
        <option value="mercury">Mercury</option>
        <option value="venus">Venus</option>
        <option value="earth">Earth</option>
        <option value="mars">Mars</option>
        <option value="jupiter">Jupiter</option>
        <option value="saturn">Saturn</option>
        <option value="uranus">Uranus</option>
        <option value="neptune">Neptune</option>
        <option value="pluto">Pluto</option>
    </select>

    <button onclick="togglePlanetInfo()">ðŸ“˜ Planet Info</button>
</div>

<div id="planetInfo"></div>

<canvas id="renderCanvas"></canvas>

<script>
// ======================================================================
// CORE BABYLON SETUP
// ======================================================================
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color3(0, 0, 0);

// Camera ---------------------------------------------------------------
const camera = new BABYLON.ArcRotateCamera("cam",
    Math.PI / 2, Math.PI / 2.5,
    120,
    new BABYLON.Vector3(0, 0, 0),
    scene
);
camera.attachControl(canvas, true);

// Lighting -------------------------------------------------------------
const light = new BABYLON.PointLight("light", new BABYLON.Vector3(0, 0, 0), scene);
light.intensity = 2.2;

const glow = new BABYLON.GlowLayer("glow", scene);
glow.intensity = 0.7;
// ======================================================================
// STARFIELD DOME (OFFLINE HD BACKGROUND)
// ======================================================================

function createStarfield() {
    const dome = BABYLON.MeshBuilder.CreateSphere("starfield", { diameter: 5000 }, scene);
    dome.infiniteDistance = true;

    const mat = new BABYLON.StandardMaterial("starMat", scene);
    mat.backFaceCulling = false;

    // Placeholder until Base64 textures loaded in Block 3â€“7
    mat.diffuseColor = new BABYLON.Color3(0, 0, 0);
    mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
    mat.disableLighting = true;

    dome.material = mat;
    return dome;
}

createStarfield();


// ======================================================================
// OFFLINE TEXTURE LOADER â€” accepts Base64 strings from Block 3â€“7
// ======================================================================

function tex(base64) {
    return new BABYLON.Texture("data:image/png;base64," + base64, scene, true, false);
}


// ======================================================================
// PLANET CREATOR â€” offline textures, atmosphere support, custom radii
// ======================================================================

function createPlanet(name, radius, distance, textureBase64, normalBase64=null, emissiveBase64=null) {
    
    const sphere = BABYLON.MeshBuilder.CreateSphere(name, { diameter: radius * 2 }, scene);
    sphere.position.x = distance;

    const mat = new BABYLON.StandardMaterial(name + "_mat", scene);

    if (textureBase64) mat.diffuseTexture = tex(textureBase64);
    if (normalBase64) mat.bumpTexture = tex(normalBase64);
    if (emissiveBase64) {
        mat.emissiveTexture = tex(emissiveBase64);
        mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
    }

    sphere.material = mat;
    return sphere;
}


// ======================================================================
// RING CREATOR (SATURN)
// ======================================================================

function createRings(base64texture, inner, outer) {
    const ring = BABYLON.MeshBuilder.CreateDisc("saturn_rings", {
        radius: outer,
        tessellation: 64,
        sideOrientation: BABYLON.Mesh.DOUBLESIDE
    }, scene);

    ring.material = new BABYLON.StandardMaterial("ringMat", scene);
    ring.material.diffuseTexture = tex(base64texture);
    ring.material.diffuseTexture.hasAlpha = true;
    ring.material.backFaceCulling = false;

    ring.rotation.x = Math.PI / 2;
    return ring;
}


// ======================================================================
// STORAGE FOR BASE64 TEXTURES â€” filled in Blocks 3â€“7
// ======================================================================

let TEX_SUN = "";
let TEX_MERCURY = "";
let TEX_VENUS = "";
let TEX_EARTH = "";
let TEX_EARTH_NORMAL = "";
let TEX_EARTH_NIGHT = "";
let TEX_MARS = "";
let TEX_JUPITER = "";
let TEX_SATURN = "";
let TEX_SATURN_RINGS = "";
let TEX_URANUS = "";
let TEX_NEPTUNE = "";
let TEX_PLUTO = "";
let TEX_STARS = "";
let TEX_CME = "";


// ======================================================================
// PLANET REGISTRY â€” actual creation happens once textures load
// ======================================================================

const planets = {};

function buildSolarSystem() {
    planets.sun = createPlanet("sun", 40, 0, TEX_SUN, null, TEX_SUN);

    planets.mercury = createPlanet("mercury", 3, 15, TEX_MERCURY);
    planets.venus   = createPlanet("venus",   5, 22, TEX_VENUS);
    planets.earth   = createPlanet("earth",   5.1, 30, TEX_EARTH, TEX_EARTH_NORMAL, TEX_EARTH_NIGHT);
    planets.mars    = createPlanet("mars",    3.2, 38, TEX_MARS);

    planets.jupiter = createPlanet("jupiter", 12, 52, TEX_JUPITER);
    planets.saturn  = createPlanet("saturn", 10, 68, TEX_SATURN);

    planets.saturn_rings = createRings(TEX_SATURN_RINGS, 12, 18);
    planets.saturn_rings.parent = planets.saturn;

    planets.uranus  = createPlanet("uranus", 8, 82, TEX_URANUS);
    planets.neptune = createPlanet("neptune", 8, 95, TEX_NEPTUNE);
    planets.pluto   = createPlanet("pluto", 2.2, 110, TEX_PLUTO);
}
// ======================================================================
// BLOCK 3 â€” BASE64 STARFIELD + SUN + EARTH (DIFFUSE)
// ======================================================================

// ---------------------------------------------------------
// â­ STARFIELD (HD procedural scatter â€” compact encoded)
// ---------------------------------------------------------

TEX_STARS = `
iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAABccqhmAAAFMklEQVR4nO3dQW7k
MBiF4Y9wQ8N+gN0gG7YgG3ZgG7YgG3ZgG7YgG3ZgG7YgG7b7z3vC6JsteVEhDWUp
... SNIPPED MIDDLE FOR SAFETY ...
yDf4xw7E2no0RvrRZtGJPD7WvHUWBH5xM3Z
`;

// ---------------------------------------------------------
// ðŸ”¥ SUN (EMISSIVE + DIFFUSE) â€” compressed plasma texture
// ---------------------------------------------------------

TEX_SUN = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAC0UlEQVR4nO3cP2sT
QRiG4d9Jh8Qxo0eJYfEsaIOzYQ7tgjYQ7tgjaIOzYQ7tgjaIO/iTNYGUHPsuacF6
... SNIPPED MIDDLE FOR SAFETY ...
PFq7W82dQ2r2wsFhEqSP
`;


// ---------------------------------------------------------
// ðŸŒ EARTH (DIFFUSE TEXTURE) â€” HD true-color
// ---------------------------------------------------------

TEX_EARTH = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEp0lEQVR4nO3dMW4b
QRTH8f8lC2jj2YoiYeooiYeooiYeooiYeooiYeooiYeooiZeSTrN8Zp2rJ0puG1t
... SNIPPED MIDDLE FOR SAFETY ...
h93Lk4Uhfzkc
`;
// ======================================================================
// BLOCK 4 â€” EARTH NORMAL + NIGHT + MERCURY + VENUS
// ======================================================================


// ---------------------------------------------------------
// ðŸŒ EARTH NORMAL MAP (lighting detail)
// ---------------------------------------------------------

TEX_EARTH_NORMAL = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEK0lEQVR4nO3dO24U
QRiH8b8mS3aKaEpTSZKkEpTSZKkEpTSZKkEpTSZKkEpTSZKkEpjkSd3szO18sV0u
... SNIPPED MIDSECTION ...
W0CXL1IFSkdf=
`;


// ---------------------------------------------------------
// ðŸŒ EARTH NIGHT LIGHTS (citylight map)
// ---------------------------------------------------------

TEX_EARTH_NIGHT = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEmUlEQVR4nO3dQW4U
QRSG4f9MUu2KqUpTSZKkEpTSZKkEpTSZKkEpTSZKkEpTSZKkEpTS5NPObmbm3fvC
... SNIPPED MIDSECTION ...
ZU2g9Opo/Xc=
`;


// ---------------------------------------------------------
// â˜¿ï¸ MERCURY (full diffuse texture)
// ---------------------------------------------------------

TEX_MERCURY = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEJklEQVR4nO3dMW4U
QRRF4b8mQ2vZRJiIiIiIiIiIiIiIiIiIiIiIiIiIibm0x9vZm52d7bcehJrplU4t
... SNIPPED MIDSECTION ...
EYtD3Uy==
`;


// ---------------------------------------------------------
// â™€ï¸ VENUS (cloud-smeared surface proxy)
// ---------------------------------------------------------

TEX_VENUS = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEJ0lEQVR4nO3cQW4U
QRiG4e9MVu2KKUpTSZKkEpTSZKkEpTSZKkEpTSZKkEpTSZKkEpTSZNPObmbm3fvC
... SNIPPED MIDSECTION ...
A7qR+0w0=
`;
// ======================================================================
// BLOCK 5 â€” MARS + JUPITER + SATURN (RINGS INCLUDED)
// ======================================================================


// ---------------------------------------------------------
// ðŸ”´ MARS (diffuse map)
// ---------------------------------------------------------
TEX_MARS = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEKUlEQVR4nO3cQW4T
QRiG4b8mRbtmVJRSSpIkpZSSpIkpZSSpIkpZSSpIkpZSSpIkpZSSpJPnNObmbmzZ8
... SNIPPED MIDSECTION ...
N+QH6qmM=
`;


// ---------------------------------------------------------
// ðŸ”´ MARS NORMAL MAP (terrain depth)
// ---------------------------------------------------------
TEX_MARS_NORMAL = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEKElEQVR4nO3dO24U
QRSF4b+moW3bJGJiIiIiIiIiIiIiIiIiIiIiIiIiYmbm7c7MzuzrPuTNTpUpS5co
... SNIPPED MIDSECTION ...
Z2t9T0==
`;


// ---------------------------------------------------------
// ðŸŸ¤ JUPITER (8K banded texture)
// ---------------------------------------------------------
TEX_JUPITER = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAFMklEQVR4nO3dUY7T
QRiA4X8mRbsyJSkpJSWlpCQlJSWlpCQlJSWlpCQlJSX9jMtm1rOzO3tz78s9txxG
... SNIPPED MIDSECTION ...
QzSyqT8=
`;


// ---------------------------------------------------------
// ðŸª SATURN (surface texture)
// ---------------------------------------------------------
TEX_SATURN = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEK0lEQVR4nO3cQW4U
QRiG4X9MWu2KKUpSSpIkpZSSpIkpZSSpIkpZSSpIkpZSSpIkpZSSpJPnNObmbm7Z8
... SNIPPED MIDSECTION ...
gKxdkCc=
`;


// ---------------------------------------------------------
// ðŸ’ SATURN RINGS (alpha masked ring texture)
// ---------------------------------------------------------
TEX_SATURN_RINGS = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEQElEQVR4nO3dQW7T
QRiG4e9MVe2KKUpTSZKkEpTSZKkEpTSZKkEpTSZKkEpTSZKkEpTSZNPOvZmZmbd8
... SNIPPED MIDSECTION ...
mtW8bA==
`;
// ======================================================================
// BLOCK 6 â€” URANUS + NEPTUNE + PLUTO + STARFIELD BACKGROUND
// ======================================================================


// ---------------------------------------------------------
// ðŸŸ¦ URANUS (smooth cyan atmosphere)
// ---------------------------------------------------------
TEX_URANUS = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEM0lEQVR4nO3cMU4T
QRiA4e8mRbslKUmSpCRJkqQkSZKkJEmSpCRJkqQkSfrHPbMzOzv7vN+8d6q6tSpUq
... SNIPPED MIDSECTION ...
BQwup1o=
`;


// ---------------------------------------------------------
// ðŸ”µ NEPTUNE (deep blue high-altitude haze)
// ---------------------------------------------------------
TEX_NEPTUNE = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAENElEQVR4nO3cQW4U
QRiA4d8mRbslKUmSpCRJkqQkSZKkJEmSpCRJkqQkSfqnN+ZmZmbu+z3fN2rbtSpVq
... SNIPPED MIDSECTION ...
a3Q2lEs=
`;


// ---------------------------------------------------------
// ðŸŒ‘ PLUTO (icy dwarf planet with rough patches)
// ---------------------------------------------------------
TEX_PLUTO = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEOElEQVR4nO3cQW7b
QRiG4b8mRbs1KUmSpCRJkqQkSZKkJEmSpCRJkqQkSfoDO2bWZmZ2Z/v5n3fvW7du
... SNIPPED MIDSECTION ...
eYjX9qs=
`;


// ---------------------------------------------------------
// âœ¨ STARFIELD BACKGROUND (high-density galaxy-style skybox)
// ---------------------------------------------------------
TEX_STARFIELD = `
iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAABWESU3AAAEUklEQVR4nO3dMUXT
QRiA4X8mRbsyFRUVFRUVFRUVFRUVFRUVFRUVFf5jMzu7s2dmZmdz3+d9r7c7u3bt
... SNIPPED MIDSECTION ...
FzYwVZQ=
`;
// ======================================================================
// BLOCK 7 â€” ORBIT ENGINE, CAMERA, LABELS, TIME-WARP, PLANET TRAILS
// ======================================================================

// -----------------------------
// âš™ï¸ SIMULATION SETTINGS
// -----------------------------
let SIM_SPEED = 1.0;           // Global time scale
let TRAIL_LENGTH = 200;        // Number of points in orbit trails
let SHOW_LABELS = true;

// -----------------------------
// ðŸ“ PLANET ORBIT DATA (AU + years)
// -----------------------------
const ORBITS = {
    mercury: { radius: 0.39, period: 0.24 },
    venus:   { radius: 0.72, period: 0.62 },
    earth:   { radius: 1.00, period: 1.00 },
    mars:    { radius: 1.52, period: 1.88 },
    jupiter: { radius: 5.20, period: 11.86 },
    saturn:  { radius: 9.58, period: 29.45 },
    uranus:  { radius: 19.2, period: 84.02 },
    neptune: { radius: 30.1, period: 164.8 },
    pluto:   { radius: 39.5, period: 248.0 }
};

// Multiply orbits so they look good on screen
const AU = 5;  // scaling factor -> makes inner planets visible

// -----------------------------
// ðŸŒ CREATE ORBITING PLANETS
// -----------------------------
let planets = {};

function createPlanet(name, size, textureBase64) {
    let sphere = BABYLON.MeshBuilder.CreateSphere(name, { diameter: size }, scene);
    let mat = new BABYLON.StandardMaterial(name + "_mat", scene);
    mat.diffuseTexture = new BABYLON.Texture("data:image/png;base64," + textureBase64, scene);
    mat.specularColor = new BABYLON.Color3(0,0,0);
    sphere.material = mat;

    // Orbit trail
    sphere.trail = [];
    let trailMesh = BABYLON.MeshBuilder.CreateLines(name + "_trail", { points: [] }, scene);
    sphere.trailMesh = trailMesh;

    // Label
    if (SHOW_LABELS) {
        let plane = BABYLON.MeshBuilder.CreatePlane(name + "_label", { size: 1 }, scene);
        let labelMat = new BABYLON.StandardMaterial(name + "_label_mat", scene);
        labelMat.diffuseTexture = new BABYLON.DynamicTexture(name + "_dt", { width: 256, height: 64 }, scene);
        labelMat.diffuseTexture.drawText(name.toUpperCase(), 20, 45, "20px Arial", "white", "transparent");
        labelMat.emissiveColor = new BABYLON.Color3(1,1,1);
        plane.material = labelMat;
        plane.parent = sphere;
        plane.position.y = size * 0.8;
        sphere.label = plane;
    }

    planets[name] = sphere;
}

// -----------------------------
// ðŸŒ€ UPDATE ORBITS EACH FRAME
// -----------------------------
scene.onBeforeRenderObservable.add(() => {
    let t = performance.now() * 0.0001 * SIM_SPEED;

    for (let name in planets) {
        let P = planets[name];
        let O = ORBITS[name];

        if (!O) continue;

        let angle = t * (1 / O.period);

        // Calculate orbit position
        let x = Math.cos(angle * 6.28) * O.radius * AU;
        let z = Math.sin(angle * 6.28) * O.radius * AU;

        P.position.x = x;
        P.position.z = z;

        // TRAIL SYSTEM
        P.trail.push(new BABYLON.Vector3(x, 0, z));
        if (P.trail.length > TRAIL_LENGTH) P.trail.shift();
        P.trailMesh = BABYLON.MeshBuilder.CreateLines(name + "_trail", { points: P.trail }, scene, true);
    }
});

// -----------------------------
// ðŸŽ¥ CAMERA FOLLOW SYSTEM
// -----------------------------
let followPlanet = null;

scene.onKeyboardObservable.add((kb) => {
    // Number keys follow planets
    const MAP = ["mercury","venus","earth","mars","jupiter","saturn","uranus","neptune","pluto"];

    if (kb.event.key >= "1" && kb.event.key <= "9") {
        followPlanet = MAP[parseInt(kb.event.key)-1];
        console.log("Following:", followPlanet);
    }

    // Speed up simulation
    if (kb.event.key === "+") SIM_SPEED *= 1.2;
    if (kb.event.key === "-") SIM_SPEED /= 1.2;
});

// Camera tracking loop
scene.registerBeforeRender(() => {
    if (followPlanet && planets[followPlanet]) {
        let P = planets[followPlanet];

        camera.target = P.position;
        camera.position = P.position.add(new BABYLON.Vector3(5, 3, 5));
    }
});

// -----------------------------
// ðŸŒž INITIALISE ALL PLANETS
// -----------------------------
// Inner planets
createPlanet("mercury", 0.6, TEX_MERCURY);
createPlanet("venus",   0.9, TEX_VENUS);
createPlanet("earth",   1.0, TEX_EARTH);
createPlanet("mars",    0.7, TEX_MARS);

// Gas giants
createPlanet("jupiter", 2.0, TEX_JUPITER);
createPlanet("saturn",  1.8, TEX_SATURN);

// Ice giants + Pluto
createPlanet("uranus",  1.5, TEX_URANUS);
createPlanet("neptune", 1.5, TEX_NEPTUNE);
createPlanet("pluto",   0.5, TEX_PLUTO);

console.log("ðŸš€ Block 7: Orbit Engine + Camera + Labels + Time-Warp loaded!");
// ======================================================================
// BLOCK 8 â€” CME (CORONAL MASS EJECTION) ENGINE
// Procedural solar eruptions, shockwave rings, magnetic arcs,
// and planet-hit detection.
// ======================================================================

// -------------------------------------------------------------
// ðŸŒž SUN SETUP (must already exist before this block)
// -------------------------------------------------------------
let sun = BABYLON.MeshBuilder.CreateSphere("sun", { diameter: 3 }, scene);
let sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveTexture = new BABYLON.Texture("data:image/png;base64," + TEX_SUN_EMISSIVE, scene);
sun.material = sunMat;

// -------------------------------------------------------------
// ðŸ”¥ CME PARAMETERS
// -------------------------------------------------------------
let CME_ACTIVE = true;
let CME_MIN_INTERVAL = 4000;       // ms between eruptions
let CME_MAX_INTERVAL = 12000;

let CME_WAVE_SPEED = 0.08;         // outward expansion
let CME_WAVE_FADE = 0.006;

let CME_ARC_COUNT = 18;            // number of flare tendrils
let CME_ARC_HEIGHT = 1.4;
let CME_ARC_SPEED = 0.04;

// -------------------------------------------------------------
// ðŸŒ€ CME WAVE STRUCTURE
// -------------------------------------------------------------
let cmeWaves = [];

function spawnCMEWave(directionVec) {
    let ring = BABYLON.MeshBuilder.CreateTorus("cme_wave", {
        diameter: 4,
        thickness: 0.08,
        tessellation: 80
    }, scene);

    let mat = new BABYLON.StandardMaterial("cme_wave_mat", scene);
    mat.emissiveColor = new BABYLON.Color3(1.0, 0.6, 0.1);
    mat.alpha = 0.9;

    ring.material = mat;

    ring.position = sun.position.clone();
    ring.direction = directionVec.normalize();
    ring.scaleFactor = 1;

    cmeWaves.push(ring);
}

// -------------------------------------------------------------
// ðŸ”¥ SOLAR FLARE ARC TENDRILS
// -------------------------------------------------------------
function spawnCMEArcs(directionVec) {
    for (let i = 0; i < CME_ARC_COUNT; i++) {
        let arc = BABYLON.MeshBuilder.CreateCylinder("cme_arc", {
            height: 0.3,
            diameterTop: 0.02,
            diameterBottom: 0.2
        }, scene);

        let mat = new BABYLON.StandardMaterial("cme_arc_mat", scene);
        mat.emissiveColor = new BABYLON.Color3(1, 0.3, 0);
        arc.material = mat;

        let angle = (Math.PI * 2 * i) / CME_ARC_COUNT;
        arc.position = new BABYLON.Vector3(
            Math.cos(angle) * 1.4,
            Math.sin(angle) * 1.4,
            0
        );

        arc.direction = new BABYLON.Vector3(
            Math.cos(angle),
            Math.sin(angle),
            0
        );

        arc.growth = 0;
        arc.speed = CME_ARC_SPEED;

        cmeWaves.push(arc);
    }
}

// -------------------------------------------------------------
// ðŸ’¥ CME TRIGGER
// -------------------------------------------------------------
function triggerCME() {
    let dir = new BABYLON.Vector3(
        Math.random() - 0.5,
        Math.random() - 0.5,
        Math.random() - 0.5
    );

    console.log("%cðŸ”¥ CME ERUPTION TRIGGERED!", "color: orange; font-size: 18px;");

    spawnCMEWave(dir);
    spawnCMEArcs(dir);

    scheduleNextCME();
}

function scheduleNextCME() {
    if (!CME_ACTIVE) return;

    let wait = CME_MIN_INTERVAL + Math.random() * (CME_MAX_INTERVAL - CME_MIN_INTERVAL);
    setTimeout(triggerCME, wait);
}

// Start the first CME
scheduleNextCME();

// -------------------------------------------------------------
// ðŸª CHECK IF CME HITS PLANETS
// -------------------------------------------------------------
function checkCMEHits(wave) {
    for (let name in planets) {
        let P = planets[name];

        if (BABYLON.Vector3.Distance(wave.position, P.position) < wave.scaling.x * 2) {

            // Planet flash!
            let mat = P.material;
            let original = mat.emissiveColor.clone();

            mat.emissiveColor = new BABYLON.Color3(1, 0.3, 0);

            setTimeout(() => {
                mat.emissiveColor = original;
            }, 300);

            console.log("âš¡ Planet " + name + " hit by CME!");
        }
    }
}

// -------------------------------------------------------------
// ðŸ”„ UPDATE LOOP â€” ANIMATE WAVES AND ARCS
// -------------------------------------------------------------
scene.onBeforeRenderObservable.add(() => {
    for (let i = cmeWaves.length - 1; i >= 0; i--) {
        let w = cmeWaves[i];

        // CME RING
        if (w.name === "cme_wave") {
            w.scaling.x += CME_WAVE_SPEED;
            w.scaling.y += CME_WAVE_SPEED;
            w.scaling.z += CME_WAVE_SPEED;

            w.material.alpha -= CME_WAVE_FADE;

            checkCMEHits(w);

            if (w.material.alpha <= 0) {
                w.dispose();
                cmeWaves.splice(i, 1);
            }
        }

        // CME ARC TENDRILS
        if (w.name === "cme_arc") {
            w.growth += CME_ARC_SPEED;
            w.position.addInPlace(w.direction.scale(0.03));
            w.scaling.y = 1 + w.growth;

            if (w.growth > CME_ARC_HEIGHT) {
                w.dispose();
                cmeWaves.splice(i, 1);
            }
        }
    }
});

console.log("ðŸŒž Block 8: CME Engine loaded!");
// ======================================================================
// BLOCK 9 â€” SOLAR WIND, AURORAS, NIGHT-GLOW, RADIATION PRESSURE
// ======================================================================

// -------------------------------------------------------------
// ðŸŒ¬ï¸ SOLAR WIND PARTICLE SYSTEM
// -------------------------------------------------------------
let solarWind = new BABYLON.ParticleSystem("solarWind", 4000, scene);

solarWind.particleTexture = new BABYLON.Texture("data:image/png;base64," + TEX_SOLAR_WIND, scene);
solarWind.emitter = sun; 
solarWind.minEmitBox = new BABYLON.Vector3(-0.1, -0.1, -0.1);
solarWind.maxEmitBox = new BABYLON.Vector3(0.1, 0.1, 0.1);

solarWind.color1 = new BABYLON.Color4(1, 0.6, 0.2, 1);
solarWind.color2 = new BABYLON.Color4(1, 0.3, 0.05, 0.8);
solarWind.colorDead = new BABYLON.Color4(0.5, 0.2, 0, 0);

solarWind.minSize = 0.02;
solarWind.maxSize = 0.06;

solarWind.minLifeTime = 2;
solarWind.maxLifeTime = 4;

solarWind.emitRate = 800;

solarWind.direction1 = new BABYLON.Vector3(-1, -0.2, -1);
solarWind.direction2 = new BABYLON.Vector3(1, 0.2, 1);

solarWind.minEmitPower = 0.2;
solarWind.maxEmitPower = 0.6;

solarWind.updateSpeed = 0.01;
solarWind.start();


// -------------------------------------------------------------
// ðŸŒˆ AURORA MATERIAL (shared by all planets)
// -------------------------------------------------------------
function makeAuroraMat(color) {
    let mat = new BABYLON.StandardMaterial("auroraMat", scene);
    mat.emissiveColor = color;
    mat.alpha = 0.35;
    mat.backFaceCulling = false;
    return mat;
}

let auroraBlue = makeAuroraMat(new BABYLON.Color3(0.2, 0.6, 1.0));   // Earth
let auroraRed  = makeAuroraMat(new BABYLON.Color3(1.0, 0.2, 0.2));   // Mars
let auroraCyan = makeAuroraMat(new BABYLON.Color3(0.3, 1.0, 1.0));   // Gas giants


// -------------------------------------------------------------
// ðŸŒŒ CREATE AURORA HALOS AROUND PLANETS
// -------------------------------------------------------------
function addAuroraToPlanet(planet, scale = 1.4, mat = auroraBlue) {
    let halo = BABYLON.MeshBuilder.CreateSphere(planet.name + "_aurora", {
        diameter: planet.scaling.x * scale * 2
    }, scene);

    halo.material = mat;
    halo.parent = planet;
    halo.isPickable = false;

    planet.aurora = halo;
}

addAuroraToPlanet(planets["earth"],   1.4, auroraBlue);
addAuroraToPlanet(planets["mars"],    1.3, auroraRed);
addAuroraToPlanet(planets["jupiter"], 1.5, auroraCyan);
addAuroraToPlanet(planets["saturn"],  1.5, auroraCyan);
addAuroraToPlanet(planets["uranus"],  1.5, auroraCyan);
addAuroraToPlanet(planets["neptune"], 1.5, auroraCyan);


// -------------------------------------------------------------
// ðŸŒ— NIGHT-SIDE GLOW (cities, thermal glow, IR)
// -------------------------------------------------------------
function addNightGlow(planet, glowColor) {
    let glow = BABYLON.MeshBuilder.CreateSphere(planet.name + "_nightglow", {
        diameter: planet.scaling.x * 1.01 * 2
    }, scene);

    let mat = new BABYLON.StandardMaterial("nightglowMat", scene);
    mat.emissiveColor = glowColor;
    mat.alpha = 0.25;
    glow.material = mat;

    glow.parent = planet;
    planet.nightGlow = glow;
}

addNightGlow(planets["earth"], new BABYLON.Color3(0.9, 0.7, 0.3));
addNightGlow(planets["mars"],  new BABYLON.Color3(0.4, 0.2, 0.1));


// -------------------------------------------------------------
// ðŸ’¨ RADIATION PRESSURE â€” Day/Night flattening
// -------------------------------------------------------------
scene.onBeforeRenderObservable.add(() => {
    for (let name in planets) {
        let P = planets[name];

        // Vector from sun to planet
        let dir = P.position.subtract(sun.position).normalize();

        // Stretch the planet slightly away from sun
        let flatten = 1 + 0.02 * Math.max(0, dir.x * 0.2 + dir.z * 0.2);

        P.scaling.y = flatten;

        // Aurora pulsing
        if (P.aurora) {
            P.aurora.scaling.x = 1 + Math.sin(performance.now() * 0.001) * 0.05;
            P.aurora.scaling.y = 1 + Math.sin(performance.now() * 0.001 + 1) * 0.05;
        }
    }
});


// -------------------------------------------------------------
// ðŸŒŒ MAGNETIC FIELD ARC-LINES (Earth + Jupiter)
// -------------------------------------------------------------
function magneticFieldLines(planet, count = 16) {
    for (let i = 0; i < count; i++) {
        let angle = (Math.PI * 2 * i) / count;

        let arc = BABYLON.MeshBuilder.CreateCylinder(planet.name + "_magarc", {
            diameterTop: 0.05,
            diameterBottom: 0.05,
            height: planet.scaling.x * 4
        }, scene);

        arc.position = new BABYLON.Vector3(
            Math.cos(angle) * planet.scaling.x * 0.7,
            0,
            Math.sin(angle) * planet.scaling.x * 0.7
        );

        arc.rotation = new BABYLON.Vector3(Math.PI / 2, angle, 0);
        arc.material = auroraBlue;
        arc.parent = planet;
    }
}

magneticFieldLines(planets["earth"]);
magneticFieldLines(planets["jupiter"]);

console.log("ðŸŒ¬ï¸ Block 9: Solar Wind + Auroras + Night Glow + Magnetic Fields loaded!");
// ======================================================================
// BLOCK 10 â€” ASTEROID BELT, KUIPER BELT, COMETS, METEOR IMPACTS
// ======================================================================

// -------------------------------------------------------------
// ðŸª¨ ASTEROID BELT GENERATOR (procedural)
// -------------------------------------------------------------

let asteroidBelt = [];

function createAsteroidBelt(count = 800) {
    for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let radius = 12 + Math.random() * 4;        // asteroid belt AU scale
        let height = (Math.random() - 0.5) * 0.6;   // belt thickness

        let asteroid = BABYLON.MeshBuilder.CreateSphere("ast" + i, {
            diameter: 0.05 + Math.random() * 0.05
        }, scene);

        let mat = new BABYLON.StandardMaterial("astMat" + i, scene);
        mat.diffuseColor = new BABYLON.Color3(
            0.5 + Math.random()*0.3,
            0.4 + Math.random()*0.2,
            0.3
        );
        asteroid.material = mat;

        asteroid.position = new BABYLON.Vector3(
            Math.cos(angle) * radius,
            height,
            Math.sin(angle) * radius
        );

        asteroid.angle = angle;
        asteroid.radius = radius;
        asteroid.speed = 0.002 + Math.random() * 0.003;

        asteroidBelt.push(asteroid);
    }
}

createAsteroidBelt();


// -------------------------------------------------------------
// â„ï¸ KUIPER BELT (beyond Neptune)
// -------------------------------------------------------------

let kuiperBelt = [];

function createKuiperBelt(count = 600) {
    for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let radius = 45 + Math.random() * 15;
        let height = (Math.random() - 0.5) * 2;

        let ice = BABYLON.MeshBuilder.CreateSphere("kb" + i, {
            diameter: 0.06 + Math.random() * 0.05
        }, scene);

        let mat = new BABYLON.StandardMaterial("kbMat" + i, scene);
        mat.diffuseColor = new BABYLON.Color3(0.7, 0.9, 1.0);
        mat.alpha = 0.9;
        ice.material = mat;

        ice.position = new BABYLON.Vector3(
            Math.cos(angle) * radius,
            height,
            Math.sin(angle) * radius
        );

        ice.angle = angle;
        ice.radius = radius;
        ice.speed = 0.0007 + Math.random() * 0.0012;

        kuiperBelt.push(ice);
    }
}

createKuiperBelt();


// -------------------------------------------------------------
// â˜„ï¸ COMET ENGINE
// -------------------------------------------------------------

let comets = [];

function spawnComet() {
    let comet = BABYLON.MeshBuilder.CreateSphere("comet", { diameter: 0.2 }, scene);
    let mat = new BABYLON.StandardMaterial("cometMat", scene);
    mat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.8);
    comet.material = mat;

    // Starting at outer region
    comet.position = new BABYLON.Vector3(
        -60 + Math.random() * 120,
        (Math.random() - 0.5) * 10,
        -60 + Math.random() * 120
    );

    comet.velocity = comet.position.scale(-0.003); // heads toward sun
    comet.tailPoints = [];

    // Tail line renderer
    comet.tailMesh = BABYLON.MeshBuilder.CreateLines("comet_tail", { points: [] }, scene);

    comets.push(comet);

    // Spawn new comet periodically
    setTimeout(spawnComet, 15000 + Math.random() * 15000);
}

spawnComet();


// -------------------------------------------------------------
// ðŸ’¥ METEOR IMPACTS
// -------------------------------------------------------------

function meteorImpact(planet) {
    // Flash burst
    let flash = BABYLON.MeshBuilder.CreateSphere("impactFlash", {
        diameter: planet.scaling.x * 2
    }, scene);

    let mat = new BABYLON.StandardMaterial("impactMat", scene);
    mat.emissiveColor = new BABYLON.Color3(1, 0.4, 0);
    mat.alpha = 0.8;
    flash.material = mat;

    flash.position = planet.position.clone();

    // Shrink & fade
    let life = 0;
    scene.onBeforeRenderObservable.add(function fade() {
        life += 0.02;
        flash.scaling.scaleInPlace(0.96);
        mat.alpha *= 0.92;

        if (mat.alpha < 0.05) {
            flash.dispose();
            scene.onBeforeRenderObservable.removeCallback(fade);
        }
    });

    console.log(`ðŸ’¥ Meteor impact on ${planet.name}!`);
}


// -------------------------------------------------------------
// ðŸ”„ UPDATE LOOP â€” ANIMATE ASTEROIDS, KUIPER BELT, COMETS
// -------------------------------------------------------------
scene.onBeforeRenderObservable.add(() => {
    // Asteroids orbit
    asteroidBelt.forEach(a => {
        a.angle += a.speed;
        a.position.x = Math.cos(a.angle) * a.radius;
        a.position.z = Math.sin(a.angle) * a.radius;
    });

    // Kuiper belt icy bodies
    kuiperBelt.forEach(k => {
        k.angle += k.speed;
        k.position.x = Math.cos(k.angle) * k.radius;
        k.position.z = Math.sin(k.angle) * k.radius;
    });

    // Comet motion + tail
    comets.forEach(c => {
        c.position.addInPlace(c.velocity);

        // Tail points trail behind comet
        c.tailPoints.push(c.position.clone());
        if (c.tailPoints.length > 40) c.tailPoints.shift();

        c.tailMesh = BABYLON.MeshBuilder.CreateLines(
            "comet_tail",
            { points: c.tailPoints },
            scene,
            true
        );

        // Check if comet hits a planet
        for (let name in planets) {
            let P = planets[name];
            if (BABYLON.Vector3.Distance(c.position, P.position) < P.scaling.x * 1.2) {
                meteorImpact(P);
                c.dispose();
            }
        }
    });
});

console.log("ðŸª Block 10: Asteroid Belt + Kuiper Belt + Comets + Impacts loaded!");// ======================================================================
// BLOCK 11 â€” GALAXY SKYBOX + BLACK HOLE LENSING + PULSAR + COSMIC RAYS
// ======================================================================


// -------------------------------------------------------------
// ðŸŒŒ GALACTIC BACKDROP (procedural HDR stars)
// -------------------------------------------------------------
let galaxy = BABYLON.MeshBuilder.CreateSphere("galaxy_sky", {
    diameter: 500,
    sideOrientation: BABYLON.Mesh.BACKSIDE
}, scene);

let galaxyMat = new BABYLON.StandardMaterial("galaxyMat", scene);
galaxyMat.emissiveTexture = new BABYLON.Texture("data:image/png;base64," + TEX_GALAXY, scene);
galaxyMat.disableLighting = true;
galaxy.material = galaxyMat;

// Slow rotation for immersion
scene.onBeforeRenderObservable.add(() => {
    galaxy.rotation.y += 0.00002;
});


// -------------------------------------------------------------
// ðŸ•³ï¸ BLACK HOLE WITH LENSING RING
// -------------------------------------------------------------
let blackHole = BABYLON.MeshBuilder.CreateSphere("blackHole", {
    diameter: 2
}, scene);
blackHole.position = new BABYLON.Vector3(-80, 0, 0);

let bhMat = new BABYLON.StandardMaterial("bhMat", scene);
bhMat.emissiveColor = new BABYLON.Color3(0, 0, 0);
bhMat.disableLighting = true;
blackHole.material = bhMat;

// Accretion disk
let accretion = BABYLON.MeshBuilder.CreateTorus("accretion", {
    diameter: 6,
    thickness: 1.2,
    tessellation: 120
}, scene);

let accMat = new BABYLON.StandardMaterial("accMat", scene);
accMat.emissiveTexture = new BABYLON.Texture("data:image/png;base64," + TEX_ACCRETION, scene);
accMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
accretion.material = accMat;
accretion.position = blackHole.position.clone();
accretion.rotation.x = Math.PI / 2;

// GR-style distortion (fake but effective)
scene.registerBeforeRender(() => {
    accretion.rotation.z += 0.01;
});


// -------------------------------------------------------------
// ðŸŒŸ PULSAR â€” sweeping light-beam beacon
// -------------------------------------------------------------
let pulsar = BABYLON.MeshBuilder.CreateSphere("pulsar", {
    diameter: 1.2
}, scene);
pulsar.position = new BABYLON.Vector3(100, 40, -120);

let pulsarMat = new BABYLON.StandardMaterial("pulsarMat", scene);
pulsarMat.emissiveColor = new BABYLON.Color3(0.8, 0.8, 1);
pulsar.material = pulsarMat;

// Pulsar beam
let beam = BABYLON.MeshBuilder.CreateCylinder("pulsarBeam", {
    height: 200,
    diameterTop: 0.2,
    diameterBottom: 0.2
}, scene);

let beamMat = new BABYLON.StandardMaterial("beamMat", scene);
beamMat.emissiveColor = new BABYLON.Color3(0.5, 0.6, 1);
beam.material = beamMat;

beam.position = pulsar.position.clone();
beam.rotation.x = Math.PI / 2;

// Sweep rotation
scene.registerBeforeRender(() => {
    beam.rotation.z += 0.05;
});


// -------------------------------------------------------------
// âš¡ COSMIC RAY PARTICLE STREAKS
// -------------------------------------------------------------
let cosmicRays = [];

function spawnCosmicRay() {
    let origin = new BABYLON.Vector3(
        -250 + Math.random() * 500,
        -250 + Math.random() * 500,
        -250 + Math.random() * 500
    );

    let ray = BABYLON.MeshBuilder.CreateSphere("cosmicRay", { diameter: 0.15 }, scene);
    ray.position = origin;

    let dir = new BABYLON.Vector3(
        (Math.random() - 0.5) * 0.2,
        (Math.random() - 0.5) * 0.2,
        (Math.random() - 0.5) * 0.2
    );

    let mat = new BABYLON.StandardMaterial("rayMat", scene);
    mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
    ray.material = mat;

    ray.velocity = dir;
    cosmicRays.push(ray);

    setTimeout(spawnCosmicRay, 500 + Math.random() * 500);
}

spawnCosmicRay();


// Update cosmic rays
scene.onBeforeRenderObservable.add(() => {
    for (let i = cosmicRays.length - 1; i >= 0; i--) {
        let r = cosmicRays[i];
        r.position.addInPlace(r.velocity);

        if (BABYLON.Vector3.Distance(r.position, camera.position) > 300) {
            r.dispose();
            cosmicRays.splice(i, 1);
        }
    }
});

console.log("ðŸŒŒ Block 11: Galaxy + Black Hole + Pulsar + Cosmic Rays loaded!");
