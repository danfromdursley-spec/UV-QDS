<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>QDS Solar System Sandbox</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #05060a;
      color: #f5f5f5;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }

    #qdsPanel {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      max-width: 420px;
      background: rgba(8, 10, 20, 0.92);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 6px 10px 8px;
      font-size: 11px;
      z-index: 10;
      backdrop-filter: blur(6px);
    }

    #qdsPanel h1 {
      margin: 0 0 4px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #qdsPanel h1 span.emoji {
      font-size: 14px;
    }

    .slider-row {
      margin: 3px 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .slider-row label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 10px;
      opacity: 0.9;
    }

    .slider-row input[type="range"] {
      width: 100%;
    }

    .controls-row {
      display: flex;
      gap: 6px;
      margin-top: 4px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 10px;
    }

    select, button {
      background: #111320;
      color: #f5f5f5;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 2px 6px;
      font-size: 10px;
    }

    button {
      cursor: pointer;
    }

    .hint {
      margin-top: 4px;
      font-size: 9px;
      opacity: 0.85;
    }

    @media (min-width: 768px) {
      #qdsPanel {
        left: 10px;
        top: 10px;
        max-width: 420px;
      }
    }
  </style>
</head>
<body>
<div id="qdsPanel">
  <h1><span class="emoji">ü™ê</span> QDS Solar System Sandbox <span class="emoji">üé©</span></h1>
  <div class="slider-row">
    <label>
      Spatial correlation Œª<sub>c</sub>
      <span id="lambdaLabel">1.0</span>
    </label>
    <input id="lambdaSlider" type="range" min="0" max="1" step="0.01" value="0.7">
  </div>

  <div class="slider-row">
    <label>
      Temporal correlation œÑ<sub>c</sub>
      <span id="tauLabel">1.0</span>
    </label>
    <input id="tauSlider" type="range" min="0" max="1" step="0.01" value="0.6">
  </div>

  <div class="slider-row">
    <label>
      Field amplitude A
      <span id="ampLabel">0.2</span>
    </label>
    <input id="ampSlider" type="range" min="0" max="1" step="0.01" value="0.2">
  </div>

  <div class="controls-row">
    <label>
      Orbit mode:
      <select id="orbitMode">
        <option value="clean">Clean Keplerian</option>
        <option value="qds">QDS-perturbed</option>
      </select>
    </label>

    <label>
      <input id="orbitTrails" type="checkbox" checked>
      Show trails
    </label>

    <label>
      Speed:
      <input id="speedSlider" type="range" min="0.2" max="3" step="0.1" value="1.0">
    </label>
  </div>

  <div class="hint">
    Drag to orbit ‚Ä¢ Pinch / scroll to zoom ‚Ä¢ QDS kernel gently perturbs the orbits.
    Pluto included because respect. üßä
  </div>
</div>

<canvas id="renderCanvas"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>

<script>
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, {
    preserveDrawingBuffer: true,
    stencil: true
  });

  const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.02, 0.03, 0.06, 1);

    // Camera
    const camera = new BABYLON.ArcRotateCamera(
      "camera",
      -Math.PI / 2.5,
      Math.PI / 2.4,
      40,
      new BABYLON.Vector3(0, 0, 0),
      scene
    );
    camera.attachControl(canvas, true);
    camera.lowerRadiusLimit = 15;
    camera.upperRadiusLimit = 120;

    // Light
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    const sunLight = new BABYLON.PointLight("sunLight", new BABYLON.Vector3(0, 0, 0), scene);
    sunLight.intensity = 2.2;

    // Sun
    const sun = BABYLON.MeshBuilder.CreateSphere("sun", {diameter: 3.5, segments: 32}, scene);
    const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
    sunMat.emissiveColor = new BABYLON.Color3(1.2, 0.95, 0.4);
    sunMat.diffuseColor = BABYLON.Color3.Black();
    sun.material = sunMat;

    // QDS vacuum grid (blue dots)
    const vacuumNodes = [];
    const gridSize = 26;
    const step = 2;
    for (let x = -gridSize; x <= gridSize; x += step) {
      for (let z = -gridSize; z <= gridSize; z += step) {
        const node = BABYLON.MeshBuilder.CreateSphere("vNode", {diameter: 0.25, segments: 6}, scene);
        node.position.x = x;
        node.position.z = z;
        node.position.y = -0.5;
        const mat = new BABYLON.StandardMaterial("vMat", scene);
        mat.emissiveColor = new BABYLON.Color3(0.2, 0.8, 1.4);
        mat.specularColor = BABYLON.Color3.Black();
        mat.diffuseColor = BABYLON.Color3.Black();
        node.material = mat;
        vacuumNodes.push(node);
      }
    }

    // Planet data (roughly scaled)
    const planetDefs = [
      { name: "Mercury", color: new BABYLON.Color3(0.76, 0.76, 0.76), orbitRadius: 5, size: 0.35, period: 0.24 },
      { name: "Venus",   color: new BABYLON.Color3(0.91, 0.72, 0.39), orbitRadius: 7, size: 0.55, period: 0.62 },
      { name: "Earth",   color: new BABYLON.Color3(0.3, 0.6, 1.0),    orbitRadius: 9, size: 0.6,  period: 1.0 },
      { name: "Mars",    color: new BABYLON.Color3(1.0, 0.43, 0.25),  orbitRadius: 11, size: 0.45, period: 1.88 },
      { name: "Jupiter", color: new BABYLON.Color3(0.97, 0.84, 0.60), orbitRadius: 15, size: 1.1,  period: 11.86 },
      { name: "Saturn",  color: new BABYLON.Color3(0.97, 0.91, 0.70), orbitRadius: 19, size: 1.0,  period: 29.46 },
      { name: "Uranus",  color: new BABYLON.Color3(0.64, 0.90, 0.98), orbitRadius: 23, size: 0.9,  period: 84 },
      { name: "Neptune", color: new BABYLON.Color3(0.35, 0.65, 1.0),  orbitRadius: 27, size: 0.9,  period: 164.8 },
      { name: "Pluto",   color: new BABYLON.Color3(0.82, 0.72, 0.60), orbitRadius: 31, size: 0.4,  period: 248 }
    ];

    const planets = [];
    const trails = [];

    const orbitMat = new BABYLON.StandardMaterial("orbitMat", scene);
    orbitMat.emissiveColor = new BABYLON.Color3(0.3, 0.4, 0.6);
    orbitMat.diffuseColor = BABYLON.Color3.Black();
    orbitMat.alpha = 0.4;

    // Orbits + planets
    planetDefs.forEach((p, idx) => {
      // Orbit ring
      const orbitPoints = [];
      const steps = 120;
      for (let i = 0; i <= steps; i++) {
        const angle = i / steps * Math.PI * 2;
        orbitPoints.push(new BABYLON.Vector3(
          Math.cos(angle) * p.orbitRadius,
          0,
          Math.sin(angle) * p.orbitRadius
        ));
      }
      const orbit = BABYLON.MeshBuilder.CreateLines("orbit_" + p.name, {
        points: orbitPoints
      }, scene);
      orbit.color = new BABYLON.Color3(0.25, 0.35, 0.55);

      // Planet mesh
      const mesh = BABYLON.MeshBuilder.CreateSphere(p.name, {
        diameter: p.size * 2,
        segments: 16
      }, scene);
      const mat = new BABYLON.StandardMaterial("mat_" + p.name, scene);
      mat.emissiveColor = p.color;
      mat.diffuseColor = BABYLON.Color3.Black();
      mat.specularColor = BABYLON.Color3.Black();
      mesh.material = mat;

      mesh.position = new BABYLON.Vector3(p.orbitRadius, 0, 0);

      planets.push({
        def: p,
        mesh,
        angle: Math.random() * Math.PI * 2
      });

      // Simple trail using a line that we update
      const trailPts = [];
      for (let i = 0; i < 40; i++) {
        trailPts.push(mesh.position.clone());
      }
      const trail = BABYLON.MeshBuilder.CreateLines("trail_" + p.name, {points: trailPts}, scene);
      trail.color = p.color.scale(0.6);
      trails.push({mesh: trail, points: trailPts});
    });

    // UI elements
    const lambdaSlider = document.getElementById("lambdaSlider");
    const tauSlider    = document.getElementById("tauSlider");
    const ampSlider    = document.getElementById("ampSlider");
    const lambdaLabel  = document.getElementById("lambdaLabel");
    const tauLabel     = document.getElementById("tauLabel");
    const ampLabel     = document.getElementById("ampLabel");
    const orbitModeSel = document.getElementById("orbitMode");
    const orbitTrails  = document.getElementById("orbitTrails");
    const speedSlider  = document.getElementById("speedSlider");

    const updateLabels = () => {
      const lambdaC = 0.3 + 2.0 * parseFloat(lambdaSlider.value);
      const tauC    = 0.3 + 2.0 * parseFloat(tauSlider.value);
      const amp     = 0.0 + 0.5 * parseFloat(ampSlider.value);

      lambdaLabel.textContent = lambdaC.toFixed(2);
      tauLabel.textContent    = tauC.toFixed(2);
      ampLabel.textContent    = amp.toFixed(2);
    };
    lambdaSlider.oninput = tauSlider.oninput = ampSlider.oninput = updateLabels;
    updateLabels();

    let startTime = performance.now();

    scene.onBeforeRenderObservable.add(() => {
      const now = performance.now();
      const dt = engine.getDeltaTime() / 1000;
      const t = (now - startTime) / 1000;

      const lambdaC = 0.3 + 2.0 * parseFloat(lambdaSlider.value); // "size" of patches
      const tauC    = 0.3 + 2.0 * parseFloat(tauSlider.value);    // time scale
      const amp     = 0.0 + 0.5 * parseFloat(ampSlider.value);    // perturbation strength
      const mode    = orbitModeSel.value;
      const simSpeed = parseFloat(speedSlider.value);

      // Drive vacuum grid height with a smooth kernel-like bump
      const lambdaScale = 12 * lambdaC;
      const invLambda2 = 1.0 / (2 * lambdaScale * lambdaScale);
      vacuumNodes.forEach((node) => {
        const r2 = node.position.x * node.position.x + node.position.z * node.position.z;
        const env = Math.exp(-r2 * invLambda2);
        const phase = (r2 * 0.02) + t / tauC;
        const y = -0.8 + amp * 2.2 * env * Math.sin(phase);
        node.position.y = y;
      });

      // Planets
      const baseSpeed = 1.0; // overall scale

      planets.forEach((p, idx) => {
        const def = p.def;
        const period = def.period;
        p.angle += dt * simSpeed * baseSpeed / period;

        // Base circular orbit
        let r = def.orbitRadius;

        if (mode === "qds") {
          // QDS perturbation: small radial wiggle depending on radius & time
          const env = Math.exp(-r * 0.04 * (1.0 / lambdaC));
          const noise =
            amp * r * 0.3 *
            env *
            Math.sin(t / tauC + r * 0.3 + idx * 1.7);
          r = def.orbitRadius + noise;
        }

        const x = Math.cos(p.angle) * r;
        const z = Math.sin(p.angle) * r;

        // Tiny inclination so the system doesn't look completely flat
        const inc = 0.02 * idx;
        const y = Math.sin(inc) * z * 0.05;

        p.mesh.position.set(x, y, z);

        // Trails
        const trailObj = trails[idx];
        trailObj.mesh.setEnabled(orbitTrails.checked);
        if (orbitTrails.checked) {
          trailObj.points.pop();
          trailObj.points.unshift(p.mesh.position.clone());
          trailObj.mesh = BABYLON.MeshBuilder.CreateLines(null, {
            points: trailObj.points,
            instance: trailObj.mesh
          });
        }
      });

      // Slight intensity pulse from QDS amplitude
      sunLight.intensity = 1.8 + amp * 0.8;
    });

    return scene;
  };

  const scene = createScene();

  engine.runRenderLoop(() => {
    scene.render();
  });

  window.addEventListener("resize", () => {
    engine.resize();
  });
</script>
</body>
</html>
