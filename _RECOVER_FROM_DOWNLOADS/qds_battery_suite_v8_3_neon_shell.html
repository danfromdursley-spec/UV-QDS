<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QDS Battery Suite v8.3 â€” Neon Shell ðŸ”‹ðŸŽ©</title>
<style>
  :root {
    --bg: #050710;
    --card: #111827;
    --card-soft: #0b1020;
    --accent: #4ade80;
    --accent-soft: rgba(74, 222, 128, 0.2);
    --accent-strong: #22c55e;
    --text-main: #e5e7eb;
    --text-muted: #9ca3af;
    --danger: #f97373;
    --border-subtle: #1f2937;
    --font-mono: "JetBrains Mono", "Fira Code", Consolas, monospace;
    --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    padding: 0;
    background: radial-gradient(circle at top, #111827 0, #020617 55%, #000 100%);
    color: var(--text-main);
    font-family: var(--font-sans);
  }

  .app {
    max-width: 1200px;
    margin: 12px auto 24px;
    padding: 12px;
  }

  header.app-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.9));
    border-radius: 18px;
    padding: 10px 14px;
    border: 1px solid var(--border-subtle);
    box-shadow: 0 14px 40px rgba(0, 0, 0, 0.5);
  }

  .title-block {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .title-row {
    display: flex;
    align-items: baseline;
    gap: 8px;
  }

  .title-row h1 {
    margin: 0;
    font-size: 18px;
    letter-spacing: 0.03em;
  }

  .pill {
    font-size: 11px;
    border-radius: 999px;
    padding: 2px 8px;
    border: 1px solid rgba(148, 163, 184, 0.4);
    color: var(--text-muted);
    background: rgba(15, 23, 42, 0.8);
  }

  .title-sub {
    font-size: 11px;
    color: var(--text-muted);
  }

  .header-right {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  /* Battery shell */
  .battery-shell {
    display: flex;
    align-items: center;
    gap: 10px;
    background: radial-gradient(circle at 10% 0, rgba(74, 222, 128, 0.15), transparent 55%),
                radial-gradient(circle at 90% 100%, rgba(56, 189, 248, 0.15), transparent 55%),
                #020617;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.25);
  }

  .battery-body {
    position: relative;
    width: 80px;
    height: 20px;
    border-radius: 6px;
    border: 2px solid #4b5563;
    padding: 1px;
    overflow: hidden;
    background: #020617;
  }

  .battery-fill {
    height: 100%;
    border-radius: 4px;
    background: linear-gradient(90deg, #22c55e, #a3e635);
    width: 45%;
    transition: width 0.4s ease-out;
  }

  .battery-cap {
    width: 6px;
    height: 12px;
    border-radius: 4px;
    background: #4b5563;
  }

  .battery-label {
    display: flex;
    flex-direction: column;
    font-size: 11px;
    line-height: 1.2;
  }

  .battery-label-strong {
    color: var(--accent);
    font-weight: 600;
  }

  .mode-chip {
    font-size: 11px;
    border-radius: 999px;
    padding: 2px 8px;
    border: 1px solid rgba(74, 222, 128, 0.5);
    background: rgba(22, 163, 74, 0.12);
    color: var(--accent);
  }

  /* Main layout */
  .layout {
    margin-top: 10px;
    display: grid;
    grid-template-columns: minmax(0, 0.95fr) minmax(0, 1.05fr);
    gap: 10px;
  }

  @media (max-width: 900px) {
    .layout {
      grid-template-columns: 1fr;
    }
    header.app-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
    }
  }

  .card {
    background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.9), rgba(15, 23, 42, 0.98));
    border-radius: 18px;
    padding: 10px 12px;
    border: 1px solid var(--border-subtle);
  }

  .card h2 {
    margin: 0 0 6px;
    font-size: 14px;
    letter-spacing: 0.03em;
    text-transform: uppercase;
    color: #e5e7eb;
  }

  .section-label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--text-muted);
    margin-bottom: 4px;
  }

  .controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 6px 10px;
    margin-bottom: 6px;
  }

  .control {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .control label {
    font-size: 11px;
    color: var(--text-muted);
  }

  .control input[type="number"] {
    width: 100%;
    padding: 3px 6px;
    border-radius: 8px;
    border: 1px solid #1f2937;
    background: #020617;
    color: var(--text-main);
    font-size: 12px;
    font-family: var(--font-mono);
  }

  .control input[type="number"]:focus {
    outline: none;
    border-color: var(--accent-soft);
    box-shadow: 0 0 0 1px rgba(74, 222, 128, 0.4);
  }

  .checkbox-row {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: var(--text-muted);
  }

  .checkbox-row input[type="checkbox"] {
    accent-color: var(--accent);
  }

  .group-row {
    display: flex;
    flex-wrap: wrap;
    gap: 6px 10px;
    margin-bottom: 4px;
  }

  .group-col {
    flex: 1 1 130px;
  }

  .group-title {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--text-muted);
    margin-bottom: 2px;
  }

  .btn-row {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 4px;
  }

  button {
    border-radius: 999px;
    border: 1px solid #1f2937;
    background: #020617;
    color: var(--text-main);
    font-size: 11px;
    padding: 4px 10px;
    cursor: pointer;
    font-family: var(--font-sans);
  }

  button:hover {
    border-color: rgba(148, 163, 184, 0.8);
    background: #020818;
  }

  button.primary {
    border-color: rgba(74, 222, 128, 0.9);
    background: radial-gradient(circle at top, rgba(74, 222, 128, 0.18), #020617);
  }

  button.danger {
    border-color: rgba(248, 113, 113, 0.8);
    color: #fecaca;
  }

  button.small {
    font-size: 10px;
    padding: 3px 8px;
  }

  /* Right panel */
  .results-row {
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr));
    gap: 6px;
    margin-bottom: 6px;
  }

  .metric {
    background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 1));
    border-radius: 12px;
    padding: 4px 6px;
    border: 1px solid #111827;
  }

  .metric-label {
    font-size: 10px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }

  .metric-value {
    font-family: var(--font-mono);
    font-size: 13px;
    margin-top: 2px;
  }

  .metric-badge {
    font-size: 10px;
    color: var(--accent);
  }

  .metric-warning {
    color: #facc15;
  }

  .metric-danger {
    color: var(--danger);
  }

  .summary-line {
    margin-top: 2px;
    font-size: 11px;
    color: var(--text-muted);
  }

  .report-area {
    margin-top: 6px;
  }

  .report-area label {
    font-size: 11px;
    color: var(--text-muted);
    display: flex;
    justify-content: space-between;
    margin-bottom: 2px;
  }

  textarea#report {
    width: 100%;
    min-height: 260px;
    resize: vertical;
    border-radius: 12px;
    border: 1px solid #1f2937;
    background: #020617;
    color: var(--text-main);
    font-family: var(--font-mono);
    font-size: 11px;
    padding: 6px;
    line-height: 1.35;
    white-space: pre-wrap;
  }

  textarea#report:focus {
    outline: none;
    border-color: var(--accent-soft);
    box-shadow: 0 0 0 1px rgba(74, 222, 128, 0.4);
  }

  .hint {
    font-size: 10px;
    color: var(--text-muted);
  }

  .soft-divider {
    height: 1px;
    border-radius: 999px;
    background: linear-gradient(90deg, transparent, rgba(55, 65, 81, 0.8), transparent);
    margin: 4px 0;
  }

  .chip-row {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-top: 2px;
  }

  .chip {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.5);
    color: var(--text-muted);
  }

  .chip.good {
    border-color: rgba(74, 222, 128, 0.8);
    color: var(--accent);
  }

  .chip.neutral {
    border-color: rgba(59, 130, 246, 0.8);
  }

  .chip.warn {
    border-color: rgba(250, 204, 21, 0.8);
    color: #facc15;
  }

  .chip.toy {
    border-color: rgba(248, 113, 113, 0.8);
    color: #fecaca;
  }
</style>
</head>
<body>
<div class="app">
  <header class="app-header">
    <div class="title-block">
      <div class="title-row">
        <h1>QDS Battery Suite v8.3 â€” Neon Shell</h1>
        <span class="pill">single-file Â· no libs Â· mobile-safe</span>
      </div>
      <div class="title-sub">
        Fairness-first correlated-noise harness + poster ladder + AutoBench.
      </div>
    </div>
    <div class="header-right">
      <div class="battery-shell">
        <div style="display:flex;align-items:center;gap:4px;">
          <div class="battery-body">
            <div class="battery-fill" id="batteryFill"></div>
          </div>
          <div class="battery-cap"></div>
        </div>
        <div class="battery-label">
          <span class="battery-label-strong" id="batteryLabelMain">LAB LOAD: EASY</span>
          <span id="batteryLabelSub" class="hint">Mobile safe mode ON</span>
        </div>
      </div>
      <span class="mode-chip" id="modeChip">Mode: Manual</span>
    </div>
  </header>

  <div class="layout">
    <!-- LEFT: controls -->
    <section class="card">
      <div class="section-label">Core Controls</div>
      <div class="controls-grid">
        <div class="control">
          <label for="baseInput">Base drain per cycle (%)</label>
          <input id="baseInput" type="number" step="0.1" min="0" value="1.2">
        </div>
        <div class="control">
          <label for="ampInput">Noise amplitude (%)</label>
          <input id="ampInput" type="number" step="0.1" min="0" value="1.8">
        </div>
        <div class="control">
          <label for="pInput">Correlation p (0â€“0.99)</label>
          <input id="pInput" type="number" step="0.01" min="0" max="0.99" value="0.25">
        </div>
        <div class="control">
          <label for="nInput">Cells (n)</label>
          <input id="nInput" type="number" step="100" min="100" value="1200">
        </div>
        <div class="control">
          <label for="maxCyclesInput">Max cycles cap</label>
          <input id="maxCyclesInput" type="number" step="100" min="100" value="4000">
        </div>
        <div class="control">
          <label for="thrInput">Failure threshold (%)</label>
          <input id="thrInput" type="number" step="1" min="1" max="99" value="50">
        </div>
      </div>

      <div class="group-row">
        <div class="group-col">
          <div class="group-title">Stress Hammers</div>
          <div class="checkbox-row">
            <input id="nonlinInput" type="checkbox" checked>
            <label for="nonlinInput">Nonlinear wear</label>
          </div>
          <div class="checkbox-row">
            <input id="heatInput" type="checkbox" checked>
            <label for="heatInput">Heat epochs</label>
          </div>
          <div class="checkbox-row">
            <input id="outlierInput" type="checkbox" checked>
            <label for="outlierInput">Rare outliers</label>
          </div>
        </div>
        <div class="group-col">
          <div class="group-title">Bias Integrity</div>
          <div class="checkbox-row">
            <input id="pairedInput" type="checkbox" checked>
            <label for="pairedInput">Paired Fair Mode</label>
          </div>
          <div class="checkbox-row">
            <input id="noregenInput" type="checkbox" checked>
            <label for="noregenInput">No Regen (no healing)</label>
          </div>
          <div class="checkbox-row">
            <input id="blindInput" type="checkbox">
            <label for="blindInput">Blind labels (UI swap)</label>
          </div>
          <div class="checkbox-row">
            <input id="hardNullInput" type="checkbox">
            <label for="hardNullInput">Hard null (force p=0)</label>
          </div>
        </div>
      </div>

      <div class="group-row">
        <div class="group-col">
          <div class="group-title">Performance & Demo Safety</div>
          <div class="checkbox-row">
            <input id="mobileSafeInput" type="checkbox" checked>
            <label for="mobileSafeInput">Mobile Safe Mode</label>
          </div>
          <div class="checkbox-row">
            <input id="lockSeedInput" type="checkbox" checked>
            <label for="lockSeedInput">Lock seed for repeats</label>
          </div>
          <div class="control">
            <label for="seedInput">Seed</label>
            <input id="seedInput" type="number" step="1" value="12345">
          </div>
          <div class="control">
            <label for="samplerInput">AutoBench sampler count</label>
            <input id="samplerInput" type="number" step="1" min="4" max="60" value="24">
          </div>
        </div>
        <div class="group-col">
          <div class="group-title">Quick Actions</div>
          <div class="btn-row">
            <button id="runBtn" class="primary small">Run single sim</button>
            <button id="resetBtn" class="small">Reset defaults</button>
          </div>
          <div class="btn-row" style="margin-top:4px;">
            <button id="ladderBtn" class="small">Poster Ladder</button>
            <button id="stabilityBtn" class="small">3-Seed Stability</button>
          </div>
          <div class="btn-row" style="margin-top:4px;">
            <button id="autoBenchBtn" class="small">AutoBench</button>
            <button id="pathBtn" class="danger small">Full Pathological Run</button>
          </div>
          <div class="btn-row" style="margin-top:4px;">
            <button id="clearBtn" class="small">Clear report</button>
          </div>
          <div class="hint" style="margin-top:4px;">
            Tip: leave <b>Mobile Safe</b> ON for phone; switch OFF for full desktop punishment.
          </div>
        </div>
      </div>
    </section>

    <!-- RIGHT: results + report -->
    <section class="card">
      <h2>Latest Results</h2>
      <div class="results-row">
        <div class="metric">
          <div class="metric-label" id="whiteLabel">White mean</div>
          <div class="metric-value" id="whiteMean">â€“</div>
          <div class="summary-line" id="whiteSigma">Ïƒ: â€“</div>
        </div>
        <div class="metric">
          <div class="metric-label" id="qdsLabel">QDS mean</div>
          <div class="metric-value" id="qdsMean">â€“</div>
          <div class="summary-line" id="qdsSigma">Ïƒ: â€“</div>
        </div>
        <div class="metric">
          <div class="metric-label">Î” (QDS vs White)</div>
          <div class="metric-value" id="deltaPct">â€“</div>
          <div class="summary-line" id="deltaNote">â€“</div>
        </div>
        <div class="metric">
          <div class="metric-label">Mean paired Î” cycles</div>
          <div class="metric-value" id="meanDeltaCycles">â€“</div>
          <div class="summary-line" id="gradeNote">Grade: â€“</div>
        </div>
      </div>
      <div class="chip-row" id="modeChips">
        <span class="chip good">Paired</span>
        <span class="chip good">NoRegen</span>
        <span class="chip neutral" id="chipMobile">Mobile safe</span>
        <span class="chip neutral" id="chipBlind">Interpret mode</span>
        <span class="chip warn" id="chipStress">Stress hammers: ON</span>
        <span class="chip toy" id="chipPathToy">Extreme toy off</span>
      </div>
      <div class="soft-divider"></div>
      <div class="report-area">
        <label for="report">
          <span>Report log</span>
          <span class="hint">Toy correlated-noise harness: fairness + regime mapping. Not a real battery-extension claim.</span>
        </label>
        <textarea id="report" spellcheck="false"></textarea>
      </div>
    </section>
  </div>
</div>

<script>
  // -------- utility: RNG + timestamp ---------------------------------
  function mulberry32(a) {
    return function() {
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function timestamp() {
    const d = new Date();
    const pad = n => String(n).padStart(2, "0");
    return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()}, ` +
           `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  function appendReport(line) {
    const ta = document.getElementById("report");
    ta.value += (ta.value ? "\n" : "") + line;
    ta.scrollTop = ta.scrollHeight;
  }

  function clearReport() {
    document.getElementById("report").value = "";
  }

  // -------- core simulation ------------------------------------------
  function runScenario(opts) {
    const {
      base, amp, p, thr, n, maxCycles,
      stressNonlin, stressHeat, stressOutliers,
      paired, noRegen, hardNull,
      seed
    } = opts;

    // Clamp / sanity
    const N = Math.max(10, Math.floor(n));
    const maxC = Math.max(10, Math.floor(maxCycles));
    const thrVal = Math.min(99, Math.max(1, thr));
    const pEff = hardNull ? 0 : Math.min(0.99, Math.max(0, p));

    const rng = mulberry32(seed >>> 0);

    const whiteCycles = new Array(N);
    const qdsCycles = new Array(N);

    for (let i = 0; i < N; i++) {
      let hW = 100;
      let hQ = 100;
      let aliveW = true;
      let aliveQ = true;
      let failW = maxC;
      let failQ = maxC;
      let qPrevNoise = 0;

      for (let cyc = 1; cyc <= maxC; cyc++) {
        // If both have failed we can stop early
        if (!aliveW && !aliveQ) break;

        // One shared innovation for fairness
        const epsInnovation = (rng() - 0.5) * 2;   // in [-1,1]

        const whiteNoise = amp * epsInnovation;

        // AR(1)-style correlated noise for QDS
        qPrevNoise = pEff * qPrevNoise + (1 - pEff) * epsInnovation;
        const qdsNoise = amp * qPrevNoise;

        // Shared stress pattern
        let stressMult = 1.0;
        if (stressNonlin) {
          const hMin = Math.min(hW, hQ);
          const x = Math.max(0, 1 - hMin / 100);
          stressMult += 1.8 * x * x; // gentle â†’ harsh near end
        }

        let heatBoost = 0;
        if (stressHeat) {
          // Periodic hot epochs
          const phase = cyc % 80;
          if (phase >= 50 && phase < 68) {
            heatBoost = base * 0.9;
          }
        }

        let outBoost = 0;
        if (stressOutliers) {
          if (rng() < 0.004) { // rare
            outBoost = 10;     // shock hit
          }
        }

        // White step
        if (aliveW) {
          let stepW = base + whiteNoise;
          stepW = stepW * stressMult + heatBoost + outBoost;
          if (noRegen && stepW < 0) stepW = 0;
          hW -= stepW;
          if (hW <= thrVal) {
            aliveW = false;
            failW = cyc;
          }
        }

        // QDS step (paired uses same innovation / stress)
        if (aliveQ) {
          let stepQ = base + (paired ? qdsNoise : ((rng() - 0.5) * 2 * amp));
          stepQ = stepQ * stressMult + heatBoost + outBoost;
          if (noRegen && stepQ < 0) stepQ = 0;
          hQ -= stepQ;
          if (hQ <= thrVal) {
            aliveQ = false;
            failQ = cyc;
          }
        }
      }

      whiteCycles[i] = failW;
      qdsCycles[i] = failQ;
    }

    function stats(arr) {
      let m = 0, m2 = 0;
      const L = arr.length;
      for (let i = 0; i < L; i++) {
        m += arr[i];
      }
      m /= L;
      for (let i = 0; i < L; i++) {
        const d = arr[i] - m;
        m2 += d * d;
      }
      m2 = m2 / L;
      return { mean: m, sigma: Math.sqrt(m2) };
    }

    const sW = stats(whiteCycles);
    const sQ = stats(qdsCycles);

    // paired Î” cycles
    let meanDelta = 0;
    for (let i = 0; i < N; i++) {
      meanDelta += (qdsCycles[i] - whiteCycles[i]);
    }
    meanDelta /= N;

    // Î”% with low-baseline guard
    let deltaPct = null;
    if (sW.mean >= 3) {
      deltaPct = (sQ.mean - sW.mean) / sW.mean * 100;
    }

    return {
      white: sW,
      qds: sQ,
      meanDeltaCycles: meanDelta,
      deltaPct: deltaPct,
      N,
      thr: thrVal,
      p: pEff
    };
  }

  // -------- UI helpers -----------------------------------------------
  function getCommonOpts(extraSeedOffset = 0) {
    const base = parseFloat(document.getElementById("baseInput").value || "0");
    const amp = parseFloat(document.getElementById("ampInput").value || "0");
    const p = parseFloat(document.getElementById("pInput").value || "0");
    const n = parseInt(document.getElementById("nInput").value || "0", 10);
    const maxCycles = parseInt(document.getElementById("maxCyclesInput").value || "0", 10);
    const thr = parseFloat(document.getElementById("thrInput").value || "0");

    const stressNonlin = document.getElementById("nonlinInput").checked;
    const stressHeat = document.getElementById("heatInput").checked;
    const stressOutliers = document.getElementById("outlierInput").checked;

    const paired = document.getElementById("pairedInput").checked;
    const noRegen = document.getElementById("noregenInput").checked;
    const hardNull = document.getElementById("hardNullInput").checked;

    let seedBase = parseInt(document.getElementById("seedInput").value || "1", 10);
    if (isNaN(seedBase)) seedBase = 1;
    if (!document.getElementById("lockSeedInput").checked) {
      seedBase = (seedBase + Math.floor(Math.random() * 1e6)) | 0;
    }
    const seed = (seedBase + extraSeedOffset) | 0;

    return {
      base, amp, p, thr, n, maxCycles,
      stressNonlin, stressHeat, stressOutliers,
      paired, noRegen, hardNull,
      seed
    };
  }

  function updateChips(stressNonlin, stressHeat, stressOutliers, mobileSafe, blind, pathologicalOn) {
    const chipMobile = document.getElementById("chipMobile");
    chipMobile.textContent = mobileSafe ? "Mobile safe" : "Desktop/full load";
    chipMobile.className = "chip neutral";

    const chipBlind = document.getElementById("chipBlind");
    chipBlind.textContent = blind ? "Bias test / blind" : "Interpret mode";
    chipBlind.className = blind ? "chip warn" : "chip neutral";

    const chipStress = document.getElementById("chipStress");
    const stressOn = stressNonlin || stressHeat || stressOutliers;
    chipStress.textContent = stressOn ? "Stress hammers: ON" : "Stress hammers: OFF";
    chipStress.className = "chip " + (stressOn ? "warn" : "neutral");

    const chipPathToy = document.getElementById("chipPathToy");
    chipPathToy.textContent = pathologicalOn ? "Extreme toy ACTIVE" : "Extreme toy off";
    chipPathToy.className = "chip toy";
  }

  function updateLatestStats(stats, label) {
    const { white, qds, deltaPct, meanDeltaCycles, thr, p } = stats;

    const blind = document.getElementById("blindInput").checked;
    const mobileSafe = document.getElementById("mobileSafeInput").checked;
    const stressNonlin = document.getElementById("nonlinInput").checked;
    const stressHeat = document.getElementById("heatInput").checked;
    const stressOutliers = document.getElementById("outlierInput").checked;

    // Possibly swap labels if blind mode
    const whiteLabelEl = document.getElementById("whiteLabel");
    const qdsLabelEl = document.getElementById("qdsLabel");
    if (blind) {
      whiteLabelEl.textContent = "Model A mean";
      qdsLabelEl.textContent = "Model B mean";
    } else {
      whiteLabelEl.textContent = "White mean";
      qdsLabelEl.textContent = "QDS mean";
    }

    document.getElementById("whiteMean").textContent = white.mean.toFixed(1);
    document.getElementById("qdsMean").textContent = qds.mean.toFixed(1);
    document.getElementById("whiteSigma").textContent = "Ïƒ: " + white.sigma.toFixed(1);
    document.getElementById("qdsSigma").textContent = "Ïƒ: " + qds.sigma.toFixed(1);

    const deltaEl = document.getElementById("deltaPct");
    const deltaNote = document.getElementById("deltaNote");
    const meanDeltaEl = document.getElementById("meanDeltaCycles");
    const gradeNote = document.getElementById("gradeNote");

    if (deltaPct === null) {
      deltaEl.textContent = "n/a";
      deltaNote.textContent = "Î”% guarded â€” baseline too low.";
    } else {
      deltaEl.textContent = (deltaPct >= 0 ? "+" : "") + deltaPct.toFixed(1) + "%";
      if (Math.abs(deltaPct) < 0.5) {
        deltaNote.textContent = "â‰ˆ neutral in this regime.";
      } else if (Math.abs(deltaPct) < 3) {
        deltaNote.textContent = "Mild signal; treat as noise-level curiosity.";
      } else {
        deltaNote.textContent = "Strong effect in this toy regime.";
      }
    }

    meanDeltaEl.textContent = meanDeltaCycles.toFixed(2);

    // Grade by |Î”%| if available
    let grade = "â€“";
    if (deltaPct === null) {
      grade = "Guarded";
    } else {
      const a = Math.abs(deltaPct);
      if (a < 0.5) grade = "A (neutral)";
      else if (a < 2) grade = "B (mild)";
      else if (a < 10) grade = "C (clear)";
      else grade = "Toy/extreme";
    }
    gradeNote.textContent = "Grade: " + grade +
      (label ? " Â· " + label : "");

    // Update battery shell indication
    const batteryFill = document.getElementById("batteryFill");
    const batteryLabelMain = document.getElementById("batteryLabelMain");
    const batteryLabelSub = document.getElementById("batteryLabelSub");

    const maxCycles = parseInt(document.getElementById("maxCyclesInput").value || "4000", 10);
    let util = (white.mean / maxCycles) * 100;
    if (!isFinite(util)) util = 40;
    const width = Math.max(8, Math.min(100, util));
    batteryFill.style.width = width.toFixed(0) + "%";

    if (maxCycles <= 3500 && stats.N <= 1500) {
      batteryLabelMain.textContent = "LAB LOAD: EASY";
    } else if (stats.N <= 2500) {
      batteryLabelMain.textContent = "LAB LOAD: MEDIUM";
    } else {
      batteryLabelMain.textContent = "LAB LOAD: HEAVY";
    }

    const msText = mobileSafe ? "Mobile safe mode ON" : "Full load / desktop-friendly";
    batteryLabelSub.textContent = msText;

    // Update chips
    updateChips(stressNonlin, stressHeat, stressOutliers, mobileSafe, blind, false);
  }

  function describeOpts(opts) {
    const parts = [];
    parts.push(`base=${opts.base.toFixed(1)}%`);
    parts.push(`amp=${opts.amp.toFixed(1)}%`);
    parts.push(`p=${opts.hardNull ? 0 : opts.p.toFixed(2)}`);
    parts.push(`thr=${opts.thr}%`);
    parts.push(`n=${opts.n}`);
    parts.push(`max=${opts.maxCycles}`);
    const sFlags = [];
    if (opts.stressNonlin) sFlags.push("nonlin");
    if (opts.stressHeat) sFlags.push("heat");
    if (opts.stressOutliers) sFlags.push("out");
    const bFlags = [];
    if (opts.paired) bFlags.push("paired");
    if (opts.noRegen) bFlags.push("noRegen");
    if (opts.hardNull) bFlags.push("hardNull");
    return {
      core: parts.join(" Â· "),
      stress: sFlags.length ? sFlags.join("+") : "none",
      bias: bFlags.length ? bFlags.join("+") : "none"
    };
  }

  // -------- button handlers ------------------------------------------
  function runSingle() {
    const opts = getCommonOpts(0);
    const desc = describeOpts(opts);
    const stats = runScenario(opts);
    updateLatestStats(stats, "Single sim");

    const t = timestamp();
    const d = stats;
    const deltaStr = d.deltaPct === null ? "n/a(low baseline)" : d.deltaPct.toFixed(1) + "%";
    const line = `${t} Â· Manual Â· ${desc.core}\n` +
                 `white Î¼=${d.white.mean.toFixed(1)} Ïƒ=${d.white.sigma.toFixed(1)} Â· ` +
                 `QDS Î¼=${d.qds.mean.toFixed(1)} Ïƒ=${d.qds.sigma.toFixed(1)} Â· Î”=${deltaStr} Â· ` +
                 `meanÎ”=${d.meanDeltaCycles.toFixed(2)} Â· stress: ${desc.stress} Â· bias: ${desc.bias}`;
    appendReport(line);

    document.getElementById("modeChip").textContent = "Mode: Manual";
  }

  function resetDefaults() {
    document.getElementById("baseInput").value = "1.2";
    document.getElementById("ampInput").value = "1.8";
    document.getElementById("pInput").value = "0.25";
    document.getElementById("nInput").value = "1200";
    document.getElementById("maxCyclesInput").value = "4000";
    document.getElementById("thrInput").value = "50";

    document.getElementById("nonlinInput").checked = true;
    document.getElementById("heatInput").checked = true;
    document.getElementById("outlierInput").checked = true;

    document.getElementById("pairedInput").checked = true;
    document.getElementById("noregenInput").checked = true;
    document.getElementById("blindInput").checked = false;
    document.getElementById("hardNullInput").checked = false;

    document.getElementById("mobileSafeInput").checked = true;
    document.getElementById("lockSeedInput").checked = true;
    document.getElementById("seedInput").value = "12345";
    document.getElementById("samplerInput").value = "24";

    updateChips(true, true, true, true, false, false);
    document.getElementById("modeChip").textContent = "Mode: Manual";
  }

  function runPosterLadder() {
    const mobileSafe = document.getElementById("mobileSafeInput").checked;
    const baseOpts = getCommonOpts(101);
    const now = timestamp();

    appendReport(`=== Poster Ladder v8.3 (poster-safe) ===`);

    function runBlock(label, overrides) {
      const o = Object.assign({}, baseOpts, overrides);
      if (mobileSafe) {
        o.n = Math.min(o.n, 1400);
        o.maxCycles = Math.min(o.maxCycles, 4000);
      }
      const stats = runScenario(o);
      const desc = describeOpts(o);
      const deltaStr = stats.deltaPct === null ? "n/a(low baseline)" : stats.deltaPct.toFixed(1) + "%";
      const line = `${now} Â· ${label} base=${o.base.toFixed(1)}% amp=${o.amp.toFixed(1)}% p=${o.hardNull ? 0 : o.p.toFixed(2)} thr=${o.thr}% n=${stats.N} max=${o.maxCycles} ` +
                   `white Î¼=${stats.white.mean.toFixed(1)} Ïƒ=${stats.white.sigma.toFixed(1)} Â· ` +
                   `QDS Î¼=${stats.qds.mean.toFixed(1)} Ïƒ=${stats.qds.sigma.toFixed(1)} Î”=${deltaStr} Â· ` +
                   `meanÎ”=${stats.meanDeltaCycles.toFixed(2)} stress: ${desc.stress} Â· bias: ${desc.bias}`;
      appendReport(line);
      return stats;
    }

    // A: amp = 0 control
    const statsA = runBlock("Ladder A â€” amp=0 control (safe)", {
      amp: 0,
      p: baseOpts.p,
      hardNull: false,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    // B: hard null p=0
    const statsB = runBlock("Ladder B â€” hard null p=0 (safe)", {
      amp: baseOpts.amp,
      p: 0,
      hardNull: true,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    // C: blind null
    const statsC = runBlock("Ladder C â€” blind null (safe)", {
      amp: baseOpts.amp,
      p: 0,
      hardNull: true,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false,
      // we don't toggle UI blind here, just keep harness itself neutral
    });

    // D: realistic phone
    const statsD = runBlock("Ladder D â€” realistic phone (safe)", {
      base: 1.2,
      amp: 1.8,
      p: 0.25,
      thr: 30,
      n: 1200,
      maxCycles: 3500,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    // E: controlled stress
    const statsE = runBlock("Ladder E â€” controlled stress (safe)", {
      base: 3.0,
      amp: 5.0,
      p: 0.60,
      thr: 50,
      n: 1400,
      maxCycles: 4000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    // F: high-corr sanity (still poster-safe: no hammers; moderate threshold)
    const statsF = runBlock("Ladder F â€” high-correlation sanity (safe)", {
      base: 3.0,
      amp: 5.0,
      p: 0.90,
      thr: 50,
      n: 1200,
      maxCycles: 4000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    appendReport("=== End ladder ===");

    // Update display with last ladder block (F) for drama
    updateLatestStats(statsF, "Ladder F");
    document.getElementById("modeChip").textContent = "Mode: Poster Ladder";
  }

  function runStability() {
    const baseOpts = getCommonOpts(0);
    const mobileSafe = document.getElementById("mobileSafeInput").checked;

    // We force p>0 for stability check
    const baseP = baseOpts.p <= 0 ? 0.25 : baseOpts.p;

    const seeds = [111, 222, 333];
    const deltas = [];
    const meanDeltas = [];
    let lastStats = null;

    appendReport("=== 3-Seed Stability ===");
    seeds.forEach((s) => {
      const o = Object.assign({}, baseOpts, {
        p: baseP,
        hardNull: false,
        seed: (s + baseOpts.seed) | 0
      });
      if (mobileSafe) {
        o.n = Math.min(o.n, 1400);
        o.maxCycles = Math.min(o.maxCycles, 4000);
      }
      const stats = runScenario(o);
      lastStats = stats;
      const desc = describeOpts(o);
      const deltaStr = stats.deltaPct === null ? "n/a(low baseline)" : stats.deltaPct.toFixed(2) + "%";
      appendReport(`${timestamp()} Â· Stability seed=${s} base=${o.base.toFixed(1)}% amp=${o.amp.toFixed(1)}% p=${o.p.toFixed(2)} thr=${o.thr}% n=${stats.N} max=${o.maxCycles} ` +
                   `white Î¼=${stats.white.mean.toFixed(1)} Ïƒ=${stats.white.sigma.toFixed(1)} Â· ` +
                   `QDS Î¼=${stats.qds.mean.toFixed(1)} Ïƒ=${stats.qds.sigma.toFixed(1)} Î”=${deltaStr} Â· meanÎ”=${stats.meanDeltaCycles.toFixed(2)} ` +
                   `stress: ${desc.stress} Â· bias: ${desc.bias}`);
      if (stats.deltaPct !== null) deltas.push(stats.deltaPct);
      meanDeltas.push(stats.meanDeltaCycles);
    });

    let meanDeltaPct = 0, minDeltaPct = 0, maxDeltaPct = 0;
    if (deltas.length) {
      let sum = 0, min = deltas[0], max = deltas[0];
      deltas.forEach(d => { sum += d; if (d < min) min = d; if (d > max) max = d; });
      meanDeltaPct = sum / deltas.length;
      minDeltaPct = min;
      maxDeltaPct = max;
    }

    let meanCycles = 0;
    if (meanDeltas.length) {
      meanCycles = meanDeltas.reduce((a,b) => a + b, 0) / meanDeltas.length;
    }

    let grade;
    const a = Math.abs(meanDeltaPct);
    if (!deltas.length || a < 0.25) grade = "A (neutral/stable)";
    else if (a < 1.5) grade = "B (mild)";
    else grade = "C+ (clear)";

    appendReport(`Stability summary: mean Î”=${meanDeltaPct.toFixed(2)}% (range ${minDeltaPct.toFixed(2)} â†’ ${maxDeltaPct.toFixed(2)}), ` +
                 `meanÎ”cycles=${meanCycles.toFixed(2)} Â· ${grade}`);
    appendReport("=== End stability ===");

    if (lastStats) {
      updateLatestStats(lastStats, "Stability");
      document.getElementById("modeChip").textContent = "Mode: 3-Seed Stability";
    }
  }

  function randomBetween(rng, a, b) {
    return a + (b - a) * rng();
  }

  function runAutoBench() {
    const mobileSafe = document.getElementById("mobileSafeInput").checked;
    const baseOpts = getCommonOpts(5000);
    let samplerCount = parseInt(document.getElementById("samplerInput").value || "16", 10);
    samplerCount = Math.max(4, Math.min(60, samplerCount));

    const rng = mulberry32(baseOpts.seed);
    appendReport(`=== AutoBench v8.3 start === Seed=${baseOpts.seed} Â· Sampler=${samplerCount} Â· MobileSafe=${mobileSafe ? "true" : "false"}`);

    // Ladder A-F again (poster-safe)
    function safeRun(label, overrides) {
      const o = Object.assign({}, baseOpts, overrides);
      if (mobileSafe) {
        o.n = Math.min(o.n, 1500);
        o.maxCycles = Math.min(o.maxCycles, 6000);
      }
      const stats = runScenario(o);
      const desc = describeOpts(o);
      const deltaStr = stats.deltaPct === null ? "n/a(low baseline)" : stats.deltaPct.toFixed(1) + "%";
      appendReport(`${timestamp()} Â· ${label} base=${o.base.toFixed(2)}% amp=${o.amp.toFixed(2)}% p=${o.hardNull ? 0 : o.p.toFixed(2)} thr=${o.thr}% n=${stats.N} max=${o.maxCycles} ` +
                   `white Î¼=${stats.white.mean.toFixed(1)} Ïƒ=${stats.white.sigma.toFixed(1)} Â· ` +
                   `QDS Î¼=${stats.qds.mean.toFixed(1)} Ïƒ=${stats.qds.sigma.toFixed(1)} Î”=${deltaStr} Â· ` +
                   `meanÎ”=${stats.meanDeltaCycles.toFixed(2)} stress: ${desc.stress} Â· bias: ${desc.bias}`);
      return stats;
    }

    safeRun("Ladder A â€” amp=0 control (safe)", {
      amp: 0,
      p: baseOpts.p,
      hardNull: false,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });
    safeRun("Ladder B â€” hard null p=0 (safe)", {
      amp: baseOpts.amp,
      p: 0,
      hardNull: true,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });
    safeRun("Ladder C â€” blind null (safe)", {
      amp: baseOpts.amp,
      p: 0,
      hardNull: true,
      thr: 50,
      n: 900,
      maxCycles: 3000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });
    safeRun("Ladder D â€” realistic phone (safe)", {
      base: 1.2,
      amp: 1.8,
      p: 0.25,
      thr: 30,
      n: 1200,
      maxCycles: 3500,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });
    safeRun("Ladder E â€” controlled stress (safe)", {
      base: 3.0,
      amp: 5.0,
      p: 0.6,
      thr: 50,
      n: 1400,
      maxCycles: 4000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });
    let lastStats = safeRun("Ladder F â€” high-correlation sanity (safe)", {
      base: 3.0,
      amp: 5.0,
      p: 0.9,
      thr: 50,
      n: 1200,
      maxCycles: 4000,
      stressNonlin: false,
      stressHeat: false,
      stressOutliers: false
    });

    appendReport("=== Sampler ===");

    const allDeltas = [];
    for (let i = 0; i < samplerCount; i++) {
      // cycle through toy "device" flavours
      const flavor = i % 4; // 0 phone, 1 laptop, 2 EV, 3 grid
      let label;
      const o = Object.assign({}, baseOpts);
      o.stressNonlin = false;
      o.stressHeat = false;
      o.stressOutliers = false;
      o.hardNull = false;
      o.paired = true;
      o.noRegen = true;

      if (flavor === 0) { // phone
        label = "Sampler " + (i+1) + " â€” phone";
        o.base = randomBetween(rng, 1.0, 1.6);
        o.amp = randomBetween(rng, 1.2, 2.4);
        o.p = randomBetween(rng, 0.05, 0.35);
        o.thr = [20, 30, 50][Math.floor(rng()*3)];
        o.n = 1200;
        o.maxCycles = mobileSafe ? 4000 : 5000;
      } else if (flavor === 1) { // laptop
        label = "Sampler " + (i+1) + " â€” laptop";
        o.base = randomBetween(rng, 0.7, 1.1);
        o.amp = randomBetween(rng, 1.0, 2.0);
        o.p = randomBetween(rng, 0.05, 0.25);
        o.thr = [30, 40][Math.floor(rng()*2)];
        o.n = mobileSafe ? 1300 : 1600;
        o.maxCycles = mobileSafe ? 6000 : 8000;
      } else if (flavor === 2) { // EV toy
        label = "Sampler " + (i+1) + " â€” EV-toy";
        o.base = randomBetween(rng, 0.25, 0.45);
        o.amp = randomBetween(rng, 0.3, 0.8);
        o.p = randomBetween(rng, 0.05, 0.3);
        o.thr = [60, 70, 80][Math.floor(rng()*3)];
        o.n = mobileSafe ? 1500 : 2000;
        o.maxCycles = mobileSafe ? 12000 : 16000;
      } else { // grid toy
        label = "Sampler " + (i+1) + " â€” grid-toy";
        o.base = randomBetween(rng, 0.18, 0.32);
        o.amp = randomBetween(rng, 0.2, 0.5);
        o.p = randomBetween(rng, 0.03, 0.2);
        o.thr = [70, 80][Math.floor(rng()*2)];
        o.n = mobileSafe ? 1800 : 2400;
        o.maxCycles = mobileSafe ? 20000 : 26000;
      }

      o.seed = (baseOpts.seed + 1000 + i) | 0;
      const stats = runScenario(o);
      lastStats = stats;
      const desc = describeOpts(o);
      const deltaStr = stats.deltaPct === null ? "n/a(low baseline)" : stats.deltaPct.toFixed(1) + "%";
      appendReport(`${timestamp()} Â· ${label} base=${o.base.toFixed(2)}% amp=${o.amp.toFixed(2)}% p=${o.p.toFixed(2)} thr=${o.thr}% n=${stats.N} max=${o.maxCycles} ` +
                   `white Î¼=${stats.white.mean.toFixed(1)} Ïƒ=${stats.white.sigma.toFixed(1)} Â· ` +
                   `QDS Î¼=${stats.qds.mean.toFixed(1)} Ïƒ=${stats.qds.sigma.toFixed(1)} Î”=${deltaStr} Â· meanÎ”=${stats.meanDeltaCycles.toFixed(2)} ` +
                   `stress: none Â· bias: paired+noRegen`);
      if (stats.deltaPct !== null) allDeltas.push(stats.deltaPct);
    }

    // Summary of sampler deltas
    if (allDeltas.length) {
      const n = allDeltas.length;
      let sum = 0, min = allDeltas[0], max = allDeltas[0];
      allDeltas.forEach(d => { sum += d; if (d < min) min = d; if (d > max) max = d; });
      const mean = sum / n;
      appendReport(`AutoBench sampler summary: mean Î”=${mean.toFixed(2)}% (min=${min.toFixed(2)}% Â· max=${max.toFixed(2)}%) over ${n} randomised toy scenarios.`);
    }

    appendReport("=== End AutoBench ===");

    if (lastStats) {
      updateLatestStats(lastStats, "AutoBench tail");
      document.getElementById("modeChip").textContent = "Mode: AutoBench";
    }
  }

  function runPathological() {
    const baseOpts = getCommonOpts(9000);
    const mobileSafe = document.getElementById("mobileSafeInput").checked;

    const o = Object.assign({}, baseOpts, {
      base: 8.0,
      amp: 14.0,
      p: 0.99,
      thr: 95,
      stressNonlin: true,
      stressHeat: true,
      stressOutliers: true,
      paired: true,
      noRegen: true,
      hardNull: false
    });

    // Big n/max only if mobile safe off
    if (mobileSafe) {
      o.n = 2500;
      o.maxCycles = 6000;
    } else {
      o.n = 5000;
      o.maxCycles = 8000;
    }

    appendReport("=== FULL PATHOLOGICAL RUN (extreme toy regime) === High p + NoRegen + harsh thr. Î”% may be n/a (low baseline).");

    const stats = runScenario(o);
    const desc = describeOpts(o);
    const deltaStr = stats.deltaPct === null ? "n/a(low baseline)" : stats.deltaPct.toFixed(1) + "%";

    appendReport(`${timestamp()} Â· Pathological â€” full load base=${o.base.toFixed(1)}% amp=${o.amp.toFixed(1)}% p=${o.p.toFixed(2)} thr=${o.thr}% n=${stats.N} max=${o.maxCycles} ` +
                 `white Î¼=${stats.white.mean.toFixed(1)} Ïƒ=${stats.white.sigma.toFixed(1)} Â· ` +
                 `QDS Î¼=${stats.qds.mean.toFixed(1)} Ïƒ=${stats.qds.sigma.toFixed(1)} Î”=${deltaStr} Â· ` +
                 `meanÎ”=${stats.meanDeltaCycles.toFixed(2)} stress: ${desc.stress} Â· bias: ${desc.bias}`);
    appendReport("=== End full pathological ===");

    updateLatestStats(stats, "Pathological toy");
    document.getElementById("modeChip").textContent = "Mode: Extreme Toy";
    // Mark toy chip as active
    const chipPathToy = document.getElementById("chipPathToy");
    chipPathToy.textContent = "Extreme toy ACTIVE";
    chipPathToy.className = "chip toy";
  }

  // -------- wire up ---------------------------------------------------
  document.getElementById("runBtn").addEventListener("click", runSingle);
  document.getElementById("resetBtn").addEventListener("click", resetDefaults);
  document.getElementById("ladderBtn").addEventListener("click", runPosterLadder);
  document.getElementById("stabilityBtn").addEventListener("click", runStability);
  document.getElementById("autoBenchBtn").addEventListener("click", runAutoBench);
  document.getElementById("pathBtn").addEventListener("click", runPathological);
  document.getElementById("clearBtn").addEventListener("click", clearReport);

  // Keep chips in sync with toggles
  ["nonlinInput","heatInput","outlierInput","mobileSafeInput","blindInput"].forEach(id => {
    document.getElementById(id).addEventListener("change", () => {
      const nonlin = document.getElementById("nonlinInput").checked;
      const heat = document.getElementById("heatInput").checked;
      const out = document.getElementById("outlierInput").checked;
      const mobileSafe = document.getElementById("mobileSafeInput").checked;
      const blind = document.getElementById("blindInput").checked;
      updateChips(nonlin, heat, out, mobileSafe, blind, false);
    });
  });

  // Initial state
  resetDefaults();
</script>
</body>
</html>
