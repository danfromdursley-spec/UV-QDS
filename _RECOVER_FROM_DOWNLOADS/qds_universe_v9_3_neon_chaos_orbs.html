<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>QDS Universe V9.3 ‚Äì Neon Chaos Orbs</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #renderCanvas {
      width: 100vw;
      height: 100vh;
      touch-action: none;
      display: block;
    }

    /* HUD ‚Äî same style as V9.2 but shrunk and kept in top-left */
    #hud {
      position: fixed;
      top: 8px;
      left: 8px;
      max-width: 320px;
      padding: 10px 12px 12px 12px;
      border-radius: 18px;
      background: radial-gradient(circle at top left, #ff4, #f06, #111);
      box-shadow: 0 0 18px rgba(0,0,0,0.9);
      color: #fff;
      z-index: 10;
      box-sizing: border-box;
      transform-origin: top left;
      transform: scale(0.72); /* ~60‚Äì70% size */
    }
    #hud h1 {
      font-size: 17px;
      margin: 0 0 4px 0;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #hud p.subtitle {
      margin: 0 0 8px 0;
      font-size: 11px;
      opacity: 0.9;
    }
    .slider-row {
      margin: 4px 0 2px 0;
    }
    .slider-row label {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      margin-bottom: 2px;
    }
    .slider-row input[type=range] {
      width: 100%;
    }
    .button-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 5px;
      margin-top: 5px;
    }
    button {
      border-radius: 999px;
      border: none;
      padding: 7px 8px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      color: #fff;
      background: #222;
      box-shadow: 0 3px 10px rgba(0,0,0,0.6);
    }
    button:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 1px 6px rgba(0,0,0,0.7);
    }
    #btnCME    { background: linear-gradient(90deg,#ff9800,#ff5722); }
    #btnChaos  { background: linear-gradient(90deg,#ff5722,#c2185b); }
    #btnNormal { background: linear-gradient(90deg,#009688,#26c6da); }
    #btnRide   { background: linear-gradient(90deg,#4caf50,#8bc34a); }
    #btnMeltdown {
      grid-column: span 2;
      background: radial-gradient(circle at top,#ffeb3b,#f44336);
    }
    .select-row {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .select-row select {
      width: 100%;
      padding: 5px 7px;
      border-radius: 999px;
      border: none;
      font-size: 11px;
      background: rgba(0,0,0,0.6);
      color: #fff;
    }
    #planetInfo {
      font-size: 10px;
      margin-top: 2px;
      padding: 4px 6px;
      border-radius: 10px;
      background: rgba(0,0,0,0.55);
    }
    #statusBar {
      font-size: 9px;
      margin-top: 4px;
      opacity: 0.85;
    }

    /* HUD toggle button (bottom-right) */
    #hudToggle {
      position: fixed;
      right: 10px;
      bottom: 16px;
      z-index: 11;
      border-radius: 999px;
      border: none;
      padding: 10px 16px;
      font-size: 13px;
      font-weight: 700;
      background: radial-gradient(circle at top,#00e5ff,#2979ff);
      color: #000;
      box-shadow: 0 4px 16px rgba(0,0,0,0.9);
      cursor: pointer;
    }

    /* Hint bar at bottom centre */
    #hintBar {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(200, 240, 255, 0.8);
      text-align: center;
      pointer-events: none;
      z-index: 9;
    }

    @media (min-width: 900px) {
      /* on big screens, scale HUD slightly up so it isn't tiny */
      #hud {
        transform: scale(0.8);
      }
    }
  </style>
</head>
<body>
<div id="hud">
  <h1>QDS Universe V9.3 üß¢üí•</h1>
  <p class="subtitle">Neon warp-grid with chaos orbs. Drag sliders, fire CMEs, ride planets, tap grid for chaos.</p>

  <div class="slider-row">
    <label><span>Œª<sub>c</sub> (spatial coherence)</span><span id="lambdaVal">1.4</span></label>
    <input id="lambdaSlider" type="range" min="0.4" max="3.0" step="0.1" value="1.4" />
  </div>
  <div class="slider-row">
    <label><span>œÑ<sub>c</sub> (temporal coherence)</span><span id="tauVal">2.0</span></label>
    <input id="tauSlider" type="range" min="0.4" max="3.0" step="0.1" value="2.0" />
  </div>

  <div class="button-row">
    <button id="btnCME">üí• Fire CME</button>
    <button id="btnChaos">üî• MAX Chaos</button>
    <button id="btnNormal">üíé Normal</button>
    <button id="btnRide">üõ∏ Ride Along</button>
    <button id="btnMeltdown">‚ò¢Ô∏è QDS MELTDOWN</button>
  </div>

  <div class="select-row">
    <select id="planetSelect">
      <option value="none">Select Planet</option>
      <option value="mercury">Mercury</option>
      <option value="venus">Venus</option>
      <option value="earth" selected>Earth</option>
      <option value="mars">Mars</option>
      <option value="jupiter">Jupiter</option>
      <option value="saturn">Saturn</option>
      <option value="uranus">Uranus</option>
      <option value="neptune">Neptune</option>
      <option value="pluto">Pluto (respect)</option>
    </select>
    <div id="planetInfo">Planet info will appear here.</div>
  </div>

  <div id="statusBar">Status: QDS idling. Grid humming softly.</div>
</div>

<button id="hudToggle">HUD</button>
<div id="hintBar">TAP GRID TO SPAWN CHAOS ORBS ¬∑ SLIDERS DRIVE QDS WARP ¬∑ HUD TOGGLE CONTROLS</div>
<canvas id="renderCanvas"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

  const PLANET_TEXT = {
    mercury: "Mercury ‚Äì fast, hot, and a bit crispy.",
    venus:   "Venus ‚Äì runaway greenhouse. Do not open windows.",
    earth:   "Earth ‚Äì liquid water, plate tectonics, questionable Wi-Fi.",
    mars:    "Mars ‚Äì dusty, cold, working on the whole 'habitable' thing.",
    jupiter: "Jupiter ‚Äì big lad. Moon hoarder. Storm enthusiast.",
    saturn:  "Saturn ‚Äì brings its own hula hoop collection.",
    uranus:  "Uranus ‚Äì tilted like it had a rough day.",
    neptune: "Neptune ‚Äì deep blue and very, very windy.",
    pluto:   "Pluto ‚Äì tiny, icy, emotionally still a planet."
  };

  const state = {
    qdsLambda: 1.4,
    qdsTau: 2.0,
    chaosOn: false,
    meltdown: false,
    rideTarget: "earth",
    rideOn: false,
    cmewaves: [],
    chaosOrbs: [],   // new chaos orbs
    t: 0
  };

  function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

    const camera = new BABYLON.ArcRotateCamera("cam",
      -Math.PI / 2.2,
      Math.PI / 2.6,
      120,
      new BABYLON.Vector3(0, 8, 0),
      scene
    );
    camera.attachControl(canvas, true);
    camera.lowerRadiusLimit = 40;
    camera.upperRadiusLimit = 220;

    const light = new BABYLON.HemisphericLight("hemi",
      new BABYLON.Vector3(0, 1, 0),
      scene
    );
    light.intensity = 0.6;

    const sunLight = new BABYLON.PointLight("sunLight",
      new BABYLON.Vector3(0, 6, 0),
      scene
    );
    sunLight.intensity = 1.3;

    const glow = new BABYLON.GlowLayer("glow", scene);
    glow.intensity = 0.7;

    // QDS grid
    const grid = BABYLON.MeshBuilder.CreateGround("qdsGrid", {
      width: 420,
      height: 420,
      subdivisions: 140
    }, scene);
    grid.position.y = -6;

    const gridMat = new BABYLON.StandardMaterial("gridMat", scene);
    gridMat.wireframe = true;
    gridMat.diffuseColor = new BABYLON.Color3(0.05, 0.7, 0.9);
    gridMat.emissiveColor = new BABYLON.Color3(0.0, 0.4, 0.6);
    grid.material = gridMat;

    // Warp the grid
    const positions = grid.getVerticesData(BABYLON.VertexBuffer.PositionKind);

    scene.registerBeforeRender(() => {
      const t = state.t;
      const lambda = state.qdsLambda;
      const tau = state.qdsTau;
      const ampBase = state.meltdown ? 2.4 : 1.4;
      const amp = ampBase + (state.chaosOn ? 0.6 : 0.0);

      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const z = positions[i + 2];
        const r = Math.sqrt(x * x + z * z);
        const wobble = Math.sin(r * 0.08 * lambda - t * 0.9 * tau);
        positions[i + 1] = wobble * amp;
      }
      grid.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
      grid.refreshBoundingInfo();

      // Update CME rings
      state.cmewaves = state.cmewaves.filter(w => {
        w.radius += w.speed;
        w.mesh.scaling.setAll(w.radius);
        const fade = Math.max(0, 1.0 - w.radius / 260);
        w.material.emissiveColor = new BABYLON.Color3(1.0, 0.8 * fade, 0.2 * fade);
        if (w.radius > 260) {
          w.mesh.dispose();
          return false;
        }
        return true;
      });

      // Update chaos orbs
      const dt = engine.getDeltaTime() * 0.001;
      state.chaosOrbs = state.chaosOrbs.filter(o => {
        o.life += dt;
        o.mesh.position.y += 3.0 * dt;
        o.mesh.rotation.y += 2.5 * dt;
        const fade = Math.max(0, 1.0 - o.life / 4.0);
        o.mat.alpha = fade;
        if (o.life > 4.0) {
          o.mesh.dispose();
          return false;
        }
        return true;
      });

      // Ride-along camera
      if (state.rideOn && planets[state.rideTarget]) {
        const target = planets[state.rideTarget].mesh;
        const pos = target.position;
        camera.target.copyFrom(pos);
        camera.alpha += 0.0015;
      }

      state.t += engine.getDeltaTime() * 0.001;
    });

    // Sun
    const sun = BABYLON.MeshBuilder.CreateSphere("sun", { diameter: 18, segments: 32 }, scene);
    sun.position.y = 6;

    const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
    sunMat.emissiveColor = new BABYLON.Color3(1.4, 1.1, 0.4);
    sun.material = sunMat;

    // Planets (same look as V9.2)
    function makePlanet(name, radius, distance, color, emissive, speed) {
      const planet = BABYLON.MeshBuilder.CreateSphere(name, {
        diameter: radius * 2.2,
        segments: 24
      }, scene);
      const mat = new BABYLON.StandardMaterial(name + "Mat", scene);
      mat.diffuseColor = color;
      mat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
      mat.emissiveColor = emissive;
      planet.material = mat;

      const halo = BABYLON.MeshBuilder.CreateSphere(name + "Halo", {
        diameter: radius * 3.3,
        segments: 24
      }, scene);
      const haloMat = new BABYLON.StandardMaterial(name + "HaloMat", scene);
      haloMat.emissiveColor = emissive.scale(1.4);
      haloMat.alpha = 0.16;
      halo.material = haloMat;

      planet.position.x = distance;
      planet.position.y = 4;
      halo.parent = planet;

      return { mesh: planet, speed, distance, angle: Math.random() * Math.PI * 2 };
    }

    window.planets = {
      mercury: makePlanet("mercury", 1.2, 26,
        new BABYLON.Color3(0.8, 0.7, 0.6),
        new BABYLON.Color3(0.9, 0.8, 0.7),
        0.024),
      venus: makePlanet("venus", 1.7, 34,
        new BABYLON.Color3(0.9, 0.8, 0.5),
        new BABYLON.Color3(1.0, 0.9, 0.6),
        0.018),
      earth: makePlanet("earth", 1.8, 42,
        new BABYLON.Color3(0.2, 0.4, 0.9),
        new BABYLON.Color3(0.3, 0.6, 1.2),
        0.015),
      mars: makePlanet("mars", 1.4, 50,
        new BABYLON.Color3(0.9, 0.3, 0.1),
        new BABYLON.Color3(1.0, 0.4, 0.2),
        0.013),
      jupiter: makePlanet("jupiter", 3.5, 64,
        new BABYLON.Color3(0.9, 0.8, 0.6),
        new BABYLON.Color3(1.1, 0.9, 0.7),
        0.010),
      saturn: makePlanet("saturn", 3.0, 80,
        new BABYLON.Color3(0.9, 0.8, 0.6),
        new BABYLON.Color3(1.0, 0.9, 0.7),
        0.008),
      uranus: makePlanet("uranus", 2.4, 96,
        new BABYLON.Color3(0.6, 0.9, 0.9),
        new BABYLON.Color3(0.6, 1.0, 1.2),
        0.006),
      neptune: makePlanet("neptune", 2.4, 112,
        new BABYLON.Color3(0.2, 0.3, 0.9),
        new BABYLON.Color3(0.4, 0.6, 1.3),
        0.005),
      pluto: makePlanet("pluto", 1.0, 128,
        new BABYLON.Color3(0.8, 0.8, 1.0),
        new BABYLON.Color3(1.0, 1.0, 1.2),
        0.004)
    };

    // Simple orbit animation
    scene.registerBeforeRender(() => {
      const dt = engine.getDeltaTime() * 0.001;
      for (const key in planets) {
        const p = planets[key];
        p.angle += p.speed * dt * (state.chaosOn ? 2.0 : 1.0);
        p.mesh.position.x = Math.cos(p.angle) * p.distance;
        p.mesh.position.z = Math.sin(p.angle) * p.distance;
      }
    });

    // CME firing
    function fireCME(strength = 1.0) {
      const torus = BABYLON.MeshBuilder.CreateTorus("cmeRing", {
        diameter: 22,
        thickness: 0.8,
        tessellation: 90
      }, scene);
      const mat = new BABYLON.StandardMaterial("cmeMat", scene);
      mat.emissiveColor = new BABYLON.Color3(1.0, 0.9, 0.4);
      torus.material = mat;
      torus.position.y = 6;
      torus.rotation.x = Math.PI / 2;
      state.cmewaves.push({
        mesh: torus,
        material: mat,
        radius: 1,
        speed: 0.7 + strength * 0.4
      });
    }
    window.fireCME = fireCME;

    // Chaos orb spawner (tap grid)
    function spawnChaosOrb(point) {
      const orb = BABYLON.MeshBuilder.CreateSphere("chaosOrb", {
        diameter: 4,
        segments: 24
      }, scene);
      const mat = new BABYLON.StandardMaterial("chaosOrbMat", scene);
      const r = 0.4 + Math.random() * 0.6;
      const g = 0.4 + Math.random() * 0.6;
      const b = 0.7 + Math.random() * 0.6;
      mat.emissiveColor = new BABYLON.Color3(r, g, b);
      mat.diffuseColor = new BABYLON.Color3(0, 0, 0);
      mat.alpha = 1.0;
      orb.material = mat;

      orb.position.copyFrom(point);
      orb.position.y += 3;

      state.chaosOrbs.push({ mesh: orb, mat, life: 0 });
    }

    // Tap-to-spawn handling
    scene.onPointerDown = function (evt, pickInfo) {
      if (pickInfo.hit && pickInfo.pickedMesh === grid) {
        spawnChaosOrb(pickInfo.pickedPoint);
        const statusBar = document.getElementById("statusBar");
        statusBar.textContent = "Status: Chaos orb spawned ‚Äì local QDS turbulence injected.";
      }
    };

    window.applyMode = function(mode) {
      if (mode === "normal") {
        state.chaosOn = false;
        state.meltdown = false;
        glow.intensity = 0.7;
        gridMat.emissiveColor = new BABYLON.Color3(0.0, 0.4, 0.6);
        sunMat.emissiveColor = new BABYLON.Color3(1.4, 1.1, 0.4);
      } else if (mode === "chaos") {
        state.chaosOn = !state.chaosOn;
      } else if (mode === "meltdown") {
        state.meltdown = !state.meltdown;
        glow.intensity = state.meltdown ? 1.0 : 0.7;
      }
    };

    window.setLambda = v => { state.qdsLambda = v; };
    window.setTau = v => { state.qdsTau = v; };
    window.getCamera = () => camera;

    return scene;
  }

  const scene = createScene();

  engine.runRenderLoop(() => {
    scene.render();
  });

  window.addEventListener("resize", () => {
    engine.resize();
  });

  // HUD wiring
  const lambdaSlider = document.getElementById("lambdaSlider");
  const tauSlider = document.getElementById("tauSlider");
  const lambdaVal = document.getElementById("lambdaVal");
  const tauVal = document.getElementById("tauVal");
  const planetSelect = document.getElementById("planetSelect");
  const planetInfo = document.getElementById("planetInfo");
  const statusBar = document.getElementById("statusBar");

  lambdaSlider.oninput = e => {
    const v = parseFloat(e.target.value);
    lambdaVal.textContent = v.toFixed(1);
    window.setLambda(v);
  };
  tauSlider.oninput = e => {
    const v = parseFloat(e.target.value);
    tauVal.textContent = v.toFixed(1);
    window.setTau(v);
  };

  document.getElementById("btnCME").onclick = () => {
    window.fireCME(1.0);
    statusBar.textContent = "Status: CME fired ‚Äì shock ring through QDS grid.";
  };
  document.getElementById("btnChaos").onclick = () => {
    window.applyMode("chaos");
    statusBar.textContent = "Status: MAX Chaos toggled ‚Äì jittery orbits and noisy grid.";
  };
  document.getElementById("btnNormal").onclick = () => {
    window.applyMode("normal");
    statusBar.textContent = "Status: Back to calmer QDS field.";
  };
  document.getElementById("btnMeltdown").onclick = () => {
    window.applyMode("meltdown");
    statusBar.textContent = "Status: QDS MELTDOWN ‚Äì grid amplitude cranked. Hold onto your hat.";
  };
  document.getElementById("btnRide").onclick = () => {
    const cam = window.getCamera();
    state.rideOn = !state.rideOn;
    if (!state.rideOn) {
      statusBar.textContent = "Status: Ride Along disengaged. Camera free.";
      return;
    }
    const targetKey = planetSelect.value === "none" ? "earth" : planetSelect.value;
    state.rideTarget = targetKey;
    statusBar.textContent = "Status: Riding along with " + targetKey.toUpperCase() + ".";
    if (planets[targetKey]) {
      cam.radius = 22;
      cam.beta = Math.PI / 2.4;
    }
  };

  planetSelect.onchange = e => {
    const key = e.target.value;
    if (key === "none") {
      planetInfo.textContent = "Planet info will appear here.";
      return;
    }
    planetInfo.textContent = PLANET_TEXT[key] || "";
    state.rideTarget = key;
  };

  document.getElementById("hudToggle").onclick = () => {
    const hud = document.getElementById("hud");
    hud.style.display = (hud.style.display === "none") ? "block" : "none";
  };
</script>
</body>
</html>
