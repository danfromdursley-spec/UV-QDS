<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>UV-QDS Playground — QDS Toys Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #050711;
      --bg-card: #141726;
      --bg-card-soft: #181b2e;
      --accent: #fcb040;
      --accent-soft: #ffdd99;
      --text: #f5f7ff;
      --muted: #a3aac5;
      --danger: #ff6b81;
      --radius: 14px;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #1b2140 0, #050711 55%);
      color: var(--text);
    }

    .shell {
      max-width: 960px;
      margin: 0 auto;
      padding: 1.2rem 1rem 2.5rem;
    }

    header.hero {
      padding: 1rem 1.1rem 1.2rem;
      border-radius: 0 0 var(--radius) var(--radius);
      background: linear-gradient(135deg, #2e335a 0, #141726 60%, #090b14 100%);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.55);
      position: sticky;
      top: 0;
      z-index: 5;
    }

    .hero-title {
      font-size: 1.45rem;
      font-weight: 600;
      margin: 0 0 0.25rem;
    }

    .hero-sub {
      margin: 0;
      font-size: 0.86rem;
      color: var(--muted);
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin-top: 0.6rem;
    }

    .pill {
      font-size: 0.7rem;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.09);
      color: var(--accent-soft);
      background: rgba(5, 7, 17, 0.6);
      backdrop-filter: blur(6px);
    }

    main {
      margin-top: 1.4rem;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 1rem;
    }

    @media (min-width: 768px) {
      main {
        grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
        align-items: flex-start;
      }
    }

    .stack {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .card {
      background: linear-gradient(145deg, var(--bg-card) 0, var(--bg-card-soft) 60%);
      border-radius: var(--radius);
      padding: 0.9rem 0.95rem 1.05rem;
      border: 1px solid rgba(255, 255, 255, 0.04);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.55);
    }

    .card-title {
      margin: 0 0 0.3rem;
      font-size: 1.0rem;
      font-weight: 600;
    }

    .card-sub {
      margin: 0 0 0.6rem;
      font-size: 0.8rem;
      color: var(--muted);
    }

    label {
      display: block;
      font-size: 0.78rem;
      margin-bottom: 0.3rem;
      color: var(--accent-soft);
    }

    input[type="number"],
    select,
    textarea {
      width: 100%;
      padding: 0.45rem 0.45rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(0, 0, 0, 0.35);
      color: var(--text);
      font-size: 0.84rem;
      outline: none;
    }

    textarea {
      min-height: 90px;
      resize: vertical;
    }

    input[type="number"]:focus,
    select:focus,
    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(252, 176, 64, 0.45);
    }

    .range-row {
      margin-bottom: 0.4rem;
    }

    .range-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.78rem;
      margin-bottom: 0.15rem;
      color: var(--accent-soft);
    }

    .range-value {
      color: var(--muted);
      font-size: 0.76rem;
      min-width: 3ch;
      text-align: right;
    }

    input[type="range"] {
      width: 100%;
    }

    .btn {
      display: inline-block;
      margin-top: 0.45rem;
      padding: 0.46rem 0.9rem;
      border-radius: 999px;
      border: none;
      background: radial-gradient(circle at 20% 0, #ffd37a 0, #fcb040 40%, #ff9950 100%);
      color: #2a1600;
      font-weight: 600;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5) inset;
    }

    .btn.secondary {
      background: rgba(255, 255, 255, 0.06);
      color: var(--accent-soft);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    canvas {
      width: 100%;
      max-width: 100%;
      border-radius: 10px;
      background: radial-gradient(circle at top, #20243e 0, #050711 70%);
      border: 1px solid rgba(255, 255, 255, 0.04);
      margin-top: 0.2rem;
    }

    .hint {
      color: var(--muted);
      font-size: 0.76rem;
    }

    .card-output {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: var(--accent-soft);
    }

    .small-text {
      font-size: 0.76rem;
    }

    .badge {
      display: inline-block;
      font-size: 0.72rem;
      padding: 0.16rem 0.45rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      color: var(--muted);
      margin-bottom: 0.35rem;
    }

    .footer-note {
      margin-top: 1.4rem;
      font-size: 0.76rem;
      color: var(--muted);
      text-align: center;
    }

  </style>
</head>
<body>
  <div class="shell">
    <header class="hero">
      <div class="hero-title">UV-QDS Playground</div>
      <p class="hero-sub">
        Cosmic variance, rotation curves, noise & compression — plus a few quick
        QDS business toys. All numbers are illustrative, not promises.
      </p>
      <div class="pill-row">
        <span class="pill">σ(H)/H toy</span>
        <span class="pill">Rotation curves</span>
        <span class="pill">Noise & compression</span>
        <span class="pill">Battery & storage</span>
        <span class="pill">Qubits & £-savings</span>
      </div>
    </header>

    <main>
      <!-- LEFT COLUMN: physics toys + sandbox -->
      <div class="stack">

        <!-- Cosmic variance card -->
        <section class="card">
          <div class="badge">Cosmic variance lab</div>
          <h2 class="card-title">σ(H)/H vs scale</h2>
          <p class="card-sub">
            Compare a QDS-style slow power-law with a steeper “standard” fall-off.
            Use sliders, eyeball the curves, take notes in your notebook.
          </p>

          <div class="range-row">
            <div class="range-label">
              <span>QDS A (amplitude)</span>
              <span class="range-value" id="cosmic_A_val"></span>
            </div>
            <input id="cosmic_A" type="range" min="0.005" max="0.04" step="0.001" value="0.017">
          </div>

          <div class="range-row">
            <div class="range-label">
              <span>QDS p (slope)</span>
              <span class="range-value" id="cosmic_p_val"></span>
            </div>
            <input id="cosmic_p" type="range" min="0.15" max="0.7" step="0.01" value="0.35">
          </div>

          <div class="range-row">
            <div class="range-label">
              <span>R max (survey scale, toy units)</span>
              <span class="range-value" id="cosmic_R_val"></span>
            </div>
            <input id="cosmic_R" type="range" min="100" max="800" step="20" value="500">
          </div>

          <canvas id="cosmic_canvas" width="360" height="210"></canvas>
          <div class="hint small-text">
            Blue ≈ QDS σ(H)/H ∝ A·R<sup>-p</sup>, orange ≈ “standard” ∝ A·R<sup>-1</sup>.
            Units are arbitrary.
          </div>
        </section>

        <!-- Rotation curves card -->
        <section class="card">
          <div class="badge">QDS vs Newtonian</div>
          <h2 class="card-title">Galaxy rotation curves</h2>
          <p class="card-sub">
            Newtonian + one extra kernel factor:
            <span class="small-text">a(r) ∝ r<sup>−2</sup>(1 + α e<sup>−r/λ</sup>)</span>.
            Shape is the point; units are toy units.
          </p>

          <div class="range-row">
            <div class="range-label">
              <span>α (boost strength)</span>
              <span class="range-value" id="rot_alpha_val"></span>
            </div>
            <input id="rot_alpha" type="range" min="0" max="3" step="0.1" value="1.5">
          </div>

          <div class="range-row">
            <div class="range-label">
              <span>λ (kernel scale)</span>
              <span class="range-value" id="rot_lambda_val"></span>
            </div>
            <input id="rot_lambda" type="range" min="0.5" max="8" step="0.1" value="3">
          </div>

          <div class="range-row">
            <div class="range-label">
              <span>Mass M (relative)</span>
              <span class="range-value" id="rot_mass_val"></span>
            </div>
            <input id="rot_mass" type="range" min="0.6" max="3" step="0.1" value="1">
          </div>

          <canvas id="rot_canvas" width="360" height="210"></canvas>
          <div class="hint small-text">
            Blue ≈ Newtonian v(r), orange ≈ QDS kernel tweak. Swap in real galaxy data if you like.
          </div>
        </section>

        <!-- Noise / compression sandbox -->
        <section class="card">
          <div class="badge">Toy QDSX view</div>
          <h2 class="card-title">Noise / compression sandbox</h2>
          <p class="card-sub">
            Paste a log or some text and get a rough feel for structure vs randomness.
            Very light-weight proxy for the full QDSX engine.
          </p>

          <label for="noise_text">Paste some text, JSON, logs, or code here.</label>
          <textarea id="noise_text" placeholder="Short is fine."></textarea>

          <button class="btn" id="noise_btn">Analyse</button>
          <button class="btn secondary" id="noise_example_btn">Load example</button>

          <div id="noise_out" class="card-output"></div>
        </section>
      </div>

      <!-- RIGHT COLUMN: batteries, savings + qubits etc -->
      <div class="stack">

        <!-- Battery life sketch -->
        <section class="card">
          <h2 class="card-title">Battery / device-life sketch</h2>
          <p class="card-sub">
            Back-of-the-envelope only. Plug in phone / device numbers and a possible
            “QDS-style gain”. Not a guarantee, just intuition.
          </p>

          <label>
            Battery capacity (mAh)
            <input id="bat_capacity" type="number" value="4200" step="100">
          </label>

          <label>
            Average drain (mA)
            <input id="bat_drain" type="number" value="300" step="10">
          </label>

          <label>
            QDS-style efficiency gain (%)
            <input id="bat_gain" type="number" value="8" step="0.5">
          </label>

          <button id="bat_btn" class="btn">Estimate runtime</button>
          <div id="bat_out" class="card-output"></div>
        </section>

        <!-- Compression savings estimator -->
        <section class="card">
          <h2 class="card-title">Compression savings estimator</h2>
          <p class="card-sub">
            Quick feel for how much storage / bandwidth QDSX-style compression
            could save vs a normal ZIP-style compressor.
          </p>

          <label>
            Original data size (MB)
            <input id="comp_size" type="number" value="500" step="10">
          </label>

          <label>
            Data type
            <select id="comp_type">
              <option value="logs">Logs / JSON / CSV</option>
              <option value="metrics">Metrics / telemetry</option>
              <option value="code">Source code / text</option>
              <option value="other">Other / mixed</option>
            </select>
          </label>

          <button id="comp_btn" class="btn">Estimate savings</button>
          <div id="comp_out" class="card-output"></div>
        </section>

        <!-- Qubit error / coherence toy -->
        <section class="card">
          <h2 class="card-title">Qubit error / coherence toy</h2>
          <p class="card-sub">
            Very rough illustration of how cutting per-gate error might change the chance
            a whole circuit survives. Independent-gate toy only.
          </p>

          <label>
            Baseline error per gate (%)
            <input id="qubit_base_err" type="number" value="0.1" step="0.01">
          </label>

          <label>
            QDS-style error reduction (%)
            <input id="qubit_qds_cut" type="number" value="20" step="1">
          </label>

          <label>
            Number of gates in a circuit
            <input id="qubit_gates" type="number" value="1000" step="50">
          </label>

          <button id="qubit_btn" class="btn">Estimate coherence</button>
          <div id="qubit_out" class="card-output"></div>
        </section>

        <!-- Business savings estimator -->
        <section class="card">
          <h2 class="card-title">Business savings estimator</h2>
          <p class="card-sub">
            Sketch of cloud/storage impact for a device fleet using QDSX-style compression.
            Good for quick £-ballparks.
          </p>

          <label>
            Number of devices
            <input id="biz_devices" type="number" value="1000" step="100">
          </label>

          <label>
            Data per device / month (GB)
            <input id="biz_data_gb" type="number" value="10" step="1">
          </label>

          <label>
            Extra saving vs ZIP (%)
            <span class="hint small-text">e.g. 40 → QDSX is 40% smaller than ZIP</span>
            <input id="biz_saving_pct" type="number" value="40" step="1">
          </label>

          <label>
            Cloud/storage cost (£ per TB / month)
            <input id="biz_cost_per_tb" type="number" value="20" step="1">
          </label>

          <button id="biz_btn" class="btn">Estimate £ impact</button>
          <div id="biz_out" class="card-output"></div>
        </section>

        <!-- Transfer-time estimator -->
        <section class="card">
          <h2 class="card-title">Transfer-time estimator</h2>
          <p class="card-sub">
            Compare how long a big dataset takes to move over a link,
            with and without QDSX-style compression.
          </p>

          <label>
            Original dataset size (GB)
            <input id="xfer_size_gb" type="number" value="100" step="1">
          </label>

          <label>
            Link speed (Mb/s)
            <input id="xfer_speed_mbps" type="number" value="100" step="10">
          </label>

          <label>
            Extra saving vs ZIP (%)
            <span class="hint small-text">Use same number as above if you like.</span>
            <input id="xfer_saving_pct" type="number" value="40" step="1">
          </label>

          <button id="xfer_btn" class="btn">Estimate transfer time</button>
          <div id="xfer_out" class="card-output"></div>
        </section>

      </div>
    </main>

    <div class="footer-note">
      Built as a light-weight public demo. Serious equations & fits live in the papers
      and the full QDS engine bank. If you can break any of these toys, the author is happy.
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const $ = (id) => document.getElementById(id);

      function clampNumber(x, min, max) {
        x = isNaN(x) ? 0 : x;
        if (min !== undefined) x = Math.max(min, x);
        if (max !== undefined) x = Math.min(max, x);
        return x;
      }

      function hoursMinutesStr(totalHours) {
        if (!isFinite(totalHours) || totalHours <= 0) return "~0 h";
        const h = Math.floor(totalHours);
        const m = Math.round((totalHours - h) * 60);
        if (h === 0) return `${m} min`;
        if (m === 0) return `${h} h`;
        return `${h} h ${m} min`;
      }

      function prettyPct(x) {
        return `${x.toFixed(2)}%`;
      }

      // --------------- COSMIC VARIANCE PLOT -----------------
      const cosmicA = $("cosmic_A");
      const cosmicP = $("cosmic_p");
      const cosmicR = $("cosmic_R");
      const cosmicCanvas = $("cosmic_canvas");
      const cctx = cosmicCanvas.getContext("2d");

      function updateCosmicLabels() {
        $("cosmic_A_val").textContent = cosmicA.value;
        $("cosmic_p_val").textContent = cosmicP.value;
        $("cosmic_R_val").textContent = cosmicR.value;
      }

      function drawCosmic() {
        updateCosmicLabels();
        const A = parseFloat(cosmicA.value);
        const p = parseFloat(cosmicP.value);
        const Rmax = parseFloat(cosmicR.value);
        const Rmin = 1;

        const w = cosmicCanvas.width;
        const h = cosmicCanvas.height;
        cctx.clearRect(0, 0, w, h);

        // background
        const grad = cctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, "#252947");
        grad.addColorStop(1, "#050711");
        cctx.fillStyle = grad;
        cctx.fillRect(0, 0, w, h);

        // grid lines
        cctx.strokeStyle = "rgba(255,255,255,0.12)";
        cctx.lineWidth = 0.5;
        cctx.beginPath();
        for (let i = 0; i <= 4; i++) {
          const y = (h - 20) * (i / 4) + 10;
          cctx.moveTo(35, y);
          cctx.lineTo(w - 8, y);
        }
        cctx.stroke();

        // sample points
        const N = 80;
        const xs = [];
        const qds = [];
        const std = [];
        let ymin = Infinity;
        let ymax = -Infinity;

        for (let i = 0; i < N; i++) {
          const t = i / (N - 1);
          const R = Rmin + (Rmax - Rmin) * t;
          const q = A * Math.pow(R, -p);
          const s = A * Math.pow(R, -1);
          xs.push(R);
          qds.push(q);
          std.push(s);
          ymin = Math.min(ymin, q, s);
          ymax = Math.max(ymax, q, s);
        }
        if (!isFinite(ymin) || !isFinite(ymax) || ymax === ymin) {
          ymin = 0;
          ymax = 1;
        }

        function toXY(R, y) {
          const tx = (R - Rmin) / (Rmax - Rmin);
          const ty = (y - ymin) / (ymax - ymin);
          const px = 35 + tx * (w - 45);
          const py = h - 10 - ty * (h - 25);
          return [px, py];
        }

        // axes
        cctx.strokeStyle = "rgba(255,255,255,0.8)";
        cctx.lineWidth = 0.9;
        cctx.beginPath();
        cctx.moveTo(35, 10);
        cctx.lineTo(35, h - 10);
        cctx.lineTo(w - 8, h - 10);
        cctx.stroke();

        // QDS curve
        cctx.strokeStyle = "#4da3ff";
        cctx.lineWidth = 1.6;
        cctx.beginPath();
        qds.forEach((y, i) => {
          const [x, py] = toXY(xs[i], y);
          if (i === 0) cctx.moveTo(x, py);
          else cctx.lineTo(x, py);
        });
        cctx.stroke();

        // Standard curve
        cctx.strokeStyle = "#ffb347";
        cctx.lineWidth = 1.4;
        cctx.beginPath();
        std.forEach((y, i) => {
          const [x, py] = toXY(xs[i], y);
          if (i === 0) cctx.moveTo(x, py);
          else cctx.lineTo(x, py);
        });
        cctx.stroke();

        // legend
        cctx.font = "11px system-ui";
        cctx.fillStyle = "#dfe3ff";
        cctx.fillText("σ(H)/H", 6, 16);
        cctx.fillText("R", w - 18, h - 2);
        cctx.fillStyle = "#4da3ff";
        cctx.fillText("QDS", w - 70, 16);
        cctx.fillStyle = "#ffb347";
        cctx.fillText("Std", w - 35, 16);
      }

      ["input", "change"].forEach((evt) => {
        cosmicA.addEventListener(evt, drawCosmic);
        cosmicP.addEventListener(evt, drawCosmic);
        cosmicR.addEventListener(evt, drawCosmic);
      });

      // --------------- ROTATION CURVE PLOT -----------------
      const rotAlpha = $("rot_alpha");
      const rotLambda = $("rot_lambda");
      const rotMass = $("rot_mass");
      const rotCanvas = $("rot_canvas");
      const rctx = rotCanvas.getContext("2d");

      function updateRotLabels() {
        $("rot_alpha_val").textContent = rotAlpha.value;
        $("rot_lambda_val").textContent = rotLambda.value;
        $("rot_mass_val").textContent = rotMass.value;
      }

      function drawRotation() {
        updateRotLabels();
        const alpha = parseFloat(rotAlpha.value);
        const lambda = parseFloat(rotLambda.value);
        const M = parseFloat(rotMass.value);

        const w = rotCanvas.width;
        const h = rotCanvas.height;
        rctx.clearRect(0, 0, w, h);
        const grad = rctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, "#252947");
        grad.addColorStop(1, "#050711");
        rctx.fillStyle = grad;
        rctx.fillRect(0, 0, w, h);

        // grid
        rctx.strokeStyle = "rgba(255,255,255,0.12)";
        rctx.lineWidth = 0.5;
        rctx.beginPath();
        for (let i = 0; i <= 4; i++) {
          const y = (h - 20) * (i / 4) + 10;
          rctx.moveTo(30, y);
          rctx.lineTo(w - 8, y);
        }
        rctx.stroke();

        const rMin = 1;
        const rMax = 20;
        const N = 80;
        const rs = [];
        const vNewton = [];
        const vQDS = [];
        let ymin = Infinity;
        let ymax = -Infinity;

        for (let i = 0; i < N; i++) {
          const t = i / (N - 1);
          const r = rMin + (rMax - rMin) * t;
          const aN = M / (r * r);
          const aQ = aN * (1 + alpha * Math.exp(-r / lambda));
          const vN = Math.sqrt(aN * r);
          const vQ = Math.sqrt(aQ * r);
          rs.push(r);
          vNewton.push(vN);
          vQDS.push(vQ);
          ymin = Math.min(ymin, vN, vQ);
          ymax = Math.max(ymax, vN, vQ);
        }
        if (!isFinite(ymin) || !isFinite(ymax) || ymax === ymin) {
          ymin = 0;
          ymax = 1;
        }

        function toXYr(r, v) {
          const tx = (r - rMin) / (rMax - rMin);
          const ty = (v - ymin) / (ymax - ymin);
          const px = 30 + tx * (w - 40);
          const py = h - 10 - ty * (h - 25);
          return [px, py];
        }

        // axes
        rctx.strokeStyle = "rgba(255,255,255,0.8)";
        rctx.lineWidth = 0.9;
        rctx.beginPath();
        rctx.moveTo(30, 10);
        rctx.lineTo(30, h - 10);
        rctx.lineTo(w - 8, h - 10);
        rctx.stroke();

        // Newtonian curve
        rctx.strokeStyle = "#4da3ff";
        rctx.lineWidth = 1.6;
        rctx.beginPath();
        vNewton.forEach((v, i) => {
          const [x, py] = toXYr(rs[i], v);
          if (i === 0) rctx.moveTo(x, py);
          else rctx.lineTo(x, py);
        });
        rctx.stroke();

        // QDS curve
        rctx.strokeStyle = "#ffb347";
        rctx.lineWidth = 1.6;
        rctx.beginPath();
        vQDS.forEach((v, i) => {
          const [x, py] = toXYr(rs[i], v);
          if (i === 0) rctx.moveTo(x, py);
          else rctx.lineTo(x, py);
        });
        rctx.stroke();

        // labels
        rctx.font = "11px system-ui";
        rctx.fillStyle = "#dfe3ff";
        rctx.fillText("v(r)", 6, 16);
        rctx.fillText("r", w - 18, h - 2);
        rctx.fillStyle = "#4da3ff";
        rctx.fillText("Newtonian", w - 110, 16);
        rctx.fillStyle = "#ffb347";
        rctx.fillText("QDS", w - 50, 16);
      }

      ["input", "change"].forEach((evt) => {
        rotAlpha.addEventListener(evt, drawRotation);
        rotLambda.addEventListener(evt, drawRotation);
        rotMass.addEventListener(evt, drawRotation);
      });

      // --------------- NOISE / COMPRESSION SANDBOX ----------
      const noiseText = $("noise_text");
      const noiseOut = $("noise_out");

      $("noise_btn").addEventListener("click", () => {
        const txt = noiseText.value || "";
        const len = txt.length;
        if (!len) {
          noiseOut.textContent = "Nothing to analyse yet — paste some text first.";
          return;
        }

        // simple stats
        const uniqueChars = new Set(txt.split("")).size;

        // very crude run-length encoding length
        let rleLen = 0;
        let runChar = null;
        let runLen = 0;
        for (const ch of txt) {
          if (ch === runChar) {
            runLen++;
          } else {
            if (runChar !== null) {
              rleLen += 1 + runLen.toString().length;
            }
            runChar = ch;
            runLen = 1;
          }
        }
        if (runChar !== null) {
          rleLen += 1 + runLen.toString().length;
        }

        const naiveZipRatio = 0.6; // toy
        const naiveQdsxRatio = 0.36; // toy

        const zipSize = len * naiveZipRatio;
        const qdsSize = len * naiveQdsxRatio;

        noiseOut.innerHTML =
          `Raw length: <strong>${len}</strong> chars<br>` +
          `Unique symbols: <strong>${uniqueChars}</strong><br>` +
          `Toy run-length size: ~<strong>${rleLen}</strong> units<br><br>` +
          `<strong>Toy compressor sketch (based on your QDSX tests):</strong><br>` +
          `ZIP-style: ~${zipSize.toFixed(0)} (≈60% of original)<br>` +
          `QDSX-style: ~${qdsSize.toFixed(0)} (≈36% of original)<br>` +
          `Extra saving vs ZIP: ~${(zipSize - qdsSize).toFixed(0)} characters (≈40% smaller than ZIP).`;
      });

      $("noise_example_btn").addEventListener("click", () => {
        noiseText.value =
`2025-10-27T12:00:01Z  device=phone42  temp=34.2C  cpu=0.31
2025-10-27T12:00:02Z  device=phone42  temp=34.3C  cpu=0.33
2025-10-27T12:00:03Z  device=phone42  temp=34.3C  cpu=0.32
2025-10-27T12:00:04Z  device=phone42  temp=34.4C  cpu=0.35`;
        noiseOut.textContent = "";
      });

      // --------------- BATTERY SKETCH ----------------
      $("bat_btn").addEventListener("click", () => {
        const cap = clampNumber(parseFloat($("bat_capacity").value), 1, 1e8);
        const drain = clampNumber(parseFloat($("bat_drain").value), 0.1, 1e6);
        const gain = clampNumber(parseFloat($("bat_gain").value), 0, 100);

        const baseHours = cap / drain;
        const effDrain = drain * (1 - gain / 100);
        const qdsHours = cap / effDrain;
        const extraHours = qdsHours - baseHours;

        $("bat_out").innerHTML =
          `Baseline runtime: <strong>~${baseHours.toFixed(1)} h</strong><br>` +
          `With QDS-style gain (${gain.toFixed(1)}%): ` +
          `<strong>~${qdsHours.toFixed(1)} h</strong><br>` +
          `Extra runtime: <strong>${extraHours.toFixed(1)} h</strong> ` +
          `(≈${((extraHours / baseHours) * 100).toFixed(1)}% more).`;
      });

      // --------------- COMPRESSION SAVINGS ESTIMATOR ----------
      $("comp_btn").addEventListener("click", () => {
        const sizeMB = clampNumber(parseFloat($("comp_size").value), 0, 1e9);
        const type = $("comp_type").value;

        let zipRatio = 0.6;
        let qdsRatio = 0.36;

        if (type === "metrics") {
          zipRatio = 0.55;
          qdsRatio = 0.30;
        } else if (type === "code") {
          zipRatio = 0.5;
          qdsRatio = 0.28;
        } else if (type === "other") {
          zipRatio = 0.7;
          qdsRatio = 0.45;
        }

        const zipMB = sizeMB * zipRatio;
        const qdsMB = sizeMB * qdsRatio;
        const extraSaving = zipMB - qdsMB;
        const pctExtra = (extraSaving / (zipMB || 1)) * 100;

        $("comp_out").innerHTML =
          `Assumed dataset: <strong>${type}</strong><br>` +
          `Original: <strong>${sizeMB.toFixed(1)} MB</strong><br>` +
          `Typical ZIP-style: ~<strong>${zipMB.toFixed(1)} MB</strong><br>` +
          `QDSX-style: ~<strong>${qdsMB.toFixed(1)} MB</strong><br>` +
          `Extra saving vs ZIP: ~<strong>${extraSaving.toFixed(1)} MB</strong> ` +
          `(≈${pctExtra.toFixed(1)}% less than ZIP).`;
      });

      // --------------- QUBIT ERROR TOY ----------------
      $("qubit_btn").addEventListener("click", () => {
        const baseErr = clampNumber(
          parseFloat($("qubit_base_err").value),
          0, 100
        );
        const cutPct = clampNumber(
          parseFloat($("qubit_qds_cut").value),
          0, 100
        );
        const gates = clampNumber(
          parseInt($("qubit_gates").value, 10),
          1, 1e7
        );

        const baseErrFrac = baseErr / 100.0;
        const effErrFrac = baseErrFrac * (1 - cutPct / 100.0);

        const pNoBase = Math.pow(1 - baseErrFrac, gates);
        const pNoQds = Math.pow(1 - effErrFrac, gates);

        $("qubit_out").innerHTML =
          `<strong>Per-gate error:</strong><br>` +
          `Baseline: ${prettyPct(baseErrFrac * 100)}<br>` +
          `With QDS-style cut: ${prettyPct(effErrFrac * 100)}<br><br>` +
          `<strong>P(no error over ${gates.toLocaleString()} gates)</strong><br>` +
          `• Baseline: ${(pNoBase * 100).toFixed(3)}%<br>` +
          `• With QDS-style cut: ${(pNoQds * 100).toFixed(3)}%<br><br>` +
          `Effective coherence boost ≈ <strong>${(pNoQds / (pNoBase || 1)).toFixed(2)}×</strong>`;
      });

      // --------------- BUSINESS SAVINGS ESTIMATOR --------------
      $("biz_btn").addEventListener("click", () => {
        const devices = clampNumber(
          parseInt($("biz_devices").value, 10),
          1, 1e9
        );
        const gbPerDev = clampNumber(
          parseFloat($("biz_data_gb").value),
          0, 1e6
        );
        const savingPct = clampNumber(
          parseFloat($("biz_saving_pct").value),
          0, 100
        );
        const costPerTb = clampNumber(
          parseFloat($("biz_cost_per_tb").value),
          0, 1e6
        );

        const monthlyOriginalGB = devices * gbPerDev;
        const monthlySavedGB = monthlyOriginalGB * (savingPct / 100.0);
        const monthlySavedTB = monthlySavedGB / 1024.0;
        const monthlySavedGBP = monthlySavedTB * costPerTb;
        const annualSavedGBP = monthlySavedGBP * 12;

        $("biz_out").innerHTML =
          `Fleet original data: ~<strong>${monthlyOriginalGB.toFixed(1)} GB</strong> / month<br>` +
          `Extra saving vs ZIP: ~<strong>${monthlySavedGB.toFixed(1)} GB</strong> ` +
          `(≈${monthlySavedTB.toFixed(3)} TB) / month<br><br>` +
          `If cloud/storage ≈ <strong>£${costPerTb.toFixed(2)}</strong> per TB / month:<br>` +
          `• Monthly saving: <strong>~£${monthlySavedGBP.toFixed(2)}</strong><br>` +
          `• Annual saving: <strong>~£${annualSavedGBP.toFixed(2)}</strong>`;
      });

      // --------------- TRANSFER TIME ESTIMATOR ----------------
      $("xfer_btn").addEventListener("click", () => {
        const sizeGB = clampNumber(
          parseFloat($("xfer_size_gb").value),
          0, 1e9
        );
        const speedMbps = clampNumber(
          parseFloat($("xfer_speed_mbps").value),
          0.1, 1e9
        );
        const savingPct = clampNumber(
          parseFloat($("xfer_saving_pct").value),
          0, 100
        );

        const sizeMbitBase = sizeGB * 1024 * 8;
        const sizeMbitQds = sizeMbitBase * (1 - savingPct / 100.0);

        const hoursBase = sizeMbitBase / (speedMbps * 3600.0);
        const hoursQds = sizeMbitQds / (speedMbps * 3600.0);

        const out = $("xfer_out");
        const diff = hoursBase - hoursQds;
        const pctFaster = (1 - hoursQds / (hoursBase || 1)) * 100;

        out.innerHTML =
          `Baseline transfer time: <strong>${hoursMinutesStr(hoursBase)}</strong><br>` +
          `With QDSX-style saving (${savingPct.toFixed(1)}% smaller): ` +
          `<strong>${hoursMinutesStr(hoursQds)}</strong><br><br>` +
          `Rough time saving: <strong>${hoursMinutesStr(diff)}</strong> ` +
          `(≈${prettyPct(pctFaster)} faster).`;
      });

      // initial draws
      drawCosmic();
      drawRotation();
    });
  </script>
</body>
</html>
